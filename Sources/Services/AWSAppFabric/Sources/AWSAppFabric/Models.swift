//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// You are not authorized to perform this operation.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension AppFabricClientTypes {

    /// Contains API key credential information.
    public struct ApiKeyCredential: Swift.Sendable {
        /// An API key for an application.
        /// This member is required.
        public var apiKey: Swift.String?

        public init(
            apiKey: Swift.String? = nil
        )
        {
            self.apiKey = apiKey
        }
    }
}

extension AppFabricClientTypes.ApiKeyCredential: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApiKeyCredential(apiKey: \"CONTENT_REDACTED\")"}
}

extension AppFabricClientTypes {

    public enum AuthType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case apiKey
        case oauth2
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthType] {
            return [
                .apiKey,
                .oauth2
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .apiKey: return "apiKey"
            case .oauth2: return "oauth2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppFabricClientTypes {

    public enum Persona: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case admin
        case enduser
        case sdkUnknown(Swift.String)

        public static var allCases: [Persona] {
            return [
                .admin,
                .enduser
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .admin: return "admin"
            case .enduser: return "endUser"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppFabricClientTypes {

    public enum AppAuthorizationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case connected
        case connectionValidationFailed
        case pendingConnect
        case tokenAutoRotationFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [AppAuthorizationStatus] {
            return [
                .connected,
                .connectionValidationFailed,
                .pendingConnect,
                .tokenAutoRotationFailed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .connected: return "Connected"
            case .connectionValidationFailed: return "ConnectionValidationFailed"
            case .pendingConnect: return "PendingConnect"
            case .tokenAutoRotationFailed: return "TokenAutoRotationFailed"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppFabricClientTypes {

    /// Contains information about an application tenant.
    public struct Tenant: Swift.Sendable {
        /// The display name of the tenant.
        /// This member is required.
        public var tenantDisplayName: Swift.String?
        /// The ID of the application tenant.
        /// This member is required.
        public var tenantIdentifier: Swift.String?

        public init(
            tenantDisplayName: Swift.String? = nil,
            tenantIdentifier: Swift.String? = nil
        )
        {
            self.tenantDisplayName = tenantDisplayName
            self.tenantIdentifier = tenantIdentifier
        }
    }
}

extension AppFabricClientTypes {

    /// Contains information about an app authorization.
    public struct AppAuthorization: Swift.Sendable {
        /// The name of the application.
        /// This member is required.
        public var app: Swift.String?
        /// The Amazon Resource Name (ARN) of the app authorization.
        /// This member is required.
        public var appAuthorizationArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the app bundle for the app authorization.
        /// This member is required.
        public var appBundleArn: Swift.String?
        /// The authorization type.
        /// This member is required.
        public var authType: AppFabricClientTypes.AuthType?
        /// The application URL for the OAuth flow.
        public var authUrl: Swift.String?
        /// The timestamp of when the app authorization was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The user persona of the app authorization. This field should always be admin.
        public var persona: AppFabricClientTypes.Persona?
        /// The state of the app authorization. The following states are possible:
        ///
        /// * PendingConnect: The initial state of the app authorization. The app authorization is created but not yet connected.
        ///
        /// * Connected: The app authorization is connected to the application, and is ready to be used.
        ///
        /// * ConnectionValidationFailed: The app authorization received a validation exception when trying to connect to the application. If the app authorization is in this state, you should verify the configured credentials and try to connect the app authorization again.
        ///
        /// * TokenAutoRotationFailed: AppFabric failed to refresh the access token. If the app authorization is in this state, you should try to reconnect the app authorization.
        /// This member is required.
        public var status: AppFabricClientTypes.AppAuthorizationStatus?
        /// Contains information about an application tenant, such as the application display name and identifier.
        /// This member is required.
        public var tenant: AppFabricClientTypes.Tenant?
        /// The timestamp of when the app authorization was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            app: Swift.String? = nil,
            appAuthorizationArn: Swift.String? = nil,
            appBundleArn: Swift.String? = nil,
            authType: AppFabricClientTypes.AuthType? = nil,
            authUrl: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            persona: AppFabricClientTypes.Persona? = nil,
            status: AppFabricClientTypes.AppAuthorizationStatus? = nil,
            tenant: AppFabricClientTypes.Tenant? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.app = app
            self.appAuthorizationArn = appAuthorizationArn
            self.appBundleArn = appBundleArn
            self.authType = authType
            self.authUrl = authUrl
            self.createdAt = createdAt
            self.persona = persona
            self.status = status
            self.tenant = tenant
            self.updatedAt = updatedAt
        }
    }
}

extension AppFabricClientTypes {

    /// Contains a summary of an app authorization.
    public struct AppAuthorizationSummary: Swift.Sendable {
        /// The name of the application.
        /// This member is required.
        public var app: Swift.String?
        /// The Amazon Resource Name (ARN) of the app authorization.
        /// This member is required.
        public var appAuthorizationArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the app bundle for the app authorization.
        /// This member is required.
        public var appBundleArn: Swift.String?
        /// The state of the app authorization. The following states are possible:
        ///
        /// * PendingConnect: The initial state of the app authorization. The app authorization is created but not yet connected.
        ///
        /// * Connected: The app authorization is connected to the application, and is ready to be used.
        ///
        /// * ConnectionValidationFailed: The app authorization received a validation exception when trying to connect to the application. If the app authorization is in this state, you should verify the configured credentials and try to connect the app authorization again.
        ///
        /// * TokenAutoRotationFailed: AppFabric failed to refresh the access token. If the app authorization is in this state, you should try to reconnect the app authorization.
        /// This member is required.
        public var status: AppFabricClientTypes.AppAuthorizationStatus?
        /// Contains information about an application tenant, such as the application display name and identifier.
        /// This member is required.
        public var tenant: AppFabricClientTypes.Tenant?
        /// Timestamp for when the app authorization was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            app: Swift.String? = nil,
            appAuthorizationArn: Swift.String? = nil,
            appBundleArn: Swift.String? = nil,
            status: AppFabricClientTypes.AppAuthorizationStatus? = nil,
            tenant: AppFabricClientTypes.Tenant? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.app = app
            self.appAuthorizationArn = appAuthorizationArn
            self.appBundleArn = appBundleArn
            self.status = status
            self.tenant = tenant
            self.updatedAt = updatedAt
        }
    }
}

extension AppFabricClientTypes {

    /// Contains information about an app bundle.
    public struct AppBundle: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the app bundle.
        /// This member is required.
        public var arn: Swift.String?
        /// The Amazon Resource Name (ARN) of the Key Management Service (KMS) key used to encrypt the application data.
        public var customerManagedKeyArn: Swift.String?

        public init(
            arn: Swift.String? = nil,
            customerManagedKeyArn: Swift.String? = nil
        )
        {
            self.arn = arn
            self.customerManagedKeyArn = customerManagedKeyArn
        }
    }
}

extension AppFabricClientTypes {

    /// Contains a summary of an app bundle.
    public struct AppBundleSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the app bundle.
        /// This member is required.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }
}

extension AppFabricClientTypes {

    /// Contains information about an Amazon Kinesis Data Firehose delivery stream.
    public struct FirehoseStream: Swift.Sendable {
        /// The name of the Amazon Kinesis Data Firehose delivery stream.
        /// This member is required.
        public var streamName: Swift.String?

        public init(
            streamName: Swift.String? = nil
        )
        {
            self.streamName = streamName
        }
    }
}

extension AppFabricClientTypes {

    /// Contains information about an Amazon S3 bucket.
    public struct S3Bucket: Swift.Sendable {
        /// The name of the Amazon S3 bucket.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The object key to use.
        public var `prefix`: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.`prefix` = `prefix`
        }
    }
}

extension AppFabricClientTypes {

    /// Contains information about an audit log destination.
    public enum Destination: Swift.Sendable {
        /// Contains information about an Amazon S3 bucket.
        case s3bucket(AppFabricClientTypes.S3Bucket)
        /// Contains information about an Amazon Kinesis Data Firehose delivery stream.
        case firehosestream(AppFabricClientTypes.FirehoseStream)
        case sdkUnknown(Swift.String)
    }
}

extension AppFabricClientTypes {

    /// Contains information about an audit log destination configuration.
    public struct AuditLogDestinationConfiguration: Swift.Sendable {
        /// Contains information about an audit log destination.
        /// This member is required.
        public var destination: AppFabricClientTypes.Destination?

        public init(
            destination: AppFabricClientTypes.Destination? = nil
        )
        {
            self.destination = destination
        }
    }
}

extension AppFabricClientTypes {

    public enum Format: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case json
        case parquet
        case sdkUnknown(Swift.String)

        public static var allCases: [Format] {
            return [
                .json,
                .parquet
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .json: return "json"
            case .parquet: return "parquet"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppFabricClientTypes {

    public enum Schema: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ocsf
        case raw
        case sdkUnknown(Swift.String)

        public static var allCases: [Schema] {
            return [
                .ocsf,
                .raw
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ocsf: return "ocsf"
            case .raw: return "raw"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppFabricClientTypes {

    /// Contains information about an audit log processing configuration.
    public struct AuditLogProcessingConfiguration: Swift.Sendable {
        /// The format in which the audit logs need to be formatted.
        /// This member is required.
        public var format: AppFabricClientTypes.Format?
        /// The event schema in which the audit logs need to be formatted.
        /// This member is required.
        public var schema: AppFabricClientTypes.Schema?

        public init(
            format: AppFabricClientTypes.Format? = nil,
            schema: AppFabricClientTypes.Schema? = nil
        )
        {
            self.format = format
            self.schema = schema
        }
    }
}

extension AppFabricClientTypes {

    /// Contains authorization request information, which is required for Amazon Web Services AppFabric to get the OAuth2 access token for an application.
    public struct AuthRequest: Swift.Sendable {
        /// The authorization code returned by the application after permission is granted in the application OAuth page (after clicking on the AuthURL).
        /// This member is required.
        public var code: Swift.String?
        /// The redirect URL that is specified in the AuthURL and the application client.
        /// This member is required.
        public var redirectUri: Swift.String?

        public init(
            code: Swift.String? = nil,
            redirectUri: Swift.String? = nil
        )
        {
            self.code = code
            self.redirectUri = redirectUri
        }
    }
}

extension AppFabricClientTypes.AuthRequest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AuthRequest(redirectUri: \(Swift.String(describing: redirectUri)), code: \"CONTENT_REDACTED\")"}
}

/// The request processing has failed because of an unknown error, exception, or failure with an internal server.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The period of time after which you should retry your request.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// The specified resource does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The resource ID.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The request rate exceeds the limit.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The code for the quota exceeded.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The period of time after which you should retry your request.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
        /// The code of the service.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

extension AppFabricClientTypes {

    /// The input failed to meet the constraints specified by the Amazon Web Services service in a specified field.
    public struct ValidationExceptionField: Swift.Sendable {
        /// A message about the validation exception.
        /// This member is required.
        public var message: Swift.String?
        /// The field name where the invalid entry was detected.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }
}

extension AppFabricClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The request has invalid or missing parameters.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The field list.
        public internal(set) var fieldList: [AppFabricClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason for the exception.
        /// This member is required.
        public internal(set) var reason: AppFabricClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [AppFabricClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: AppFabricClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

public struct BatchGetUserAccessTasksInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// The tasks IDs to use for the request.
    /// This member is required.
    public var taskIdList: [Swift.String]?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        taskIdList: [Swift.String]? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.taskIdList = taskIdList
    }
}

extension AppFabricClientTypes {

    public enum ResultStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case expired
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ResultStatus] {
            return [
                .completed,
                .expired,
                .failed,
                .inProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .expired: return "EXPIRED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppFabricClientTypes {

    /// Contains information about an error returned from a user access task.
    public struct TaskError: Swift.Sendable {
        /// The code of the error.
        public var errorCode: Swift.String?
        /// The message of the error.
        public var errorMessage: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }
}

extension AppFabricClientTypes {

    /// Contains information about a user's access to an application.
    public struct UserAccessResultItem: Swift.Sendable {
        /// The name of the application.
        public var app: Swift.String?
        /// The email address of the target user.
        public var email: Swift.String?
        /// The status of the user access result item. The following states are possible:
        ///
        /// * IN_PROGRESS: The user access task is in progress.
        ///
        /// * COMPLETED: The user access task completed successfully.
        ///
        /// * FAILED: The user access task failed.
        ///
        /// * EXPIRED: The user access task expired.
        public var resultStatus: AppFabricClientTypes.ResultStatus?
        /// Contains information about an error returned from a user access task.
        public var taskError: AppFabricClientTypes.TaskError?
        /// The unique ID of the task.
        public var taskId: Swift.String?
        /// The display name of the tenant.
        public var tenantDisplayName: Swift.String?
        /// The ID of the application tenant.
        public var tenantId: Swift.String?
        /// The first name of the user.
        public var userFirstName: Swift.String?
        /// The full name of the user.
        public var userFullName: Swift.String?
        /// The unique ID of user.
        public var userId: Swift.String?
        /// The last name of the user.
        public var userLastName: Swift.String?
        /// The status of the user returned by the application.
        public var userStatus: Swift.String?

        public init(
            app: Swift.String? = nil,
            email: Swift.String? = nil,
            resultStatus: AppFabricClientTypes.ResultStatus? = nil,
            taskError: AppFabricClientTypes.TaskError? = nil,
            taskId: Swift.String? = nil,
            tenantDisplayName: Swift.String? = nil,
            tenantId: Swift.String? = nil,
            userFirstName: Swift.String? = nil,
            userFullName: Swift.String? = nil,
            userId: Swift.String? = nil,
            userLastName: Swift.String? = nil,
            userStatus: Swift.String? = nil
        )
        {
            self.app = app
            self.email = email
            self.resultStatus = resultStatus
            self.taskError = taskError
            self.taskId = taskId
            self.tenantDisplayName = tenantDisplayName
            self.tenantId = tenantId
            self.userFirstName = userFirstName
            self.userFullName = userFullName
            self.userId = userId
            self.userLastName = userLastName
            self.userStatus = userStatus
        }
    }
}

extension AppFabricClientTypes.UserAccessResultItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserAccessResultItem(app: \(Swift.String(describing: app)), resultStatus: \(Swift.String(describing: resultStatus)), taskError: \(Swift.String(describing: taskError)), taskId: \(Swift.String(describing: taskId)), tenantDisplayName: \(Swift.String(describing: tenantDisplayName)), tenantId: \(Swift.String(describing: tenantId)), userStatus: \(Swift.String(describing: userStatus)), email: \"CONTENT_REDACTED\", userFirstName: \"CONTENT_REDACTED\", userFullName: \"CONTENT_REDACTED\", userId: \"CONTENT_REDACTED\", userLastName: \"CONTENT_REDACTED\")"}
}

public struct BatchGetUserAccessTasksOutput: Swift.Sendable {
    /// Contains a list of user access results.
    public var userAccessResultsList: [AppFabricClientTypes.UserAccessResultItem]?

    public init(
        userAccessResultsList: [AppFabricClientTypes.UserAccessResultItem]? = nil
    )
    {
        self.userAccessResultsList = userAccessResultsList
    }
}

/// The request has created a conflict. Check the request parameters and try again.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The resource ID.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

public struct ConnectAppAuthorizationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app authorization to use for the request.
    /// This member is required.
    public var appAuthorizationIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle that contains the app authorization to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// Contains OAuth2 authorization information. This is required if the app authorization for the request is configured with an OAuth2 (oauth2) authorization type.
    public var authRequest: AppFabricClientTypes.AuthRequest?

    public init(
        appAuthorizationIdentifier: Swift.String? = nil,
        appBundleIdentifier: Swift.String? = nil,
        authRequest: AppFabricClientTypes.AuthRequest? = nil
    )
    {
        self.appAuthorizationIdentifier = appAuthorizationIdentifier
        self.appBundleIdentifier = appBundleIdentifier
        self.authRequest = authRequest
    }
}

public struct ConnectAppAuthorizationOutput: Swift.Sendable {
    /// Contains a summary of the app authorization.
    /// This member is required.
    public var appAuthorizationSummary: AppFabricClientTypes.AppAuthorizationSummary?

    public init(
        appAuthorizationSummary: AppFabricClientTypes.AppAuthorizationSummary? = nil
    )
    {
        self.appAuthorizationSummary = appAuthorizationSummary
    }
}

/// The request exceeds a service quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The code for the quota exceeded.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The resource ID.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
        /// The code of the service.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

extension AppFabricClientTypes {

    /// Contains OAuth2 client credential information.
    public struct Oauth2Credential: Swift.Sendable {
        /// The client ID of the client application.
        /// This member is required.
        public var clientId: Swift.String?
        /// The client secret of the client application.
        /// This member is required.
        public var clientSecret: Swift.String?

        public init(
            clientId: Swift.String? = nil,
            clientSecret: Swift.String? = nil
        )
        {
            self.clientId = clientId
            self.clientSecret = clientSecret
        }
    }
}

extension AppFabricClientTypes.Oauth2Credential: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Oauth2Credential(clientId: \(Swift.String(describing: clientId)), clientSecret: \"CONTENT_REDACTED\")"}
}

extension AppFabricClientTypes {

    /// Contains credential information for an application.
    public enum Credential: Swift.Sendable {
        /// Contains OAuth2 client credential information.
        case oauth2credential(AppFabricClientTypes.Oauth2Credential)
        /// Contains API key credential information.
        case apikeycredential(AppFabricClientTypes.ApiKeyCredential)
        case sdkUnknown(Swift.String)
    }
}

extension AppFabricClientTypes {

    /// The key or keys of the key-value pairs for the tag or tags assigned to a resource.
    public struct Tag: Swift.Sendable {
        /// Tag key.
        /// This member is required.
        public var key: Swift.String?
        /// Tag value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

public struct CreateAppAuthorizationInput: Swift.Sendable {
    /// The name of the application. Valid values are:
    ///
    /// * SLACK
    ///
    /// * ASANA
    ///
    /// * JIRA
    ///
    /// * M365
    ///
    /// * M365AUDITLOGS
    ///
    /// * ZOOM
    ///
    /// * ZENDESK
    ///
    /// * OKTA
    ///
    /// * GOOGLE
    ///
    /// * DROPBOX
    ///
    /// * SMARTSHEET
    ///
    /// * CISCO
    /// This member is required.
    public var app: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// The authorization type for the app authorization.
    /// This member is required.
    public var authType: AppFabricClientTypes.AuthType?
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// Contains credentials for the application, such as an API key or OAuth2 client ID and secret. Specify credentials that match the authorization type for your request. For example, if the authorization type for your request is OAuth2 (oauth2), then you should provide only the OAuth2 credentials.
    /// This member is required.
    public var credential: AppFabricClientTypes.Credential?
    /// A map of the key-value pairs of the tag or tags to assign to the resource.
    public var tags: [AppFabricClientTypes.Tag]?
    /// Contains information about an application tenant, such as the application display name and identifier.
    /// This member is required.
    public var tenant: AppFabricClientTypes.Tenant?

    public init(
        app: Swift.String? = nil,
        appBundleIdentifier: Swift.String? = nil,
        authType: AppFabricClientTypes.AuthType? = nil,
        clientToken: Swift.String? = nil,
        credential: AppFabricClientTypes.Credential? = nil,
        tags: [AppFabricClientTypes.Tag]? = nil,
        tenant: AppFabricClientTypes.Tenant? = nil
    )
    {
        self.app = app
        self.appBundleIdentifier = appBundleIdentifier
        self.authType = authType
        self.clientToken = clientToken
        self.credential = credential
        self.tags = tags
        self.tenant = tenant
    }
}

public struct CreateAppAuthorizationOutput: Swift.Sendable {
    /// Contains information about an app authorization.
    /// This member is required.
    public var appAuthorization: AppFabricClientTypes.AppAuthorization?

    public init(
        appAuthorization: AppFabricClientTypes.AppAuthorization? = nil
    )
    {
        self.appAuthorization = appAuthorization
    }
}

public struct CreateAppBundleInput: Swift.Sendable {
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the Key Management Service (KMS) key to use to encrypt the application data. If this is not specified, an Amazon Web Services owned key is used for encryption.
    public var customerManagedKeyIdentifier: Swift.String?
    /// A map of the key-value pairs of the tag or tags to assign to the resource.
    public var tags: [AppFabricClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        customerManagedKeyIdentifier: Swift.String? = nil,
        tags: [AppFabricClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.customerManagedKeyIdentifier = customerManagedKeyIdentifier
        self.tags = tags
    }
}

public struct CreateAppBundleOutput: Swift.Sendable {
    /// Contains information about an app bundle.
    /// This member is required.
    public var appBundle: AppFabricClientTypes.AppBundle?

    public init(
        appBundle: AppFabricClientTypes.AppBundle? = nil
    )
    {
        self.appBundle = appBundle
    }
}

extension AppFabricClientTypes {

    public enum IngestionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case auditLog
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionType] {
            return [
                .auditLog
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .auditLog: return "auditLog"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateIngestionInput: Swift.Sendable {
    /// The name of the application. Valid values are:
    ///
    /// * SLACK
    ///
    /// * ASANA
    ///
    /// * JIRA
    ///
    /// * M365
    ///
    /// * M365AUDITLOGS
    ///
    /// * ZOOM
    ///
    /// * ZENDESK
    ///
    /// * OKTA
    ///
    /// * GOOGLE
    ///
    /// * DROPBOX
    ///
    /// * SMARTSHEET
    ///
    /// * CISCO
    /// This member is required.
    public var app: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// The ingestion type.
    /// This member is required.
    public var ingestionType: AppFabricClientTypes.IngestionType?
    /// A map of the key-value pairs of the tag or tags to assign to the resource.
    public var tags: [AppFabricClientTypes.Tag]?
    /// The ID of the application tenant.
    /// This member is required.
    public var tenantId: Swift.String?

    public init(
        app: Swift.String? = nil,
        appBundleIdentifier: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        ingestionType: AppFabricClientTypes.IngestionType? = nil,
        tags: [AppFabricClientTypes.Tag]? = nil,
        tenantId: Swift.String? = nil
    )
    {
        self.app = app
        self.appBundleIdentifier = appBundleIdentifier
        self.clientToken = clientToken
        self.ingestionType = ingestionType
        self.tags = tags
        self.tenantId = tenantId
    }
}

extension AppFabricClientTypes {

    public enum IngestionState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionState] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "disabled"
            case .enabled: return "enabled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppFabricClientTypes {

    /// Contains information about an ingestion.
    public struct Ingestion: Swift.Sendable {
        /// The name of the application.
        /// This member is required.
        public var app: Swift.String?
        /// The Amazon Resource Name (ARN) of the app bundle for the ingestion.
        /// This member is required.
        public var appBundleArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the ingestion.
        /// This member is required.
        public var arn: Swift.String?
        /// The timestamp of when the ingestion was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The type of the ingestion.
        /// This member is required.
        public var ingestionType: AppFabricClientTypes.IngestionType?
        /// The status of the ingestion.
        /// This member is required.
        public var state: AppFabricClientTypes.IngestionState?
        /// The ID of the application tenant.
        /// This member is required.
        public var tenantId: Swift.String?
        /// The timestamp of when the ingestion was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            app: Swift.String? = nil,
            appBundleArn: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            ingestionType: AppFabricClientTypes.IngestionType? = nil,
            state: AppFabricClientTypes.IngestionState? = nil,
            tenantId: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.app = app
            self.appBundleArn = appBundleArn
            self.arn = arn
            self.createdAt = createdAt
            self.ingestionType = ingestionType
            self.state = state
            self.tenantId = tenantId
            self.updatedAt = updatedAt
        }
    }
}

public struct CreateIngestionOutput: Swift.Sendable {
    /// Contains information about an ingestion.
    /// This member is required.
    public var ingestion: AppFabricClientTypes.Ingestion?

    public init(
        ingestion: AppFabricClientTypes.Ingestion? = nil
    )
    {
        self.ingestion = ingestion
    }
}

extension AppFabricClientTypes {

    /// Contains information about the destination of ingested data.
    public enum DestinationConfiguration: Swift.Sendable {
        /// Contains information about an audit log destination configuration.
        case auditlog(AppFabricClientTypes.AuditLogDestinationConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension AppFabricClientTypes {

    /// Contains information about how ingested data is processed.
    public enum ProcessingConfiguration: Swift.Sendable {
        /// Contains information about an audit log processing configuration.
        case auditlog(AppFabricClientTypes.AuditLogProcessingConfiguration)
        case sdkUnknown(Swift.String)
    }
}

public struct CreateIngestionDestinationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// Contains information about the destination of ingested data.
    /// This member is required.
    public var destinationConfiguration: AppFabricClientTypes.DestinationConfiguration?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion to use for the request.
    /// This member is required.
    public var ingestionIdentifier: Swift.String?
    /// Contains information about how ingested data is processed.
    /// This member is required.
    public var processingConfiguration: AppFabricClientTypes.ProcessingConfiguration?
    /// A map of the key-value pairs of the tag or tags to assign to the resource.
    public var tags: [AppFabricClientTypes.Tag]?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        destinationConfiguration: AppFabricClientTypes.DestinationConfiguration? = nil,
        ingestionIdentifier: Swift.String? = nil,
        processingConfiguration: AppFabricClientTypes.ProcessingConfiguration? = nil,
        tags: [AppFabricClientTypes.Tag]? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.clientToken = clientToken
        self.destinationConfiguration = destinationConfiguration
        self.ingestionIdentifier = ingestionIdentifier
        self.processingConfiguration = processingConfiguration
        self.tags = tags
    }
}

extension AppFabricClientTypes {

    public enum IngestionDestinationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionDestinationStatus] {
            return [
                .active,
                .failed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .failed: return "Failed"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppFabricClientTypes {

    /// Contains information about an ingestion destination.
    public struct IngestionDestination: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the ingestion destination.
        /// This member is required.
        public var arn: Swift.String?
        /// The timestamp of when the ingestion destination was created.
        public var createdAt: Foundation.Date?
        /// Contains information about the destination of ingested data.
        /// This member is required.
        public var destinationConfiguration: AppFabricClientTypes.DestinationConfiguration?
        /// The Amazon Resource Name (ARN) of the ingestion.
        /// This member is required.
        public var ingestionArn: Swift.String?
        /// Contains information about how ingested data is processed.
        /// This member is required.
        public var processingConfiguration: AppFabricClientTypes.ProcessingConfiguration?
        /// The state of the ingestion destination. The following states are possible:
        ///
        /// * Active: The ingestion destination is active and is ready to be used.
        ///
        /// * Failed: The ingestion destination has failed. If the ingestion destination is in this state, you should verify the ingestion destination configuration and try again.
        public var status: AppFabricClientTypes.IngestionDestinationStatus?
        /// The reason for the current status of the ingestion destination. Only present when the status of ingestion destination is Failed.
        public var statusReason: Swift.String?
        /// The timestamp of when the ingestion destination was last updated.
        public var updatedAt: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            destinationConfiguration: AppFabricClientTypes.DestinationConfiguration? = nil,
            ingestionArn: Swift.String? = nil,
            processingConfiguration: AppFabricClientTypes.ProcessingConfiguration? = nil,
            status: AppFabricClientTypes.IngestionDestinationStatus? = nil,
            statusReason: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.destinationConfiguration = destinationConfiguration
            self.ingestionArn = ingestionArn
            self.processingConfiguration = processingConfiguration
            self.status = status
            self.statusReason = statusReason
            self.updatedAt = updatedAt
        }
    }
}

public struct CreateIngestionDestinationOutput: Swift.Sendable {
    /// Contains information about an ingestion destination.
    /// This member is required.
    public var ingestionDestination: AppFabricClientTypes.IngestionDestination?

    public init(
        ingestionDestination: AppFabricClientTypes.IngestionDestination? = nil
    )
    {
        self.ingestionDestination = ingestionDestination
    }
}

public struct DeleteAppAuthorizationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app authorization to use for the request.
    /// This member is required.
    public var appAuthorizationIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?

    public init(
        appAuthorizationIdentifier: Swift.String? = nil,
        appBundleIdentifier: Swift.String? = nil
    )
    {
        self.appAuthorizationIdentifier = appAuthorizationIdentifier
        self.appBundleIdentifier = appBundleIdentifier
    }
}

public struct DeleteAppAuthorizationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteAppBundleInput: Swift.Sendable {
    /// The ID or Amazon Resource Name (ARN) of the app bundle that needs to be deleted.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
    }
}

public struct DeleteAppBundleOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteIngestionInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion to use for the request.
    /// This member is required.
    public var ingestionIdentifier: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        ingestionIdentifier: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.ingestionIdentifier = ingestionIdentifier
    }
}

public struct DeleteIngestionOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteIngestionDestinationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion destination to use for the request.
    /// This member is required.
    public var ingestionDestinationIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion to use for the request.
    /// This member is required.
    public var ingestionIdentifier: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        ingestionDestinationIdentifier: Swift.String? = nil,
        ingestionIdentifier: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.ingestionDestinationIdentifier = ingestionDestinationIdentifier
        self.ingestionIdentifier = ingestionIdentifier
    }
}

public struct DeleteIngestionDestinationOutput: Swift.Sendable {

    public init() { }
}

public struct GetAppAuthorizationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app authorization to use for the request.
    /// This member is required.
    public var appAuthorizationIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?

    public init(
        appAuthorizationIdentifier: Swift.String? = nil,
        appBundleIdentifier: Swift.String? = nil
    )
    {
        self.appAuthorizationIdentifier = appAuthorizationIdentifier
        self.appBundleIdentifier = appBundleIdentifier
    }
}

public struct GetAppAuthorizationOutput: Swift.Sendable {
    /// Contains information about an app authorization.
    /// This member is required.
    public var appAuthorization: AppFabricClientTypes.AppAuthorization?

    public init(
        appAuthorization: AppFabricClientTypes.AppAuthorization? = nil
    )
    {
        self.appAuthorization = appAuthorization
    }
}

public struct GetAppBundleInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
    }
}

public struct GetAppBundleOutput: Swift.Sendable {
    /// Contains information about an app bundle.
    /// This member is required.
    public var appBundle: AppFabricClientTypes.AppBundle?

    public init(
        appBundle: AppFabricClientTypes.AppBundle? = nil
    )
    {
        self.appBundle = appBundle
    }
}

public struct GetIngestionInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion to use for the request.
    /// This member is required.
    public var ingestionIdentifier: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        ingestionIdentifier: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.ingestionIdentifier = ingestionIdentifier
    }
}

public struct GetIngestionOutput: Swift.Sendable {
    /// Contains information about an ingestion.
    /// This member is required.
    public var ingestion: AppFabricClientTypes.Ingestion?

    public init(
        ingestion: AppFabricClientTypes.Ingestion? = nil
    )
    {
        self.ingestion = ingestion
    }
}

public struct GetIngestionDestinationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion destination to use for the request.
    /// This member is required.
    public var ingestionDestinationIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion to use for the request.
    /// This member is required.
    public var ingestionIdentifier: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        ingestionDestinationIdentifier: Swift.String? = nil,
        ingestionIdentifier: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.ingestionDestinationIdentifier = ingestionDestinationIdentifier
        self.ingestionIdentifier = ingestionIdentifier
    }
}

public struct GetIngestionDestinationOutput: Swift.Sendable {
    /// Contains information about an ingestion destination.
    /// This member is required.
    public var ingestionDestination: AppFabricClientTypes.IngestionDestination?

    public init(
        ingestionDestination: AppFabricClientTypes.IngestionDestination? = nil
    )
    {
        self.ingestionDestination = ingestionDestination
    }
}

public struct ListAppAuthorizationsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    public var maxResults: Swift.Int?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAppAuthorizationsOutput: Swift.Sendable {
    /// Contains a list of app authorization summaries.
    /// This member is required.
    public var appAuthorizationSummaryList: [AppFabricClientTypes.AppAuthorizationSummary]?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        appAuthorizationSummaryList: [AppFabricClientTypes.AppAuthorizationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appAuthorizationSummaryList = appAuthorizationSummaryList
        self.nextToken = nextToken
    }
}

public struct ListAppBundlesInput: Swift.Sendable {
    /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    public var maxResults: Swift.Int?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAppBundlesOutput: Swift.Sendable {
    /// Contains a list of app bundle summaries.
    /// This member is required.
    public var appBundleSummaryList: [AppFabricClientTypes.AppBundleSummary]?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        appBundleSummaryList: [AppFabricClientTypes.AppBundleSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appBundleSummaryList = appBundleSummaryList
        self.nextToken = nextToken
    }
}

public struct ListIngestionDestinationsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion to use for the request.
    /// This member is required.
    public var ingestionIdentifier: Swift.String?
    /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    public var maxResults: Swift.Int?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        ingestionIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.ingestionIdentifier = ingestionIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension AppFabricClientTypes {

    /// Contains a summary of an ingestion destination.
    public struct IngestionDestinationSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the ingestion destination.
        /// This member is required.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }
}

public struct ListIngestionDestinationsOutput: Swift.Sendable {
    /// Contains a list of ingestion destination summaries.
    /// This member is required.
    public var ingestionDestinations: [AppFabricClientTypes.IngestionDestinationSummary]?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        ingestionDestinations: [AppFabricClientTypes.IngestionDestinationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ingestionDestinations = ingestionDestinations
        self.nextToken = nextToken
    }
}

public struct ListIngestionsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    public var maxResults: Swift.Int?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension AppFabricClientTypes {

    /// Contains a summary of an ingestion.
    public struct IngestionSummary: Swift.Sendable {
        /// The name of the application.
        /// This member is required.
        public var app: Swift.String?
        /// The Amazon Resource Name (ARN) of the ingestion.
        /// This member is required.
        public var arn: Swift.String?
        /// The status of the ingestion.
        /// This member is required.
        public var state: AppFabricClientTypes.IngestionState?
        /// The ID of the application tenant.
        /// This member is required.
        public var tenantId: Swift.String?

        public init(
            app: Swift.String? = nil,
            arn: Swift.String? = nil,
            state: AppFabricClientTypes.IngestionState? = nil,
            tenantId: Swift.String? = nil
        )
        {
            self.app = app
            self.arn = arn
            self.state = state
            self.tenantId = tenantId
        }
    }
}

public struct ListIngestionsOutput: Swift.Sendable {
    /// Contains a list of ingestion summaries.
    /// This member is required.
    public var ingestions: [AppFabricClientTypes.IngestionSummary]?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        ingestions: [AppFabricClientTypes.IngestionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ingestions = ingestions
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource for which you want to retrieve tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// A map of the key-value pairs for the tag or tags assigned to the specified resource.
    public var tags: [AppFabricClientTypes.Tag]?

    public init(
        tags: [AppFabricClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

public struct StartIngestionInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion to use for the request.
    /// This member is required.
    public var ingestionIdentifier: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        ingestionIdentifier: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.ingestionIdentifier = ingestionIdentifier
    }
}

public struct StartIngestionOutput: Swift.Sendable {

    public init() { }
}

public struct StartUserAccessTasksInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// The email address of the target user.
    /// This member is required.
    public var email: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        email: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.email = email
    }
}

extension StartUserAccessTasksInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartUserAccessTasksInput(appBundleIdentifier: \(Swift.String(describing: appBundleIdentifier)), email: \"CONTENT_REDACTED\")"}
}

extension AppFabricClientTypes {

    /// Contains information about a user access task.
    public struct UserAccessTaskItem: Swift.Sendable {
        /// The name of the application.
        /// This member is required.
        public var app: Swift.String?
        /// Error from the task, if any.
        public var error: AppFabricClientTypes.TaskError?
        /// The unique ID of the task.
        public var taskId: Swift.String?
        /// The ID of the application tenant.
        /// This member is required.
        public var tenantId: Swift.String?

        public init(
            app: Swift.String? = nil,
            error: AppFabricClientTypes.TaskError? = nil,
            taskId: Swift.String? = nil,
            tenantId: Swift.String? = nil
        )
        {
            self.app = app
            self.error = error
            self.taskId = taskId
            self.tenantId = tenantId
        }
    }
}

public struct StartUserAccessTasksOutput: Swift.Sendable {
    /// Contains a list of user access task information.
    public var userAccessTasksList: [AppFabricClientTypes.UserAccessTaskItem]?

    public init(
        userAccessTasksList: [AppFabricClientTypes.UserAccessTaskItem]? = nil
    )
    {
        self.userAccessTasksList = userAccessTasksList
    }
}

public struct StopIngestionInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion to use for the request.
    /// This member is required.
    public var ingestionIdentifier: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        ingestionIdentifier: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.ingestionIdentifier = ingestionIdentifier
    }
}

public struct StopIngestionOutput: Swift.Sendable {

    public init() { }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource that you want to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A map of the key-value pairs of the tag or tags to assign to the resource.
    /// This member is required.
    public var tags: [AppFabricClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [AppFabricClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource that you want to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the key-value pairs for the tag or tags you want to remove from the specified resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateAppAuthorizationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app authorization to use for the request.
    /// This member is required.
    public var appAuthorizationIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// Contains credentials for the application, such as an API key or OAuth2 client ID and secret. Specify credentials that match the authorization type of the app authorization to update. For example, if the authorization type of the app authorization is OAuth2 (oauth2), then you should provide only the OAuth2 credentials.
    public var credential: AppFabricClientTypes.Credential?
    /// Contains information about an application tenant, such as the application display name and identifier.
    public var tenant: AppFabricClientTypes.Tenant?

    public init(
        appAuthorizationIdentifier: Swift.String? = nil,
        appBundleIdentifier: Swift.String? = nil,
        credential: AppFabricClientTypes.Credential? = nil,
        tenant: AppFabricClientTypes.Tenant? = nil
    )
    {
        self.appAuthorizationIdentifier = appAuthorizationIdentifier
        self.appBundleIdentifier = appBundleIdentifier
        self.credential = credential
        self.tenant = tenant
    }
}

public struct UpdateAppAuthorizationOutput: Swift.Sendable {
    /// Contains information about an app authorization.
    /// This member is required.
    public var appAuthorization: AppFabricClientTypes.AppAuthorization?

    public init(
        appAuthorization: AppFabricClientTypes.AppAuthorization? = nil
    )
    {
        self.appAuthorization = appAuthorization
    }
}

public struct UpdateIngestionDestinationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// Contains information about the destination of ingested data.
    /// This member is required.
    public var destinationConfiguration: AppFabricClientTypes.DestinationConfiguration?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion destination to use for the request.
    /// This member is required.
    public var ingestionDestinationIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion to use for the request.
    /// This member is required.
    public var ingestionIdentifier: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        destinationConfiguration: AppFabricClientTypes.DestinationConfiguration? = nil,
        ingestionDestinationIdentifier: Swift.String? = nil,
        ingestionIdentifier: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.destinationConfiguration = destinationConfiguration
        self.ingestionDestinationIdentifier = ingestionDestinationIdentifier
        self.ingestionIdentifier = ingestionIdentifier
    }
}

public struct UpdateIngestionDestinationOutput: Swift.Sendable {
    /// Contains information about an ingestion destination.
    /// This member is required.
    public var ingestionDestination: AppFabricClientTypes.IngestionDestination?

    public init(
        ingestionDestination: AppFabricClientTypes.IngestionDestination? = nil
    )
    {
        self.ingestionDestination = ingestionDestination
    }
}

extension BatchGetUserAccessTasksInput {

    static func urlPathProvider(_ value: BatchGetUserAccessTasksInput) -> Swift.String? {
        return "/useraccess/batchget"
    }
}

extension ConnectAppAuthorizationInput {

    static func urlPathProvider(_ value: ConnectAppAuthorizationInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        guard let appAuthorizationIdentifier = value.appAuthorizationIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/appauthorizations/\(appAuthorizationIdentifier.urlPercentEncoding())/connect"
    }
}

extension CreateAppAuthorizationInput {

    static func urlPathProvider(_ value: CreateAppAuthorizationInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/appauthorizations"
    }
}

extension CreateAppBundleInput {

    static func urlPathProvider(_ value: CreateAppBundleInput) -> Swift.String? {
        return "/appbundles"
    }
}

extension CreateIngestionInput {

    static func urlPathProvider(_ value: CreateIngestionInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/ingestions"
    }
}

extension CreateIngestionDestinationInput {

    static func urlPathProvider(_ value: CreateIngestionDestinationInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        guard let ingestionIdentifier = value.ingestionIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/ingestions/\(ingestionIdentifier.urlPercentEncoding())/ingestiondestinations"
    }
}

extension DeleteAppAuthorizationInput {

    static func urlPathProvider(_ value: DeleteAppAuthorizationInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        guard let appAuthorizationIdentifier = value.appAuthorizationIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/appauthorizations/\(appAuthorizationIdentifier.urlPercentEncoding())"
    }
}

extension DeleteAppBundleInput {

    static func urlPathProvider(_ value: DeleteAppBundleInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())"
    }
}

extension DeleteIngestionInput {

    static func urlPathProvider(_ value: DeleteIngestionInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        guard let ingestionIdentifier = value.ingestionIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/ingestions/\(ingestionIdentifier.urlPercentEncoding())"
    }
}

extension DeleteIngestionDestinationInput {

    static func urlPathProvider(_ value: DeleteIngestionDestinationInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        guard let ingestionIdentifier = value.ingestionIdentifier else {
            return nil
        }
        guard let ingestionDestinationIdentifier = value.ingestionDestinationIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/ingestions/\(ingestionIdentifier.urlPercentEncoding())/ingestiondestinations/\(ingestionDestinationIdentifier.urlPercentEncoding())"
    }
}

extension GetAppAuthorizationInput {

    static func urlPathProvider(_ value: GetAppAuthorizationInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        guard let appAuthorizationIdentifier = value.appAuthorizationIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/appauthorizations/\(appAuthorizationIdentifier.urlPercentEncoding())"
    }
}

extension GetAppBundleInput {

    static func urlPathProvider(_ value: GetAppBundleInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())"
    }
}

extension GetIngestionInput {

    static func urlPathProvider(_ value: GetIngestionInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        guard let ingestionIdentifier = value.ingestionIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/ingestions/\(ingestionIdentifier.urlPercentEncoding())"
    }
}

extension GetIngestionDestinationInput {

    static func urlPathProvider(_ value: GetIngestionDestinationInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        guard let ingestionIdentifier = value.ingestionIdentifier else {
            return nil
        }
        guard let ingestionDestinationIdentifier = value.ingestionDestinationIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/ingestions/\(ingestionIdentifier.urlPercentEncoding())/ingestiondestinations/\(ingestionDestinationIdentifier.urlPercentEncoding())"
    }
}

extension ListAppAuthorizationsInput {

    static func urlPathProvider(_ value: ListAppAuthorizationsInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/appauthorizations"
    }
}

extension ListAppAuthorizationsInput {

    static func queryItemProvider(_ value: ListAppAuthorizationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListAppBundlesInput {

    static func urlPathProvider(_ value: ListAppBundlesInput) -> Swift.String? {
        return "/appbundles"
    }
}

extension ListAppBundlesInput {

    static func queryItemProvider(_ value: ListAppBundlesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListIngestionDestinationsInput {

    static func urlPathProvider(_ value: ListIngestionDestinationsInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        guard let ingestionIdentifier = value.ingestionIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/ingestions/\(ingestionIdentifier.urlPercentEncoding())/ingestiondestinations"
    }
}

extension ListIngestionDestinationsInput {

    static func queryItemProvider(_ value: ListIngestionDestinationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListIngestionsInput {

    static func urlPathProvider(_ value: ListIngestionsInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/ingestions"
    }
}

extension ListIngestionsInput {

    static func queryItemProvider(_ value: ListIngestionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension StartIngestionInput {

    static func urlPathProvider(_ value: StartIngestionInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        guard let ingestionIdentifier = value.ingestionIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/ingestions/\(ingestionIdentifier.urlPercentEncoding())/start"
    }
}

extension StartUserAccessTasksInput {

    static func urlPathProvider(_ value: StartUserAccessTasksInput) -> Swift.String? {
        return "/useraccess/start"
    }
}

extension StopIngestionInput {

    static func urlPathProvider(_ value: StopIngestionInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        guard let ingestionIdentifier = value.ingestionIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/ingestions/\(ingestionIdentifier.urlPercentEncoding())/stop"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateAppAuthorizationInput {

    static func urlPathProvider(_ value: UpdateAppAuthorizationInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        guard let appAuthorizationIdentifier = value.appAuthorizationIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/appauthorizations/\(appAuthorizationIdentifier.urlPercentEncoding())"
    }
}

extension UpdateIngestionDestinationInput {

    static func urlPathProvider(_ value: UpdateIngestionDestinationInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        guard let ingestionIdentifier = value.ingestionIdentifier else {
            return nil
        }
        guard let ingestionDestinationIdentifier = value.ingestionDestinationIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/ingestions/\(ingestionIdentifier.urlPercentEncoding())/ingestiondestinations/\(ingestionDestinationIdentifier.urlPercentEncoding())"
    }
}

extension BatchGetUserAccessTasksInput {

    static func write(value: BatchGetUserAccessTasksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appBundleIdentifier"].write(value.appBundleIdentifier)
        try writer["taskIdList"].writeList(value.taskIdList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ConnectAppAuthorizationInput {

    static func write(value: ConnectAppAuthorizationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authRequest"].write(value.authRequest, with: AppFabricClientTypes.AuthRequest.write(value:to:))
    }
}

extension CreateAppAuthorizationInput {

    static func write(value: CreateAppAuthorizationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["app"].write(value.app)
        try writer["authType"].write(value.authType)
        try writer["clientToken"].write(value.clientToken)
        try writer["credential"].write(value.credential, with: AppFabricClientTypes.Credential.write(value:to:))
        try writer["tags"].writeList(value.tags, memberWritingClosure: AppFabricClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tenant"].write(value.tenant, with: AppFabricClientTypes.Tenant.write(value:to:))
    }
}

extension CreateAppBundleInput {

    static func write(value: CreateAppBundleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["customerManagedKeyIdentifier"].write(value.customerManagedKeyIdentifier)
        try writer["tags"].writeList(value.tags, memberWritingClosure: AppFabricClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateIngestionInput {

    static func write(value: CreateIngestionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["app"].write(value.app)
        try writer["clientToken"].write(value.clientToken)
        try writer["ingestionType"].write(value.ingestionType)
        try writer["tags"].writeList(value.tags, memberWritingClosure: AppFabricClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tenantId"].write(value.tenantId)
    }
}

extension CreateIngestionDestinationInput {

    static func write(value: CreateIngestionDestinationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["destinationConfiguration"].write(value.destinationConfiguration, with: AppFabricClientTypes.DestinationConfiguration.write(value:to:))
        try writer["processingConfiguration"].write(value.processingConfiguration, with: AppFabricClientTypes.ProcessingConfiguration.write(value:to:))
        try writer["tags"].writeList(value.tags, memberWritingClosure: AppFabricClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension StartUserAccessTasksInput {

    static func write(value: StartUserAccessTasksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appBundleIdentifier"].write(value.appBundleIdentifier)
        try writer["email"].write(value.email)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeList(value.tags, memberWritingClosure: AppFabricClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateAppAuthorizationInput {

    static func write(value: UpdateAppAuthorizationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["credential"].write(value.credential, with: AppFabricClientTypes.Credential.write(value:to:))
        try writer["tenant"].write(value.tenant, with: AppFabricClientTypes.Tenant.write(value:to:))
    }
}

extension UpdateIngestionDestinationInput {

    static func write(value: UpdateIngestionDestinationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destinationConfiguration"].write(value.destinationConfiguration, with: AppFabricClientTypes.DestinationConfiguration.write(value:to:))
    }
}

extension BatchGetUserAccessTasksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetUserAccessTasksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetUserAccessTasksOutput()
        value.userAccessResultsList = try reader["userAccessResultsList"].readListIfPresent(memberReadingClosure: AppFabricClientTypes.UserAccessResultItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ConnectAppAuthorizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ConnectAppAuthorizationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ConnectAppAuthorizationOutput()
        value.appAuthorizationSummary = try reader["appAuthorizationSummary"].readIfPresent(with: AppFabricClientTypes.AppAuthorizationSummary.read(from:))
        return value
    }
}

extension CreateAppAuthorizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAppAuthorizationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAppAuthorizationOutput()
        value.appAuthorization = try reader["appAuthorization"].readIfPresent(with: AppFabricClientTypes.AppAuthorization.read(from:))
        return value
    }
}

extension CreateAppBundleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAppBundleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAppBundleOutput()
        value.appBundle = try reader["appBundle"].readIfPresent(with: AppFabricClientTypes.AppBundle.read(from:))
        return value
    }
}

extension CreateIngestionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateIngestionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateIngestionOutput()
        value.ingestion = try reader["ingestion"].readIfPresent(with: AppFabricClientTypes.Ingestion.read(from:))
        return value
    }
}

extension CreateIngestionDestinationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateIngestionDestinationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateIngestionDestinationOutput()
        value.ingestionDestination = try reader["ingestionDestination"].readIfPresent(with: AppFabricClientTypes.IngestionDestination.read(from:))
        return value
    }
}

extension DeleteAppAuthorizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAppAuthorizationOutput {
        return DeleteAppAuthorizationOutput()
    }
}

extension DeleteAppBundleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAppBundleOutput {
        return DeleteAppBundleOutput()
    }
}

extension DeleteIngestionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteIngestionOutput {
        return DeleteIngestionOutput()
    }
}

extension DeleteIngestionDestinationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteIngestionDestinationOutput {
        return DeleteIngestionDestinationOutput()
    }
}

extension GetAppAuthorizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAppAuthorizationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAppAuthorizationOutput()
        value.appAuthorization = try reader["appAuthorization"].readIfPresent(with: AppFabricClientTypes.AppAuthorization.read(from:))
        return value
    }
}

extension GetAppBundleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAppBundleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAppBundleOutput()
        value.appBundle = try reader["appBundle"].readIfPresent(with: AppFabricClientTypes.AppBundle.read(from:))
        return value
    }
}

extension GetIngestionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetIngestionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIngestionOutput()
        value.ingestion = try reader["ingestion"].readIfPresent(with: AppFabricClientTypes.Ingestion.read(from:))
        return value
    }
}

extension GetIngestionDestinationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetIngestionDestinationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIngestionDestinationOutput()
        value.ingestionDestination = try reader["ingestionDestination"].readIfPresent(with: AppFabricClientTypes.IngestionDestination.read(from:))
        return value
    }
}

extension ListAppAuthorizationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAppAuthorizationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAppAuthorizationsOutput()
        value.appAuthorizationSummaryList = try reader["appAuthorizationSummaryList"].readListIfPresent(memberReadingClosure: AppFabricClientTypes.AppAuthorizationSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAppBundlesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAppBundlesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAppBundlesOutput()
        value.appBundleSummaryList = try reader["appBundleSummaryList"].readListIfPresent(memberReadingClosure: AppFabricClientTypes.AppBundleSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListIngestionDestinationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListIngestionDestinationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIngestionDestinationsOutput()
        value.ingestionDestinations = try reader["ingestionDestinations"].readListIfPresent(memberReadingClosure: AppFabricClientTypes.IngestionDestinationSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListIngestionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListIngestionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIngestionsOutput()
        value.ingestions = try reader["ingestions"].readListIfPresent(memberReadingClosure: AppFabricClientTypes.IngestionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: AppFabricClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension StartIngestionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartIngestionOutput {
        return StartIngestionOutput()
    }
}

extension StartUserAccessTasksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartUserAccessTasksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartUserAccessTasksOutput()
        value.userAccessTasksList = try reader["userAccessTasksList"].readListIfPresent(memberReadingClosure: AppFabricClientTypes.UserAccessTaskItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension StopIngestionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopIngestionOutput {
        return StopIngestionOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAppAuthorizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAppAuthorizationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAppAuthorizationOutput()
        value.appAuthorization = try reader["appAuthorization"].readIfPresent(with: AppFabricClientTypes.AppAuthorization.read(from:))
        return value
    }
}

extension UpdateIngestionDestinationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateIngestionDestinationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateIngestionDestinationOutput()
        value.ingestionDestination = try reader["ingestionDestination"].readIfPresent(with: AppFabricClientTypes.IngestionDestination.read(from:))
        return value
    }
}

enum BatchGetUserAccessTasksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ConnectAppAuthorizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAppAuthorizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAppBundleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateIngestionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateIngestionDestinationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAppAuthorizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAppBundleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteIngestionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteIngestionDestinationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAppAuthorizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAppBundleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetIngestionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetIngestionDestinationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAppAuthorizationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAppBundlesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListIngestionDestinationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListIngestionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartIngestionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartUserAccessTasksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopIngestionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAppAuthorizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateIngestionDestinationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: AppFabricClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AppFabricClientTypes.UserAccessResultItem {

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.UserAccessResultItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppFabricClientTypes.UserAccessResultItem()
        value.app = try reader["app"].readIfPresent()
        value.tenantId = try reader["tenantId"].readIfPresent()
        value.tenantDisplayName = try reader["tenantDisplayName"].readIfPresent()
        value.taskId = try reader["taskId"].readIfPresent()
        value.resultStatus = try reader["resultStatus"].readIfPresent()
        value.email = try reader["email"].readIfPresent()
        value.userId = try reader["userId"].readIfPresent()
        value.userFullName = try reader["userFullName"].readIfPresent()
        value.userFirstName = try reader["userFirstName"].readIfPresent()
        value.userLastName = try reader["userLastName"].readIfPresent()
        value.userStatus = try reader["userStatus"].readIfPresent()
        value.taskError = try reader["taskError"].readIfPresent(with: AppFabricClientTypes.TaskError.read(from:))
        return value
    }
}

extension AppFabricClientTypes.TaskError {

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.TaskError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppFabricClientTypes.TaskError()
        value.errorCode = try reader["errorCode"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        return value
    }
}

extension AppFabricClientTypes.AppAuthorizationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.AppAuthorizationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppFabricClientTypes.AppAuthorizationSummary()
        value.appAuthorizationArn = try reader["appAuthorizationArn"].readIfPresent() ?? ""
        value.appBundleArn = try reader["appBundleArn"].readIfPresent() ?? ""
        value.app = try reader["app"].readIfPresent() ?? ""
        value.tenant = try reader["tenant"].readIfPresent(with: AppFabricClientTypes.Tenant.read(from:))
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension AppFabricClientTypes.Tenant {

    static func write(value: AppFabricClientTypes.Tenant?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tenantDisplayName"].write(value.tenantDisplayName)
        try writer["tenantIdentifier"].write(value.tenantIdentifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.Tenant {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppFabricClientTypes.Tenant()
        value.tenantIdentifier = try reader["tenantIdentifier"].readIfPresent() ?? ""
        value.tenantDisplayName = try reader["tenantDisplayName"].readIfPresent() ?? ""
        return value
    }
}

extension AppFabricClientTypes.AppAuthorization {

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.AppAuthorization {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppFabricClientTypes.AppAuthorization()
        value.appAuthorizationArn = try reader["appAuthorizationArn"].readIfPresent() ?? ""
        value.appBundleArn = try reader["appBundleArn"].readIfPresent() ?? ""
        value.app = try reader["app"].readIfPresent() ?? ""
        value.tenant = try reader["tenant"].readIfPresent(with: AppFabricClientTypes.Tenant.read(from:))
        value.authType = try reader["authType"].readIfPresent() ?? .sdkUnknown("")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.persona = try reader["persona"].readIfPresent()
        value.authUrl = try reader["authUrl"].readIfPresent()
        return value
    }
}

extension AppFabricClientTypes.AppBundle {

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.AppBundle {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppFabricClientTypes.AppBundle()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.customerManagedKeyArn = try reader["customerManagedKeyArn"].readIfPresent()
        return value
    }
}

extension AppFabricClientTypes.Ingestion {

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.Ingestion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppFabricClientTypes.Ingestion()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.appBundleArn = try reader["appBundleArn"].readIfPresent() ?? ""
        value.app = try reader["app"].readIfPresent() ?? ""
        value.tenantId = try reader["tenantId"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.ingestionType = try reader["ingestionType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension AppFabricClientTypes.IngestionDestination {

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.IngestionDestination {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppFabricClientTypes.IngestionDestination()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.ingestionArn = try reader["ingestionArn"].readIfPresent() ?? ""
        value.processingConfiguration = try reader["processingConfiguration"].readIfPresent(with: AppFabricClientTypes.ProcessingConfiguration.read(from:))
        value.destinationConfiguration = try reader["destinationConfiguration"].readIfPresent(with: AppFabricClientTypes.DestinationConfiguration.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension AppFabricClientTypes.DestinationConfiguration {

    static func write(value: AppFabricClientTypes.DestinationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .auditlog(auditlog):
                try writer["auditLog"].write(auditlog, with: AppFabricClientTypes.AuditLogDestinationConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.DestinationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "auditLog":
                return .auditlog(try reader["auditLog"].read(with: AppFabricClientTypes.AuditLogDestinationConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppFabricClientTypes.AuditLogDestinationConfiguration {

    static func write(value: AppFabricClientTypes.AuditLogDestinationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destination"].write(value.destination, with: AppFabricClientTypes.Destination.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.AuditLogDestinationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppFabricClientTypes.AuditLogDestinationConfiguration()
        value.destination = try reader["destination"].readIfPresent(with: AppFabricClientTypes.Destination.read(from:))
        return value
    }
}

extension AppFabricClientTypes.Destination {

    static func write(value: AppFabricClientTypes.Destination?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .firehosestream(firehosestream):
                try writer["firehoseStream"].write(firehosestream, with: AppFabricClientTypes.FirehoseStream.write(value:to:))
            case let .s3bucket(s3bucket):
                try writer["s3Bucket"].write(s3bucket, with: AppFabricClientTypes.S3Bucket.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.Destination {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "s3Bucket":
                return .s3bucket(try reader["s3Bucket"].read(with: AppFabricClientTypes.S3Bucket.read(from:)))
            case "firehoseStream":
                return .firehosestream(try reader["firehoseStream"].read(with: AppFabricClientTypes.FirehoseStream.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppFabricClientTypes.FirehoseStream {

    static func write(value: AppFabricClientTypes.FirehoseStream?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["streamName"].write(value.streamName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.FirehoseStream {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppFabricClientTypes.FirehoseStream()
        value.streamName = try reader["streamName"].readIfPresent() ?? ""
        return value
    }
}

extension AppFabricClientTypes.S3Bucket {

    static func write(value: AppFabricClientTypes.S3Bucket?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketName"].write(value.bucketName)
        try writer["prefix"].write(value.`prefix`)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.S3Bucket {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppFabricClientTypes.S3Bucket()
        value.bucketName = try reader["bucketName"].readIfPresent() ?? ""
        value.`prefix` = try reader["prefix"].readIfPresent()
        return value
    }
}

extension AppFabricClientTypes.ProcessingConfiguration {

    static func write(value: AppFabricClientTypes.ProcessingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .auditlog(auditlog):
                try writer["auditLog"].write(auditlog, with: AppFabricClientTypes.AuditLogProcessingConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.ProcessingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "auditLog":
                return .auditlog(try reader["auditLog"].read(with: AppFabricClientTypes.AuditLogProcessingConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppFabricClientTypes.AuditLogProcessingConfiguration {

    static func write(value: AppFabricClientTypes.AuditLogProcessingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["format"].write(value.format)
        try writer["schema"].write(value.schema)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.AuditLogProcessingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppFabricClientTypes.AuditLogProcessingConfiguration()
        value.schema = try reader["schema"].readIfPresent() ?? .sdkUnknown("")
        value.format = try reader["format"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension AppFabricClientTypes.AppBundleSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.AppBundleSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppFabricClientTypes.AppBundleSummary()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        return value
    }
}

extension AppFabricClientTypes.IngestionDestinationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.IngestionDestinationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppFabricClientTypes.IngestionDestinationSummary()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        return value
    }
}

extension AppFabricClientTypes.IngestionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.IngestionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppFabricClientTypes.IngestionSummary()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.app = try reader["app"].readIfPresent() ?? ""
        value.tenantId = try reader["tenantId"].readIfPresent() ?? ""
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension AppFabricClientTypes.Tag {

    static func write(value: AppFabricClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppFabricClientTypes.Tag()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension AppFabricClientTypes.UserAccessTaskItem {

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.UserAccessTaskItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppFabricClientTypes.UserAccessTaskItem()
        value.app = try reader["app"].readIfPresent() ?? ""
        value.tenantId = try reader["tenantId"].readIfPresent() ?? ""
        value.taskId = try reader["taskId"].readIfPresent()
        value.error = try reader["error"].readIfPresent(with: AppFabricClientTypes.TaskError.read(from:))
        return value
    }
}

extension AppFabricClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppFabricClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension AppFabricClientTypes.AuthRequest {

    static func write(value: AppFabricClientTypes.AuthRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["code"].write(value.code)
        try writer["redirectUri"].write(value.redirectUri)
    }
}

extension AppFabricClientTypes.Credential {

    static func write(value: AppFabricClientTypes.Credential?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .apikeycredential(apikeycredential):
                try writer["apiKeyCredential"].write(apikeycredential, with: AppFabricClientTypes.ApiKeyCredential.write(value:to:))
            case let .oauth2credential(oauth2credential):
                try writer["oauth2Credential"].write(oauth2credential, with: AppFabricClientTypes.Oauth2Credential.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension AppFabricClientTypes.ApiKeyCredential {

    static func write(value: AppFabricClientTypes.ApiKeyCredential?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiKey"].write(value.apiKey)
    }
}

extension AppFabricClientTypes.Oauth2Credential {

    static func write(value: AppFabricClientTypes.Oauth2Credential?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientId"].write(value.clientId)
        try writer["clientSecret"].write(value.clientSecret)
    }
}

public enum AppFabricClientTypes {}
