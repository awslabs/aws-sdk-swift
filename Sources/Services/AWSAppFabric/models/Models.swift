// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You are not authorized to perform this operation.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppFabricClientTypes.ApiKeyCredential: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKey = self.apiKey {
            try encodeContainer.encode(apiKey, forKey: .apiKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKey)
        apiKey = apiKeyDecoded
    }
}

extension AppFabricClientTypes.ApiKeyCredential: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApiKeyCredential(apiKey: \"CONTENT_REDACTED\")"}
}

extension AppFabricClientTypes {
    /// Contains API key credential information.
    public struct ApiKeyCredential: Swift.Equatable {
        /// An API key for an application.
        /// This member is required.
        public var apiKey: Swift.String?

        public init(
            apiKey: Swift.String? = nil
        )
        {
            self.apiKey = apiKey
        }
    }

}

extension AppFabricClientTypes.AppAuthorization: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case app
        case appAuthorizationArn
        case appBundleArn
        case authType
        case authUrl
        case createdAt
        case persona
        case status
        case tenant
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let app = self.app {
            try encodeContainer.encode(app, forKey: .app)
        }
        if let appAuthorizationArn = self.appAuthorizationArn {
            try encodeContainer.encode(appAuthorizationArn, forKey: .appAuthorizationArn)
        }
        if let appBundleArn = self.appBundleArn {
            try encodeContainer.encode(appBundleArn, forKey: .appBundleArn)
        }
        if let authType = self.authType {
            try encodeContainer.encode(authType.rawValue, forKey: .authType)
        }
        if let authUrl = self.authUrl {
            try encodeContainer.encode(authUrl, forKey: .authUrl)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let persona = self.persona {
            try encodeContainer.encode(persona.rawValue, forKey: .persona)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tenant = self.tenant {
            try encodeContainer.encode(tenant, forKey: .tenant)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appAuthorizationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appAuthorizationArn)
        appAuthorizationArn = appAuthorizationArnDecoded
        let appBundleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appBundleArn)
        appBundleArn = appBundleArnDecoded
        let appDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .app)
        app = appDecoded
        let tenantDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.Tenant.self, forKey: .tenant)
        tenant = tenantDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.AuthType.self, forKey: .authType)
        authType = authTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.AppAuthorizationStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let personaDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.Persona.self, forKey: .persona)
        persona = personaDecoded
        let authUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authUrl)
        authUrl = authUrlDecoded
    }
}

extension AppFabricClientTypes {
    /// Contains information about an app authorization.
    public struct AppAuthorization: Swift.Equatable {
        /// The name of the application.
        /// This member is required.
        public var app: Swift.String?
        /// The Amazon Resource Name (ARN) of the app authorization.
        /// This member is required.
        public var appAuthorizationArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the app bundle for the app authorization.
        /// This member is required.
        public var appBundleArn: Swift.String?
        /// The authorization type.
        /// This member is required.
        public var authType: AppFabricClientTypes.AuthType?
        /// The application URL for the OAuth flow.
        public var authUrl: Swift.String?
        /// The timestamp of when the app authorization was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The user persona of the app authorization. This field should always be admin.
        public var persona: AppFabricClientTypes.Persona?
        /// The state of the app authorization. The following states are possible:
        ///
        /// * PendingConnect: The initial state of the app authorization. The app authorization is created but not yet connected.
        ///
        /// * Connected: The app authorization is connected to the application, and is ready to be used.
        ///
        /// * ConnectionValidationFailed: The app authorization received a validation exception when trying to connect to the application. If the app authorization is in this state, you should verify the configured credentials and try to connect the app authorization again.
        ///
        /// * TokenAutoRotationFailed: AppFabric failed to refresh the access token. If the app authorization is in this state, you should try to reconnect the app authorization.
        /// This member is required.
        public var status: AppFabricClientTypes.AppAuthorizationStatus?
        /// Contains information about an application tenant, such as the application display name and identifier.
        /// This member is required.
        public var tenant: AppFabricClientTypes.Tenant?
        /// The timestamp of when the app authorization was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            app: Swift.String? = nil,
            appAuthorizationArn: Swift.String? = nil,
            appBundleArn: Swift.String? = nil,
            authType: AppFabricClientTypes.AuthType? = nil,
            authUrl: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            persona: AppFabricClientTypes.Persona? = nil,
            status: AppFabricClientTypes.AppAuthorizationStatus? = nil,
            tenant: AppFabricClientTypes.Tenant? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.app = app
            self.appAuthorizationArn = appAuthorizationArn
            self.appBundleArn = appBundleArn
            self.authType = authType
            self.authUrl = authUrl
            self.createdAt = createdAt
            self.persona = persona
            self.status = status
            self.tenant = tenant
            self.updatedAt = updatedAt
        }
    }

}

extension AppFabricClientTypes {
    public enum AppAuthorizationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connected
        case connectionValidationFailed
        case pendingConnect
        case tokenAutoRotationFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [AppAuthorizationStatus] {
            return [
                .connected,
                .connectionValidationFailed,
                .pendingConnect,
                .tokenAutoRotationFailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connected: return "Connected"
            case .connectionValidationFailed: return "ConnectionValidationFailed"
            case .pendingConnect: return "PendingConnect"
            case .tokenAutoRotationFailed: return "TokenAutoRotationFailed"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppAuthorizationStatus(rawValue: rawValue) ?? AppAuthorizationStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppFabricClientTypes.AppAuthorizationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case app
        case appAuthorizationArn
        case appBundleArn
        case status
        case tenant
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let app = self.app {
            try encodeContainer.encode(app, forKey: .app)
        }
        if let appAuthorizationArn = self.appAuthorizationArn {
            try encodeContainer.encode(appAuthorizationArn, forKey: .appAuthorizationArn)
        }
        if let appBundleArn = self.appBundleArn {
            try encodeContainer.encode(appBundleArn, forKey: .appBundleArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tenant = self.tenant {
            try encodeContainer.encode(tenant, forKey: .tenant)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appAuthorizationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appAuthorizationArn)
        appAuthorizationArn = appAuthorizationArnDecoded
        let appBundleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appBundleArn)
        appBundleArn = appBundleArnDecoded
        let appDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .app)
        app = appDecoded
        let tenantDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.Tenant.self, forKey: .tenant)
        tenant = tenantDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.AppAuthorizationStatus.self, forKey: .status)
        status = statusDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension AppFabricClientTypes {
    /// Contains a summary of an app authorization.
    public struct AppAuthorizationSummary: Swift.Equatable {
        /// The name of the application.
        /// This member is required.
        public var app: Swift.String?
        /// The Amazon Resource Name (ARN) of the app authorization.
        /// This member is required.
        public var appAuthorizationArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the app bundle for the app authorization.
        /// This member is required.
        public var appBundleArn: Swift.String?
        /// The state of the app authorization. The following states are possible:
        ///
        /// * PendingConnect: The initial state of the app authorization. The app authorization is created but not yet connected.
        ///
        /// * Connected: The app authorization is connected to the application, and is ready to be used.
        ///
        /// * ConnectionValidationFailed: The app authorization received a validation exception when trying to connect to the application. If the app authorization is in this state, you should verify the configured credentials and try to connect the app authorization again.
        ///
        /// * TokenAutoRotationFailed: AppFabric failed to refresh the access token. If the app authorization is in this state, you should try to reconnect the app authorization.
        /// This member is required.
        public var status: AppFabricClientTypes.AppAuthorizationStatus?
        /// Contains information about an application tenant, such as the application display name and identifier.
        /// This member is required.
        public var tenant: AppFabricClientTypes.Tenant?
        /// Timestamp for when the app authorization was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            app: Swift.String? = nil,
            appAuthorizationArn: Swift.String? = nil,
            appBundleArn: Swift.String? = nil,
            status: AppFabricClientTypes.AppAuthorizationStatus? = nil,
            tenant: AppFabricClientTypes.Tenant? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.app = app
            self.appAuthorizationArn = appAuthorizationArn
            self.appBundleArn = appBundleArn
            self.status = status
            self.tenant = tenant
            self.updatedAt = updatedAt
        }
    }

}

extension AppFabricClientTypes.AppBundle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case customerManagedKeyArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let customerManagedKeyArn = self.customerManagedKeyArn {
            try encodeContainer.encode(customerManagedKeyArn, forKey: .customerManagedKeyArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let customerManagedKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerManagedKeyArn)
        customerManagedKeyArn = customerManagedKeyArnDecoded
    }
}

extension AppFabricClientTypes {
    /// Contains information about an app bundle.
    public struct AppBundle: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the app bundle.
        /// This member is required.
        public var arn: Swift.String?
        /// The Amazon Resource Name (ARN) of the Key Management Service (KMS) key used to encrypt the application data.
        public var customerManagedKeyArn: Swift.String?

        public init(
            arn: Swift.String? = nil,
            customerManagedKeyArn: Swift.String? = nil
        )
        {
            self.arn = arn
            self.customerManagedKeyArn = customerManagedKeyArn
        }
    }

}

extension AppFabricClientTypes.AppBundleSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension AppFabricClientTypes {
    /// Contains a summary of an app bundle.
    public struct AppBundleSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the app bundle.
        /// This member is required.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension AppFabricClientTypes.AuditLogDestinationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destination
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.Destination.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension AppFabricClientTypes {
    /// Contains information about an audit log destination configuration.
    public struct AuditLogDestinationConfiguration: Swift.Equatable {
        /// Contains information about an audit log destination.
        /// This member is required.
        public var destination: AppFabricClientTypes.Destination?

        public init(
            destination: AppFabricClientTypes.Destination? = nil
        )
        {
            self.destination = destination
        }
    }

}

extension AppFabricClientTypes.AuditLogProcessingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format
        case schema
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let schema = self.schema {
            try encodeContainer.encode(schema.rawValue, forKey: .schema)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.Schema.self, forKey: .schema)
        schema = schemaDecoded
        let formatDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.Format.self, forKey: .format)
        format = formatDecoded
    }
}

extension AppFabricClientTypes {
    /// Contains information about an audit log processing configuration.
    public struct AuditLogProcessingConfiguration: Swift.Equatable {
        /// The format in which the audit logs need to be formatted.
        /// This member is required.
        public var format: AppFabricClientTypes.Format?
        /// The event schema in which the audit logs need to be formatted.
        /// This member is required.
        public var schema: AppFabricClientTypes.Schema?

        public init(
            format: AppFabricClientTypes.Format? = nil,
            schema: AppFabricClientTypes.Schema? = nil
        )
        {
            self.format = format
            self.schema = schema
        }
    }

}

extension AppFabricClientTypes.AuthRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case redirectUri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let redirectUri = self.redirectUri {
            try encodeContainer.encode(redirectUri, forKey: .redirectUri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let redirectUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .redirectUri)
        redirectUri = redirectUriDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension AppFabricClientTypes.AuthRequest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AuthRequest(redirectUri: \(Swift.String(describing: redirectUri)), code: \"CONTENT_REDACTED\")"}
}

extension AppFabricClientTypes {
    /// Contains authorization request information, which is required for Amazon Web Services AppFabric to get the OAuth2 access token for an application.
    public struct AuthRequest: Swift.Equatable {
        /// The authorization code returned by the application after permission is granted in the application OAuth page (after clicking on the AuthURL).
        /// This member is required.
        public var code: Swift.String?
        /// The redirect URL that is specified in the AuthURL and the application client.
        /// This member is required.
        public var redirectUri: Swift.String?

        public init(
            code: Swift.String? = nil,
            redirectUri: Swift.String? = nil
        )
        {
            self.code = code
            self.redirectUri = redirectUri
        }
    }

}

extension AppFabricClientTypes {
    public enum AuthType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case apiKey
        case oauth2
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthType] {
            return [
                .apiKey,
                .oauth2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .apiKey: return "apiKey"
            case .oauth2: return "oauth2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthType(rawValue: rawValue) ?? AuthType.sdkUnknown(rawValue)
        }
    }
}

extension BatchGetUserAccessTasksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBundleIdentifier
        case taskIdList
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appBundleIdentifier = self.appBundleIdentifier {
            try encodeContainer.encode(appBundleIdentifier, forKey: .appBundleIdentifier)
        }
        if let taskIdList = taskIdList {
            var taskIdListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .taskIdList)
            for uuid0 in taskIdList {
                try taskIdListContainer.encode(uuid0)
            }
        }
    }
}

extension BatchGetUserAccessTasksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/useraccess/batchget"
    }
}

public struct BatchGetUserAccessTasksInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// The tasks IDs to use for the request.
    /// This member is required.
    public var taskIdList: [Swift.String]?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        taskIdList: [Swift.String]? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.taskIdList = taskIdList
    }
}

struct BatchGetUserAccessTasksInputBody: Swift.Equatable {
    let appBundleIdentifier: Swift.String?
    let taskIdList: [Swift.String]?
}

extension BatchGetUserAccessTasksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBundleIdentifier
        case taskIdList
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appBundleIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appBundleIdentifier)
        appBundleIdentifier = appBundleIdentifierDecoded
        let taskIdListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .taskIdList)
        var taskIdListDecoded0:[Swift.String]? = nil
        if let taskIdListContainer = taskIdListContainer {
            taskIdListDecoded0 = [Swift.String]()
            for string0 in taskIdListContainer {
                if let string0 = string0 {
                    taskIdListDecoded0?.append(string0)
                }
            }
        }
        taskIdList = taskIdListDecoded0
    }
}

extension BatchGetUserAccessTasksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchGetUserAccessTasksOutputBody = try responseDecoder.decode(responseBody: data)
            self.userAccessResultsList = output.userAccessResultsList
        } else {
            self.userAccessResultsList = nil
        }
    }
}

public struct BatchGetUserAccessTasksOutput: Swift.Equatable {
    /// Contains a list of user access results.
    public var userAccessResultsList: [AppFabricClientTypes.UserAccessResultItem]?

    public init(
        userAccessResultsList: [AppFabricClientTypes.UserAccessResultItem]? = nil
    )
    {
        self.userAccessResultsList = userAccessResultsList
    }
}

struct BatchGetUserAccessTasksOutputBody: Swift.Equatable {
    let userAccessResultsList: [AppFabricClientTypes.UserAccessResultItem]?
}

extension BatchGetUserAccessTasksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userAccessResultsList
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userAccessResultsListContainer = try containerValues.decodeIfPresent([AppFabricClientTypes.UserAccessResultItem?].self, forKey: .userAccessResultsList)
        var userAccessResultsListDecoded0:[AppFabricClientTypes.UserAccessResultItem]? = nil
        if let userAccessResultsListContainer = userAccessResultsListContainer {
            userAccessResultsListDecoded0 = [AppFabricClientTypes.UserAccessResultItem]()
            for structure0 in userAccessResultsListContainer {
                if let structure0 = structure0 {
                    userAccessResultsListDecoded0?.append(structure0)
                }
            }
        }
        userAccessResultsList = userAccessResultsListDecoded0
    }
}

enum BatchGetUserAccessTasksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request has created a conflict. Check the request parameters and try again.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The resource ID.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ConnectAppAuthorizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authRequest
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authRequest = self.authRequest {
            try encodeContainer.encode(authRequest, forKey: .authRequest)
        }
    }
}

extension ConnectAppAuthorizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appBundleIdentifier = appBundleIdentifier else {
            return nil
        }
        guard let appAuthorizationIdentifier = appAuthorizationIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/appauthorizations/\(appAuthorizationIdentifier.urlPercentEncoding())/connect"
    }
}

public struct ConnectAppAuthorizationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app authorization to use for the request.
    /// This member is required.
    public var appAuthorizationIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle that contains the app authorization to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// Contains OAuth2 authorization information. This is required if the app authorization for the request is configured with an OAuth2 (oauth2) authorization type.
    public var authRequest: AppFabricClientTypes.AuthRequest?

    public init(
        appAuthorizationIdentifier: Swift.String? = nil,
        appBundleIdentifier: Swift.String? = nil,
        authRequest: AppFabricClientTypes.AuthRequest? = nil
    )
    {
        self.appAuthorizationIdentifier = appAuthorizationIdentifier
        self.appBundleIdentifier = appBundleIdentifier
        self.authRequest = authRequest
    }
}

struct ConnectAppAuthorizationInputBody: Swift.Equatable {
    let authRequest: AppFabricClientTypes.AuthRequest?
}

extension ConnectAppAuthorizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authRequest
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authRequestDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.AuthRequest.self, forKey: .authRequest)
        authRequest = authRequestDecoded
    }
}

extension ConnectAppAuthorizationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConnectAppAuthorizationOutputBody = try responseDecoder.decode(responseBody: data)
            self.appAuthorizationSummary = output.appAuthorizationSummary
        } else {
            self.appAuthorizationSummary = nil
        }
    }
}

public struct ConnectAppAuthorizationOutput: Swift.Equatable {
    /// Contains a summary of the app authorization.
    /// This member is required.
    public var appAuthorizationSummary: AppFabricClientTypes.AppAuthorizationSummary?

    public init(
        appAuthorizationSummary: AppFabricClientTypes.AppAuthorizationSummary? = nil
    )
    {
        self.appAuthorizationSummary = appAuthorizationSummary
    }
}

struct ConnectAppAuthorizationOutputBody: Swift.Equatable {
    let appAuthorizationSummary: AppFabricClientTypes.AppAuthorizationSummary?
}

extension ConnectAppAuthorizationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appAuthorizationSummary
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appAuthorizationSummaryDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.AppAuthorizationSummary.self, forKey: .appAuthorizationSummary)
        appAuthorizationSummary = appAuthorizationSummaryDecoded
    }
}

enum ConnectAppAuthorizationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateAppAuthorizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case app
        case authType
        case clientToken
        case credential
        case tags
        case tenant
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let app = self.app {
            try encodeContainer.encode(app, forKey: .app)
        }
        if let authType = self.authType {
            try encodeContainer.encode(authType.rawValue, forKey: .authType)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let credential = self.credential {
            try encodeContainer.encode(credential, forKey: .credential)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let tenant = self.tenant {
            try encodeContainer.encode(tenant, forKey: .tenant)
        }
    }
}

extension CreateAppAuthorizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appBundleIdentifier = appBundleIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/appauthorizations"
    }
}

public struct CreateAppAuthorizationInput: Swift.Equatable {
    /// The name of the application. Valid values are:
    ///
    /// * SLACK
    ///
    /// * ASANA
    ///
    /// * JIRA
    ///
    /// * M365
    ///
    /// * M365AUDITLOGS
    ///
    /// * ZOOM
    ///
    /// * ZENDESK
    ///
    /// * OKTA
    ///
    /// * GOOGLE
    ///
    /// * DROPBOX
    ///
    /// * SMARTSHEET
    ///
    /// * CISCO
    /// This member is required.
    public var app: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// The authorization type for the app authorization.
    /// This member is required.
    public var authType: AppFabricClientTypes.AuthType?
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// Contains credentials for the application, such as an API key or OAuth2 client ID and secret. Specify credentials that match the authorization type for your request. For example, if the authorization type for your request is OAuth2 (oauth2), then you should provide only the OAuth2 credentials.
    /// This member is required.
    public var credential: AppFabricClientTypes.Credential?
    /// A map of the key-value pairs of the tag or tags to assign to the resource.
    public var tags: [AppFabricClientTypes.Tag]?
    /// Contains information about an application tenant, such as the application display name and identifier.
    /// This member is required.
    public var tenant: AppFabricClientTypes.Tenant?

    public init(
        app: Swift.String? = nil,
        appBundleIdentifier: Swift.String? = nil,
        authType: AppFabricClientTypes.AuthType? = nil,
        clientToken: Swift.String? = nil,
        credential: AppFabricClientTypes.Credential? = nil,
        tags: [AppFabricClientTypes.Tag]? = nil,
        tenant: AppFabricClientTypes.Tenant? = nil
    )
    {
        self.app = app
        self.appBundleIdentifier = appBundleIdentifier
        self.authType = authType
        self.clientToken = clientToken
        self.credential = credential
        self.tags = tags
        self.tenant = tenant
    }
}

struct CreateAppAuthorizationInputBody: Swift.Equatable {
    let app: Swift.String?
    let credential: AppFabricClientTypes.Credential?
    let tenant: AppFabricClientTypes.Tenant?
    let authType: AppFabricClientTypes.AuthType?
    let clientToken: Swift.String?
    let tags: [AppFabricClientTypes.Tag]?
}

extension CreateAppAuthorizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case app
        case authType
        case clientToken
        case credential
        case tags
        case tenant
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .app)
        app = appDecoded
        let credentialDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.Credential.self, forKey: .credential)
        credential = credentialDecoded
        let tenantDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.Tenant.self, forKey: .tenant)
        tenant = tenantDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.AuthType.self, forKey: .authType)
        authType = authTypeDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AppFabricClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AppFabricClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AppFabricClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAppAuthorizationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAppAuthorizationOutputBody = try responseDecoder.decode(responseBody: data)
            self.appAuthorization = output.appAuthorization
        } else {
            self.appAuthorization = nil
        }
    }
}

public struct CreateAppAuthorizationOutput: Swift.Equatable {
    /// Contains information about an app authorization.
    /// This member is required.
    public var appAuthorization: AppFabricClientTypes.AppAuthorization?

    public init(
        appAuthorization: AppFabricClientTypes.AppAuthorization? = nil
    )
    {
        self.appAuthorization = appAuthorization
    }
}

struct CreateAppAuthorizationOutputBody: Swift.Equatable {
    let appAuthorization: AppFabricClientTypes.AppAuthorization?
}

extension CreateAppAuthorizationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appAuthorization
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appAuthorizationDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.AppAuthorization.self, forKey: .appAuthorization)
        appAuthorization = appAuthorizationDecoded
    }
}

enum CreateAppAuthorizationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateAppBundleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case customerManagedKeyIdentifier
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let customerManagedKeyIdentifier = self.customerManagedKeyIdentifier {
            try encodeContainer.encode(customerManagedKeyIdentifier, forKey: .customerManagedKeyIdentifier)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateAppBundleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/appbundles"
    }
}

public struct CreateAppBundleInput: Swift.Equatable {
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the Key Management Service (KMS) key to use to encrypt the application data. If this is not specified, an Amazon Web Services owned key is used for encryption.
    public var customerManagedKeyIdentifier: Swift.String?
    /// A map of the key-value pairs of the tag or tags to assign to the resource.
    public var tags: [AppFabricClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        customerManagedKeyIdentifier: Swift.String? = nil,
        tags: [AppFabricClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.customerManagedKeyIdentifier = customerManagedKeyIdentifier
        self.tags = tags
    }
}

struct CreateAppBundleInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let customerManagedKeyIdentifier: Swift.String?
    let tags: [AppFabricClientTypes.Tag]?
}

extension CreateAppBundleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case customerManagedKeyIdentifier
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let customerManagedKeyIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerManagedKeyIdentifier)
        customerManagedKeyIdentifier = customerManagedKeyIdentifierDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AppFabricClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AppFabricClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AppFabricClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAppBundleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAppBundleOutputBody = try responseDecoder.decode(responseBody: data)
            self.appBundle = output.appBundle
        } else {
            self.appBundle = nil
        }
    }
}

public struct CreateAppBundleOutput: Swift.Equatable {
    /// Contains information about an app bundle.
    /// This member is required.
    public var appBundle: AppFabricClientTypes.AppBundle?

    public init(
        appBundle: AppFabricClientTypes.AppBundle? = nil
    )
    {
        self.appBundle = appBundle
    }
}

struct CreateAppBundleOutputBody: Swift.Equatable {
    let appBundle: AppFabricClientTypes.AppBundle?
}

extension CreateAppBundleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBundle
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appBundleDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.AppBundle.self, forKey: .appBundle)
        appBundle = appBundleDecoded
    }
}

enum CreateAppBundleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateIngestionDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case destinationConfiguration
        case processingConfiguration
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let destinationConfiguration = self.destinationConfiguration {
            try encodeContainer.encode(destinationConfiguration, forKey: .destinationConfiguration)
        }
        if let processingConfiguration = self.processingConfiguration {
            try encodeContainer.encode(processingConfiguration, forKey: .processingConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateIngestionDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appBundleIdentifier = appBundleIdentifier else {
            return nil
        }
        guard let ingestionIdentifier = ingestionIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/ingestions/\(ingestionIdentifier.urlPercentEncoding())/ingestiondestinations"
    }
}

public struct CreateIngestionDestinationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// Contains information about the destination of ingested data.
    /// This member is required.
    public var destinationConfiguration: AppFabricClientTypes.DestinationConfiguration?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion to use for the request.
    /// This member is required.
    public var ingestionIdentifier: Swift.String?
    /// Contains information about how ingested data is processed.
    /// This member is required.
    public var processingConfiguration: AppFabricClientTypes.ProcessingConfiguration?
    /// A map of the key-value pairs of the tag or tags to assign to the resource.
    public var tags: [AppFabricClientTypes.Tag]?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        destinationConfiguration: AppFabricClientTypes.DestinationConfiguration? = nil,
        ingestionIdentifier: Swift.String? = nil,
        processingConfiguration: AppFabricClientTypes.ProcessingConfiguration? = nil,
        tags: [AppFabricClientTypes.Tag]? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.clientToken = clientToken
        self.destinationConfiguration = destinationConfiguration
        self.ingestionIdentifier = ingestionIdentifier
        self.processingConfiguration = processingConfiguration
        self.tags = tags
    }
}

struct CreateIngestionDestinationInputBody: Swift.Equatable {
    let processingConfiguration: AppFabricClientTypes.ProcessingConfiguration?
    let destinationConfiguration: AppFabricClientTypes.DestinationConfiguration?
    let clientToken: Swift.String?
    let tags: [AppFabricClientTypes.Tag]?
}

extension CreateIngestionDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case destinationConfiguration
        case processingConfiguration
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let processingConfigurationDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.ProcessingConfiguration.self, forKey: .processingConfiguration)
        processingConfiguration = processingConfigurationDecoded
        let destinationConfigurationDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.DestinationConfiguration.self, forKey: .destinationConfiguration)
        destinationConfiguration = destinationConfigurationDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AppFabricClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AppFabricClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AppFabricClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateIngestionDestinationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateIngestionDestinationOutputBody = try responseDecoder.decode(responseBody: data)
            self.ingestionDestination = output.ingestionDestination
        } else {
            self.ingestionDestination = nil
        }
    }
}

public struct CreateIngestionDestinationOutput: Swift.Equatable {
    /// Contains information about an ingestion destination.
    /// This member is required.
    public var ingestionDestination: AppFabricClientTypes.IngestionDestination?

    public init(
        ingestionDestination: AppFabricClientTypes.IngestionDestination? = nil
    )
    {
        self.ingestionDestination = ingestionDestination
    }
}

struct CreateIngestionDestinationOutputBody: Swift.Equatable {
    let ingestionDestination: AppFabricClientTypes.IngestionDestination?
}

extension CreateIngestionDestinationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ingestionDestination
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ingestionDestinationDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.IngestionDestination.self, forKey: .ingestionDestination)
        ingestionDestination = ingestionDestinationDecoded
    }
}

enum CreateIngestionDestinationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateIngestionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case app
        case clientToken
        case ingestionType
        case tags
        case tenantId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let app = self.app {
            try encodeContainer.encode(app, forKey: .app)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let ingestionType = self.ingestionType {
            try encodeContainer.encode(ingestionType.rawValue, forKey: .ingestionType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let tenantId = self.tenantId {
            try encodeContainer.encode(tenantId, forKey: .tenantId)
        }
    }
}

extension CreateIngestionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appBundleIdentifier = appBundleIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/ingestions"
    }
}

public struct CreateIngestionInput: Swift.Equatable {
    /// The name of the application. Valid values are:
    ///
    /// * SLACK
    ///
    /// * ASANA
    ///
    /// * JIRA
    ///
    /// * M365
    ///
    /// * M365AUDITLOGS
    ///
    /// * ZOOM
    ///
    /// * ZENDESK
    ///
    /// * OKTA
    ///
    /// * GOOGLE
    ///
    /// * DROPBOX
    ///
    /// * SMARTSHEET
    ///
    /// * CISCO
    /// This member is required.
    public var app: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// The ingestion type.
    /// This member is required.
    public var ingestionType: AppFabricClientTypes.IngestionType?
    /// A map of the key-value pairs of the tag or tags to assign to the resource.
    public var tags: [AppFabricClientTypes.Tag]?
    /// The ID of the application tenant.
    /// This member is required.
    public var tenantId: Swift.String?

    public init(
        app: Swift.String? = nil,
        appBundleIdentifier: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        ingestionType: AppFabricClientTypes.IngestionType? = nil,
        tags: [AppFabricClientTypes.Tag]? = nil,
        tenantId: Swift.String? = nil
    )
    {
        self.app = app
        self.appBundleIdentifier = appBundleIdentifier
        self.clientToken = clientToken
        self.ingestionType = ingestionType
        self.tags = tags
        self.tenantId = tenantId
    }
}

struct CreateIngestionInputBody: Swift.Equatable {
    let app: Swift.String?
    let tenantId: Swift.String?
    let ingestionType: AppFabricClientTypes.IngestionType?
    let clientToken: Swift.String?
    let tags: [AppFabricClientTypes.Tag]?
}

extension CreateIngestionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case app
        case clientToken
        case ingestionType
        case tags
        case tenantId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .app)
        app = appDecoded
        let tenantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tenantId)
        tenantId = tenantIdDecoded
        let ingestionTypeDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.IngestionType.self, forKey: .ingestionType)
        ingestionType = ingestionTypeDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AppFabricClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AppFabricClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AppFabricClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateIngestionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateIngestionOutputBody = try responseDecoder.decode(responseBody: data)
            self.ingestion = output.ingestion
        } else {
            self.ingestion = nil
        }
    }
}

public struct CreateIngestionOutput: Swift.Equatable {
    /// Contains information about an ingestion.
    /// This member is required.
    public var ingestion: AppFabricClientTypes.Ingestion?

    public init(
        ingestion: AppFabricClientTypes.Ingestion? = nil
    )
    {
        self.ingestion = ingestion
    }
}

struct CreateIngestionOutputBody: Swift.Equatable {
    let ingestion: AppFabricClientTypes.Ingestion?
}

extension CreateIngestionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ingestion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ingestionDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.Ingestion.self, forKey: .ingestion)
        ingestion = ingestionDecoded
    }
}

enum CreateIngestionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppFabricClientTypes.Credential: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apikeycredential = "apiKeyCredential"
        case oauth2credential = "oauth2Credential"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .apikeycredential(apikeycredential):
                try container.encode(apikeycredential, forKey: .apikeycredential)
            case let .oauth2credential(oauth2credential):
                try container.encode(oauth2credential, forKey: .oauth2credential)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let oauth2credentialDecoded = try values.decodeIfPresent(AppFabricClientTypes.Oauth2Credential.self, forKey: .oauth2credential)
        if let oauth2credential = oauth2credentialDecoded {
            self = .oauth2credential(oauth2credential)
            return
        }
        let apikeycredentialDecoded = try values.decodeIfPresent(AppFabricClientTypes.ApiKeyCredential.self, forKey: .apikeycredential)
        if let apikeycredential = apikeycredentialDecoded {
            self = .apikeycredential(apikeycredential)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AppFabricClientTypes {
    /// Contains credential information for an application.
    public enum Credential: Swift.Equatable {
        /// Contains OAuth2 client credential information.
        case oauth2credential(AppFabricClientTypes.Oauth2Credential)
        /// Contains API key credential information.
        case apikeycredential(AppFabricClientTypes.ApiKeyCredential)
        case sdkUnknown(Swift.String)
    }

}

extension DeleteAppAuthorizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appBundleIdentifier = appBundleIdentifier else {
            return nil
        }
        guard let appAuthorizationIdentifier = appAuthorizationIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/appauthorizations/\(appAuthorizationIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteAppAuthorizationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app authorization to use for the request.
    /// This member is required.
    public var appAuthorizationIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?

    public init(
        appAuthorizationIdentifier: Swift.String? = nil,
        appBundleIdentifier: Swift.String? = nil
    )
    {
        self.appAuthorizationIdentifier = appAuthorizationIdentifier
        self.appBundleIdentifier = appBundleIdentifier
    }
}

struct DeleteAppAuthorizationInputBody: Swift.Equatable {
}

extension DeleteAppAuthorizationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAppAuthorizationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAppAuthorizationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAppAuthorizationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAppBundleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appBundleIdentifier = appBundleIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteAppBundleInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the app bundle that needs to be deleted.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
    }
}

struct DeleteAppBundleInputBody: Swift.Equatable {
}

extension DeleteAppBundleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAppBundleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAppBundleOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAppBundleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteIngestionDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appBundleIdentifier = appBundleIdentifier else {
            return nil
        }
        guard let ingestionIdentifier = ingestionIdentifier else {
            return nil
        }
        guard let ingestionDestinationIdentifier = ingestionDestinationIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/ingestions/\(ingestionIdentifier.urlPercentEncoding())/ingestiondestinations/\(ingestionDestinationIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteIngestionDestinationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion destination to use for the request.
    /// This member is required.
    public var ingestionDestinationIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion to use for the request.
    /// This member is required.
    public var ingestionIdentifier: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        ingestionDestinationIdentifier: Swift.String? = nil,
        ingestionIdentifier: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.ingestionDestinationIdentifier = ingestionDestinationIdentifier
        self.ingestionIdentifier = ingestionIdentifier
    }
}

struct DeleteIngestionDestinationInputBody: Swift.Equatable {
}

extension DeleteIngestionDestinationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteIngestionDestinationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteIngestionDestinationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteIngestionDestinationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteIngestionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appBundleIdentifier = appBundleIdentifier else {
            return nil
        }
        guard let ingestionIdentifier = ingestionIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/ingestions/\(ingestionIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteIngestionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion to use for the request.
    /// This member is required.
    public var ingestionIdentifier: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        ingestionIdentifier: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.ingestionIdentifier = ingestionIdentifier
    }
}

struct DeleteIngestionInputBody: Swift.Equatable {
}

extension DeleteIngestionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteIngestionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteIngestionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteIngestionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppFabricClientTypes.Destination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case firehosestream = "firehoseStream"
        case s3bucket = "s3Bucket"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .firehosestream(firehosestream):
                try container.encode(firehosestream, forKey: .firehosestream)
            case let .s3bucket(s3bucket):
                try container.encode(s3bucket, forKey: .s3bucket)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let s3bucketDecoded = try values.decodeIfPresent(AppFabricClientTypes.S3Bucket.self, forKey: .s3bucket)
        if let s3bucket = s3bucketDecoded {
            self = .s3bucket(s3bucket)
            return
        }
        let firehosestreamDecoded = try values.decodeIfPresent(AppFabricClientTypes.FirehoseStream.self, forKey: .firehosestream)
        if let firehosestream = firehosestreamDecoded {
            self = .firehosestream(firehosestream)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AppFabricClientTypes {
    /// Contains information about an audit log destination.
    public enum Destination: Swift.Equatable {
        /// Contains information about an Amazon S3 bucket.
        case s3bucket(AppFabricClientTypes.S3Bucket)
        /// Contains information about an Amazon Kinesis Data Firehose delivery stream.
        case firehosestream(AppFabricClientTypes.FirehoseStream)
        case sdkUnknown(Swift.String)
    }

}

extension AppFabricClientTypes.DestinationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditlog = "auditLog"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .auditlog(auditlog):
                try container.encode(auditlog, forKey: .auditlog)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let auditlogDecoded = try values.decodeIfPresent(AppFabricClientTypes.AuditLogDestinationConfiguration.self, forKey: .auditlog)
        if let auditlog = auditlogDecoded {
            self = .auditlog(auditlog)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AppFabricClientTypes {
    /// Contains information about the destination of ingested data.
    public enum DestinationConfiguration: Swift.Equatable {
        /// Contains information about an audit log destination configuration.
        case auditlog(AppFabricClientTypes.AuditLogDestinationConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension AppFabricClientTypes.FirehoseStream: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
    }
}

extension AppFabricClientTypes {
    /// Contains information about an Amazon Kinesis Data Firehose delivery stream.
    public struct FirehoseStream: Swift.Equatable {
        /// The name of the Amazon Kinesis Data Firehose delivery stream.
        /// This member is required.
        public var streamName: Swift.String?

        public init(
            streamName: Swift.String? = nil
        )
        {
            self.streamName = streamName
        }
    }

}

extension AppFabricClientTypes {
    public enum Format: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case json
        case parquet
        case sdkUnknown(Swift.String)

        public static var allCases: [Format] {
            return [
                .json,
                .parquet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .json: return "json"
            case .parquet: return "parquet"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Format(rawValue: rawValue) ?? Format.sdkUnknown(rawValue)
        }
    }
}

extension GetAppAuthorizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appBundleIdentifier = appBundleIdentifier else {
            return nil
        }
        guard let appAuthorizationIdentifier = appAuthorizationIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/appauthorizations/\(appAuthorizationIdentifier.urlPercentEncoding())"
    }
}

public struct GetAppAuthorizationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app authorization to use for the request.
    /// This member is required.
    public var appAuthorizationIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?

    public init(
        appAuthorizationIdentifier: Swift.String? = nil,
        appBundleIdentifier: Swift.String? = nil
    )
    {
        self.appAuthorizationIdentifier = appAuthorizationIdentifier
        self.appBundleIdentifier = appBundleIdentifier
    }
}

struct GetAppAuthorizationInputBody: Swift.Equatable {
}

extension GetAppAuthorizationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAppAuthorizationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAppAuthorizationOutputBody = try responseDecoder.decode(responseBody: data)
            self.appAuthorization = output.appAuthorization
        } else {
            self.appAuthorization = nil
        }
    }
}

public struct GetAppAuthorizationOutput: Swift.Equatable {
    /// Contains information about an app authorization.
    /// This member is required.
    public var appAuthorization: AppFabricClientTypes.AppAuthorization?

    public init(
        appAuthorization: AppFabricClientTypes.AppAuthorization? = nil
    )
    {
        self.appAuthorization = appAuthorization
    }
}

struct GetAppAuthorizationOutputBody: Swift.Equatable {
    let appAuthorization: AppFabricClientTypes.AppAuthorization?
}

extension GetAppAuthorizationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appAuthorization
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appAuthorizationDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.AppAuthorization.self, forKey: .appAuthorization)
        appAuthorization = appAuthorizationDecoded
    }
}

enum GetAppAuthorizationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAppBundleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appBundleIdentifier = appBundleIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())"
    }
}

public struct GetAppBundleInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
    }
}

struct GetAppBundleInputBody: Swift.Equatable {
}

extension GetAppBundleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAppBundleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAppBundleOutputBody = try responseDecoder.decode(responseBody: data)
            self.appBundle = output.appBundle
        } else {
            self.appBundle = nil
        }
    }
}

public struct GetAppBundleOutput: Swift.Equatable {
    /// Contains information about an app bundle.
    /// This member is required.
    public var appBundle: AppFabricClientTypes.AppBundle?

    public init(
        appBundle: AppFabricClientTypes.AppBundle? = nil
    )
    {
        self.appBundle = appBundle
    }
}

struct GetAppBundleOutputBody: Swift.Equatable {
    let appBundle: AppFabricClientTypes.AppBundle?
}

extension GetAppBundleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBundle
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appBundleDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.AppBundle.self, forKey: .appBundle)
        appBundle = appBundleDecoded
    }
}

enum GetAppBundleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetIngestionDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appBundleIdentifier = appBundleIdentifier else {
            return nil
        }
        guard let ingestionIdentifier = ingestionIdentifier else {
            return nil
        }
        guard let ingestionDestinationIdentifier = ingestionDestinationIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/ingestions/\(ingestionIdentifier.urlPercentEncoding())/ingestiondestinations/\(ingestionDestinationIdentifier.urlPercentEncoding())"
    }
}

public struct GetIngestionDestinationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion destination to use for the request.
    /// This member is required.
    public var ingestionDestinationIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion to use for the request.
    /// This member is required.
    public var ingestionIdentifier: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        ingestionDestinationIdentifier: Swift.String? = nil,
        ingestionIdentifier: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.ingestionDestinationIdentifier = ingestionDestinationIdentifier
        self.ingestionIdentifier = ingestionIdentifier
    }
}

struct GetIngestionDestinationInputBody: Swift.Equatable {
}

extension GetIngestionDestinationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetIngestionDestinationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetIngestionDestinationOutputBody = try responseDecoder.decode(responseBody: data)
            self.ingestionDestination = output.ingestionDestination
        } else {
            self.ingestionDestination = nil
        }
    }
}

public struct GetIngestionDestinationOutput: Swift.Equatable {
    /// Contains information about an ingestion destination.
    /// This member is required.
    public var ingestionDestination: AppFabricClientTypes.IngestionDestination?

    public init(
        ingestionDestination: AppFabricClientTypes.IngestionDestination? = nil
    )
    {
        self.ingestionDestination = ingestionDestination
    }
}

struct GetIngestionDestinationOutputBody: Swift.Equatable {
    let ingestionDestination: AppFabricClientTypes.IngestionDestination?
}

extension GetIngestionDestinationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ingestionDestination
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ingestionDestinationDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.IngestionDestination.self, forKey: .ingestionDestination)
        ingestionDestination = ingestionDestinationDecoded
    }
}

enum GetIngestionDestinationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetIngestionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appBundleIdentifier = appBundleIdentifier else {
            return nil
        }
        guard let ingestionIdentifier = ingestionIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/ingestions/\(ingestionIdentifier.urlPercentEncoding())"
    }
}

public struct GetIngestionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion to use for the request.
    /// This member is required.
    public var ingestionIdentifier: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        ingestionIdentifier: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.ingestionIdentifier = ingestionIdentifier
    }
}

struct GetIngestionInputBody: Swift.Equatable {
}

extension GetIngestionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetIngestionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetIngestionOutputBody = try responseDecoder.decode(responseBody: data)
            self.ingestion = output.ingestion
        } else {
            self.ingestion = nil
        }
    }
}

public struct GetIngestionOutput: Swift.Equatable {
    /// Contains information about an ingestion.
    /// This member is required.
    public var ingestion: AppFabricClientTypes.Ingestion?

    public init(
        ingestion: AppFabricClientTypes.Ingestion? = nil
    )
    {
        self.ingestion = ingestion
    }
}

struct GetIngestionOutputBody: Swift.Equatable {
    let ingestion: AppFabricClientTypes.Ingestion?
}

extension GetIngestionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ingestion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ingestionDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.Ingestion.self, forKey: .ingestion)
        ingestion = ingestionDecoded
    }
}

enum GetIngestionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppFabricClientTypes.Ingestion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case app
        case appBundleArn
        case arn
        case createdAt
        case ingestionType
        case state
        case tenantId
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let app = self.app {
            try encodeContainer.encode(app, forKey: .app)
        }
        if let appBundleArn = self.appBundleArn {
            try encodeContainer.encode(appBundleArn, forKey: .appBundleArn)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let ingestionType = self.ingestionType {
            try encodeContainer.encode(ingestionType.rawValue, forKey: .ingestionType)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tenantId = self.tenantId {
            try encodeContainer.encode(tenantId, forKey: .tenantId)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let appBundleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appBundleArn)
        appBundleArn = appBundleArnDecoded
        let appDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .app)
        app = appDecoded
        let tenantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tenantId)
        tenantId = tenantIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.IngestionState.self, forKey: .state)
        state = stateDecoded
        let ingestionTypeDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.IngestionType.self, forKey: .ingestionType)
        ingestionType = ingestionTypeDecoded
    }
}

extension AppFabricClientTypes {
    /// Contains information about an ingestion.
    public struct Ingestion: Swift.Equatable {
        /// The name of the application.
        /// This member is required.
        public var app: Swift.String?
        /// The Amazon Resource Name (ARN) of the app bundle for the ingestion.
        /// This member is required.
        public var appBundleArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the ingestion.
        /// This member is required.
        public var arn: Swift.String?
        /// The timestamp of when the ingestion was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The type of the ingestion.
        /// This member is required.
        public var ingestionType: AppFabricClientTypes.IngestionType?
        /// The status of the ingestion.
        /// This member is required.
        public var state: AppFabricClientTypes.IngestionState?
        /// The ID of the application tenant.
        /// This member is required.
        public var tenantId: Swift.String?
        /// The timestamp of when the ingestion was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            app: Swift.String? = nil,
            appBundleArn: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            ingestionType: AppFabricClientTypes.IngestionType? = nil,
            state: AppFabricClientTypes.IngestionState? = nil,
            tenantId: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.app = app
            self.appBundleArn = appBundleArn
            self.arn = arn
            self.createdAt = createdAt
            self.ingestionType = ingestionType
            self.state = state
            self.tenantId = tenantId
            self.updatedAt = updatedAt
        }
    }

}

extension AppFabricClientTypes.IngestionDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case destinationConfiguration
        case ingestionArn
        case processingConfiguration
        case status
        case statusReason
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let destinationConfiguration = self.destinationConfiguration {
            try encodeContainer.encode(destinationConfiguration, forKey: .destinationConfiguration)
        }
        if let ingestionArn = self.ingestionArn {
            try encodeContainer.encode(ingestionArn, forKey: .ingestionArn)
        }
        if let processingConfiguration = self.processingConfiguration {
            try encodeContainer.encode(processingConfiguration, forKey: .processingConfiguration)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let ingestionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ingestionArn)
        ingestionArn = ingestionArnDecoded
        let processingConfigurationDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.ProcessingConfiguration.self, forKey: .processingConfiguration)
        processingConfiguration = processingConfigurationDecoded
        let destinationConfigurationDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.DestinationConfiguration.self, forKey: .destinationConfiguration)
        destinationConfiguration = destinationConfigurationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.IngestionDestinationStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension AppFabricClientTypes {
    /// Contains information about an ingestion destination.
    public struct IngestionDestination: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the ingestion destination.
        /// This member is required.
        public var arn: Swift.String?
        /// The timestamp of when the ingestion destination was created.
        public var createdAt: ClientRuntime.Date?
        /// Contains information about the destination of ingested data.
        /// This member is required.
        public var destinationConfiguration: AppFabricClientTypes.DestinationConfiguration?
        /// The Amazon Resource Name (ARN) of the ingestion.
        /// This member is required.
        public var ingestionArn: Swift.String?
        /// Contains information about how ingested data is processed.
        /// This member is required.
        public var processingConfiguration: AppFabricClientTypes.ProcessingConfiguration?
        /// The state of the ingestion destination. The following states are possible:
        ///
        /// * Active: The ingestion destination is active and is ready to be used.
        ///
        /// * Failed: The ingestion destination has failed. If the ingestion destination is in this state, you should verify the ingestion destination configuration and try again.
        public var status: AppFabricClientTypes.IngestionDestinationStatus?
        /// The reason for the current status of the ingestion destination. Only present when the status of ingestion destination is Failed.
        public var statusReason: Swift.String?
        /// The timestamp of when the ingestion destination was last updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            destinationConfiguration: AppFabricClientTypes.DestinationConfiguration? = nil,
            ingestionArn: Swift.String? = nil,
            processingConfiguration: AppFabricClientTypes.ProcessingConfiguration? = nil,
            status: AppFabricClientTypes.IngestionDestinationStatus? = nil,
            statusReason: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.destinationConfiguration = destinationConfiguration
            self.ingestionArn = ingestionArn
            self.processingConfiguration = processingConfiguration
            self.status = status
            self.statusReason = statusReason
            self.updatedAt = updatedAt
        }
    }

}

extension AppFabricClientTypes {
    public enum IngestionDestinationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionDestinationStatus] {
            return [
                .active,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .failed: return "Failed"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IngestionDestinationStatus(rawValue: rawValue) ?? IngestionDestinationStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppFabricClientTypes.IngestionDestinationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension AppFabricClientTypes {
    /// Contains a summary of an ingestion destination.
    public struct IngestionDestinationSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the ingestion destination.
        /// This member is required.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension AppFabricClientTypes {
    public enum IngestionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "disabled"
            case .enabled: return "enabled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IngestionState(rawValue: rawValue) ?? IngestionState.sdkUnknown(rawValue)
        }
    }
}

extension AppFabricClientTypes.IngestionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case app
        case arn
        case state
        case tenantId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let app = self.app {
            try encodeContainer.encode(app, forKey: .app)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tenantId = self.tenantId {
            try encodeContainer.encode(tenantId, forKey: .tenantId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let appDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .app)
        app = appDecoded
        let tenantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tenantId)
        tenantId = tenantIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.IngestionState.self, forKey: .state)
        state = stateDecoded
    }
}

extension AppFabricClientTypes {
    /// Contains a summary of an ingestion.
    public struct IngestionSummary: Swift.Equatable {
        /// The name of the application.
        /// This member is required.
        public var app: Swift.String?
        /// The Amazon Resource Name (ARN) of the ingestion.
        /// This member is required.
        public var arn: Swift.String?
        /// The status of the ingestion.
        /// This member is required.
        public var state: AppFabricClientTypes.IngestionState?
        /// The ID of the application tenant.
        /// This member is required.
        public var tenantId: Swift.String?

        public init(
            app: Swift.String? = nil,
            arn: Swift.String? = nil,
            state: AppFabricClientTypes.IngestionState? = nil,
            tenantId: Swift.String? = nil
        )
        {
            self.app = app
            self.arn = arn
            self.state = state
            self.tenantId = tenantId
        }
    }

}

extension AppFabricClientTypes {
    public enum IngestionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case auditLog
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionType] {
            return [
                .auditLog,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .auditLog: return "auditLog"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IngestionType(rawValue: rawValue) ?? IngestionType.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request processing has failed because of an unknown error, exception, or failure with an internal server.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The period of time after which you should retry your request.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAppAuthorizationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListAppAuthorizationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appBundleIdentifier = appBundleIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/appauthorizations"
    }
}

public struct ListAppAuthorizationsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    public var maxResults: Swift.Int?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppAuthorizationsInputBody: Swift.Equatable {
}

extension ListAppAuthorizationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAppAuthorizationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAppAuthorizationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.appAuthorizationSummaryList = output.appAuthorizationSummaryList
            self.nextToken = output.nextToken
        } else {
            self.appAuthorizationSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppAuthorizationsOutput: Swift.Equatable {
    /// Contains a list of app authorization summaries.
    /// This member is required.
    public var appAuthorizationSummaryList: [AppFabricClientTypes.AppAuthorizationSummary]?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        appAuthorizationSummaryList: [AppFabricClientTypes.AppAuthorizationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appAuthorizationSummaryList = appAuthorizationSummaryList
        self.nextToken = nextToken
    }
}

struct ListAppAuthorizationsOutputBody: Swift.Equatable {
    let appAuthorizationSummaryList: [AppFabricClientTypes.AppAuthorizationSummary]?
    let nextToken: Swift.String?
}

extension ListAppAuthorizationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appAuthorizationSummaryList
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appAuthorizationSummaryListContainer = try containerValues.decodeIfPresent([AppFabricClientTypes.AppAuthorizationSummary?].self, forKey: .appAuthorizationSummaryList)
        var appAuthorizationSummaryListDecoded0:[AppFabricClientTypes.AppAuthorizationSummary]? = nil
        if let appAuthorizationSummaryListContainer = appAuthorizationSummaryListContainer {
            appAuthorizationSummaryListDecoded0 = [AppFabricClientTypes.AppAuthorizationSummary]()
            for structure0 in appAuthorizationSummaryListContainer {
                if let structure0 = structure0 {
                    appAuthorizationSummaryListDecoded0?.append(structure0)
                }
            }
        }
        appAuthorizationSummaryList = appAuthorizationSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAppAuthorizationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAppBundlesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListAppBundlesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/appbundles"
    }
}

public struct ListAppBundlesInput: Swift.Equatable {
    /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    public var maxResults: Swift.Int?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppBundlesInputBody: Swift.Equatable {
}

extension ListAppBundlesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAppBundlesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAppBundlesOutputBody = try responseDecoder.decode(responseBody: data)
            self.appBundleSummaryList = output.appBundleSummaryList
            self.nextToken = output.nextToken
        } else {
            self.appBundleSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppBundlesOutput: Swift.Equatable {
    /// Contains a list of app bundle summaries.
    /// This member is required.
    public var appBundleSummaryList: [AppFabricClientTypes.AppBundleSummary]?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        appBundleSummaryList: [AppFabricClientTypes.AppBundleSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appBundleSummaryList = appBundleSummaryList
        self.nextToken = nextToken
    }
}

struct ListAppBundlesOutputBody: Swift.Equatable {
    let appBundleSummaryList: [AppFabricClientTypes.AppBundleSummary]?
    let nextToken: Swift.String?
}

extension ListAppBundlesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBundleSummaryList
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appBundleSummaryListContainer = try containerValues.decodeIfPresent([AppFabricClientTypes.AppBundleSummary?].self, forKey: .appBundleSummaryList)
        var appBundleSummaryListDecoded0:[AppFabricClientTypes.AppBundleSummary]? = nil
        if let appBundleSummaryListContainer = appBundleSummaryListContainer {
            appBundleSummaryListDecoded0 = [AppFabricClientTypes.AppBundleSummary]()
            for structure0 in appBundleSummaryListContainer {
                if let structure0 = structure0 {
                    appBundleSummaryListDecoded0?.append(structure0)
                }
            }
        }
        appBundleSummaryList = appBundleSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAppBundlesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListIngestionDestinationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListIngestionDestinationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appBundleIdentifier = appBundleIdentifier else {
            return nil
        }
        guard let ingestionIdentifier = ingestionIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/ingestions/\(ingestionIdentifier.urlPercentEncoding())/ingestiondestinations"
    }
}

public struct ListIngestionDestinationsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion to use for the request.
    /// This member is required.
    public var ingestionIdentifier: Swift.String?
    /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    public var maxResults: Swift.Int?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        ingestionIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.ingestionIdentifier = ingestionIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIngestionDestinationsInputBody: Swift.Equatable {
}

extension ListIngestionDestinationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListIngestionDestinationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListIngestionDestinationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.ingestionDestinations = output.ingestionDestinations
            self.nextToken = output.nextToken
        } else {
            self.ingestionDestinations = nil
            self.nextToken = nil
        }
    }
}

public struct ListIngestionDestinationsOutput: Swift.Equatable {
    /// Contains a list of ingestion destination summaries.
    /// This member is required.
    public var ingestionDestinations: [AppFabricClientTypes.IngestionDestinationSummary]?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        ingestionDestinations: [AppFabricClientTypes.IngestionDestinationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ingestionDestinations = ingestionDestinations
        self.nextToken = nextToken
    }
}

struct ListIngestionDestinationsOutputBody: Swift.Equatable {
    let ingestionDestinations: [AppFabricClientTypes.IngestionDestinationSummary]?
    let nextToken: Swift.String?
}

extension ListIngestionDestinationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ingestionDestinations
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ingestionDestinationsContainer = try containerValues.decodeIfPresent([AppFabricClientTypes.IngestionDestinationSummary?].self, forKey: .ingestionDestinations)
        var ingestionDestinationsDecoded0:[AppFabricClientTypes.IngestionDestinationSummary]? = nil
        if let ingestionDestinationsContainer = ingestionDestinationsContainer {
            ingestionDestinationsDecoded0 = [AppFabricClientTypes.IngestionDestinationSummary]()
            for structure0 in ingestionDestinationsContainer {
                if let structure0 = structure0 {
                    ingestionDestinationsDecoded0?.append(structure0)
                }
            }
        }
        ingestionDestinations = ingestionDestinationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListIngestionDestinationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListIngestionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListIngestionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appBundleIdentifier = appBundleIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/ingestions"
    }
}

public struct ListIngestionsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    public var maxResults: Swift.Int?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIngestionsInputBody: Swift.Equatable {
}

extension ListIngestionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListIngestionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListIngestionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.ingestions = output.ingestions
            self.nextToken = output.nextToken
        } else {
            self.ingestions = nil
            self.nextToken = nil
        }
    }
}

public struct ListIngestionsOutput: Swift.Equatable {
    /// Contains a list of ingestion summaries.
    /// This member is required.
    public var ingestions: [AppFabricClientTypes.IngestionSummary]?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        ingestions: [AppFabricClientTypes.IngestionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ingestions = ingestions
        self.nextToken = nextToken
    }
}

struct ListIngestionsOutputBody: Swift.Equatable {
    let ingestions: [AppFabricClientTypes.IngestionSummary]?
    let nextToken: Swift.String?
}

extension ListIngestionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ingestions
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ingestionsContainer = try containerValues.decodeIfPresent([AppFabricClientTypes.IngestionSummary?].self, forKey: .ingestions)
        var ingestionsDecoded0:[AppFabricClientTypes.IngestionSummary]? = nil
        if let ingestionsContainer = ingestionsContainer {
            ingestionsDecoded0 = [AppFabricClientTypes.IngestionSummary]()
            for structure0 in ingestionsContainer {
                if let structure0 = structure0 {
                    ingestionsDecoded0?.append(structure0)
                }
            }
        }
        ingestions = ingestionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListIngestionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource for which you want to retrieve tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A map of the key-value pairs for the tag or tags assigned to the specified resource.
    public var tags: [AppFabricClientTypes.Tag]?

    public init(
        tags: [AppFabricClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [AppFabricClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([AppFabricClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AppFabricClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AppFabricClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppFabricClientTypes.Oauth2Credential: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientId
        case clientSecret
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientId = self.clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientSecret = self.clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
    }
}

extension AppFabricClientTypes.Oauth2Credential: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Oauth2Credential(clientId: \(Swift.String(describing: clientId)), clientSecret: \"CONTENT_REDACTED\")"}
}

extension AppFabricClientTypes {
    /// Contains OAuth2 client credential information.
    public struct Oauth2Credential: Swift.Equatable {
        /// The client ID of the client application.
        /// This member is required.
        public var clientId: Swift.String?
        /// The client secret of the client application.
        /// This member is required.
        public var clientSecret: Swift.String?

        public init(
            clientId: Swift.String? = nil,
            clientSecret: Swift.String? = nil
        )
        {
            self.clientId = clientId
            self.clientSecret = clientSecret
        }
    }

}

extension AppFabricClientTypes {
    public enum Persona: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case admin
        case enduser
        case sdkUnknown(Swift.String)

        public static var allCases: [Persona] {
            return [
                .admin,
                .enduser,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .admin: return "admin"
            case .enduser: return "endUser"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Persona(rawValue: rawValue) ?? Persona.sdkUnknown(rawValue)
        }
    }
}

extension AppFabricClientTypes.ProcessingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditlog = "auditLog"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .auditlog(auditlog):
                try container.encode(auditlog, forKey: .auditlog)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let auditlogDecoded = try values.decodeIfPresent(AppFabricClientTypes.AuditLogProcessingConfiguration.self, forKey: .auditlog)
        if let auditlog = auditlogDecoded {
            self = .auditlog(auditlog)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AppFabricClientTypes {
    /// Contains information about how ingested data is processed.
    public enum ProcessingConfiguration: Swift.Equatable {
        /// Contains information about an audit log processing configuration.
        case auditlog(AppFabricClientTypes.AuditLogProcessingConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The resource ID.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension AppFabricClientTypes {
    public enum ResultStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case expired
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ResultStatus] {
            return [
                .completed,
                .expired,
                .failed,
                .inProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .expired: return "EXPIRED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResultStatus(rawValue: rawValue) ?? ResultStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppFabricClientTypes.S3Bucket: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case `prefix` = "prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension AppFabricClientTypes {
    /// Contains information about an Amazon S3 bucket.
    public struct S3Bucket: Swift.Equatable {
        /// The name of the Amazon S3 bucket.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The object key to use.
        public var `prefix`: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.`prefix` = `prefix`
        }
    }

}

extension AppFabricClientTypes {
    public enum Schema: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ocsf
        case raw
        case sdkUnknown(Swift.String)

        public static var allCases: [Schema] {
            return [
                .ocsf,
                .raw,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ocsf: return "ocsf"
            case .raw: return "raw"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Schema(rawValue: rawValue) ?? Schema.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request exceeds a service quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The code for the quota exceeded.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The resource ID.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
        /// The code of the service.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case resourceId
        case resourceType
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension StartIngestionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appBundleIdentifier = appBundleIdentifier else {
            return nil
        }
        guard let ingestionIdentifier = ingestionIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/ingestions/\(ingestionIdentifier.urlPercentEncoding())/start"
    }
}

public struct StartIngestionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion to use for the request.
    /// This member is required.
    public var ingestionIdentifier: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        ingestionIdentifier: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.ingestionIdentifier = ingestionIdentifier
    }
}

struct StartIngestionInputBody: Swift.Equatable {
}

extension StartIngestionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StartIngestionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StartIngestionOutput: Swift.Equatable {

    public init() { }
}

enum StartIngestionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartUserAccessTasksInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartUserAccessTasksInput(appBundleIdentifier: \(Swift.String(describing: appBundleIdentifier)), email: \"CONTENT_REDACTED\")"}
}

extension StartUserAccessTasksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBundleIdentifier
        case email
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appBundleIdentifier = self.appBundleIdentifier {
            try encodeContainer.encode(appBundleIdentifier, forKey: .appBundleIdentifier)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
    }
}

extension StartUserAccessTasksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/useraccess/start"
    }
}

public struct StartUserAccessTasksInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// The email address of the target user.
    /// This member is required.
    public var email: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        email: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.email = email
    }
}

struct StartUserAccessTasksInputBody: Swift.Equatable {
    let appBundleIdentifier: Swift.String?
    let email: Swift.String?
}

extension StartUserAccessTasksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBundleIdentifier
        case email
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appBundleIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appBundleIdentifier)
        appBundleIdentifier = appBundleIdentifierDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
    }
}

extension StartUserAccessTasksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartUserAccessTasksOutputBody = try responseDecoder.decode(responseBody: data)
            self.userAccessTasksList = output.userAccessTasksList
        } else {
            self.userAccessTasksList = nil
        }
    }
}

public struct StartUserAccessTasksOutput: Swift.Equatable {
    /// Contains a list of user access task information.
    public var userAccessTasksList: [AppFabricClientTypes.UserAccessTaskItem]?

    public init(
        userAccessTasksList: [AppFabricClientTypes.UserAccessTaskItem]? = nil
    )
    {
        self.userAccessTasksList = userAccessTasksList
    }
}

struct StartUserAccessTasksOutputBody: Swift.Equatable {
    let userAccessTasksList: [AppFabricClientTypes.UserAccessTaskItem]?
}

extension StartUserAccessTasksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userAccessTasksList
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userAccessTasksListContainer = try containerValues.decodeIfPresent([AppFabricClientTypes.UserAccessTaskItem?].self, forKey: .userAccessTasksList)
        var userAccessTasksListDecoded0:[AppFabricClientTypes.UserAccessTaskItem]? = nil
        if let userAccessTasksListContainer = userAccessTasksListContainer {
            userAccessTasksListDecoded0 = [AppFabricClientTypes.UserAccessTaskItem]()
            for structure0 in userAccessTasksListContainer {
                if let structure0 = structure0 {
                    userAccessTasksListDecoded0?.append(structure0)
                }
            }
        }
        userAccessTasksList = userAccessTasksListDecoded0
    }
}

enum StartUserAccessTasksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopIngestionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appBundleIdentifier = appBundleIdentifier else {
            return nil
        }
        guard let ingestionIdentifier = ingestionIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/ingestions/\(ingestionIdentifier.urlPercentEncoding())/stop"
    }
}

public struct StopIngestionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion to use for the request.
    /// This member is required.
    public var ingestionIdentifier: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        ingestionIdentifier: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.ingestionIdentifier = ingestionIdentifier
    }
}

struct StopIngestionInputBody: Swift.Equatable {
}

extension StopIngestionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StopIngestionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopIngestionOutput: Swift.Equatable {

    public init() { }
}

enum StopIngestionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppFabricClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AppFabricClientTypes {
    /// The key or keys of the key-value pairs for the tag or tags assigned to a resource.
    public struct Tag: Swift.Equatable {
        /// Tag key.
        /// This member is required.
        public var key: Swift.String?
        /// Tag value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A map of the key-value pairs of the tag or tags to assign to the resource.
    /// This member is required.
    public var tags: [AppFabricClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [AppFabricClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [AppFabricClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([AppFabricClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AppFabricClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AppFabricClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppFabricClientTypes.TaskError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension AppFabricClientTypes {
    /// Contains information about an error returned from a user access task.
    public struct TaskError: Swift.Equatable {
        /// The code of the error.
        public var errorCode: Swift.String?
        /// The message of the error.
        public var errorMessage: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension AppFabricClientTypes.Tenant: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tenantDisplayName
        case tenantIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tenantDisplayName = self.tenantDisplayName {
            try encodeContainer.encode(tenantDisplayName, forKey: .tenantDisplayName)
        }
        if let tenantIdentifier = self.tenantIdentifier {
            try encodeContainer.encode(tenantIdentifier, forKey: .tenantIdentifier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tenantIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tenantIdentifier)
        tenantIdentifier = tenantIdentifierDecoded
        let tenantDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tenantDisplayName)
        tenantDisplayName = tenantDisplayNameDecoded
    }
}

extension AppFabricClientTypes {
    /// Contains information about an application tenant.
    public struct Tenant: Swift.Equatable {
        /// The display name of the tenant.
        /// This member is required.
        public var tenantDisplayName: Swift.String?
        /// The ID of the application tenant.
        /// This member is required.
        public var tenantIdentifier: Swift.String?

        public init(
            tenantDisplayName: Swift.String? = nil,
            tenantIdentifier: Swift.String? = nil
        )
        {
            self.tenantDisplayName = tenantDisplayName
            self.tenantIdentifier = tenantIdentifier
        }
    }

}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request rate exceeds the limit.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The code for the quota exceeded.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The period of time after which you should retry your request.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
        /// The code of the service.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the key-value pairs for the tag or tags you want to remove from the specified resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAppAuthorizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credential
        case tenant
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let credential = self.credential {
            try encodeContainer.encode(credential, forKey: .credential)
        }
        if let tenant = self.tenant {
            try encodeContainer.encode(tenant, forKey: .tenant)
        }
    }
}

extension UpdateAppAuthorizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appBundleIdentifier = appBundleIdentifier else {
            return nil
        }
        guard let appAuthorizationIdentifier = appAuthorizationIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/appauthorizations/\(appAuthorizationIdentifier.urlPercentEncoding())"
    }
}

public struct UpdateAppAuthorizationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app authorization to use for the request.
    /// This member is required.
    public var appAuthorizationIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// Contains credentials for the application, such as an API key or OAuth2 client ID and secret. Specify credentials that match the authorization type of the app authorization to update. For example, if the authorization type of the app authorization is OAuth2 (oauth2), then you should provide only the OAuth2 credentials.
    public var credential: AppFabricClientTypes.Credential?
    /// Contains information about an application tenant, such as the application display name and identifier.
    public var tenant: AppFabricClientTypes.Tenant?

    public init(
        appAuthorizationIdentifier: Swift.String? = nil,
        appBundleIdentifier: Swift.String? = nil,
        credential: AppFabricClientTypes.Credential? = nil,
        tenant: AppFabricClientTypes.Tenant? = nil
    )
    {
        self.appAuthorizationIdentifier = appAuthorizationIdentifier
        self.appBundleIdentifier = appBundleIdentifier
        self.credential = credential
        self.tenant = tenant
    }
}

struct UpdateAppAuthorizationInputBody: Swift.Equatable {
    let credential: AppFabricClientTypes.Credential?
    let tenant: AppFabricClientTypes.Tenant?
}

extension UpdateAppAuthorizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credential
        case tenant
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let credentialDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.Credential.self, forKey: .credential)
        credential = credentialDecoded
        let tenantDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.Tenant.self, forKey: .tenant)
        tenant = tenantDecoded
    }
}

extension UpdateAppAuthorizationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAppAuthorizationOutputBody = try responseDecoder.decode(responseBody: data)
            self.appAuthorization = output.appAuthorization
        } else {
            self.appAuthorization = nil
        }
    }
}

public struct UpdateAppAuthorizationOutput: Swift.Equatable {
    /// Contains information about an app authorization.
    /// This member is required.
    public var appAuthorization: AppFabricClientTypes.AppAuthorization?

    public init(
        appAuthorization: AppFabricClientTypes.AppAuthorization? = nil
    )
    {
        self.appAuthorization = appAuthorization
    }
}

struct UpdateAppAuthorizationOutputBody: Swift.Equatable {
    let appAuthorization: AppFabricClientTypes.AppAuthorization?
}

extension UpdateAppAuthorizationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appAuthorization
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appAuthorizationDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.AppAuthorization.self, forKey: .appAuthorization)
        appAuthorization = appAuthorizationDecoded
    }
}

enum UpdateAppAuthorizationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateIngestionDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfiguration = self.destinationConfiguration {
            try encodeContainer.encode(destinationConfiguration, forKey: .destinationConfiguration)
        }
    }
}

extension UpdateIngestionDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appBundleIdentifier = appBundleIdentifier else {
            return nil
        }
        guard let ingestionIdentifier = ingestionIdentifier else {
            return nil
        }
        guard let ingestionDestinationIdentifier = ingestionDestinationIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/ingestions/\(ingestionIdentifier.urlPercentEncoding())/ingestiondestinations/\(ingestionDestinationIdentifier.urlPercentEncoding())"
    }
}

public struct UpdateIngestionDestinationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// Contains information about the destination of ingested data.
    /// This member is required.
    public var destinationConfiguration: AppFabricClientTypes.DestinationConfiguration?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion destination to use for the request.
    /// This member is required.
    public var ingestionDestinationIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion to use for the request.
    /// This member is required.
    public var ingestionIdentifier: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        destinationConfiguration: AppFabricClientTypes.DestinationConfiguration? = nil,
        ingestionDestinationIdentifier: Swift.String? = nil,
        ingestionIdentifier: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.destinationConfiguration = destinationConfiguration
        self.ingestionDestinationIdentifier = ingestionDestinationIdentifier
        self.ingestionIdentifier = ingestionIdentifier
    }
}

struct UpdateIngestionDestinationInputBody: Swift.Equatable {
    let destinationConfiguration: AppFabricClientTypes.DestinationConfiguration?
}

extension UpdateIngestionDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationConfigurationDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.DestinationConfiguration.self, forKey: .destinationConfiguration)
        destinationConfiguration = destinationConfigurationDecoded
    }
}

extension UpdateIngestionDestinationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateIngestionDestinationOutputBody = try responseDecoder.decode(responseBody: data)
            self.ingestionDestination = output.ingestionDestination
        } else {
            self.ingestionDestination = nil
        }
    }
}

public struct UpdateIngestionDestinationOutput: Swift.Equatable {
    /// Contains information about an ingestion destination.
    /// This member is required.
    public var ingestionDestination: AppFabricClientTypes.IngestionDestination?

    public init(
        ingestionDestination: AppFabricClientTypes.IngestionDestination? = nil
    )
    {
        self.ingestionDestination = ingestionDestination
    }
}

struct UpdateIngestionDestinationOutputBody: Swift.Equatable {
    let ingestionDestination: AppFabricClientTypes.IngestionDestination?
}

extension UpdateIngestionDestinationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ingestionDestination
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ingestionDestinationDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.IngestionDestination.self, forKey: .ingestionDestination)
        ingestionDestination = ingestionDestinationDecoded
    }
}

enum UpdateIngestionDestinationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppFabricClientTypes.UserAccessResultItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case app
        case email
        case resultStatus
        case taskError
        case taskId
        case tenantDisplayName
        case tenantId
        case userFirstName
        case userFullName
        case userId
        case userLastName
        case userStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let app = self.app {
            try encodeContainer.encode(app, forKey: .app)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let resultStatus = self.resultStatus {
            try encodeContainer.encode(resultStatus.rawValue, forKey: .resultStatus)
        }
        if let taskError = self.taskError {
            try encodeContainer.encode(taskError, forKey: .taskError)
        }
        if let taskId = self.taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
        if let tenantDisplayName = self.tenantDisplayName {
            try encodeContainer.encode(tenantDisplayName, forKey: .tenantDisplayName)
        }
        if let tenantId = self.tenantId {
            try encodeContainer.encode(tenantId, forKey: .tenantId)
        }
        if let userFirstName = self.userFirstName {
            try encodeContainer.encode(userFirstName, forKey: .userFirstName)
        }
        if let userFullName = self.userFullName {
            try encodeContainer.encode(userFullName, forKey: .userFullName)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
        if let userLastName = self.userLastName {
            try encodeContainer.encode(userLastName, forKey: .userLastName)
        }
        if let userStatus = self.userStatus {
            try encodeContainer.encode(userStatus, forKey: .userStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .app)
        app = appDecoded
        let tenantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tenantId)
        tenantId = tenantIdDecoded
        let tenantDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tenantDisplayName)
        tenantDisplayName = tenantDisplayNameDecoded
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let resultStatusDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.ResultStatus.self, forKey: .resultStatus)
        resultStatus = resultStatusDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let userFullNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userFullName)
        userFullName = userFullNameDecoded
        let userFirstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userFirstName)
        userFirstName = userFirstNameDecoded
        let userLastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userLastName)
        userLastName = userLastNameDecoded
        let userStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userStatus)
        userStatus = userStatusDecoded
        let taskErrorDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.TaskError.self, forKey: .taskError)
        taskError = taskErrorDecoded
    }
}

extension AppFabricClientTypes.UserAccessResultItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserAccessResultItem(app: \(Swift.String(describing: app)), resultStatus: \(Swift.String(describing: resultStatus)), taskError: \(Swift.String(describing: taskError)), taskId: \(Swift.String(describing: taskId)), tenantDisplayName: \(Swift.String(describing: tenantDisplayName)), tenantId: \(Swift.String(describing: tenantId)), userStatus: \(Swift.String(describing: userStatus)), email: \"CONTENT_REDACTED\", userFirstName: \"CONTENT_REDACTED\", userFullName: \"CONTENT_REDACTED\", userId: \"CONTENT_REDACTED\", userLastName: \"CONTENT_REDACTED\")"}
}

extension AppFabricClientTypes {
    /// Contains information about a user's access to an application.
    public struct UserAccessResultItem: Swift.Equatable {
        /// The name of the application.
        public var app: Swift.String?
        /// The email address of the target user.
        public var email: Swift.String?
        /// The status of the user access result item. The following states are possible:
        ///
        /// * IN_PROGRESS: The user access task is in progress.
        ///
        /// * COMPLETED: The user access task completed successfully.
        ///
        /// * FAILED: The user access task failed.
        ///
        /// * EXPIRED: The user access task expired.
        public var resultStatus: AppFabricClientTypes.ResultStatus?
        /// Contains information about an error returned from a user access task.
        public var taskError: AppFabricClientTypes.TaskError?
        /// The unique ID of the task.
        public var taskId: Swift.String?
        /// The display name of the tenant.
        public var tenantDisplayName: Swift.String?
        /// The ID of the application tenant.
        public var tenantId: Swift.String?
        /// The first name of the user.
        public var userFirstName: Swift.String?
        /// The full name of the user.
        public var userFullName: Swift.String?
        /// The unique ID of user.
        public var userId: Swift.String?
        /// The last name of the user.
        public var userLastName: Swift.String?
        /// The status of the user returned by the application.
        public var userStatus: Swift.String?

        public init(
            app: Swift.String? = nil,
            email: Swift.String? = nil,
            resultStatus: AppFabricClientTypes.ResultStatus? = nil,
            taskError: AppFabricClientTypes.TaskError? = nil,
            taskId: Swift.String? = nil,
            tenantDisplayName: Swift.String? = nil,
            tenantId: Swift.String? = nil,
            userFirstName: Swift.String? = nil,
            userFullName: Swift.String? = nil,
            userId: Swift.String? = nil,
            userLastName: Swift.String? = nil,
            userStatus: Swift.String? = nil
        )
        {
            self.app = app
            self.email = email
            self.resultStatus = resultStatus
            self.taskError = taskError
            self.taskId = taskId
            self.tenantDisplayName = tenantDisplayName
            self.tenantId = tenantId
            self.userFirstName = userFirstName
            self.userFullName = userFullName
            self.userId = userId
            self.userLastName = userLastName
            self.userStatus = userStatus
        }
    }

}

extension AppFabricClientTypes.UserAccessTaskItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case app
        case error
        case taskId
        case tenantId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let app = self.app {
            try encodeContainer.encode(app, forKey: .app)
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let taskId = self.taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
        if let tenantId = self.tenantId {
            try encodeContainer.encode(tenantId, forKey: .tenantId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .app)
        app = appDecoded
        let tenantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tenantId)
        tenantId = tenantIdDecoded
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let errorDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.TaskError.self, forKey: .error)
        error = errorDecoded
    }
}

extension AppFabricClientTypes {
    /// Contains information about a user access task.
    public struct UserAccessTaskItem: Swift.Equatable {
        /// The name of the application.
        /// This member is required.
        public var app: Swift.String?
        /// Error from the task, if any.
        public var error: AppFabricClientTypes.TaskError?
        /// The unique ID of the task.
        public var taskId: Swift.String?
        /// The ID of the application tenant.
        /// This member is required.
        public var tenantId: Swift.String?

        public init(
            app: Swift.String? = nil,
            error: AppFabricClientTypes.TaskError? = nil,
            taskId: Swift.String? = nil,
            tenantId: Swift.String? = nil
        )
        {
            self.app = app
            self.error = error
            self.taskId = taskId
            self.tenantId = tenantId
        }
    }

}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fieldList = output.fieldList
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.fieldList = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request has invalid or missing parameters.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The field list.
        public internal(set) var fieldList: [AppFabricClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason for the exception.
        /// This member is required.
        public internal(set) var reason: AppFabricClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [AppFabricClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: AppFabricClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: AppFabricClientTypes.ValidationExceptionReason?
    let fieldList: [AppFabricClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(AppFabricClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([AppFabricClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[AppFabricClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [AppFabricClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension AppFabricClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppFabricClientTypes {
    /// The input failed to meet the constraints specified by the Amazon Web Services service in a specified field.
    public struct ValidationExceptionField: Swift.Equatable {
        /// A message about the validation exception.
        /// This member is required.
        public var message: Swift.String?
        /// The field name where the invalid entry was detected.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension AppFabricClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
