// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime
import SmithyJSON
import SmithyReadWrite

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// You are not authorized to perform this operation.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension AppFabricClientTypes.ApiKeyCredential: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApiKeyCredential(apiKey: \"CONTENT_REDACTED\")"}
}

extension AppFabricClientTypes.ApiKeyCredential {

    static func write(value: AppFabricClientTypes.ApiKeyCredential?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apiKey"].write(value.apiKey)
    }
}

extension AppFabricClientTypes {
    /// Contains API key credential information.
    public struct ApiKeyCredential {
        /// An API key for an application.
        /// This member is required.
        public var apiKey: Swift.String?

        public init(
            apiKey: Swift.String? = nil
        )
        {
            self.apiKey = apiKey
        }
    }

}

extension AppFabricClientTypes.AppAuthorization {

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.AppAuthorization {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppFabricClientTypes.AppAuthorization()
        value.appAuthorizationArn = try reader["appAuthorizationArn"].readIfPresent()
        value.appBundleArn = try reader["appBundleArn"].readIfPresent()
        value.app = try reader["app"].readIfPresent()
        value.tenant = try reader["tenant"].readIfPresent(with: AppFabricClientTypes.Tenant.read(from:))
        value.authType = try reader["authType"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        value.persona = try reader["persona"].readIfPresent()
        value.authUrl = try reader["authUrl"].readIfPresent()
        return value
    }
}

extension AppFabricClientTypes {
    /// Contains information about an app authorization.
    public struct AppAuthorization {
        /// The name of the application.
        /// This member is required.
        public var app: Swift.String?
        /// The Amazon Resource Name (ARN) of the app authorization.
        /// This member is required.
        public var appAuthorizationArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the app bundle for the app authorization.
        /// This member is required.
        public var appBundleArn: Swift.String?
        /// The authorization type.
        /// This member is required.
        public var authType: AppFabricClientTypes.AuthType?
        /// The application URL for the OAuth flow.
        public var authUrl: Swift.String?
        /// The timestamp of when the app authorization was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The user persona of the app authorization. This field should always be admin.
        public var persona: AppFabricClientTypes.Persona?
        /// The state of the app authorization. The following states are possible:
        ///
        /// * PendingConnect: The initial state of the app authorization. The app authorization is created but not yet connected.
        ///
        /// * Connected: The app authorization is connected to the application, and is ready to be used.
        ///
        /// * ConnectionValidationFailed: The app authorization received a validation exception when trying to connect to the application. If the app authorization is in this state, you should verify the configured credentials and try to connect the app authorization again.
        ///
        /// * TokenAutoRotationFailed: AppFabric failed to refresh the access token. If the app authorization is in this state, you should try to reconnect the app authorization.
        /// This member is required.
        public var status: AppFabricClientTypes.AppAuthorizationStatus?
        /// Contains information about an application tenant, such as the application display name and identifier.
        /// This member is required.
        public var tenant: AppFabricClientTypes.Tenant?
        /// The timestamp of when the app authorization was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            app: Swift.String? = nil,
            appAuthorizationArn: Swift.String? = nil,
            appBundleArn: Swift.String? = nil,
            authType: AppFabricClientTypes.AuthType? = nil,
            authUrl: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            persona: AppFabricClientTypes.Persona? = nil,
            status: AppFabricClientTypes.AppAuthorizationStatus? = nil,
            tenant: AppFabricClientTypes.Tenant? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.app = app
            self.appAuthorizationArn = appAuthorizationArn
            self.appBundleArn = appBundleArn
            self.authType = authType
            self.authUrl = authUrl
            self.createdAt = createdAt
            self.persona = persona
            self.status = status
            self.tenant = tenant
            self.updatedAt = updatedAt
        }
    }

}

extension AppFabricClientTypes {

    public enum AppAuthorizationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case connected
        case connectionValidationFailed
        case pendingConnect
        case tokenAutoRotationFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [AppAuthorizationStatus] {
            return [
                .connected,
                .connectionValidationFailed,
                .pendingConnect,
                .tokenAutoRotationFailed,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .connected: return "Connected"
            case .connectionValidationFailed: return "ConnectionValidationFailed"
            case .pendingConnect: return "PendingConnect"
            case .tokenAutoRotationFailed: return "TokenAutoRotationFailed"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppFabricClientTypes.AppAuthorizationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.AppAuthorizationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppFabricClientTypes.AppAuthorizationSummary()
        value.appAuthorizationArn = try reader["appAuthorizationArn"].readIfPresent()
        value.appBundleArn = try reader["appBundleArn"].readIfPresent()
        value.app = try reader["app"].readIfPresent()
        value.tenant = try reader["tenant"].readIfPresent(with: AppFabricClientTypes.Tenant.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension AppFabricClientTypes {
    /// Contains a summary of an app authorization.
    public struct AppAuthorizationSummary {
        /// The name of the application.
        /// This member is required.
        public var app: Swift.String?
        /// The Amazon Resource Name (ARN) of the app authorization.
        /// This member is required.
        public var appAuthorizationArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the app bundle for the app authorization.
        /// This member is required.
        public var appBundleArn: Swift.String?
        /// The state of the app authorization. The following states are possible:
        ///
        /// * PendingConnect: The initial state of the app authorization. The app authorization is created but not yet connected.
        ///
        /// * Connected: The app authorization is connected to the application, and is ready to be used.
        ///
        /// * ConnectionValidationFailed: The app authorization received a validation exception when trying to connect to the application. If the app authorization is in this state, you should verify the configured credentials and try to connect the app authorization again.
        ///
        /// * TokenAutoRotationFailed: AppFabric failed to refresh the access token. If the app authorization is in this state, you should try to reconnect the app authorization.
        /// This member is required.
        public var status: AppFabricClientTypes.AppAuthorizationStatus?
        /// Contains information about an application tenant, such as the application display name and identifier.
        /// This member is required.
        public var tenant: AppFabricClientTypes.Tenant?
        /// Timestamp for when the app authorization was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            app: Swift.String? = nil,
            appAuthorizationArn: Swift.String? = nil,
            appBundleArn: Swift.String? = nil,
            status: AppFabricClientTypes.AppAuthorizationStatus? = nil,
            tenant: AppFabricClientTypes.Tenant? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.app = app
            self.appAuthorizationArn = appAuthorizationArn
            self.appBundleArn = appBundleArn
            self.status = status
            self.tenant = tenant
            self.updatedAt = updatedAt
        }
    }

}

extension AppFabricClientTypes.AppBundle {

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.AppBundle {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppFabricClientTypes.AppBundle()
        value.arn = try reader["arn"].readIfPresent()
        value.customerManagedKeyArn = try reader["customerManagedKeyArn"].readIfPresent()
        return value
    }
}

extension AppFabricClientTypes {
    /// Contains information about an app bundle.
    public struct AppBundle {
        /// The Amazon Resource Name (ARN) of the app bundle.
        /// This member is required.
        public var arn: Swift.String?
        /// The Amazon Resource Name (ARN) of the Key Management Service (KMS) key used to encrypt the application data.
        public var customerManagedKeyArn: Swift.String?

        public init(
            arn: Swift.String? = nil,
            customerManagedKeyArn: Swift.String? = nil
        )
        {
            self.arn = arn
            self.customerManagedKeyArn = customerManagedKeyArn
        }
    }

}

extension AppFabricClientTypes.AppBundleSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.AppBundleSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppFabricClientTypes.AppBundleSummary()
        value.arn = try reader["arn"].readIfPresent()
        return value
    }
}

extension AppFabricClientTypes {
    /// Contains a summary of an app bundle.
    public struct AppBundleSummary {
        /// The Amazon Resource Name (ARN) of the app bundle.
        /// This member is required.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

public enum AppFabricClientTypes {}

extension AppFabricClientTypes.AuditLogDestinationConfiguration {

    static func write(value: AppFabricClientTypes.AuditLogDestinationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destination"].write(value.destination, with: AppFabricClientTypes.Destination.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.AuditLogDestinationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppFabricClientTypes.AuditLogDestinationConfiguration()
        value.destination = try reader["destination"].readIfPresent(with: AppFabricClientTypes.Destination.read(from:))
        return value
    }
}

extension AppFabricClientTypes {
    /// Contains information about an audit log destination configuration.
    public struct AuditLogDestinationConfiguration {
        /// Contains information about an audit log destination.
        /// This member is required.
        public var destination: AppFabricClientTypes.Destination?

        public init(
            destination: AppFabricClientTypes.Destination? = nil
        )
        {
            self.destination = destination
        }
    }

}

extension AppFabricClientTypes.AuditLogProcessingConfiguration {

    static func write(value: AppFabricClientTypes.AuditLogProcessingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["format"].write(value.format)
        try writer["schema"].write(value.schema)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.AuditLogProcessingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppFabricClientTypes.AuditLogProcessingConfiguration()
        value.schema = try reader["schema"].readIfPresent()
        value.format = try reader["format"].readIfPresent()
        return value
    }
}

extension AppFabricClientTypes {
    /// Contains information about an audit log processing configuration.
    public struct AuditLogProcessingConfiguration {
        /// The format in which the audit logs need to be formatted.
        /// This member is required.
        public var format: AppFabricClientTypes.Format?
        /// The event schema in which the audit logs need to be formatted.
        /// This member is required.
        public var schema: AppFabricClientTypes.Schema?

        public init(
            format: AppFabricClientTypes.Format? = nil,
            schema: AppFabricClientTypes.Schema? = nil
        )
        {
            self.format = format
            self.schema = schema
        }
    }

}

extension AppFabricClientTypes.AuthRequest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AuthRequest(redirectUri: \(Swift.String(describing: redirectUri)), code: \"CONTENT_REDACTED\")"}
}

extension AppFabricClientTypes.AuthRequest {

    static func write(value: AppFabricClientTypes.AuthRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["code"].write(value.code)
        try writer["redirectUri"].write(value.redirectUri)
    }
}

extension AppFabricClientTypes {
    /// Contains authorization request information, which is required for Amazon Web Services AppFabric to get the OAuth2 access token for an application.
    public struct AuthRequest {
        /// The authorization code returned by the application after permission is granted in the application OAuth page (after clicking on the AuthURL).
        /// This member is required.
        public var code: Swift.String?
        /// The redirect URL that is specified in the AuthURL and the application client.
        /// This member is required.
        public var redirectUri: Swift.String?

        public init(
            code: Swift.String? = nil,
            redirectUri: Swift.String? = nil
        )
        {
            self.code = code
            self.redirectUri = redirectUri
        }
    }

}

extension AppFabricClientTypes {

    public enum AuthType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case apiKey
        case oauth2
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthType] {
            return [
                .apiKey,
                .oauth2,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .apiKey: return "apiKey"
            case .oauth2: return "oauth2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BatchGetUserAccessTasksInput {

    static func urlPathProvider(_ value: BatchGetUserAccessTasksInput) -> Swift.String? {
        return "/useraccess/batchget"
    }
}

extension BatchGetUserAccessTasksInput {

    static func write(value: BatchGetUserAccessTasksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appBundleIdentifier"].write(value.appBundleIdentifier)
        try writer["taskIdList"].writeList(value.taskIdList, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct BatchGetUserAccessTasksInput {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// The tasks IDs to use for the request.
    /// This member is required.
    public var taskIdList: [Swift.String]?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        taskIdList: [Swift.String]? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.taskIdList = taskIdList
    }
}

extension BatchGetUserAccessTasksOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> BatchGetUserAccessTasksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetUserAccessTasksOutput()
        value.userAccessResultsList = try reader["userAccessResultsList"].readListIfPresent(memberReadingClosure: AppFabricClientTypes.UserAccessResultItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct BatchGetUserAccessTasksOutput {
    /// Contains a list of user access results.
    public var userAccessResultsList: [AppFabricClientTypes.UserAccessResultItem]?

    public init(
        userAccessResultsList: [AppFabricClientTypes.UserAccessResultItem]? = nil
    )
    {
        self.userAccessResultsList = userAccessResultsList
    }
}

enum BatchGetUserAccessTasksOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The request has created a conflict. Check the request parameters and try again.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The resource ID.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

extension ConnectAppAuthorizationInput {

    static func urlPathProvider(_ value: ConnectAppAuthorizationInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        guard let appAuthorizationIdentifier = value.appAuthorizationIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/appauthorizations/\(appAuthorizationIdentifier.urlPercentEncoding())/connect"
    }
}

extension ConnectAppAuthorizationInput {

    static func write(value: ConnectAppAuthorizationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authRequest"].write(value.authRequest, with: AppFabricClientTypes.AuthRequest.write(value:to:))
    }
}

public struct ConnectAppAuthorizationInput {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app authorization to use for the request.
    /// This member is required.
    public var appAuthorizationIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle that contains the app authorization to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// Contains OAuth2 authorization information. This is required if the app authorization for the request is configured with an OAuth2 (oauth2) authorization type.
    public var authRequest: AppFabricClientTypes.AuthRequest?

    public init(
        appAuthorizationIdentifier: Swift.String? = nil,
        appBundleIdentifier: Swift.String? = nil,
        authRequest: AppFabricClientTypes.AuthRequest? = nil
    )
    {
        self.appAuthorizationIdentifier = appAuthorizationIdentifier
        self.appBundleIdentifier = appBundleIdentifier
        self.authRequest = authRequest
    }
}

extension ConnectAppAuthorizationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ConnectAppAuthorizationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ConnectAppAuthorizationOutput()
        value.appAuthorizationSummary = try reader["appAuthorizationSummary"].readIfPresent(with: AppFabricClientTypes.AppAuthorizationSummary.read(from:))
        return value
    }
}

public struct ConnectAppAuthorizationOutput {
    /// Contains a summary of the app authorization.
    /// This member is required.
    public var appAuthorizationSummary: AppFabricClientTypes.AppAuthorizationSummary?

    public init(
        appAuthorizationSummary: AppFabricClientTypes.AppAuthorizationSummary? = nil
    )
    {
        self.appAuthorizationSummary = appAuthorizationSummary
    }
}

enum ConnectAppAuthorizationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateAppAuthorizationInput {

    static func urlPathProvider(_ value: CreateAppAuthorizationInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/appauthorizations"
    }
}

extension CreateAppAuthorizationInput {

    static func write(value: CreateAppAuthorizationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["app"].write(value.app)
        try writer["authType"].write(value.authType)
        try writer["clientToken"].write(value.clientToken)
        try writer["credential"].write(value.credential, with: AppFabricClientTypes.Credential.write(value:to:))
        try writer["tags"].writeList(value.tags, memberWritingClosure: AppFabricClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tenant"].write(value.tenant, with: AppFabricClientTypes.Tenant.write(value:to:))
    }
}

public struct CreateAppAuthorizationInput {
    /// The name of the application. Valid values are:
    ///
    /// * SLACK
    ///
    /// * ASANA
    ///
    /// * JIRA
    ///
    /// * M365
    ///
    /// * M365AUDITLOGS
    ///
    /// * ZOOM
    ///
    /// * ZENDESK
    ///
    /// * OKTA
    ///
    /// * GOOGLE
    ///
    /// * DROPBOX
    ///
    /// * SMARTSHEET
    ///
    /// * CISCO
    /// This member is required.
    public var app: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// The authorization type for the app authorization.
    /// This member is required.
    public var authType: AppFabricClientTypes.AuthType?
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// Contains credentials for the application, such as an API key or OAuth2 client ID and secret. Specify credentials that match the authorization type for your request. For example, if the authorization type for your request is OAuth2 (oauth2), then you should provide only the OAuth2 credentials.
    /// This member is required.
    public var credential: AppFabricClientTypes.Credential?
    /// A map of the key-value pairs of the tag or tags to assign to the resource.
    public var tags: [AppFabricClientTypes.Tag]?
    /// Contains information about an application tenant, such as the application display name and identifier.
    /// This member is required.
    public var tenant: AppFabricClientTypes.Tenant?

    public init(
        app: Swift.String? = nil,
        appBundleIdentifier: Swift.String? = nil,
        authType: AppFabricClientTypes.AuthType? = nil,
        clientToken: Swift.String? = nil,
        credential: AppFabricClientTypes.Credential? = nil,
        tags: [AppFabricClientTypes.Tag]? = nil,
        tenant: AppFabricClientTypes.Tenant? = nil
    )
    {
        self.app = app
        self.appBundleIdentifier = appBundleIdentifier
        self.authType = authType
        self.clientToken = clientToken
        self.credential = credential
        self.tags = tags
        self.tenant = tenant
    }
}

extension CreateAppAuthorizationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateAppAuthorizationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAppAuthorizationOutput()
        value.appAuthorization = try reader["appAuthorization"].readIfPresent(with: AppFabricClientTypes.AppAuthorization.read(from:))
        return value
    }
}

public struct CreateAppAuthorizationOutput {
    /// Contains information about an app authorization.
    /// This member is required.
    public var appAuthorization: AppFabricClientTypes.AppAuthorization?

    public init(
        appAuthorization: AppFabricClientTypes.AppAuthorization? = nil
    )
    {
        self.appAuthorization = appAuthorization
    }
}

enum CreateAppAuthorizationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateAppBundleInput {

    static func urlPathProvider(_ value: CreateAppBundleInput) -> Swift.String? {
        return "/appbundles"
    }
}

extension CreateAppBundleInput {

    static func write(value: CreateAppBundleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["customerManagedKeyIdentifier"].write(value.customerManagedKeyIdentifier)
        try writer["tags"].writeList(value.tags, memberWritingClosure: AppFabricClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct CreateAppBundleInput {
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the Key Management Service (KMS) key to use to encrypt the application data. If this is not specified, an Amazon Web Services owned key is used for encryption.
    public var customerManagedKeyIdentifier: Swift.String?
    /// A map of the key-value pairs of the tag or tags to assign to the resource.
    public var tags: [AppFabricClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        customerManagedKeyIdentifier: Swift.String? = nil,
        tags: [AppFabricClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.customerManagedKeyIdentifier = customerManagedKeyIdentifier
        self.tags = tags
    }
}

extension CreateAppBundleOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateAppBundleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAppBundleOutput()
        value.appBundle = try reader["appBundle"].readIfPresent(with: AppFabricClientTypes.AppBundle.read(from:))
        return value
    }
}

public struct CreateAppBundleOutput {
    /// Contains information about an app bundle.
    /// This member is required.
    public var appBundle: AppFabricClientTypes.AppBundle?

    public init(
        appBundle: AppFabricClientTypes.AppBundle? = nil
    )
    {
        self.appBundle = appBundle
    }
}

enum CreateAppBundleOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateIngestionDestinationInput {

    static func urlPathProvider(_ value: CreateIngestionDestinationInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        guard let ingestionIdentifier = value.ingestionIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/ingestions/\(ingestionIdentifier.urlPercentEncoding())/ingestiondestinations"
    }
}

extension CreateIngestionDestinationInput {

    static func write(value: CreateIngestionDestinationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["destinationConfiguration"].write(value.destinationConfiguration, with: AppFabricClientTypes.DestinationConfiguration.write(value:to:))
        try writer["processingConfiguration"].write(value.processingConfiguration, with: AppFabricClientTypes.ProcessingConfiguration.write(value:to:))
        try writer["tags"].writeList(value.tags, memberWritingClosure: AppFabricClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct CreateIngestionDestinationInput {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// Contains information about the destination of ingested data.
    /// This member is required.
    public var destinationConfiguration: AppFabricClientTypes.DestinationConfiguration?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion to use for the request.
    /// This member is required.
    public var ingestionIdentifier: Swift.String?
    /// Contains information about how ingested data is processed.
    /// This member is required.
    public var processingConfiguration: AppFabricClientTypes.ProcessingConfiguration?
    /// A map of the key-value pairs of the tag or tags to assign to the resource.
    public var tags: [AppFabricClientTypes.Tag]?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        destinationConfiguration: AppFabricClientTypes.DestinationConfiguration? = nil,
        ingestionIdentifier: Swift.String? = nil,
        processingConfiguration: AppFabricClientTypes.ProcessingConfiguration? = nil,
        tags: [AppFabricClientTypes.Tag]? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.clientToken = clientToken
        self.destinationConfiguration = destinationConfiguration
        self.ingestionIdentifier = ingestionIdentifier
        self.processingConfiguration = processingConfiguration
        self.tags = tags
    }
}

extension CreateIngestionDestinationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateIngestionDestinationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateIngestionDestinationOutput()
        value.ingestionDestination = try reader["ingestionDestination"].readIfPresent(with: AppFabricClientTypes.IngestionDestination.read(from:))
        return value
    }
}

public struct CreateIngestionDestinationOutput {
    /// Contains information about an ingestion destination.
    /// This member is required.
    public var ingestionDestination: AppFabricClientTypes.IngestionDestination?

    public init(
        ingestionDestination: AppFabricClientTypes.IngestionDestination? = nil
    )
    {
        self.ingestionDestination = ingestionDestination
    }
}

enum CreateIngestionDestinationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateIngestionInput {

    static func urlPathProvider(_ value: CreateIngestionInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/ingestions"
    }
}

extension CreateIngestionInput {

    static func write(value: CreateIngestionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["app"].write(value.app)
        try writer["clientToken"].write(value.clientToken)
        try writer["ingestionType"].write(value.ingestionType)
        try writer["tags"].writeList(value.tags, memberWritingClosure: AppFabricClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tenantId"].write(value.tenantId)
    }
}

public struct CreateIngestionInput {
    /// The name of the application. Valid values are:
    ///
    /// * SLACK
    ///
    /// * ASANA
    ///
    /// * JIRA
    ///
    /// * M365
    ///
    /// * M365AUDITLOGS
    ///
    /// * ZOOM
    ///
    /// * ZENDESK
    ///
    /// * OKTA
    ///
    /// * GOOGLE
    ///
    /// * DROPBOX
    ///
    /// * SMARTSHEET
    ///
    /// * CISCO
    /// This member is required.
    public var app: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// The ingestion type.
    /// This member is required.
    public var ingestionType: AppFabricClientTypes.IngestionType?
    /// A map of the key-value pairs of the tag or tags to assign to the resource.
    public var tags: [AppFabricClientTypes.Tag]?
    /// The ID of the application tenant.
    /// This member is required.
    public var tenantId: Swift.String?

    public init(
        app: Swift.String? = nil,
        appBundleIdentifier: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        ingestionType: AppFabricClientTypes.IngestionType? = nil,
        tags: [AppFabricClientTypes.Tag]? = nil,
        tenantId: Swift.String? = nil
    )
    {
        self.app = app
        self.appBundleIdentifier = appBundleIdentifier
        self.clientToken = clientToken
        self.ingestionType = ingestionType
        self.tags = tags
        self.tenantId = tenantId
    }
}

extension CreateIngestionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateIngestionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateIngestionOutput()
        value.ingestion = try reader["ingestion"].readIfPresent(with: AppFabricClientTypes.Ingestion.read(from:))
        return value
    }
}

public struct CreateIngestionOutput {
    /// Contains information about an ingestion.
    /// This member is required.
    public var ingestion: AppFabricClientTypes.Ingestion?

    public init(
        ingestion: AppFabricClientTypes.Ingestion? = nil
    )
    {
        self.ingestion = ingestion
    }
}

enum CreateIngestionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AppFabricClientTypes.Credential {

    static func write(value: AppFabricClientTypes.Credential?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .apikeycredential(apikeycredential):
                try writer["apiKeyCredential"].write(apikeycredential, with: AppFabricClientTypes.ApiKeyCredential.write(value:to:))
            case let .oauth2credential(oauth2credential):
                try writer["oauth2Credential"].write(oauth2credential, with: AppFabricClientTypes.Oauth2Credential.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension AppFabricClientTypes {
    /// Contains credential information for an application.
    public enum Credential {
        /// Contains OAuth2 client credential information.
        case oauth2credential(AppFabricClientTypes.Oauth2Credential)
        /// Contains API key credential information.
        case apikeycredential(AppFabricClientTypes.ApiKeyCredential)
        case sdkUnknown(Swift.String)
    }

}

extension DeleteAppAuthorizationInput {

    static func urlPathProvider(_ value: DeleteAppAuthorizationInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        guard let appAuthorizationIdentifier = value.appAuthorizationIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/appauthorizations/\(appAuthorizationIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteAppAuthorizationInput {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app authorization to use for the request.
    /// This member is required.
    public var appAuthorizationIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?

    public init(
        appAuthorizationIdentifier: Swift.String? = nil,
        appBundleIdentifier: Swift.String? = nil
    )
    {
        self.appAuthorizationIdentifier = appAuthorizationIdentifier
        self.appBundleIdentifier = appBundleIdentifier
    }
}

extension DeleteAppAuthorizationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteAppAuthorizationOutput {
        return DeleteAppAuthorizationOutput()
    }
}

public struct DeleteAppAuthorizationOutput {

    public init() { }
}

enum DeleteAppAuthorizationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteAppBundleInput {

    static func urlPathProvider(_ value: DeleteAppBundleInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteAppBundleInput {
    /// The ID or Amazon Resource Name (ARN) of the app bundle that needs to be deleted.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
    }
}

extension DeleteAppBundleOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteAppBundleOutput {
        return DeleteAppBundleOutput()
    }
}

public struct DeleteAppBundleOutput {

    public init() { }
}

enum DeleteAppBundleOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteIngestionDestinationInput {

    static func urlPathProvider(_ value: DeleteIngestionDestinationInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        guard let ingestionIdentifier = value.ingestionIdentifier else {
            return nil
        }
        guard let ingestionDestinationIdentifier = value.ingestionDestinationIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/ingestions/\(ingestionIdentifier.urlPercentEncoding())/ingestiondestinations/\(ingestionDestinationIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteIngestionDestinationInput {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion destination to use for the request.
    /// This member is required.
    public var ingestionDestinationIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion to use for the request.
    /// This member is required.
    public var ingestionIdentifier: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        ingestionDestinationIdentifier: Swift.String? = nil,
        ingestionIdentifier: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.ingestionDestinationIdentifier = ingestionDestinationIdentifier
        self.ingestionIdentifier = ingestionIdentifier
    }
}

extension DeleteIngestionDestinationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteIngestionDestinationOutput {
        return DeleteIngestionDestinationOutput()
    }
}

public struct DeleteIngestionDestinationOutput {

    public init() { }
}

enum DeleteIngestionDestinationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteIngestionInput {

    static func urlPathProvider(_ value: DeleteIngestionInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        guard let ingestionIdentifier = value.ingestionIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/ingestions/\(ingestionIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteIngestionInput {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion to use for the request.
    /// This member is required.
    public var ingestionIdentifier: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        ingestionIdentifier: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.ingestionIdentifier = ingestionIdentifier
    }
}

extension DeleteIngestionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteIngestionOutput {
        return DeleteIngestionOutput()
    }
}

public struct DeleteIngestionOutput {

    public init() { }
}

enum DeleteIngestionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AppFabricClientTypes.Destination {

    static func write(value: AppFabricClientTypes.Destination?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .firehosestream(firehosestream):
                try writer["firehoseStream"].write(firehosestream, with: AppFabricClientTypes.FirehoseStream.write(value:to:))
            case let .s3bucket(s3bucket):
                try writer["s3Bucket"].write(s3bucket, with: AppFabricClientTypes.S3Bucket.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.Destination {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "s3Bucket":
                return .s3bucket(try reader["s3Bucket"].read(with: AppFabricClientTypes.S3Bucket.read(from:)))
            case "firehoseStream":
                return .firehosestream(try reader["firehoseStream"].read(with: AppFabricClientTypes.FirehoseStream.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppFabricClientTypes {
    /// Contains information about an audit log destination.
    public enum Destination {
        /// Contains information about an Amazon S3 bucket.
        case s3bucket(AppFabricClientTypes.S3Bucket)
        /// Contains information about an Amazon Kinesis Data Firehose delivery stream.
        case firehosestream(AppFabricClientTypes.FirehoseStream)
        case sdkUnknown(Swift.String)
    }

}

extension AppFabricClientTypes.DestinationConfiguration {

    static func write(value: AppFabricClientTypes.DestinationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .auditlog(auditlog):
                try writer["auditLog"].write(auditlog, with: AppFabricClientTypes.AuditLogDestinationConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.DestinationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "auditLog":
                return .auditlog(try reader["auditLog"].read(with: AppFabricClientTypes.AuditLogDestinationConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppFabricClientTypes {
    /// Contains information about the destination of ingested data.
    public enum DestinationConfiguration {
        /// Contains information about an audit log destination configuration.
        case auditlog(AppFabricClientTypes.AuditLogDestinationConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension AppFabricClientTypes.FirehoseStream {

    static func write(value: AppFabricClientTypes.FirehoseStream?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["streamName"].write(value.streamName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.FirehoseStream {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppFabricClientTypes.FirehoseStream()
        value.streamName = try reader["streamName"].readIfPresent()
        return value
    }
}

extension AppFabricClientTypes {
    /// Contains information about an Amazon Kinesis Data Firehose delivery stream.
    public struct FirehoseStream {
        /// The name of the Amazon Kinesis Data Firehose delivery stream.
        /// This member is required.
        public var streamName: Swift.String?

        public init(
            streamName: Swift.String? = nil
        )
        {
            self.streamName = streamName
        }
    }

}

extension AppFabricClientTypes {

    public enum Format: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case json
        case parquet
        case sdkUnknown(Swift.String)

        public static var allCases: [Format] {
            return [
                .json,
                .parquet,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .json: return "json"
            case .parquet: return "parquet"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GetAppAuthorizationInput {

    static func urlPathProvider(_ value: GetAppAuthorizationInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        guard let appAuthorizationIdentifier = value.appAuthorizationIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/appauthorizations/\(appAuthorizationIdentifier.urlPercentEncoding())"
    }
}

public struct GetAppAuthorizationInput {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app authorization to use for the request.
    /// This member is required.
    public var appAuthorizationIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?

    public init(
        appAuthorizationIdentifier: Swift.String? = nil,
        appBundleIdentifier: Swift.String? = nil
    )
    {
        self.appAuthorizationIdentifier = appAuthorizationIdentifier
        self.appBundleIdentifier = appBundleIdentifier
    }
}

extension GetAppAuthorizationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetAppAuthorizationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAppAuthorizationOutput()
        value.appAuthorization = try reader["appAuthorization"].readIfPresent(with: AppFabricClientTypes.AppAuthorization.read(from:))
        return value
    }
}

public struct GetAppAuthorizationOutput {
    /// Contains information about an app authorization.
    /// This member is required.
    public var appAuthorization: AppFabricClientTypes.AppAuthorization?

    public init(
        appAuthorization: AppFabricClientTypes.AppAuthorization? = nil
    )
    {
        self.appAuthorization = appAuthorization
    }
}

enum GetAppAuthorizationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetAppBundleInput {

    static func urlPathProvider(_ value: GetAppBundleInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())"
    }
}

public struct GetAppBundleInput {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
    }
}

extension GetAppBundleOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetAppBundleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAppBundleOutput()
        value.appBundle = try reader["appBundle"].readIfPresent(with: AppFabricClientTypes.AppBundle.read(from:))
        return value
    }
}

public struct GetAppBundleOutput {
    /// Contains information about an app bundle.
    /// This member is required.
    public var appBundle: AppFabricClientTypes.AppBundle?

    public init(
        appBundle: AppFabricClientTypes.AppBundle? = nil
    )
    {
        self.appBundle = appBundle
    }
}

enum GetAppBundleOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetIngestionDestinationInput {

    static func urlPathProvider(_ value: GetIngestionDestinationInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        guard let ingestionIdentifier = value.ingestionIdentifier else {
            return nil
        }
        guard let ingestionDestinationIdentifier = value.ingestionDestinationIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/ingestions/\(ingestionIdentifier.urlPercentEncoding())/ingestiondestinations/\(ingestionDestinationIdentifier.urlPercentEncoding())"
    }
}

public struct GetIngestionDestinationInput {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion destination to use for the request.
    /// This member is required.
    public var ingestionDestinationIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion to use for the request.
    /// This member is required.
    public var ingestionIdentifier: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        ingestionDestinationIdentifier: Swift.String? = nil,
        ingestionIdentifier: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.ingestionDestinationIdentifier = ingestionDestinationIdentifier
        self.ingestionIdentifier = ingestionIdentifier
    }
}

extension GetIngestionDestinationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetIngestionDestinationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIngestionDestinationOutput()
        value.ingestionDestination = try reader["ingestionDestination"].readIfPresent(with: AppFabricClientTypes.IngestionDestination.read(from:))
        return value
    }
}

public struct GetIngestionDestinationOutput {
    /// Contains information about an ingestion destination.
    /// This member is required.
    public var ingestionDestination: AppFabricClientTypes.IngestionDestination?

    public init(
        ingestionDestination: AppFabricClientTypes.IngestionDestination? = nil
    )
    {
        self.ingestionDestination = ingestionDestination
    }
}

enum GetIngestionDestinationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetIngestionInput {

    static func urlPathProvider(_ value: GetIngestionInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        guard let ingestionIdentifier = value.ingestionIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/ingestions/\(ingestionIdentifier.urlPercentEncoding())"
    }
}

public struct GetIngestionInput {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion to use for the request.
    /// This member is required.
    public var ingestionIdentifier: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        ingestionIdentifier: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.ingestionIdentifier = ingestionIdentifier
    }
}

extension GetIngestionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetIngestionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIngestionOutput()
        value.ingestion = try reader["ingestion"].readIfPresent(with: AppFabricClientTypes.Ingestion.read(from:))
        return value
    }
}

public struct GetIngestionOutput {
    /// Contains information about an ingestion.
    /// This member is required.
    public var ingestion: AppFabricClientTypes.Ingestion?

    public init(
        ingestion: AppFabricClientTypes.Ingestion? = nil
    )
    {
        self.ingestion = ingestion
    }
}

enum GetIngestionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AppFabricClientTypes.Ingestion {

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.Ingestion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppFabricClientTypes.Ingestion()
        value.arn = try reader["arn"].readIfPresent()
        value.appBundleArn = try reader["appBundleArn"].readIfPresent()
        value.app = try reader["app"].readIfPresent()
        value.tenantId = try reader["tenantId"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        value.state = try reader["state"].readIfPresent()
        value.ingestionType = try reader["ingestionType"].readIfPresent()
        return value
    }
}

extension AppFabricClientTypes {
    /// Contains information about an ingestion.
    public struct Ingestion {
        /// The name of the application.
        /// This member is required.
        public var app: Swift.String?
        /// The Amazon Resource Name (ARN) of the app bundle for the ingestion.
        /// This member is required.
        public var appBundleArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the ingestion.
        /// This member is required.
        public var arn: Swift.String?
        /// The timestamp of when the ingestion was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The type of the ingestion.
        /// This member is required.
        public var ingestionType: AppFabricClientTypes.IngestionType?
        /// The status of the ingestion.
        /// This member is required.
        public var state: AppFabricClientTypes.IngestionState?
        /// The ID of the application tenant.
        /// This member is required.
        public var tenantId: Swift.String?
        /// The timestamp of when the ingestion was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            app: Swift.String? = nil,
            appBundleArn: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            ingestionType: AppFabricClientTypes.IngestionType? = nil,
            state: AppFabricClientTypes.IngestionState? = nil,
            tenantId: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.app = app
            self.appBundleArn = appBundleArn
            self.arn = arn
            self.createdAt = createdAt
            self.ingestionType = ingestionType
            self.state = state
            self.tenantId = tenantId
            self.updatedAt = updatedAt
        }
    }

}

extension AppFabricClientTypes.IngestionDestination {

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.IngestionDestination {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppFabricClientTypes.IngestionDestination()
        value.arn = try reader["arn"].readIfPresent()
        value.ingestionArn = try reader["ingestionArn"].readIfPresent()
        value.processingConfiguration = try reader["processingConfiguration"].readIfPresent(with: AppFabricClientTypes.ProcessingConfiguration.read(from:))
        value.destinationConfiguration = try reader["destinationConfiguration"].readIfPresent(with: AppFabricClientTypes.DestinationConfiguration.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension AppFabricClientTypes {
    /// Contains information about an ingestion destination.
    public struct IngestionDestination {
        /// The Amazon Resource Name (ARN) of the ingestion destination.
        /// This member is required.
        public var arn: Swift.String?
        /// The timestamp of when the ingestion destination was created.
        public var createdAt: ClientRuntime.Date?
        /// Contains information about the destination of ingested data.
        /// This member is required.
        public var destinationConfiguration: AppFabricClientTypes.DestinationConfiguration?
        /// The Amazon Resource Name (ARN) of the ingestion.
        /// This member is required.
        public var ingestionArn: Swift.String?
        /// Contains information about how ingested data is processed.
        /// This member is required.
        public var processingConfiguration: AppFabricClientTypes.ProcessingConfiguration?
        /// The state of the ingestion destination. The following states are possible:
        ///
        /// * Active: The ingestion destination is active and is ready to be used.
        ///
        /// * Failed: The ingestion destination has failed. If the ingestion destination is in this state, you should verify the ingestion destination configuration and try again.
        public var status: AppFabricClientTypes.IngestionDestinationStatus?
        /// The reason for the current status of the ingestion destination. Only present when the status of ingestion destination is Failed.
        public var statusReason: Swift.String?
        /// The timestamp of when the ingestion destination was last updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            destinationConfiguration: AppFabricClientTypes.DestinationConfiguration? = nil,
            ingestionArn: Swift.String? = nil,
            processingConfiguration: AppFabricClientTypes.ProcessingConfiguration? = nil,
            status: AppFabricClientTypes.IngestionDestinationStatus? = nil,
            statusReason: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.destinationConfiguration = destinationConfiguration
            self.ingestionArn = ingestionArn
            self.processingConfiguration = processingConfiguration
            self.status = status
            self.statusReason = statusReason
            self.updatedAt = updatedAt
        }
    }

}

extension AppFabricClientTypes {

    public enum IngestionDestinationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionDestinationStatus] {
            return [
                .active,
                .failed,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .failed: return "Failed"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppFabricClientTypes.IngestionDestinationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.IngestionDestinationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppFabricClientTypes.IngestionDestinationSummary()
        value.arn = try reader["arn"].readIfPresent()
        return value
    }
}

extension AppFabricClientTypes {
    /// Contains a summary of an ingestion destination.
    public struct IngestionDestinationSummary {
        /// The Amazon Resource Name (ARN) of the ingestion destination.
        /// This member is required.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension AppFabricClientTypes {

    public enum IngestionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "disabled"
            case .enabled: return "enabled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppFabricClientTypes.IngestionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.IngestionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppFabricClientTypes.IngestionSummary()
        value.arn = try reader["arn"].readIfPresent()
        value.app = try reader["app"].readIfPresent()
        value.tenantId = try reader["tenantId"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        return value
    }
}

extension AppFabricClientTypes {
    /// Contains a summary of an ingestion.
    public struct IngestionSummary {
        /// The name of the application.
        /// This member is required.
        public var app: Swift.String?
        /// The Amazon Resource Name (ARN) of the ingestion.
        /// This member is required.
        public var arn: Swift.String?
        /// The status of the ingestion.
        /// This member is required.
        public var state: AppFabricClientTypes.IngestionState?
        /// The ID of the application tenant.
        /// This member is required.
        public var tenantId: Swift.String?

        public init(
            app: Swift.String? = nil,
            arn: Swift.String? = nil,
            state: AppFabricClientTypes.IngestionState? = nil,
            tenantId: Swift.String? = nil
        )
        {
            self.app = app
            self.arn = arn
            self.state = state
            self.tenantId = tenantId
        }
    }

}

extension AppFabricClientTypes {

    public enum IngestionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case auditLog
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionType] {
            return [
                .auditLog,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .auditLog: return "auditLog"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The request processing has failed because of an unknown error, exception, or failure with an internal server.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The period of time after which you should retry your request.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

extension ListAppAuthorizationsInput {

    static func queryItemProvider(_ value: ListAppAuthorizationsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListAppAuthorizationsInput {

    static func urlPathProvider(_ value: ListAppAuthorizationsInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/appauthorizations"
    }
}

public struct ListAppAuthorizationsInput {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    public var maxResults: Swift.Int?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListAppAuthorizationsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListAppAuthorizationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAppAuthorizationsOutput()
        value.appAuthorizationSummaryList = try reader["appAuthorizationSummaryList"].readListIfPresent(memberReadingClosure: AppFabricClientTypes.AppAuthorizationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListAppAuthorizationsOutput {
    /// Contains a list of app authorization summaries.
    /// This member is required.
    public var appAuthorizationSummaryList: [AppFabricClientTypes.AppAuthorizationSummary]?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        appAuthorizationSummaryList: [AppFabricClientTypes.AppAuthorizationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appAuthorizationSummaryList = appAuthorizationSummaryList
        self.nextToken = nextToken
    }
}

enum ListAppAuthorizationsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListAppBundlesInput {

    static func queryItemProvider(_ value: ListAppBundlesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListAppBundlesInput {

    static func urlPathProvider(_ value: ListAppBundlesInput) -> Swift.String? {
        return "/appbundles"
    }
}

public struct ListAppBundlesInput {
    /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    public var maxResults: Swift.Int?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListAppBundlesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListAppBundlesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAppBundlesOutput()
        value.appBundleSummaryList = try reader["appBundleSummaryList"].readListIfPresent(memberReadingClosure: AppFabricClientTypes.AppBundleSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListAppBundlesOutput {
    /// Contains a list of app bundle summaries.
    /// This member is required.
    public var appBundleSummaryList: [AppFabricClientTypes.AppBundleSummary]?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        appBundleSummaryList: [AppFabricClientTypes.AppBundleSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appBundleSummaryList = appBundleSummaryList
        self.nextToken = nextToken
    }
}

enum ListAppBundlesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListIngestionDestinationsInput {

    static func queryItemProvider(_ value: ListIngestionDestinationsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListIngestionDestinationsInput {

    static func urlPathProvider(_ value: ListIngestionDestinationsInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        guard let ingestionIdentifier = value.ingestionIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/ingestions/\(ingestionIdentifier.urlPercentEncoding())/ingestiondestinations"
    }
}

public struct ListIngestionDestinationsInput {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion to use for the request.
    /// This member is required.
    public var ingestionIdentifier: Swift.String?
    /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    public var maxResults: Swift.Int?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        ingestionIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.ingestionIdentifier = ingestionIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListIngestionDestinationsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListIngestionDestinationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIngestionDestinationsOutput()
        value.ingestionDestinations = try reader["ingestionDestinations"].readListIfPresent(memberReadingClosure: AppFabricClientTypes.IngestionDestinationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListIngestionDestinationsOutput {
    /// Contains a list of ingestion destination summaries.
    /// This member is required.
    public var ingestionDestinations: [AppFabricClientTypes.IngestionDestinationSummary]?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        ingestionDestinations: [AppFabricClientTypes.IngestionDestinationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ingestionDestinations = ingestionDestinations
        self.nextToken = nextToken
    }
}

enum ListIngestionDestinationsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListIngestionsInput {

    static func queryItemProvider(_ value: ListIngestionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListIngestionsInput {

    static func urlPathProvider(_ value: ListIngestionsInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/ingestions"
    }
}

public struct ListIngestionsInput {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    public var maxResults: Swift.Int?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListIngestionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListIngestionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIngestionsOutput()
        value.ingestions = try reader["ingestions"].readListIfPresent(memberReadingClosure: AppFabricClientTypes.IngestionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListIngestionsOutput {
    /// Contains a list of ingestion summaries.
    /// This member is required.
    public var ingestions: [AppFabricClientTypes.IngestionSummary]?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        ingestions: [AppFabricClientTypes.IngestionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ingestions = ingestions
        self.nextToken = nextToken
    }
}

enum ListIngestionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) of the resource for which you want to retrieve tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: AppFabricClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListTagsForResourceOutput {
    /// A map of the key-value pairs for the tag or tags assigned to the specified resource.
    public var tags: [AppFabricClientTypes.Tag]?

    public init(
        tags: [AppFabricClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AppFabricClientTypes.Oauth2Credential: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Oauth2Credential(clientId: \(Swift.String(describing: clientId)), clientSecret: \"CONTENT_REDACTED\")"}
}

extension AppFabricClientTypes.Oauth2Credential {

    static func write(value: AppFabricClientTypes.Oauth2Credential?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientId"].write(value.clientId)
        try writer["clientSecret"].write(value.clientSecret)
    }
}

extension AppFabricClientTypes {
    /// Contains OAuth2 client credential information.
    public struct Oauth2Credential {
        /// The client ID of the client application.
        /// This member is required.
        public var clientId: Swift.String?
        /// The client secret of the client application.
        /// This member is required.
        public var clientSecret: Swift.String?

        public init(
            clientId: Swift.String? = nil,
            clientSecret: Swift.String? = nil
        )
        {
            self.clientId = clientId
            self.clientSecret = clientSecret
        }
    }

}

extension AppFabricClientTypes {

    public enum Persona: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case admin
        case enduser
        case sdkUnknown(Swift.String)

        public static var allCases: [Persona] {
            return [
                .admin,
                .enduser,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .admin: return "admin"
            case .enduser: return "endUser"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppFabricClientTypes.ProcessingConfiguration {

    static func write(value: AppFabricClientTypes.ProcessingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .auditlog(auditlog):
                try writer["auditLog"].write(auditlog, with: AppFabricClientTypes.AuditLogProcessingConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.ProcessingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "auditLog":
                return .auditlog(try reader["auditLog"].read(with: AppFabricClientTypes.AuditLogProcessingConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension AppFabricClientTypes {
    /// Contains information about how ingested data is processed.
    public enum ProcessingConfiguration {
        /// Contains information about an audit log processing configuration.
        case auditlog(AppFabricClientTypes.AuditLogProcessingConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The specified resource does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The resource ID.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

extension AppFabricClientTypes {

    public enum ResultStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case expired
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ResultStatus] {
            return [
                .completed,
                .expired,
                .failed,
                .inProgress,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .expired: return "EXPIRED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppFabricClientTypes.S3Bucket {

    static func write(value: AppFabricClientTypes.S3Bucket?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketName"].write(value.bucketName)
        try writer["prefix"].write(value.`prefix`)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.S3Bucket {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppFabricClientTypes.S3Bucket()
        value.bucketName = try reader["bucketName"].readIfPresent()
        value.`prefix` = try reader["prefix"].readIfPresent()
        return value
    }
}

extension AppFabricClientTypes {
    /// Contains information about an Amazon S3 bucket.
    public struct S3Bucket {
        /// The name of the Amazon S3 bucket.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The object key to use.
        public var `prefix`: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.`prefix` = `prefix`
        }
    }

}

extension AppFabricClientTypes {

    public enum Schema: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ocsf
        case raw
        case sdkUnknown(Swift.String)

        public static var allCases: [Schema] {
            return [
                .ocsf,
                .raw,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ocsf: return "ocsf"
            case .raw: return "raw"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The request exceeds a service quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The code for the quota exceeded.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The resource ID.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
        /// The code of the service.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

extension StartIngestionInput {

    static func urlPathProvider(_ value: StartIngestionInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        guard let ingestionIdentifier = value.ingestionIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/ingestions/\(ingestionIdentifier.urlPercentEncoding())/start"
    }
}

public struct StartIngestionInput {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion to use for the request.
    /// This member is required.
    public var ingestionIdentifier: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        ingestionIdentifier: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.ingestionIdentifier = ingestionIdentifier
    }
}

extension StartIngestionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> StartIngestionOutput {
        return StartIngestionOutput()
    }
}

public struct StartIngestionOutput {

    public init() { }
}

enum StartIngestionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension StartUserAccessTasksInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartUserAccessTasksInput(appBundleIdentifier: \(Swift.String(describing: appBundleIdentifier)), email: \"CONTENT_REDACTED\")"}
}

extension StartUserAccessTasksInput {

    static func urlPathProvider(_ value: StartUserAccessTasksInput) -> Swift.String? {
        return "/useraccess/start"
    }
}

extension StartUserAccessTasksInput {

    static func write(value: StartUserAccessTasksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appBundleIdentifier"].write(value.appBundleIdentifier)
        try writer["email"].write(value.email)
    }
}

public struct StartUserAccessTasksInput {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// The email address of the target user.
    /// This member is required.
    public var email: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        email: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.email = email
    }
}

extension StartUserAccessTasksOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> StartUserAccessTasksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartUserAccessTasksOutput()
        value.userAccessTasksList = try reader["userAccessTasksList"].readListIfPresent(memberReadingClosure: AppFabricClientTypes.UserAccessTaskItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct StartUserAccessTasksOutput {
    /// Contains a list of user access task information.
    public var userAccessTasksList: [AppFabricClientTypes.UserAccessTaskItem]?

    public init(
        userAccessTasksList: [AppFabricClientTypes.UserAccessTaskItem]? = nil
    )
    {
        self.userAccessTasksList = userAccessTasksList
    }
}

enum StartUserAccessTasksOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension StopIngestionInput {

    static func urlPathProvider(_ value: StopIngestionInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        guard let ingestionIdentifier = value.ingestionIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/ingestions/\(ingestionIdentifier.urlPercentEncoding())/stop"
    }
}

public struct StopIngestionInput {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion to use for the request.
    /// This member is required.
    public var ingestionIdentifier: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        ingestionIdentifier: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.ingestionIdentifier = ingestionIdentifier
    }
}

extension StopIngestionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> StopIngestionOutput {
        return StopIngestionOutput()
    }
}

public struct StopIngestionOutput {

    public init() { }
}

enum StopIngestionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AppFabricClientTypes.Tag {

    static func write(value: AppFabricClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppFabricClientTypes.Tag()
        value.key = try reader["key"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension AppFabricClientTypes {
    /// The key or keys of the key-value pairs for the tag or tags assigned to a resource.
    public struct Tag {
        /// Tag key.
        /// This member is required.
        public var key: Swift.String?
        /// Tag value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeList(value.tags, memberWritingClosure: AppFabricClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource that you want to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A map of the key-value pairs of the tag or tags to assign to the resource.
    /// This member is required.
    public var tags: [AppFabricClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [AppFabricClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

public struct TagResourceOutput {

    public init() { }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AppFabricClientTypes.TaskError {

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.TaskError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppFabricClientTypes.TaskError()
        value.errorCode = try reader["errorCode"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        return value
    }
}

extension AppFabricClientTypes {
    /// Contains information about an error returned from a user access task.
    public struct TaskError {
        /// The code of the error.
        public var errorCode: Swift.String?
        /// The message of the error.
        public var errorMessage: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension AppFabricClientTypes.Tenant {

    static func write(value: AppFabricClientTypes.Tenant?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tenantDisplayName"].write(value.tenantDisplayName)
        try writer["tenantIdentifier"].write(value.tenantIdentifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.Tenant {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppFabricClientTypes.Tenant()
        value.tenantIdentifier = try reader["tenantIdentifier"].readIfPresent()
        value.tenantDisplayName = try reader["tenantDisplayName"].readIfPresent()
        return value
    }
}

extension AppFabricClientTypes {
    /// Contains information about an application tenant.
    public struct Tenant {
        /// The display name of the tenant.
        /// This member is required.
        public var tenantDisplayName: Swift.String?
        /// The ID of the application tenant.
        /// This member is required.
        public var tenantIdentifier: Swift.String?

        public init(
            tenantDisplayName: Swift.String? = nil,
            tenantIdentifier: Swift.String? = nil
        )
        {
            self.tenantDisplayName = tenantDisplayName
            self.tenantIdentifier = tenantIdentifier
        }
    }

}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The request rate exceeds the limit.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The code for the quota exceeded.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The period of time after which you should retry your request.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
        /// The code of the service.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource that you want to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the key-value pairs for the tag or tags you want to remove from the specified resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

public struct UntagResourceOutput {

    public init() { }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateAppAuthorizationInput {

    static func urlPathProvider(_ value: UpdateAppAuthorizationInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        guard let appAuthorizationIdentifier = value.appAuthorizationIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/appauthorizations/\(appAuthorizationIdentifier.urlPercentEncoding())"
    }
}

extension UpdateAppAuthorizationInput {

    static func write(value: UpdateAppAuthorizationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["credential"].write(value.credential, with: AppFabricClientTypes.Credential.write(value:to:))
        try writer["tenant"].write(value.tenant, with: AppFabricClientTypes.Tenant.write(value:to:))
    }
}

public struct UpdateAppAuthorizationInput {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app authorization to use for the request.
    /// This member is required.
    public var appAuthorizationIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// Contains credentials for the application, such as an API key or OAuth2 client ID and secret. Specify credentials that match the authorization type of the app authorization to update. For example, if the authorization type of the app authorization is OAuth2 (oauth2), then you should provide only the OAuth2 credentials.
    public var credential: AppFabricClientTypes.Credential?
    /// Contains information about an application tenant, such as the application display name and identifier.
    public var tenant: AppFabricClientTypes.Tenant?

    public init(
        appAuthorizationIdentifier: Swift.String? = nil,
        appBundleIdentifier: Swift.String? = nil,
        credential: AppFabricClientTypes.Credential? = nil,
        tenant: AppFabricClientTypes.Tenant? = nil
    )
    {
        self.appAuthorizationIdentifier = appAuthorizationIdentifier
        self.appBundleIdentifier = appBundleIdentifier
        self.credential = credential
        self.tenant = tenant
    }
}

extension UpdateAppAuthorizationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateAppAuthorizationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAppAuthorizationOutput()
        value.appAuthorization = try reader["appAuthorization"].readIfPresent(with: AppFabricClientTypes.AppAuthorization.read(from:))
        return value
    }
}

public struct UpdateAppAuthorizationOutput {
    /// Contains information about an app authorization.
    /// This member is required.
    public var appAuthorization: AppFabricClientTypes.AppAuthorization?

    public init(
        appAuthorization: AppFabricClientTypes.AppAuthorization? = nil
    )
    {
        self.appAuthorization = appAuthorization
    }
}

enum UpdateAppAuthorizationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateIngestionDestinationInput {

    static func urlPathProvider(_ value: UpdateIngestionDestinationInput) -> Swift.String? {
        guard let appBundleIdentifier = value.appBundleIdentifier else {
            return nil
        }
        guard let ingestionIdentifier = value.ingestionIdentifier else {
            return nil
        }
        guard let ingestionDestinationIdentifier = value.ingestionDestinationIdentifier else {
            return nil
        }
        return "/appbundles/\(appBundleIdentifier.urlPercentEncoding())/ingestions/\(ingestionIdentifier.urlPercentEncoding())/ingestiondestinations/\(ingestionDestinationIdentifier.urlPercentEncoding())"
    }
}

extension UpdateIngestionDestinationInput {

    static func write(value: UpdateIngestionDestinationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destinationConfiguration"].write(value.destinationConfiguration, with: AppFabricClientTypes.DestinationConfiguration.write(value:to:))
    }
}

public struct UpdateIngestionDestinationInput {
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the app bundle to use for the request.
    /// This member is required.
    public var appBundleIdentifier: Swift.String?
    /// Contains information about the destination of ingested data.
    /// This member is required.
    public var destinationConfiguration: AppFabricClientTypes.DestinationConfiguration?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion destination to use for the request.
    /// This member is required.
    public var ingestionDestinationIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) or Universal Unique Identifier (UUID) of the ingestion to use for the request.
    /// This member is required.
    public var ingestionIdentifier: Swift.String?

    public init(
        appBundleIdentifier: Swift.String? = nil,
        destinationConfiguration: AppFabricClientTypes.DestinationConfiguration? = nil,
        ingestionDestinationIdentifier: Swift.String? = nil,
        ingestionIdentifier: Swift.String? = nil
    )
    {
        self.appBundleIdentifier = appBundleIdentifier
        self.destinationConfiguration = destinationConfiguration
        self.ingestionDestinationIdentifier = ingestionDestinationIdentifier
        self.ingestionIdentifier = ingestionIdentifier
    }
}

extension UpdateIngestionDestinationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateIngestionDestinationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateIngestionDestinationOutput()
        value.ingestionDestination = try reader["ingestionDestination"].readIfPresent(with: AppFabricClientTypes.IngestionDestination.read(from:))
        return value
    }
}

public struct UpdateIngestionDestinationOutput {
    /// Contains information about an ingestion destination.
    /// This member is required.
    public var ingestionDestination: AppFabricClientTypes.IngestionDestination?

    public init(
        ingestionDestination: AppFabricClientTypes.IngestionDestination? = nil
    )
    {
        self.ingestionDestination = ingestionDestination
    }
}

enum UpdateIngestionDestinationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AppFabricClientTypes.UserAccessResultItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserAccessResultItem(app: \(Swift.String(describing: app)), resultStatus: \(Swift.String(describing: resultStatus)), taskError: \(Swift.String(describing: taskError)), taskId: \(Swift.String(describing: taskId)), tenantDisplayName: \(Swift.String(describing: tenantDisplayName)), tenantId: \(Swift.String(describing: tenantId)), userStatus: \(Swift.String(describing: userStatus)), email: \"CONTENT_REDACTED\", userFirstName: \"CONTENT_REDACTED\", userFullName: \"CONTENT_REDACTED\", userId: \"CONTENT_REDACTED\", userLastName: \"CONTENT_REDACTED\")"}
}

extension AppFabricClientTypes.UserAccessResultItem {

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.UserAccessResultItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppFabricClientTypes.UserAccessResultItem()
        value.app = try reader["app"].readIfPresent()
        value.tenantId = try reader["tenantId"].readIfPresent()
        value.tenantDisplayName = try reader["tenantDisplayName"].readIfPresent()
        value.taskId = try reader["taskId"].readIfPresent()
        value.resultStatus = try reader["resultStatus"].readIfPresent()
        value.email = try reader["email"].readIfPresent()
        value.userId = try reader["userId"].readIfPresent()
        value.userFullName = try reader["userFullName"].readIfPresent()
        value.userFirstName = try reader["userFirstName"].readIfPresent()
        value.userLastName = try reader["userLastName"].readIfPresent()
        value.userStatus = try reader["userStatus"].readIfPresent()
        value.taskError = try reader["taskError"].readIfPresent(with: AppFabricClientTypes.TaskError.read(from:))
        return value
    }
}

extension AppFabricClientTypes {
    /// Contains information about a user's access to an application.
    public struct UserAccessResultItem {
        /// The name of the application.
        public var app: Swift.String?
        /// The email address of the target user.
        public var email: Swift.String?
        /// The status of the user access result item. The following states are possible:
        ///
        /// * IN_PROGRESS: The user access task is in progress.
        ///
        /// * COMPLETED: The user access task completed successfully.
        ///
        /// * FAILED: The user access task failed.
        ///
        /// * EXPIRED: The user access task expired.
        public var resultStatus: AppFabricClientTypes.ResultStatus?
        /// Contains information about an error returned from a user access task.
        public var taskError: AppFabricClientTypes.TaskError?
        /// The unique ID of the task.
        public var taskId: Swift.String?
        /// The display name of the tenant.
        public var tenantDisplayName: Swift.String?
        /// The ID of the application tenant.
        public var tenantId: Swift.String?
        /// The first name of the user.
        public var userFirstName: Swift.String?
        /// The full name of the user.
        public var userFullName: Swift.String?
        /// The unique ID of user.
        public var userId: Swift.String?
        /// The last name of the user.
        public var userLastName: Swift.String?
        /// The status of the user returned by the application.
        public var userStatus: Swift.String?

        public init(
            app: Swift.String? = nil,
            email: Swift.String? = nil,
            resultStatus: AppFabricClientTypes.ResultStatus? = nil,
            taskError: AppFabricClientTypes.TaskError? = nil,
            taskId: Swift.String? = nil,
            tenantDisplayName: Swift.String? = nil,
            tenantId: Swift.String? = nil,
            userFirstName: Swift.String? = nil,
            userFullName: Swift.String? = nil,
            userId: Swift.String? = nil,
            userLastName: Swift.String? = nil,
            userStatus: Swift.String? = nil
        )
        {
            self.app = app
            self.email = email
            self.resultStatus = resultStatus
            self.taskError = taskError
            self.taskId = taskId
            self.tenantDisplayName = tenantDisplayName
            self.tenantId = tenantId
            self.userFirstName = userFirstName
            self.userFullName = userFullName
            self.userId = userId
            self.userLastName = userLastName
            self.userStatus = userStatus
        }
    }

}

extension AppFabricClientTypes.UserAccessTaskItem {

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.UserAccessTaskItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppFabricClientTypes.UserAccessTaskItem()
        value.app = try reader["app"].readIfPresent()
        value.tenantId = try reader["tenantId"].readIfPresent()
        value.taskId = try reader["taskId"].readIfPresent()
        value.error = try reader["error"].readIfPresent(with: AppFabricClientTypes.TaskError.read(from:))
        return value
    }
}

extension AppFabricClientTypes {
    /// Contains information about a user access task.
    public struct UserAccessTaskItem {
        /// The name of the application.
        /// This member is required.
        public var app: Swift.String?
        /// Error from the task, if any.
        public var error: AppFabricClientTypes.TaskError?
        /// The unique ID of the task.
        public var taskId: Swift.String?
        /// The ID of the application tenant.
        /// This member is required.
        public var tenantId: Swift.String?

        public init(
            app: Swift.String? = nil,
            error: AppFabricClientTypes.TaskError? = nil,
            taskId: Swift.String? = nil,
            tenantId: Swift.String? = nil
        )
        {
            self.app = app
            self.error = error
            self.taskId = taskId
            self.tenantId = tenantId
        }
    }

}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: AppFabricClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.reason = try reader["reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The request has invalid or missing parameters.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The field list.
        public internal(set) var fieldList: [AppFabricClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason for the exception.
        /// This member is required.
        public internal(set) var reason: AppFabricClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [AppFabricClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: AppFabricClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension AppFabricClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> AppFabricClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppFabricClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension AppFabricClientTypes {
    /// The input failed to meet the constraints specified by the Amazon Web Services service in a specified field.
    public struct ValidationExceptionField {
        /// A message about the validation exception.
        /// This member is required.
        public var message: Swift.String?
        /// The field name where the invalid entry was detected.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension AppFabricClientTypes {

    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}
