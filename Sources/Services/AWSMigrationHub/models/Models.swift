// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MigrationHubClientTypes.ApplicationState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case applicationStatus = "ApplicationStatus"
        case lastUpdatedTime = "LastUpdatedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let applicationStatus = self.applicationStatus {
            try encodeContainer.encode(applicationStatus.rawValue, forKey: .applicationStatus)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let applicationStatusDecoded = try containerValues.decodeIfPresent(MigrationHubClientTypes.ApplicationStatus.self, forKey: .applicationStatus)
        applicationStatus = applicationStatusDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension MigrationHubClientTypes {
    /// The state of an application discovered through Migration Hub import, the AWS Agentless Discovery Connector, or the AWS Application Discovery Agent.
    public struct ApplicationState: Swift.Equatable {
        /// The configurationId from the Application Discovery Service that uniquely identifies an application.
        public var applicationId: Swift.String?
        /// The current status of an application.
        public var applicationStatus: MigrationHubClientTypes.ApplicationStatus?
        /// The timestamp when the application status was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?

        public init (
            applicationId: Swift.String? = nil,
            applicationStatus: MigrationHubClientTypes.ApplicationStatus? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil
        )
        {
            self.applicationId = applicationId
            self.applicationStatus = applicationStatus
            self.lastUpdatedTime = lastUpdatedTime
        }
    }

}

extension MigrationHubClientTypes {
    public enum ApplicationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case inProgress
        case notStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationStatus] {
            return [
                .completed,
                .inProgress,
                .notStarted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationStatus(rawValue: rawValue) ?? ApplicationStatus.sdkUnknown(rawValue)
        }
    }
}

extension AssociateCreatedArtifactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdArtifact = "CreatedArtifact"
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdArtifact = self.createdArtifact {
            try encodeContainer.encode(createdArtifact, forKey: .createdArtifact)
        }
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let migrationTaskName = self.migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let progressUpdateStream = self.progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
    }
}

extension AssociateCreatedArtifactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateCreatedArtifactInput: Swift.Equatable {
    /// An ARN of the AWS resource related to the migration (e.g., AMI, EC2 instance, RDS instance, etc.)
    /// This member is required.
    public var createdArtifact: MigrationHubClientTypes.CreatedArtifact?
    /// Optional boolean flag to indicate whether any effect should take place. Used to test if the caller has permission to make the call.
    public var dryRun: Swift.Bool
    /// Unique identifier that references the migration task. Do not store personal data in this field.
    /// This member is required.
    public var migrationTaskName: Swift.String?
    /// The name of the ProgressUpdateStream.
    /// This member is required.
    public var progressUpdateStream: Swift.String?

    public init (
        createdArtifact: MigrationHubClientTypes.CreatedArtifact? = nil,
        dryRun: Swift.Bool = false,
        migrationTaskName: Swift.String? = nil,
        progressUpdateStream: Swift.String? = nil
    )
    {
        self.createdArtifact = createdArtifact
        self.dryRun = dryRun
        self.migrationTaskName = migrationTaskName
        self.progressUpdateStream = progressUpdateStream
    }
}

struct AssociateCreatedArtifactInputBody: Swift.Equatable {
    let progressUpdateStream: Swift.String?
    let migrationTaskName: Swift.String?
    let createdArtifact: MigrationHubClientTypes.CreatedArtifact?
    let dryRun: Swift.Bool
}

extension AssociateCreatedArtifactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdArtifact = "CreatedArtifact"
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let createdArtifactDecoded = try containerValues.decodeIfPresent(MigrationHubClientTypes.CreatedArtifact.self, forKey: .createdArtifact)
        createdArtifact = createdArtifactDecoded
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun) ?? false
        dryRun = dryRunDecoded
    }
}

extension AssociateCreatedArtifactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateCreatedArtifactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DryRunOperation" : self = .dryRunOperation(try DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateCreatedArtifactOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dryRunOperation(DryRunOperation)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateCreatedArtifactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateCreatedArtifactOutputResponse: Swift.Equatable {

    public init () { }
}

extension AssociateDiscoveredResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case discoveredResource = "DiscoveredResource"
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let discoveredResource = self.discoveredResource {
            try encodeContainer.encode(discoveredResource, forKey: .discoveredResource)
        }
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let migrationTaskName = self.migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let progressUpdateStream = self.progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
    }
}

extension AssociateDiscoveredResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateDiscoveredResourceInput: Swift.Equatable {
    /// Object representing a Resource.
    /// This member is required.
    public var discoveredResource: MigrationHubClientTypes.DiscoveredResource?
    /// Optional boolean flag to indicate whether any effect should take place. Used to test if the caller has permission to make the call.
    public var dryRun: Swift.Bool
    /// The identifier given to the MigrationTask. Do not store personal data in this field.
    /// This member is required.
    public var migrationTaskName: Swift.String?
    /// The name of the ProgressUpdateStream.
    /// This member is required.
    public var progressUpdateStream: Swift.String?

    public init (
        discoveredResource: MigrationHubClientTypes.DiscoveredResource? = nil,
        dryRun: Swift.Bool = false,
        migrationTaskName: Swift.String? = nil,
        progressUpdateStream: Swift.String? = nil
    )
    {
        self.discoveredResource = discoveredResource
        self.dryRun = dryRun
        self.migrationTaskName = migrationTaskName
        self.progressUpdateStream = progressUpdateStream
    }
}

struct AssociateDiscoveredResourceInputBody: Swift.Equatable {
    let progressUpdateStream: Swift.String?
    let migrationTaskName: Swift.String?
    let discoveredResource: MigrationHubClientTypes.DiscoveredResource?
    let dryRun: Swift.Bool
}

extension AssociateDiscoveredResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case discoveredResource = "DiscoveredResource"
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let discoveredResourceDecoded = try containerValues.decodeIfPresent(MigrationHubClientTypes.DiscoveredResource.self, forKey: .discoveredResource)
        discoveredResource = discoveredResourceDecoded
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun) ?? false
        dryRun = dryRunDecoded
    }
}

extension AssociateDiscoveredResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateDiscoveredResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DryRunOperation" : self = .dryRunOperation(try DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyErrorException" : self = .policyErrorException(try PolicyErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateDiscoveredResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dryRunOperation(DryRunOperation)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case policyErrorException(PolicyErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateDiscoveredResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateDiscoveredResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension CreateProgressUpdateStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case progressUpdateStreamName = "ProgressUpdateStreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let progressUpdateStreamName = self.progressUpdateStreamName {
            try encodeContainer.encode(progressUpdateStreamName, forKey: .progressUpdateStreamName)
        }
    }
}

extension CreateProgressUpdateStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateProgressUpdateStreamInput: Swift.Equatable {
    /// Optional boolean flag to indicate whether any effect should take place. Used to test if the caller has permission to make the call.
    public var dryRun: Swift.Bool
    /// The name of the ProgressUpdateStream. Do not store personal data in this field.
    /// This member is required.
    public var progressUpdateStreamName: Swift.String?

    public init (
        dryRun: Swift.Bool = false,
        progressUpdateStreamName: Swift.String? = nil
    )
    {
        self.dryRun = dryRun
        self.progressUpdateStreamName = progressUpdateStreamName
    }
}

struct CreateProgressUpdateStreamInputBody: Swift.Equatable {
    let progressUpdateStreamName: Swift.String?
    let dryRun: Swift.Bool
}

extension CreateProgressUpdateStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case progressUpdateStreamName = "ProgressUpdateStreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStreamName)
        progressUpdateStreamName = progressUpdateStreamNameDecoded
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun) ?? false
        dryRun = dryRunDecoded
    }
}

extension CreateProgressUpdateStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProgressUpdateStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DryRunOperation" : self = .dryRunOperation(try DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateProgressUpdateStreamOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dryRunOperation(DryRunOperation)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProgressUpdateStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateProgressUpdateStreamOutputResponse: Swift.Equatable {

    public init () { }
}

extension MigrationHubClientTypes.CreatedArtifact: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension MigrationHubClientTypes {
    /// An ARN of the AWS cloud resource target receiving the migration (e.g., AMI, EC2 instance, RDS instance, etc.).
    public struct CreatedArtifact: Swift.Equatable {
        /// A description that can be free-form text to record additional detail about the artifact for clarity or for later reference.
        public var description: Swift.String?
        /// An ARN that uniquely identifies the result of a migration task.
        /// This member is required.
        public var name: Swift.String?

        public init (
            description: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.description = description
            self.name = name
        }
    }

}

extension DeleteProgressUpdateStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case progressUpdateStreamName = "ProgressUpdateStreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let progressUpdateStreamName = self.progressUpdateStreamName {
            try encodeContainer.encode(progressUpdateStreamName, forKey: .progressUpdateStreamName)
        }
    }
}

extension DeleteProgressUpdateStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteProgressUpdateStreamInput: Swift.Equatable {
    /// Optional boolean flag to indicate whether any effect should take place. Used to test if the caller has permission to make the call.
    public var dryRun: Swift.Bool
    /// The name of the ProgressUpdateStream. Do not store personal data in this field.
    /// This member is required.
    public var progressUpdateStreamName: Swift.String?

    public init (
        dryRun: Swift.Bool = false,
        progressUpdateStreamName: Swift.String? = nil
    )
    {
        self.dryRun = dryRun
        self.progressUpdateStreamName = progressUpdateStreamName
    }
}

struct DeleteProgressUpdateStreamInputBody: Swift.Equatable {
    let progressUpdateStreamName: Swift.String?
    let dryRun: Swift.Bool
}

extension DeleteProgressUpdateStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case progressUpdateStreamName = "ProgressUpdateStreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStreamName)
        progressUpdateStreamName = progressUpdateStreamNameDecoded
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun) ?? false
        dryRun = dryRunDecoded
    }
}

extension DeleteProgressUpdateStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProgressUpdateStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DryRunOperation" : self = .dryRunOperation(try DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteProgressUpdateStreamOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dryRunOperation(DryRunOperation)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProgressUpdateStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProgressUpdateStreamOutputResponse: Swift.Equatable {

    public init () { }
}

extension DescribeApplicationStateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
    }
}

extension DescribeApplicationStateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeApplicationStateInput: Swift.Equatable {
    /// The configurationId in Application Discovery Service that uniquely identifies the grouped application.
    /// This member is required.
    public var applicationId: Swift.String?

    public init (
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct DescribeApplicationStateInputBody: Swift.Equatable {
    let applicationId: Swift.String?
}

extension DescribeApplicationStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
    }
}

extension DescribeApplicationStateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeApplicationStateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyErrorException" : self = .policyErrorException(try PolicyErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeApplicationStateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case policyErrorException(PolicyErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeApplicationStateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeApplicationStateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationStatus = output.applicationStatus
            self.lastUpdatedTime = output.lastUpdatedTime
        } else {
            self.applicationStatus = nil
            self.lastUpdatedTime = nil
        }
    }
}

public struct DescribeApplicationStateOutputResponse: Swift.Equatable {
    /// Status of the application - Not Started, In-Progress, Complete.
    public var applicationStatus: MigrationHubClientTypes.ApplicationStatus?
    /// The timestamp when the application status was last updated.
    public var lastUpdatedTime: ClientRuntime.Date?

    public init (
        applicationStatus: MigrationHubClientTypes.ApplicationStatus? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil
    )
    {
        self.applicationStatus = applicationStatus
        self.lastUpdatedTime = lastUpdatedTime
    }
}

struct DescribeApplicationStateOutputResponseBody: Swift.Equatable {
    let applicationStatus: MigrationHubClientTypes.ApplicationStatus?
    let lastUpdatedTime: ClientRuntime.Date?
}

extension DescribeApplicationStateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationStatus = "ApplicationStatus"
        case lastUpdatedTime = "LastUpdatedTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationStatusDecoded = try containerValues.decodeIfPresent(MigrationHubClientTypes.ApplicationStatus.self, forKey: .applicationStatus)
        applicationStatus = applicationStatusDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension DescribeMigrationTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let migrationTaskName = self.migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let progressUpdateStream = self.progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
    }
}

extension DescribeMigrationTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeMigrationTaskInput: Swift.Equatable {
    /// The identifier given to the MigrationTask. Do not store personal data in this field.
    /// This member is required.
    public var migrationTaskName: Swift.String?
    /// The name of the ProgressUpdateStream.
    /// This member is required.
    public var progressUpdateStream: Swift.String?

    public init (
        migrationTaskName: Swift.String? = nil,
        progressUpdateStream: Swift.String? = nil
    )
    {
        self.migrationTaskName = migrationTaskName
        self.progressUpdateStream = progressUpdateStream
    }
}

struct DescribeMigrationTaskInputBody: Swift.Equatable {
    let progressUpdateStream: Swift.String?
    let migrationTaskName: Swift.String?
}

extension DescribeMigrationTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
    }
}

extension DescribeMigrationTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMigrationTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeMigrationTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMigrationTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeMigrationTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.migrationTask = output.migrationTask
        } else {
            self.migrationTask = nil
        }
    }
}

public struct DescribeMigrationTaskOutputResponse: Swift.Equatable {
    /// Object encapsulating information about the migration task.
    public var migrationTask: MigrationHubClientTypes.MigrationTask?

    public init (
        migrationTask: MigrationHubClientTypes.MigrationTask? = nil
    )
    {
        self.migrationTask = migrationTask
    }
}

struct DescribeMigrationTaskOutputResponseBody: Swift.Equatable {
    let migrationTask: MigrationHubClientTypes.MigrationTask?
}

extension DescribeMigrationTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationTask = "MigrationTask"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let migrationTaskDecoded = try containerValues.decodeIfPresent(MigrationHubClientTypes.MigrationTask.self, forKey: .migrationTask)
        migrationTask = migrationTaskDecoded
    }
}

extension DisassociateCreatedArtifactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdArtifactName = "CreatedArtifactName"
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdArtifactName = self.createdArtifactName {
            try encodeContainer.encode(createdArtifactName, forKey: .createdArtifactName)
        }
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let migrationTaskName = self.migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let progressUpdateStream = self.progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
    }
}

extension DisassociateCreatedArtifactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateCreatedArtifactInput: Swift.Equatable {
    /// An ARN of the AWS resource related to the migration (e.g., AMI, EC2 instance, RDS instance, etc.)
    /// This member is required.
    public var createdArtifactName: Swift.String?
    /// Optional boolean flag to indicate whether any effect should take place. Used to test if the caller has permission to make the call.
    public var dryRun: Swift.Bool
    /// Unique identifier that references the migration task to be disassociated with the artifact. Do not store personal data in this field.
    /// This member is required.
    public var migrationTaskName: Swift.String?
    /// The name of the ProgressUpdateStream.
    /// This member is required.
    public var progressUpdateStream: Swift.String?

    public init (
        createdArtifactName: Swift.String? = nil,
        dryRun: Swift.Bool = false,
        migrationTaskName: Swift.String? = nil,
        progressUpdateStream: Swift.String? = nil
    )
    {
        self.createdArtifactName = createdArtifactName
        self.dryRun = dryRun
        self.migrationTaskName = migrationTaskName
        self.progressUpdateStream = progressUpdateStream
    }
}

struct DisassociateCreatedArtifactInputBody: Swift.Equatable {
    let progressUpdateStream: Swift.String?
    let migrationTaskName: Swift.String?
    let createdArtifactName: Swift.String?
    let dryRun: Swift.Bool
}

extension DisassociateCreatedArtifactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdArtifactName = "CreatedArtifactName"
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let createdArtifactNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdArtifactName)
        createdArtifactName = createdArtifactNameDecoded
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun) ?? false
        dryRun = dryRunDecoded
    }
}

extension DisassociateCreatedArtifactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateCreatedArtifactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DryRunOperation" : self = .dryRunOperation(try DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateCreatedArtifactOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dryRunOperation(DryRunOperation)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateCreatedArtifactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateCreatedArtifactOutputResponse: Swift.Equatable {

    public init () { }
}

extension DisassociateDiscoveredResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationId = "ConfigurationId"
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationId = self.configurationId {
            try encodeContainer.encode(configurationId, forKey: .configurationId)
        }
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let migrationTaskName = self.migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let progressUpdateStream = self.progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
    }
}

extension DisassociateDiscoveredResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateDiscoveredResourceInput: Swift.Equatable {
    /// ConfigurationId of the Application Discovery Service resource to be disassociated.
    /// This member is required.
    public var configurationId: Swift.String?
    /// Optional boolean flag to indicate whether any effect should take place. Used to test if the caller has permission to make the call.
    public var dryRun: Swift.Bool
    /// The identifier given to the MigrationTask. Do not store personal data in this field.
    /// This member is required.
    public var migrationTaskName: Swift.String?
    /// The name of the ProgressUpdateStream.
    /// This member is required.
    public var progressUpdateStream: Swift.String?

    public init (
        configurationId: Swift.String? = nil,
        dryRun: Swift.Bool = false,
        migrationTaskName: Swift.String? = nil,
        progressUpdateStream: Swift.String? = nil
    )
    {
        self.configurationId = configurationId
        self.dryRun = dryRun
        self.migrationTaskName = migrationTaskName
        self.progressUpdateStream = progressUpdateStream
    }
}

struct DisassociateDiscoveredResourceInputBody: Swift.Equatable {
    let progressUpdateStream: Swift.String?
    let migrationTaskName: Swift.String?
    let configurationId: Swift.String?
    let dryRun: Swift.Bool
}

extension DisassociateDiscoveredResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationId = "ConfigurationId"
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let configurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationId)
        configurationId = configurationIdDecoded
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun) ?? false
        dryRun = dryRunDecoded
    }
}

extension DisassociateDiscoveredResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateDiscoveredResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DryRunOperation" : self = .dryRunOperation(try DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateDiscoveredResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dryRunOperation(DryRunOperation)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateDiscoveredResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateDiscoveredResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension MigrationHubClientTypes.DiscoveredResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationId = "ConfigurationId"
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationId = self.configurationId {
            try encodeContainer.encode(configurationId, forKey: .configurationId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationId)
        configurationId = configurationIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension MigrationHubClientTypes {
    /// Object representing the on-premises resource being migrated.
    public struct DiscoveredResource: Swift.Equatable {
        /// The configurationId in Application Discovery Service that uniquely identifies the on-premise resource.
        /// This member is required.
        public var configurationId: Swift.String?
        /// A description that can be free-form text to record additional detail about the discovered resource for clarity or later reference.
        public var description: Swift.String?

        public init (
            configurationId: Swift.String? = nil,
            description: Swift.String? = nil
        )
        {
            self.configurationId = configurationId
            self.description = description
        }
    }

}

extension DryRunOperation {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DryRunOperationBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception raised to indicate a successfully authorized action when the DryRun flag is set to "true".
public struct DryRunOperation: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DryRunOperationBody: Swift.Equatable {
    let message: Swift.String?
}

extension DryRunOperationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HomeRegionNotSetException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: HomeRegionNotSetExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The home region is not set. Set the home region to continue.
public struct HomeRegionNotSetException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct HomeRegionNotSetExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension HomeRegionNotSetExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ImportMigrationTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let migrationTaskName = self.migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let progressUpdateStream = self.progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
    }
}

extension ImportMigrationTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ImportMigrationTaskInput: Swift.Equatable {
    /// Optional boolean flag to indicate whether any effect should take place. Used to test if the caller has permission to make the call.
    public var dryRun: Swift.Bool
    /// Unique identifier that references the migration task. Do not store personal data in this field.
    /// This member is required.
    public var migrationTaskName: Swift.String?
    /// The name of the ProgressUpdateStream. >
    /// This member is required.
    public var progressUpdateStream: Swift.String?

    public init (
        dryRun: Swift.Bool = false,
        migrationTaskName: Swift.String? = nil,
        progressUpdateStream: Swift.String? = nil
    )
    {
        self.dryRun = dryRun
        self.migrationTaskName = migrationTaskName
        self.progressUpdateStream = progressUpdateStream
    }
}

struct ImportMigrationTaskInputBody: Swift.Equatable {
    let progressUpdateStream: Swift.String?
    let migrationTaskName: Swift.String?
    let dryRun: Swift.Bool
}

extension ImportMigrationTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun) ?? false
        dryRun = dryRunDecoded
    }
}

extension ImportMigrationTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportMigrationTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DryRunOperation" : self = .dryRunOperation(try DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ImportMigrationTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dryRunOperation(DryRunOperation)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportMigrationTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ImportMigrationTaskOutputResponse: Swift.Equatable {

    public init () { }
}

extension InternalServerError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerErrorBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception raised when an internal, configuration, or dependency error is encountered.
public struct InternalServerError: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerErrorBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInputException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception raised when the provided input violates a policy constraint or is entered in the wrong format or data type.
public struct InvalidInputException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInputExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidInputExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListApplicationStatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationIds = "ApplicationIds"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationIds = applicationIds {
            var applicationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applicationIds)
            for applicationid0 in applicationIds {
                try applicationIdsContainer.encode(applicationid0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListApplicationStatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListApplicationStatesInput: Swift.Equatable {
    /// The configurationIds from the Application Discovery Service that uniquely identifies your applications.
    public var applicationIds: [Swift.String]?
    /// Maximum number of results to be returned per page.
    public var maxResults: Swift.Int?
    /// If a NextToken was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in NextToken.
    public var nextToken: Swift.String?

    public init (
        applicationIds: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationIds = applicationIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApplicationStatesInputBody: Swift.Equatable {
    let applicationIds: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListApplicationStatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationIds = "ApplicationIds"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .applicationIds)
        var applicationIdsDecoded0:[Swift.String]? = nil
        if let applicationIdsContainer = applicationIdsContainer {
            applicationIdsDecoded0 = [Swift.String]()
            for string0 in applicationIdsContainer {
                if let string0 = string0 {
                    applicationIdsDecoded0?.append(string0)
                }
            }
        }
        applicationIds = applicationIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListApplicationStatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApplicationStatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListApplicationStatesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApplicationStatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListApplicationStatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationStateList = output.applicationStateList
            self.nextToken = output.nextToken
        } else {
            self.applicationStateList = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationStatesOutputResponse: Swift.Equatable {
    /// A list of Applications that exist in Application Discovery Service.
    public var applicationStateList: [MigrationHubClientTypes.ApplicationState]?
    /// If a NextToken was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in NextToken.
    public var nextToken: Swift.String?

    public init (
        applicationStateList: [MigrationHubClientTypes.ApplicationState]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationStateList = applicationStateList
        self.nextToken = nextToken
    }
}

struct ListApplicationStatesOutputResponseBody: Swift.Equatable {
    let applicationStateList: [MigrationHubClientTypes.ApplicationState]?
    let nextToken: Swift.String?
}

extension ListApplicationStatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationStateList = "ApplicationStateList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationStateListContainer = try containerValues.decodeIfPresent([MigrationHubClientTypes.ApplicationState?].self, forKey: .applicationStateList)
        var applicationStateListDecoded0:[MigrationHubClientTypes.ApplicationState]? = nil
        if let applicationStateListContainer = applicationStateListContainer {
            applicationStateListDecoded0 = [MigrationHubClientTypes.ApplicationState]()
            for structure0 in applicationStateListContainer {
                if let structure0 = structure0 {
                    applicationStateListDecoded0?.append(structure0)
                }
            }
        }
        applicationStateList = applicationStateListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCreatedArtifactsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case migrationTaskName = "MigrationTaskName"
        case nextToken = "NextToken"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let migrationTaskName = self.migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let progressUpdateStream = self.progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
    }
}

extension ListCreatedArtifactsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListCreatedArtifactsInput: Swift.Equatable {
    /// Maximum number of results to be returned per page.
    public var maxResults: Swift.Int?
    /// Unique identifier that references the migration task. Do not store personal data in this field.
    /// This member is required.
    public var migrationTaskName: Swift.String?
    /// If a NextToken was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in NextToken.
    public var nextToken: Swift.String?
    /// The name of the ProgressUpdateStream.
    /// This member is required.
    public var progressUpdateStream: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        migrationTaskName: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        progressUpdateStream: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.migrationTaskName = migrationTaskName
        self.nextToken = nextToken
        self.progressUpdateStream = progressUpdateStream
    }
}

struct ListCreatedArtifactsInputBody: Swift.Equatable {
    let progressUpdateStream: Swift.String?
    let migrationTaskName: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListCreatedArtifactsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case migrationTaskName = "MigrationTaskName"
        case nextToken = "NextToken"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListCreatedArtifactsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCreatedArtifactsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListCreatedArtifactsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCreatedArtifactsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListCreatedArtifactsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdArtifactList = output.createdArtifactList
            self.nextToken = output.nextToken
        } else {
            self.createdArtifactList = nil
            self.nextToken = nil
        }
    }
}

public struct ListCreatedArtifactsOutputResponse: Swift.Equatable {
    /// List of created artifacts up to the maximum number of results specified in the request.
    public var createdArtifactList: [MigrationHubClientTypes.CreatedArtifact]?
    /// If there are more created artifacts than the max result, return the next token to be passed to the next call as a bookmark of where to start from.
    public var nextToken: Swift.String?

    public init (
        createdArtifactList: [MigrationHubClientTypes.CreatedArtifact]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.createdArtifactList = createdArtifactList
        self.nextToken = nextToken
    }
}

struct ListCreatedArtifactsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let createdArtifactList: [MigrationHubClientTypes.CreatedArtifact]?
}

extension ListCreatedArtifactsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdArtifactList = "CreatedArtifactList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let createdArtifactListContainer = try containerValues.decodeIfPresent([MigrationHubClientTypes.CreatedArtifact?].self, forKey: .createdArtifactList)
        var createdArtifactListDecoded0:[MigrationHubClientTypes.CreatedArtifact]? = nil
        if let createdArtifactListContainer = createdArtifactListContainer {
            createdArtifactListDecoded0 = [MigrationHubClientTypes.CreatedArtifact]()
            for structure0 in createdArtifactListContainer {
                if let structure0 = structure0 {
                    createdArtifactListDecoded0?.append(structure0)
                }
            }
        }
        createdArtifactList = createdArtifactListDecoded0
    }
}

extension ListDiscoveredResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case migrationTaskName = "MigrationTaskName"
        case nextToken = "NextToken"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let migrationTaskName = self.migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let progressUpdateStream = self.progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
    }
}

extension ListDiscoveredResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDiscoveredResourcesInput: Swift.Equatable {
    /// The maximum number of results returned per page.
    public var maxResults: Swift.Int?
    /// The name of the MigrationTask. Do not store personal data in this field.
    /// This member is required.
    public var migrationTaskName: Swift.String?
    /// If a NextToken was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in NextToken.
    public var nextToken: Swift.String?
    /// The name of the ProgressUpdateStream.
    /// This member is required.
    public var progressUpdateStream: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        migrationTaskName: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        progressUpdateStream: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.migrationTaskName = migrationTaskName
        self.nextToken = nextToken
        self.progressUpdateStream = progressUpdateStream
    }
}

struct ListDiscoveredResourcesInputBody: Swift.Equatable {
    let progressUpdateStream: Swift.String?
    let migrationTaskName: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDiscoveredResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case migrationTaskName = "MigrationTaskName"
        case nextToken = "NextToken"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDiscoveredResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDiscoveredResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDiscoveredResourcesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDiscoveredResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDiscoveredResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.discoveredResourceList = output.discoveredResourceList
            self.nextToken = output.nextToken
        } else {
            self.discoveredResourceList = nil
            self.nextToken = nil
        }
    }
}

public struct ListDiscoveredResourcesOutputResponse: Swift.Equatable {
    /// Returned list of discovered resources associated with the given MigrationTask.
    public var discoveredResourceList: [MigrationHubClientTypes.DiscoveredResource]?
    /// If there are more discovered resources than the max result, return the next token to be passed to the next call as a bookmark of where to start from.
    public var nextToken: Swift.String?

    public init (
        discoveredResourceList: [MigrationHubClientTypes.DiscoveredResource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.discoveredResourceList = discoveredResourceList
        self.nextToken = nextToken
    }
}

struct ListDiscoveredResourcesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let discoveredResourceList: [MigrationHubClientTypes.DiscoveredResource]?
}

extension ListDiscoveredResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case discoveredResourceList = "DiscoveredResourceList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let discoveredResourceListContainer = try containerValues.decodeIfPresent([MigrationHubClientTypes.DiscoveredResource?].self, forKey: .discoveredResourceList)
        var discoveredResourceListDecoded0:[MigrationHubClientTypes.DiscoveredResource]? = nil
        if let discoveredResourceListContainer = discoveredResourceListContainer {
            discoveredResourceListDecoded0 = [MigrationHubClientTypes.DiscoveredResource]()
            for structure0 in discoveredResourceListContainer {
                if let structure0 = structure0 {
                    discoveredResourceListDecoded0?.append(structure0)
                }
            }
        }
        discoveredResourceList = discoveredResourceListDecoded0
    }
}

extension ListMigrationTasksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceName = "ResourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

extension ListMigrationTasksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListMigrationTasksInput: Swift.Equatable {
    /// Value to specify how many results are returned per page.
    public var maxResults: Swift.Int?
    /// If a NextToken was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in NextToken.
    public var nextToken: Swift.String?
    /// Filter migration tasks by discovered resource name.
    public var resourceName: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceName = resourceName
    }
}

struct ListMigrationTasksInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let resourceName: Swift.String?
}

extension ListMigrationTasksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceName = "ResourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension ListMigrationTasksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMigrationTasksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyErrorException" : self = .policyErrorException(try PolicyErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListMigrationTasksOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case policyErrorException(PolicyErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMigrationTasksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListMigrationTasksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.migrationTaskSummaryList = output.migrationTaskSummaryList
            self.nextToken = output.nextToken
        } else {
            self.migrationTaskSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListMigrationTasksOutputResponse: Swift.Equatable {
    /// Lists the migration task's summary which includes: MigrationTaskName, ProgressPercent, ProgressUpdateStream, Status, and the UpdateDateTime for each task.
    public var migrationTaskSummaryList: [MigrationHubClientTypes.MigrationTaskSummary]?
    /// If there are more migration tasks than the max result, return the next token to be passed to the next call as a bookmark of where to start from.
    public var nextToken: Swift.String?

    public init (
        migrationTaskSummaryList: [MigrationHubClientTypes.MigrationTaskSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.migrationTaskSummaryList = migrationTaskSummaryList
        self.nextToken = nextToken
    }
}

struct ListMigrationTasksOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let migrationTaskSummaryList: [MigrationHubClientTypes.MigrationTaskSummary]?
}

extension ListMigrationTasksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationTaskSummaryList = "MigrationTaskSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let migrationTaskSummaryListContainer = try containerValues.decodeIfPresent([MigrationHubClientTypes.MigrationTaskSummary?].self, forKey: .migrationTaskSummaryList)
        var migrationTaskSummaryListDecoded0:[MigrationHubClientTypes.MigrationTaskSummary]? = nil
        if let migrationTaskSummaryListContainer = migrationTaskSummaryListContainer {
            migrationTaskSummaryListDecoded0 = [MigrationHubClientTypes.MigrationTaskSummary]()
            for structure0 in migrationTaskSummaryListContainer {
                if let structure0 = structure0 {
                    migrationTaskSummaryListDecoded0?.append(structure0)
                }
            }
        }
        migrationTaskSummaryList = migrationTaskSummaryListDecoded0
    }
}

extension ListProgressUpdateStreamsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListProgressUpdateStreamsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListProgressUpdateStreamsInput: Swift.Equatable {
    /// Filter to limit the maximum number of results to list per page.
    public var maxResults: Swift.Int?
    /// If a NextToken was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in NextToken.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProgressUpdateStreamsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListProgressUpdateStreamsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListProgressUpdateStreamsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProgressUpdateStreamsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListProgressUpdateStreamsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProgressUpdateStreamsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListProgressUpdateStreamsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.progressUpdateStreamSummaryList = output.progressUpdateStreamSummaryList
        } else {
            self.nextToken = nil
            self.progressUpdateStreamSummaryList = nil
        }
    }
}

public struct ListProgressUpdateStreamsOutputResponse: Swift.Equatable {
    /// If there are more streams created than the max result, return the next token to be passed to the next call as a bookmark of where to start from.
    public var nextToken: Swift.String?
    /// List of progress update streams up to the max number of results passed in the input.
    public var progressUpdateStreamSummaryList: [MigrationHubClientTypes.ProgressUpdateStreamSummary]?

    public init (
        nextToken: Swift.String? = nil,
        progressUpdateStreamSummaryList: [MigrationHubClientTypes.ProgressUpdateStreamSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.progressUpdateStreamSummaryList = progressUpdateStreamSummaryList
    }
}

struct ListProgressUpdateStreamsOutputResponseBody: Swift.Equatable {
    let progressUpdateStreamSummaryList: [MigrationHubClientTypes.ProgressUpdateStreamSummary]?
    let nextToken: Swift.String?
}

extension ListProgressUpdateStreamsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case progressUpdateStreamSummaryList = "ProgressUpdateStreamSummaryList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamSummaryListContainer = try containerValues.decodeIfPresent([MigrationHubClientTypes.ProgressUpdateStreamSummary?].self, forKey: .progressUpdateStreamSummaryList)
        var progressUpdateStreamSummaryListDecoded0:[MigrationHubClientTypes.ProgressUpdateStreamSummary]? = nil
        if let progressUpdateStreamSummaryListContainer = progressUpdateStreamSummaryListContainer {
            progressUpdateStreamSummaryListDecoded0 = [MigrationHubClientTypes.ProgressUpdateStreamSummary]()
            for structure0 in progressUpdateStreamSummaryListContainer {
                if let structure0 = structure0 {
                    progressUpdateStreamSummaryListDecoded0?.append(structure0)
                }
            }
        }
        progressUpdateStreamSummaryList = progressUpdateStreamSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MigrationHubClientTypes.MigrationTask: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
        case resourceAttributeList = "ResourceAttributeList"
        case task = "Task"
        case updateDateTime = "UpdateDateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let migrationTaskName = self.migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let progressUpdateStream = self.progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
        if let resourceAttributeList = resourceAttributeList {
            var resourceAttributeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAttributeList)
            for resourceattribute0 in resourceAttributeList {
                try resourceAttributeListContainer.encode(resourceattribute0)
            }
        }
        if let task = self.task {
            try encodeContainer.encode(task, forKey: .task)
        }
        if let updateDateTime = self.updateDateTime {
            try encodeContainer.encodeTimestamp(updateDateTime, format: .epochSeconds, forKey: .updateDateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let taskDecoded = try containerValues.decodeIfPresent(MigrationHubClientTypes.Task.self, forKey: .task)
        task = taskDecoded
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
        let resourceAttributeListContainer = try containerValues.decodeIfPresent([MigrationHubClientTypes.ResourceAttribute?].self, forKey: .resourceAttributeList)
        var resourceAttributeListDecoded0:[MigrationHubClientTypes.ResourceAttribute]? = nil
        if let resourceAttributeListContainer = resourceAttributeListContainer {
            resourceAttributeListDecoded0 = [MigrationHubClientTypes.ResourceAttribute]()
            for structure0 in resourceAttributeListContainer {
                if let structure0 = structure0 {
                    resourceAttributeListDecoded0?.append(structure0)
                }
            }
        }
        resourceAttributeList = resourceAttributeListDecoded0
    }
}

extension MigrationHubClientTypes {
    /// Represents a migration task in a migration tool.
    public struct MigrationTask: Swift.Equatable {
        /// Unique identifier that references the migration task. Do not store personal data in this field.
        public var migrationTaskName: Swift.String?
        /// A name that identifies the vendor of the migration tool being used.
        public var progressUpdateStream: Swift.String?
        /// Information about the resource that is being migrated. This data will be used to map the task to a resource in the Application Discovery Service repository.
        public var resourceAttributeList: [MigrationHubClientTypes.ResourceAttribute]?
        /// Task object encapsulating task information.
        public var task: MigrationHubClientTypes.Task?
        /// The timestamp when the task was gathered.
        public var updateDateTime: ClientRuntime.Date?

        public init (
            migrationTaskName: Swift.String? = nil,
            progressUpdateStream: Swift.String? = nil,
            resourceAttributeList: [MigrationHubClientTypes.ResourceAttribute]? = nil,
            task: MigrationHubClientTypes.Task? = nil,
            updateDateTime: ClientRuntime.Date? = nil
        )
        {
            self.migrationTaskName = migrationTaskName
            self.progressUpdateStream = progressUpdateStream
            self.resourceAttributeList = resourceAttributeList
            self.task = task
            self.updateDateTime = updateDateTime
        }
    }

}

extension MigrationHubClientTypes.MigrationTaskSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationTaskName = "MigrationTaskName"
        case progressPercent = "ProgressPercent"
        case progressUpdateStream = "ProgressUpdateStream"
        case status = "Status"
        case statusDetail = "StatusDetail"
        case updateDateTime = "UpdateDateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let migrationTaskName = self.migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let progressPercent = self.progressPercent {
            try encodeContainer.encode(progressPercent, forKey: .progressPercent)
        }
        if let progressUpdateStream = self.progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDetail = self.statusDetail {
            try encodeContainer.encode(statusDetail, forKey: .statusDetail)
        }
        if let updateDateTime = self.updateDateTime {
            try encodeContainer.encodeTimestamp(updateDateTime, format: .epochSeconds, forKey: .updateDateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let progressPercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .progressPercent)
        progressPercent = progressPercentDecoded
        let statusDetailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDetail)
        statusDetail = statusDetailDecoded
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
    }
}

extension MigrationHubClientTypes {
    /// MigrationTaskSummary includes MigrationTaskName, ProgressPercent, ProgressUpdateStream, Status, and UpdateDateTime for each task.
    public struct MigrationTaskSummary: Swift.Equatable {
        /// Unique identifier that references the migration task. Do not store personal data in this field.
        public var migrationTaskName: Swift.String?
        /// Indication of the percentage completion of the task.
        public var progressPercent: Swift.Int?
        /// An AWS resource used for access control. It should uniquely identify the migration tool as it is used for all updates made by the tool.
        public var progressUpdateStream: Swift.String?
        /// Status of the task.
        public var status: MigrationHubClientTypes.Status?
        /// Detail information of what is being done within the overall status state.
        public var statusDetail: Swift.String?
        /// The timestamp when the task was gathered.
        public var updateDateTime: ClientRuntime.Date?

        public init (
            migrationTaskName: Swift.String? = nil,
            progressPercent: Swift.Int? = nil,
            progressUpdateStream: Swift.String? = nil,
            status: MigrationHubClientTypes.Status? = nil,
            statusDetail: Swift.String? = nil,
            updateDateTime: ClientRuntime.Date? = nil
        )
        {
            self.migrationTaskName = migrationTaskName
            self.progressPercent = progressPercent
            self.progressUpdateStream = progressUpdateStream
            self.status = status
            self.statusDetail = statusDetail
            self.updateDateTime = updateDateTime
        }
    }

}

extension NotifyApplicationStateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case dryRun = "DryRun"
        case status = "Status"
        case updateDateTime = "UpdateDateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updateDateTime = self.updateDateTime {
            try encodeContainer.encodeTimestamp(updateDateTime, format: .epochSeconds, forKey: .updateDateTime)
        }
    }
}

extension NotifyApplicationStateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct NotifyApplicationStateInput: Swift.Equatable {
    /// The configurationId in Application Discovery Service that uniquely identifies the grouped application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// Optional boolean flag to indicate whether any effect should take place. Used to test if the caller has permission to make the call.
    public var dryRun: Swift.Bool
    /// Status of the application - Not Started, In-Progress, Complete.
    /// This member is required.
    public var status: MigrationHubClientTypes.ApplicationStatus?
    /// The timestamp when the application state changed.
    public var updateDateTime: ClientRuntime.Date?

    public init (
        applicationId: Swift.String? = nil,
        dryRun: Swift.Bool = false,
        status: MigrationHubClientTypes.ApplicationStatus? = nil,
        updateDateTime: ClientRuntime.Date? = nil
    )
    {
        self.applicationId = applicationId
        self.dryRun = dryRun
        self.status = status
        self.updateDateTime = updateDateTime
    }
}

struct NotifyApplicationStateInputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let status: MigrationHubClientTypes.ApplicationStatus?
    let updateDateTime: ClientRuntime.Date?
    let dryRun: Swift.Bool
}

extension NotifyApplicationStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case dryRun = "DryRun"
        case status = "Status"
        case updateDateTime = "UpdateDateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubClientTypes.ApplicationStatus.self, forKey: .status)
        status = statusDecoded
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun) ?? false
        dryRun = dryRunDecoded
    }
}

extension NotifyApplicationStateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension NotifyApplicationStateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DryRunOperation" : self = .dryRunOperation(try DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyErrorException" : self = .policyErrorException(try PolicyErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum NotifyApplicationStateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dryRunOperation(DryRunOperation)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case policyErrorException(PolicyErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension NotifyApplicationStateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct NotifyApplicationStateOutputResponse: Swift.Equatable {

    public init () { }
}

extension NotifyMigrationTaskStateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case nextUpdateSeconds = "NextUpdateSeconds"
        case progressUpdateStream = "ProgressUpdateStream"
        case task = "Task"
        case updateDateTime = "UpdateDateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let migrationTaskName = self.migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if nextUpdateSeconds != 0 {
            try encodeContainer.encode(nextUpdateSeconds, forKey: .nextUpdateSeconds)
        }
        if let progressUpdateStream = self.progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
        if let task = self.task {
            try encodeContainer.encode(task, forKey: .task)
        }
        if let updateDateTime = self.updateDateTime {
            try encodeContainer.encodeTimestamp(updateDateTime, format: .epochSeconds, forKey: .updateDateTime)
        }
    }
}

extension NotifyMigrationTaskStateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct NotifyMigrationTaskStateInput: Swift.Equatable {
    /// Optional boolean flag to indicate whether any effect should take place. Used to test if the caller has permission to make the call.
    public var dryRun: Swift.Bool
    /// Unique identifier that references the migration task. Do not store personal data in this field.
    /// This member is required.
    public var migrationTaskName: Swift.String?
    /// Number of seconds after the UpdateDateTime within which the Migration Hub can expect an update. If Migration Hub does not receive an update within the specified interval, then the migration task will be considered stale.
    /// This member is required.
    public var nextUpdateSeconds: Swift.Int
    /// The name of the ProgressUpdateStream.
    /// This member is required.
    public var progressUpdateStream: Swift.String?
    /// Information about the task's progress and status.
    /// This member is required.
    public var task: MigrationHubClientTypes.Task?
    /// The timestamp when the task was gathered.
    /// This member is required.
    public var updateDateTime: ClientRuntime.Date?

    public init (
        dryRun: Swift.Bool = false,
        migrationTaskName: Swift.String? = nil,
        nextUpdateSeconds: Swift.Int = 0,
        progressUpdateStream: Swift.String? = nil,
        task: MigrationHubClientTypes.Task? = nil,
        updateDateTime: ClientRuntime.Date? = nil
    )
    {
        self.dryRun = dryRun
        self.migrationTaskName = migrationTaskName
        self.nextUpdateSeconds = nextUpdateSeconds
        self.progressUpdateStream = progressUpdateStream
        self.task = task
        self.updateDateTime = updateDateTime
    }
}

struct NotifyMigrationTaskStateInputBody: Swift.Equatable {
    let progressUpdateStream: Swift.String?
    let migrationTaskName: Swift.String?
    let task: MigrationHubClientTypes.Task?
    let updateDateTime: ClientRuntime.Date?
    let nextUpdateSeconds: Swift.Int
    let dryRun: Swift.Bool
}

extension NotifyMigrationTaskStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case nextUpdateSeconds = "NextUpdateSeconds"
        case progressUpdateStream = "ProgressUpdateStream"
        case task = "Task"
        case updateDateTime = "UpdateDateTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let taskDecoded = try containerValues.decodeIfPresent(MigrationHubClientTypes.Task.self, forKey: .task)
        task = taskDecoded
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
        let nextUpdateSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .nextUpdateSeconds) ?? 0
        nextUpdateSeconds = nextUpdateSecondsDecoded
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun) ?? false
        dryRun = dryRunDecoded
    }
}

extension NotifyMigrationTaskStateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension NotifyMigrationTaskStateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DryRunOperation" : self = .dryRunOperation(try DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum NotifyMigrationTaskStateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dryRunOperation(DryRunOperation)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension NotifyMigrationTaskStateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct NotifyMigrationTaskStateOutputResponse: Swift.Equatable {

    public init () { }
}

extension PolicyErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PolicyErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception raised when there are problems accessing Application Discovery Service (Application Discovery Service); most likely due to a misconfigured policy or the migrationhub-discovery role is missing or not configured correctly.
public struct PolicyErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PolicyErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PolicyErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MigrationHubClientTypes.ProgressUpdateStreamSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case progressUpdateStreamName = "ProgressUpdateStreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let progressUpdateStreamName = self.progressUpdateStreamName {
            try encodeContainer.encode(progressUpdateStreamName, forKey: .progressUpdateStreamName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStreamName)
        progressUpdateStreamName = progressUpdateStreamNameDecoded
    }
}

extension MigrationHubClientTypes {
    /// Summary of the AWS resource used for access control that is implicitly linked to your AWS account.
    public struct ProgressUpdateStreamSummary: Swift.Equatable {
        /// The name of the ProgressUpdateStream. Do not store personal data in this field.
        public var progressUpdateStreamName: Swift.String?

        public init (
            progressUpdateStreamName: Swift.String? = nil
        )
        {
            self.progressUpdateStreamName = progressUpdateStreamName
        }
    }

}

extension PutResourceAttributesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
        case resourceAttributeList = "ResourceAttributeList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let migrationTaskName = self.migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let progressUpdateStream = self.progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
        if let resourceAttributeList = resourceAttributeList {
            var resourceAttributeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAttributeList)
            for resourceattribute0 in resourceAttributeList {
                try resourceAttributeListContainer.encode(resourceattribute0)
            }
        }
    }
}

extension PutResourceAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutResourceAttributesInput: Swift.Equatable {
    /// Optional boolean flag to indicate whether any effect should take place. Used to test if the caller has permission to make the call.
    public var dryRun: Swift.Bool
    /// Unique identifier that references the migration task. Do not store personal data in this field.
    /// This member is required.
    public var migrationTaskName: Swift.String?
    /// The name of the ProgressUpdateStream.
    /// This member is required.
    public var progressUpdateStream: Swift.String?
    /// Information about the resource that is being migrated. This data will be used to map the task to a resource in the Application Discovery Service repository. Takes the object array of ResourceAttribute where the Type field is reserved for the following values: IPV4_ADDRESS | IPV6_ADDRESS | MAC_ADDRESS | FQDN | VM_MANAGER_ID | VM_MANAGED_OBJECT_REFERENCE | VM_NAME | VM_PATH | BIOS_ID | MOTHERBOARD_SERIAL_NUMBER where the identifying value can be a string up to 256 characters.
    ///
    /// * If any "VM" related value is set for a ResourceAttribute object, it is required that VM_MANAGER_ID, as a minimum, is always set. If VM_MANAGER_ID is not set, then all "VM" fields will be discarded and "VM" fields will not be used for matching the migration task to a server in Application Discovery Service repository. See the [Example](https://docs.aws.amazon.com/migrationhub/latest/ug/API_PutResourceAttributes.html#API_PutResourceAttributes_Examples) section below for a use case of specifying "VM" related values.
    ///
    /// * If a server you are trying to match has multiple IP or MAC addresses, you should provide as many as you know in separate type/value pairs passed to the ResourceAttributeList parameter to maximize the chances of matching.
    /// This member is required.
    public var resourceAttributeList: [MigrationHubClientTypes.ResourceAttribute]?

    public init (
        dryRun: Swift.Bool = false,
        migrationTaskName: Swift.String? = nil,
        progressUpdateStream: Swift.String? = nil,
        resourceAttributeList: [MigrationHubClientTypes.ResourceAttribute]? = nil
    )
    {
        self.dryRun = dryRun
        self.migrationTaskName = migrationTaskName
        self.progressUpdateStream = progressUpdateStream
        self.resourceAttributeList = resourceAttributeList
    }
}

struct PutResourceAttributesInputBody: Swift.Equatable {
    let progressUpdateStream: Swift.String?
    let migrationTaskName: Swift.String?
    let resourceAttributeList: [MigrationHubClientTypes.ResourceAttribute]?
    let dryRun: Swift.Bool
}

extension PutResourceAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
        case resourceAttributeList = "ResourceAttributeList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let resourceAttributeListContainer = try containerValues.decodeIfPresent([MigrationHubClientTypes.ResourceAttribute?].self, forKey: .resourceAttributeList)
        var resourceAttributeListDecoded0:[MigrationHubClientTypes.ResourceAttribute]? = nil
        if let resourceAttributeListContainer = resourceAttributeListContainer {
            resourceAttributeListDecoded0 = [MigrationHubClientTypes.ResourceAttribute]()
            for structure0 in resourceAttributeListContainer {
                if let structure0 = structure0 {
                    resourceAttributeListDecoded0?.append(structure0)
                }
            }
        }
        resourceAttributeList = resourceAttributeListDecoded0
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun) ?? false
        dryRun = dryRunDecoded
    }
}

extension PutResourceAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutResourceAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DryRunOperation" : self = .dryRunOperation(try DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "HomeRegionNotSetException" : self = .homeRegionNotSetException(try HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperation" : self = .unauthorizedOperation(try UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutResourceAttributesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case dryRunOperation(DryRunOperation)
    case homeRegionNotSetException(HomeRegionNotSetException)
    case internalServerError(InternalServerError)
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unauthorizedOperation(UnauthorizedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutResourceAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutResourceAttributesOutputResponse: Swift.Equatable {

    public init () { }
}

extension MigrationHubClientTypes.ResourceAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(MigrationHubClientTypes.ResourceAttributeType.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension MigrationHubClientTypes {
    /// Attribute associated with a resource. Note the corresponding format required per type listed below: IPV4 x.x.x.x where x is an integer in the range [0,255] IPV6 y : y : y : y : y : y : y : y where y is a hexadecimal between 0 and FFFF. [0, FFFF] MAC_ADDRESS ^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$ FQDN ^[^<>{}\\/?,=\p{Cntrl}]{1,256}$
    public struct ResourceAttribute: Swift.Equatable {
        /// Type of resource.
        /// This member is required.
        public var type: MigrationHubClientTypes.ResourceAttributeType?
        /// Value of the resource type.
        /// This member is required.
        public var value: Swift.String?

        public init (
            type: MigrationHubClientTypes.ResourceAttributeType? = nil,
            value: Swift.String? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }

}

extension MigrationHubClientTypes {
    public enum ResourceAttributeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case biosId
        case fqdn
        case ipv4Address
        case ipv6Address
        case macAddress
        case motherboardSerialNumber
        case vmManagedObjectReference
        case vmManagerId
        case vmName
        case vmPath
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceAttributeType] {
            return [
                .biosId,
                .fqdn,
                .ipv4Address,
                .ipv6Address,
                .macAddress,
                .motherboardSerialNumber,
                .vmManagedObjectReference,
                .vmManagerId,
                .vmName,
                .vmPath,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .biosId: return "BIOS_ID"
            case .fqdn: return "FQDN"
            case .ipv4Address: return "IPV4_ADDRESS"
            case .ipv6Address: return "IPV6_ADDRESS"
            case .macAddress: return "MAC_ADDRESS"
            case .motherboardSerialNumber: return "MOTHERBOARD_SERIAL_NUMBER"
            case .vmManagedObjectReference: return "VM_MANAGED_OBJECT_REFERENCE"
            case .vmManagerId: return "VM_MANAGER_ID"
            case .vmName: return "VM_NAME"
            case .vmPath: return "VM_PATH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceAttributeType(rawValue: rawValue) ?? ResourceAttributeType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception raised when the request references a resource (Application Discovery Service configuration, update stream, migration task, etc.) that does not exist in Application Discovery Service (Application Discovery Service) or in Migration Hub's repository.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception raised when there is an internal, configuration, or dependency error encountered.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MigrationHubClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case notStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .completed,
                .failed,
                .inProgress,
                .notStarted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubClientTypes.Task: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case progressPercent = "ProgressPercent"
        case status = "Status"
        case statusDetail = "StatusDetail"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let progressPercent = self.progressPercent {
            try encodeContainer.encode(progressPercent, forKey: .progressPercent)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDetail = self.statusDetail {
            try encodeContainer.encode(statusDetail, forKey: .statusDetail)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let statusDetailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDetail)
        statusDetail = statusDetailDecoded
        let progressPercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .progressPercent)
        progressPercent = progressPercentDecoded
    }
}

extension MigrationHubClientTypes {
    /// Task object encapsulating task information.
    public struct Task: Swift.Equatable {
        /// Indication of the percentage completion of the task.
        public var progressPercent: Swift.Int?
        /// Status of the task - Not Started, In-Progress, Complete.
        /// This member is required.
        public var status: MigrationHubClientTypes.Status?
        /// Details of task status as notified by a migration tool. A tool might use this field to provide clarifying information about the status that is unique to that tool or that explains an error state.
        public var statusDetail: Swift.String?

        public init (
            progressPercent: Swift.Int? = nil,
            status: MigrationHubClientTypes.Status? = nil,
            statusDetail: Swift.String? = nil
        )
        {
            self.progressPercent = progressPercent
            self.status = status
            self.statusDetail = statusDetail
        }
    }

}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A message that provides information about the exception.
    /// This member is required.
    public var message: Swift.String?
    /// The number of seconds the caller should wait before retrying.
    public var retryAfterSeconds: Swift.Int

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnauthorizedOperation {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UnauthorizedOperationBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception raised to indicate a request was not authorized when the DryRun flag is set to "true".
public struct UnauthorizedOperation: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnauthorizedOperationBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnauthorizedOperationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
