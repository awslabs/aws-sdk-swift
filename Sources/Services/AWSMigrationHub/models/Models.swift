// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MigrationHubClientTypes.ApplicationState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case applicationStatus = "ApplicationStatus"
        case lastUpdatedTime = "LastUpdatedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let applicationStatus = self.applicationStatus {
            try encodeContainer.encode(applicationStatus.rawValue, forKey: .applicationStatus)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let applicationStatusDecoded = try containerValues.decodeIfPresent(MigrationHubClientTypes.ApplicationStatus.self, forKey: .applicationStatus)
        applicationStatus = applicationStatusDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension MigrationHubClientTypes {
    /// The state of an application discovered through Migration Hub import, the AWS Agentless Discovery Connector, or the AWS Application Discovery Agent.
    public struct ApplicationState: Swift.Equatable {
        /// The configurationId from the Application Discovery Service that uniquely identifies an application.
        public var applicationId: Swift.String?
        /// The current status of an application.
        public var applicationStatus: MigrationHubClientTypes.ApplicationStatus?
        /// The timestamp when the application status was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?

        public init(
            applicationId: Swift.String? = nil,
            applicationStatus: MigrationHubClientTypes.ApplicationStatus? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil
        )
        {
            self.applicationId = applicationId
            self.applicationStatus = applicationStatus
            self.lastUpdatedTime = lastUpdatedTime
        }
    }

}

extension MigrationHubClientTypes {
    public enum ApplicationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case inProgress
        case notStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationStatus] {
            return [
                .completed,
                .inProgress,
                .notStarted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationStatus(rawValue: rawValue) ?? ApplicationStatus.sdkUnknown(rawValue)
        }
    }
}

extension AssociateCreatedArtifactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdArtifact = "CreatedArtifact"
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdArtifact = self.createdArtifact {
            try encodeContainer.encode(createdArtifact, forKey: .createdArtifact)
        }
        if let dryRun = self.dryRun {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let migrationTaskName = self.migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let progressUpdateStream = self.progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
    }
}

extension AssociateCreatedArtifactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateCreatedArtifactInput: Swift.Equatable {
    /// An ARN of the AWS resource related to the migration (e.g., AMI, EC2 instance, RDS instance, etc.)
    /// This member is required.
    public var createdArtifact: MigrationHubClientTypes.CreatedArtifact?
    /// Optional boolean flag to indicate whether any effect should take place. Used to test if the caller has permission to make the call.
    public var dryRun: Swift.Bool?
    /// Unique identifier that references the migration task. Do not store personal data in this field.
    /// This member is required.
    public var migrationTaskName: Swift.String?
    /// The name of the ProgressUpdateStream.
    /// This member is required.
    public var progressUpdateStream: Swift.String?

    public init(
        createdArtifact: MigrationHubClientTypes.CreatedArtifact? = nil,
        dryRun: Swift.Bool? = nil,
        migrationTaskName: Swift.String? = nil,
        progressUpdateStream: Swift.String? = nil
    )
    {
        self.createdArtifact = createdArtifact
        self.dryRun = dryRun
        self.migrationTaskName = migrationTaskName
        self.progressUpdateStream = progressUpdateStream
    }
}

struct AssociateCreatedArtifactInputBody: Swift.Equatable {
    let progressUpdateStream: Swift.String?
    let migrationTaskName: Swift.String?
    let createdArtifact: MigrationHubClientTypes.CreatedArtifact?
    let dryRun: Swift.Bool?
}

extension AssociateCreatedArtifactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdArtifact = "CreatedArtifact"
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let createdArtifactDecoded = try containerValues.decodeIfPresent(MigrationHubClientTypes.CreatedArtifact.self, forKey: .createdArtifact)
        createdArtifact = createdArtifactDecoded
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension AssociateCreatedArtifactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateCreatedArtifactOutput: Swift.Equatable {

    public init() { }
}

enum AssociateCreatedArtifactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DryRunOperation": return try await DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateDiscoveredResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case discoveredResource = "DiscoveredResource"
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let discoveredResource = self.discoveredResource {
            try encodeContainer.encode(discoveredResource, forKey: .discoveredResource)
        }
        if let dryRun = self.dryRun {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let migrationTaskName = self.migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let progressUpdateStream = self.progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
    }
}

extension AssociateDiscoveredResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateDiscoveredResourceInput: Swift.Equatable {
    /// Object representing a Resource.
    /// This member is required.
    public var discoveredResource: MigrationHubClientTypes.DiscoveredResource?
    /// Optional boolean flag to indicate whether any effect should take place. Used to test if the caller has permission to make the call.
    public var dryRun: Swift.Bool?
    /// The identifier given to the MigrationTask. Do not store personal data in this field.
    /// This member is required.
    public var migrationTaskName: Swift.String?
    /// The name of the ProgressUpdateStream.
    /// This member is required.
    public var progressUpdateStream: Swift.String?

    public init(
        discoveredResource: MigrationHubClientTypes.DiscoveredResource? = nil,
        dryRun: Swift.Bool? = nil,
        migrationTaskName: Swift.String? = nil,
        progressUpdateStream: Swift.String? = nil
    )
    {
        self.discoveredResource = discoveredResource
        self.dryRun = dryRun
        self.migrationTaskName = migrationTaskName
        self.progressUpdateStream = progressUpdateStream
    }
}

struct AssociateDiscoveredResourceInputBody: Swift.Equatable {
    let progressUpdateStream: Swift.String?
    let migrationTaskName: Swift.String?
    let discoveredResource: MigrationHubClientTypes.DiscoveredResource?
    let dryRun: Swift.Bool?
}

extension AssociateDiscoveredResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case discoveredResource = "DiscoveredResource"
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let discoveredResourceDecoded = try containerValues.decodeIfPresent(MigrationHubClientTypes.DiscoveredResource.self, forKey: .discoveredResource)
        discoveredResource = discoveredResourceDecoded
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension AssociateDiscoveredResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateDiscoveredResourceOutput: Swift.Equatable {

    public init() { }
}

enum AssociateDiscoveredResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DryRunOperation": return try await DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PolicyErrorException": return try await PolicyErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateProgressUpdateStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case progressUpdateStreamName = "ProgressUpdateStreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dryRun = self.dryRun {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let progressUpdateStreamName = self.progressUpdateStreamName {
            try encodeContainer.encode(progressUpdateStreamName, forKey: .progressUpdateStreamName)
        }
    }
}

extension CreateProgressUpdateStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateProgressUpdateStreamInput: Swift.Equatable {
    /// Optional boolean flag to indicate whether any effect should take place. Used to test if the caller has permission to make the call.
    public var dryRun: Swift.Bool?
    /// The name of the ProgressUpdateStream. Do not store personal data in this field.
    /// This member is required.
    public var progressUpdateStreamName: Swift.String?

    public init(
        dryRun: Swift.Bool? = nil,
        progressUpdateStreamName: Swift.String? = nil
    )
    {
        self.dryRun = dryRun
        self.progressUpdateStreamName = progressUpdateStreamName
    }
}

struct CreateProgressUpdateStreamInputBody: Swift.Equatable {
    let progressUpdateStreamName: Swift.String?
    let dryRun: Swift.Bool?
}

extension CreateProgressUpdateStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case progressUpdateStreamName = "ProgressUpdateStreamName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStreamName)
        progressUpdateStreamName = progressUpdateStreamNameDecoded
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension CreateProgressUpdateStreamOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateProgressUpdateStreamOutput: Swift.Equatable {

    public init() { }
}

enum CreateProgressUpdateStreamOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DryRunOperation": return try await DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MigrationHubClientTypes.CreatedArtifact: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension MigrationHubClientTypes {
    /// An ARN of the AWS cloud resource target receiving the migration (e.g., AMI, EC2 instance, RDS instance, etc.).
    public struct CreatedArtifact: Swift.Equatable {
        /// A description that can be free-form text to record additional detail about the artifact for clarity or for later reference.
        public var description: Swift.String?
        /// An ARN that uniquely identifies the result of a migration task.
        /// This member is required.
        public var name: Swift.String?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.description = description
            self.name = name
        }
    }

}

extension DeleteProgressUpdateStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case progressUpdateStreamName = "ProgressUpdateStreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dryRun = self.dryRun {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let progressUpdateStreamName = self.progressUpdateStreamName {
            try encodeContainer.encode(progressUpdateStreamName, forKey: .progressUpdateStreamName)
        }
    }
}

extension DeleteProgressUpdateStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteProgressUpdateStreamInput: Swift.Equatable {
    /// Optional boolean flag to indicate whether any effect should take place. Used to test if the caller has permission to make the call.
    public var dryRun: Swift.Bool?
    /// The name of the ProgressUpdateStream. Do not store personal data in this field.
    /// This member is required.
    public var progressUpdateStreamName: Swift.String?

    public init(
        dryRun: Swift.Bool? = nil,
        progressUpdateStreamName: Swift.String? = nil
    )
    {
        self.dryRun = dryRun
        self.progressUpdateStreamName = progressUpdateStreamName
    }
}

struct DeleteProgressUpdateStreamInputBody: Swift.Equatable {
    let progressUpdateStreamName: Swift.String?
    let dryRun: Swift.Bool?
}

extension DeleteProgressUpdateStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case progressUpdateStreamName = "ProgressUpdateStreamName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStreamName)
        progressUpdateStreamName = progressUpdateStreamNameDecoded
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension DeleteProgressUpdateStreamOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteProgressUpdateStreamOutput: Swift.Equatable {

    public init() { }
}

enum DeleteProgressUpdateStreamOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DryRunOperation": return try await DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeApplicationStateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
    }
}

extension DescribeApplicationStateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeApplicationStateInput: Swift.Equatable {
    /// The configurationId in Application Discovery Service that uniquely identifies the grouped application.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct DescribeApplicationStateInputBody: Swift.Equatable {
    let applicationId: Swift.String?
}

extension DescribeApplicationStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
    }
}

extension DescribeApplicationStateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeApplicationStateOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationStatus = output.applicationStatus
            self.lastUpdatedTime = output.lastUpdatedTime
        } else {
            self.applicationStatus = nil
            self.lastUpdatedTime = nil
        }
    }
}

public struct DescribeApplicationStateOutput: Swift.Equatable {
    /// Status of the application - Not Started, In-Progress, Complete.
    public var applicationStatus: MigrationHubClientTypes.ApplicationStatus?
    /// The timestamp when the application status was last updated.
    public var lastUpdatedTime: ClientRuntime.Date?

    public init(
        applicationStatus: MigrationHubClientTypes.ApplicationStatus? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil
    )
    {
        self.applicationStatus = applicationStatus
        self.lastUpdatedTime = lastUpdatedTime
    }
}

struct DescribeApplicationStateOutputBody: Swift.Equatable {
    let applicationStatus: MigrationHubClientTypes.ApplicationStatus?
    let lastUpdatedTime: ClientRuntime.Date?
}

extension DescribeApplicationStateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationStatus = "ApplicationStatus"
        case lastUpdatedTime = "LastUpdatedTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationStatusDecoded = try containerValues.decodeIfPresent(MigrationHubClientTypes.ApplicationStatus.self, forKey: .applicationStatus)
        applicationStatus = applicationStatusDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

enum DescribeApplicationStateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PolicyErrorException": return try await PolicyErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeMigrationTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let migrationTaskName = self.migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let progressUpdateStream = self.progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
    }
}

extension DescribeMigrationTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeMigrationTaskInput: Swift.Equatable {
    /// The identifier given to the MigrationTask. Do not store personal data in this field.
    /// This member is required.
    public var migrationTaskName: Swift.String?
    /// The name of the ProgressUpdateStream.
    /// This member is required.
    public var progressUpdateStream: Swift.String?

    public init(
        migrationTaskName: Swift.String? = nil,
        progressUpdateStream: Swift.String? = nil
    )
    {
        self.migrationTaskName = migrationTaskName
        self.progressUpdateStream = progressUpdateStream
    }
}

struct DescribeMigrationTaskInputBody: Swift.Equatable {
    let progressUpdateStream: Swift.String?
    let migrationTaskName: Swift.String?
}

extension DescribeMigrationTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
    }
}

extension DescribeMigrationTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeMigrationTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.migrationTask = output.migrationTask
        } else {
            self.migrationTask = nil
        }
    }
}

public struct DescribeMigrationTaskOutput: Swift.Equatable {
    /// Object encapsulating information about the migration task.
    public var migrationTask: MigrationHubClientTypes.MigrationTask?

    public init(
        migrationTask: MigrationHubClientTypes.MigrationTask? = nil
    )
    {
        self.migrationTask = migrationTask
    }
}

struct DescribeMigrationTaskOutputBody: Swift.Equatable {
    let migrationTask: MigrationHubClientTypes.MigrationTask?
}

extension DescribeMigrationTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationTask = "MigrationTask"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let migrationTaskDecoded = try containerValues.decodeIfPresent(MigrationHubClientTypes.MigrationTask.self, forKey: .migrationTask)
        migrationTask = migrationTaskDecoded
    }
}

enum DescribeMigrationTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateCreatedArtifactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdArtifactName = "CreatedArtifactName"
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdArtifactName = self.createdArtifactName {
            try encodeContainer.encode(createdArtifactName, forKey: .createdArtifactName)
        }
        if let dryRun = self.dryRun {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let migrationTaskName = self.migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let progressUpdateStream = self.progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
    }
}

extension DisassociateCreatedArtifactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateCreatedArtifactInput: Swift.Equatable {
    /// An ARN of the AWS resource related to the migration (e.g., AMI, EC2 instance, RDS instance, etc.)
    /// This member is required.
    public var createdArtifactName: Swift.String?
    /// Optional boolean flag to indicate whether any effect should take place. Used to test if the caller has permission to make the call.
    public var dryRun: Swift.Bool?
    /// Unique identifier that references the migration task to be disassociated with the artifact. Do not store personal data in this field.
    /// This member is required.
    public var migrationTaskName: Swift.String?
    /// The name of the ProgressUpdateStream.
    /// This member is required.
    public var progressUpdateStream: Swift.String?

    public init(
        createdArtifactName: Swift.String? = nil,
        dryRun: Swift.Bool? = nil,
        migrationTaskName: Swift.String? = nil,
        progressUpdateStream: Swift.String? = nil
    )
    {
        self.createdArtifactName = createdArtifactName
        self.dryRun = dryRun
        self.migrationTaskName = migrationTaskName
        self.progressUpdateStream = progressUpdateStream
    }
}

struct DisassociateCreatedArtifactInputBody: Swift.Equatable {
    let progressUpdateStream: Swift.String?
    let migrationTaskName: Swift.String?
    let createdArtifactName: Swift.String?
    let dryRun: Swift.Bool?
}

extension DisassociateCreatedArtifactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdArtifactName = "CreatedArtifactName"
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let createdArtifactNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdArtifactName)
        createdArtifactName = createdArtifactNameDecoded
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension DisassociateCreatedArtifactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateCreatedArtifactOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateCreatedArtifactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DryRunOperation": return try await DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateDiscoveredResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationId = "ConfigurationId"
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationId = self.configurationId {
            try encodeContainer.encode(configurationId, forKey: .configurationId)
        }
        if let dryRun = self.dryRun {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let migrationTaskName = self.migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let progressUpdateStream = self.progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
    }
}

extension DisassociateDiscoveredResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateDiscoveredResourceInput: Swift.Equatable {
    /// ConfigurationId of the Application Discovery Service resource to be disassociated.
    /// This member is required.
    public var configurationId: Swift.String?
    /// Optional boolean flag to indicate whether any effect should take place. Used to test if the caller has permission to make the call.
    public var dryRun: Swift.Bool?
    /// The identifier given to the MigrationTask. Do not store personal data in this field.
    /// This member is required.
    public var migrationTaskName: Swift.String?
    /// The name of the ProgressUpdateStream.
    /// This member is required.
    public var progressUpdateStream: Swift.String?

    public init(
        configurationId: Swift.String? = nil,
        dryRun: Swift.Bool? = nil,
        migrationTaskName: Swift.String? = nil,
        progressUpdateStream: Swift.String? = nil
    )
    {
        self.configurationId = configurationId
        self.dryRun = dryRun
        self.migrationTaskName = migrationTaskName
        self.progressUpdateStream = progressUpdateStream
    }
}

struct DisassociateDiscoveredResourceInputBody: Swift.Equatable {
    let progressUpdateStream: Swift.String?
    let migrationTaskName: Swift.String?
    let configurationId: Swift.String?
    let dryRun: Swift.Bool?
}

extension DisassociateDiscoveredResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationId = "ConfigurationId"
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let configurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationId)
        configurationId = configurationIdDecoded
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension DisassociateDiscoveredResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateDiscoveredResourceOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateDiscoveredResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DryRunOperation": return try await DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MigrationHubClientTypes.DiscoveredResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationId = "ConfigurationId"
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationId = self.configurationId {
            try encodeContainer.encode(configurationId, forKey: .configurationId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationId)
        configurationId = configurationIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension MigrationHubClientTypes {
    /// Object representing the on-premises resource being migrated.
    public struct DiscoveredResource: Swift.Equatable {
        /// The configurationId in Application Discovery Service that uniquely identifies the on-premise resource.
        /// This member is required.
        public var configurationId: Swift.String?
        /// A description that can be free-form text to record additional detail about the discovered resource for clarity or later reference.
        public var description: Swift.String?

        public init(
            configurationId: Swift.String? = nil,
            description: Swift.String? = nil
        )
        {
            self.configurationId = configurationId
            self.description = description
        }
    }

}

extension DryRunOperation {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DryRunOperationBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception raised to indicate a successfully authorized action when the DryRun flag is set to "true".
public struct DryRunOperation: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DryRunOperation" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DryRunOperationBody: Swift.Equatable {
    let message: Swift.String?
}

extension DryRunOperationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HomeRegionNotSetException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: HomeRegionNotSetExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The home region is not set. Set the home region to continue.
public struct HomeRegionNotSetException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "HomeRegionNotSetException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct HomeRegionNotSetExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension HomeRegionNotSetExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ImportMigrationTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dryRun = self.dryRun {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let migrationTaskName = self.migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let progressUpdateStream = self.progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
    }
}

extension ImportMigrationTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ImportMigrationTaskInput: Swift.Equatable {
    /// Optional boolean flag to indicate whether any effect should take place. Used to test if the caller has permission to make the call.
    public var dryRun: Swift.Bool?
    /// Unique identifier that references the migration task. Do not store personal data in this field.
    /// This member is required.
    public var migrationTaskName: Swift.String?
    /// The name of the ProgressUpdateStream. >
    /// This member is required.
    public var progressUpdateStream: Swift.String?

    public init(
        dryRun: Swift.Bool? = nil,
        migrationTaskName: Swift.String? = nil,
        progressUpdateStream: Swift.String? = nil
    )
    {
        self.dryRun = dryRun
        self.migrationTaskName = migrationTaskName
        self.progressUpdateStream = progressUpdateStream
    }
}

struct ImportMigrationTaskInputBody: Swift.Equatable {
    let progressUpdateStream: Swift.String?
    let migrationTaskName: Swift.String?
    let dryRun: Swift.Bool?
}

extension ImportMigrationTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension ImportMigrationTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ImportMigrationTaskOutput: Swift.Equatable {

    public init() { }
}

enum ImportMigrationTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DryRunOperation": return try await DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerError {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerErrorBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception raised when an internal, configuration, or dependency error is encountered.
public struct InternalServerError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerError" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerErrorBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInputException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception raised when the provided input violates a policy constraint or is entered in the wrong format or data type.
public struct InvalidInputException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidInputException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidInputExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidInputExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListApplicationStatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationIds = "ApplicationIds"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationIds = applicationIds {
            var applicationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applicationIds)
            for applicationid0 in applicationIds {
                try applicationIdsContainer.encode(applicationid0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListApplicationStatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListApplicationStatesInput: Swift.Equatable {
    /// The configurationIds from the Application Discovery Service that uniquely identifies your applications.
    public var applicationIds: [Swift.String]?
    /// Maximum number of results to be returned per page.
    public var maxResults: Swift.Int?
    /// If a NextToken was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in NextToken.
    public var nextToken: Swift.String?

    public init(
        applicationIds: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationIds = applicationIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApplicationStatesInputBody: Swift.Equatable {
    let applicationIds: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListApplicationStatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationIds = "ApplicationIds"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .applicationIds)
        var applicationIdsDecoded0:[Swift.String]? = nil
        if let applicationIdsContainer = applicationIdsContainer {
            applicationIdsDecoded0 = [Swift.String]()
            for string0 in applicationIdsContainer {
                if let string0 = string0 {
                    applicationIdsDecoded0?.append(string0)
                }
            }
        }
        applicationIds = applicationIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListApplicationStatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListApplicationStatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationStateList = output.applicationStateList
            self.nextToken = output.nextToken
        } else {
            self.applicationStateList = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationStatesOutput: Swift.Equatable {
    /// A list of Applications that exist in Application Discovery Service.
    public var applicationStateList: [MigrationHubClientTypes.ApplicationState]?
    /// If a NextToken was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in NextToken.
    public var nextToken: Swift.String?

    public init(
        applicationStateList: [MigrationHubClientTypes.ApplicationState]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationStateList = applicationStateList
        self.nextToken = nextToken
    }
}

struct ListApplicationStatesOutputBody: Swift.Equatable {
    let applicationStateList: [MigrationHubClientTypes.ApplicationState]?
    let nextToken: Swift.String?
}

extension ListApplicationStatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationStateList = "ApplicationStateList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationStateListContainer = try containerValues.decodeIfPresent([MigrationHubClientTypes.ApplicationState?].self, forKey: .applicationStateList)
        var applicationStateListDecoded0:[MigrationHubClientTypes.ApplicationState]? = nil
        if let applicationStateListContainer = applicationStateListContainer {
            applicationStateListDecoded0 = [MigrationHubClientTypes.ApplicationState]()
            for structure0 in applicationStateListContainer {
                if let structure0 = structure0 {
                    applicationStateListDecoded0?.append(structure0)
                }
            }
        }
        applicationStateList = applicationStateListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListApplicationStatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCreatedArtifactsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case migrationTaskName = "MigrationTaskName"
        case nextToken = "NextToken"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let migrationTaskName = self.migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let progressUpdateStream = self.progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
    }
}

extension ListCreatedArtifactsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListCreatedArtifactsInput: Swift.Equatable {
    /// Maximum number of results to be returned per page.
    public var maxResults: Swift.Int?
    /// Unique identifier that references the migration task. Do not store personal data in this field.
    /// This member is required.
    public var migrationTaskName: Swift.String?
    /// If a NextToken was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in NextToken.
    public var nextToken: Swift.String?
    /// The name of the ProgressUpdateStream.
    /// This member is required.
    public var progressUpdateStream: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        migrationTaskName: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        progressUpdateStream: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.migrationTaskName = migrationTaskName
        self.nextToken = nextToken
        self.progressUpdateStream = progressUpdateStream
    }
}

struct ListCreatedArtifactsInputBody: Swift.Equatable {
    let progressUpdateStream: Swift.String?
    let migrationTaskName: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListCreatedArtifactsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case migrationTaskName = "MigrationTaskName"
        case nextToken = "NextToken"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListCreatedArtifactsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCreatedArtifactsOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdArtifactList = output.createdArtifactList
            self.nextToken = output.nextToken
        } else {
            self.createdArtifactList = nil
            self.nextToken = nil
        }
    }
}

public struct ListCreatedArtifactsOutput: Swift.Equatable {
    /// List of created artifacts up to the maximum number of results specified in the request.
    public var createdArtifactList: [MigrationHubClientTypes.CreatedArtifact]?
    /// If there are more created artifacts than the max result, return the next token to be passed to the next call as a bookmark of where to start from.
    public var nextToken: Swift.String?

    public init(
        createdArtifactList: [MigrationHubClientTypes.CreatedArtifact]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.createdArtifactList = createdArtifactList
        self.nextToken = nextToken
    }
}

struct ListCreatedArtifactsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let createdArtifactList: [MigrationHubClientTypes.CreatedArtifact]?
}

extension ListCreatedArtifactsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdArtifactList = "CreatedArtifactList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let createdArtifactListContainer = try containerValues.decodeIfPresent([MigrationHubClientTypes.CreatedArtifact?].self, forKey: .createdArtifactList)
        var createdArtifactListDecoded0:[MigrationHubClientTypes.CreatedArtifact]? = nil
        if let createdArtifactListContainer = createdArtifactListContainer {
            createdArtifactListDecoded0 = [MigrationHubClientTypes.CreatedArtifact]()
            for structure0 in createdArtifactListContainer {
                if let structure0 = structure0 {
                    createdArtifactListDecoded0?.append(structure0)
                }
            }
        }
        createdArtifactList = createdArtifactListDecoded0
    }
}

enum ListCreatedArtifactsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDiscoveredResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case migrationTaskName = "MigrationTaskName"
        case nextToken = "NextToken"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let migrationTaskName = self.migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let progressUpdateStream = self.progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
    }
}

extension ListDiscoveredResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDiscoveredResourcesInput: Swift.Equatable {
    /// The maximum number of results returned per page.
    public var maxResults: Swift.Int?
    /// The name of the MigrationTask. Do not store personal data in this field.
    /// This member is required.
    public var migrationTaskName: Swift.String?
    /// If a NextToken was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in NextToken.
    public var nextToken: Swift.String?
    /// The name of the ProgressUpdateStream.
    /// This member is required.
    public var progressUpdateStream: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        migrationTaskName: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        progressUpdateStream: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.migrationTaskName = migrationTaskName
        self.nextToken = nextToken
        self.progressUpdateStream = progressUpdateStream
    }
}

struct ListDiscoveredResourcesInputBody: Swift.Equatable {
    let progressUpdateStream: Swift.String?
    let migrationTaskName: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDiscoveredResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case migrationTaskName = "MigrationTaskName"
        case nextToken = "NextToken"
        case progressUpdateStream = "ProgressUpdateStream"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDiscoveredResourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDiscoveredResourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.discoveredResourceList = output.discoveredResourceList
            self.nextToken = output.nextToken
        } else {
            self.discoveredResourceList = nil
            self.nextToken = nil
        }
    }
}

public struct ListDiscoveredResourcesOutput: Swift.Equatable {
    /// Returned list of discovered resources associated with the given MigrationTask.
    public var discoveredResourceList: [MigrationHubClientTypes.DiscoveredResource]?
    /// If there are more discovered resources than the max result, return the next token to be passed to the next call as a bookmark of where to start from.
    public var nextToken: Swift.String?

    public init(
        discoveredResourceList: [MigrationHubClientTypes.DiscoveredResource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.discoveredResourceList = discoveredResourceList
        self.nextToken = nextToken
    }
}

struct ListDiscoveredResourcesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let discoveredResourceList: [MigrationHubClientTypes.DiscoveredResource]?
}

extension ListDiscoveredResourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case discoveredResourceList = "DiscoveredResourceList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let discoveredResourceListContainer = try containerValues.decodeIfPresent([MigrationHubClientTypes.DiscoveredResource?].self, forKey: .discoveredResourceList)
        var discoveredResourceListDecoded0:[MigrationHubClientTypes.DiscoveredResource]? = nil
        if let discoveredResourceListContainer = discoveredResourceListContainer {
            discoveredResourceListDecoded0 = [MigrationHubClientTypes.DiscoveredResource]()
            for structure0 in discoveredResourceListContainer {
                if let structure0 = structure0 {
                    discoveredResourceListDecoded0?.append(structure0)
                }
            }
        }
        discoveredResourceList = discoveredResourceListDecoded0
    }
}

enum ListDiscoveredResourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMigrationTasksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceName = "ResourceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceName = self.resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

extension ListMigrationTasksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListMigrationTasksInput: Swift.Equatable {
    /// Value to specify how many results are returned per page.
    public var maxResults: Swift.Int?
    /// If a NextToken was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in NextToken.
    public var nextToken: Swift.String?
    /// Filter migration tasks by discovered resource name.
    public var resourceName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceName = resourceName
    }
}

struct ListMigrationTasksInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let resourceName: Swift.String?
}

extension ListMigrationTasksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceName = "ResourceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension ListMigrationTasksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMigrationTasksOutputBody = try responseDecoder.decode(responseBody: data)
            self.migrationTaskSummaryList = output.migrationTaskSummaryList
            self.nextToken = output.nextToken
        } else {
            self.migrationTaskSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListMigrationTasksOutput: Swift.Equatable {
    /// Lists the migration task's summary which includes: MigrationTaskName, ProgressPercent, ProgressUpdateStream, Status, and the UpdateDateTime for each task.
    public var migrationTaskSummaryList: [MigrationHubClientTypes.MigrationTaskSummary]?
    /// If there are more migration tasks than the max result, return the next token to be passed to the next call as a bookmark of where to start from.
    public var nextToken: Swift.String?

    public init(
        migrationTaskSummaryList: [MigrationHubClientTypes.MigrationTaskSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.migrationTaskSummaryList = migrationTaskSummaryList
        self.nextToken = nextToken
    }
}

struct ListMigrationTasksOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let migrationTaskSummaryList: [MigrationHubClientTypes.MigrationTaskSummary]?
}

extension ListMigrationTasksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationTaskSummaryList = "MigrationTaskSummaryList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let migrationTaskSummaryListContainer = try containerValues.decodeIfPresent([MigrationHubClientTypes.MigrationTaskSummary?].self, forKey: .migrationTaskSummaryList)
        var migrationTaskSummaryListDecoded0:[MigrationHubClientTypes.MigrationTaskSummary]? = nil
        if let migrationTaskSummaryListContainer = migrationTaskSummaryListContainer {
            migrationTaskSummaryListDecoded0 = [MigrationHubClientTypes.MigrationTaskSummary]()
            for structure0 in migrationTaskSummaryListContainer {
                if let structure0 = structure0 {
                    migrationTaskSummaryListDecoded0?.append(structure0)
                }
            }
        }
        migrationTaskSummaryList = migrationTaskSummaryListDecoded0
    }
}

enum ListMigrationTasksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PolicyErrorException": return try await PolicyErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProgressUpdateStreamsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListProgressUpdateStreamsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListProgressUpdateStreamsInput: Swift.Equatable {
    /// Filter to limit the maximum number of results to list per page.
    public var maxResults: Swift.Int?
    /// If a NextToken was returned by a previous call, there are more results available. To retrieve the next page of results, make the call again using the returned token in NextToken.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProgressUpdateStreamsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListProgressUpdateStreamsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListProgressUpdateStreamsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProgressUpdateStreamsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.progressUpdateStreamSummaryList = output.progressUpdateStreamSummaryList
        } else {
            self.nextToken = nil
            self.progressUpdateStreamSummaryList = nil
        }
    }
}

public struct ListProgressUpdateStreamsOutput: Swift.Equatable {
    /// If there are more streams created than the max result, return the next token to be passed to the next call as a bookmark of where to start from.
    public var nextToken: Swift.String?
    /// List of progress update streams up to the max number of results passed in the input.
    public var progressUpdateStreamSummaryList: [MigrationHubClientTypes.ProgressUpdateStreamSummary]?

    public init(
        nextToken: Swift.String? = nil,
        progressUpdateStreamSummaryList: [MigrationHubClientTypes.ProgressUpdateStreamSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.progressUpdateStreamSummaryList = progressUpdateStreamSummaryList
    }
}

struct ListProgressUpdateStreamsOutputBody: Swift.Equatable {
    let progressUpdateStreamSummaryList: [MigrationHubClientTypes.ProgressUpdateStreamSummary]?
    let nextToken: Swift.String?
}

extension ListProgressUpdateStreamsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case progressUpdateStreamSummaryList = "ProgressUpdateStreamSummaryList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamSummaryListContainer = try containerValues.decodeIfPresent([MigrationHubClientTypes.ProgressUpdateStreamSummary?].self, forKey: .progressUpdateStreamSummaryList)
        var progressUpdateStreamSummaryListDecoded0:[MigrationHubClientTypes.ProgressUpdateStreamSummary]? = nil
        if let progressUpdateStreamSummaryListContainer = progressUpdateStreamSummaryListContainer {
            progressUpdateStreamSummaryListDecoded0 = [MigrationHubClientTypes.ProgressUpdateStreamSummary]()
            for structure0 in progressUpdateStreamSummaryListContainer {
                if let structure0 = structure0 {
                    progressUpdateStreamSummaryListDecoded0?.append(structure0)
                }
            }
        }
        progressUpdateStreamSummaryList = progressUpdateStreamSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListProgressUpdateStreamsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MigrationHubClientTypes.MigrationTask: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
        case resourceAttributeList = "ResourceAttributeList"
        case task = "Task"
        case updateDateTime = "UpdateDateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let migrationTaskName = self.migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let progressUpdateStream = self.progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
        if let resourceAttributeList = resourceAttributeList {
            var resourceAttributeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAttributeList)
            for resourceattribute0 in resourceAttributeList {
                try resourceAttributeListContainer.encode(resourceattribute0)
            }
        }
        if let task = self.task {
            try encodeContainer.encode(task, forKey: .task)
        }
        if let updateDateTime = self.updateDateTime {
            try encodeContainer.encodeTimestamp(updateDateTime, format: .epochSeconds, forKey: .updateDateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let taskDecoded = try containerValues.decodeIfPresent(MigrationHubClientTypes.Task.self, forKey: .task)
        task = taskDecoded
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
        let resourceAttributeListContainer = try containerValues.decodeIfPresent([MigrationHubClientTypes.ResourceAttribute?].self, forKey: .resourceAttributeList)
        var resourceAttributeListDecoded0:[MigrationHubClientTypes.ResourceAttribute]? = nil
        if let resourceAttributeListContainer = resourceAttributeListContainer {
            resourceAttributeListDecoded0 = [MigrationHubClientTypes.ResourceAttribute]()
            for structure0 in resourceAttributeListContainer {
                if let structure0 = structure0 {
                    resourceAttributeListDecoded0?.append(structure0)
                }
            }
        }
        resourceAttributeList = resourceAttributeListDecoded0
    }
}

extension MigrationHubClientTypes {
    /// Represents a migration task in a migration tool.
    public struct MigrationTask: Swift.Equatable {
        /// Unique identifier that references the migration task. Do not store personal data in this field.
        public var migrationTaskName: Swift.String?
        /// A name that identifies the vendor of the migration tool being used.
        public var progressUpdateStream: Swift.String?
        /// Information about the resource that is being migrated. This data will be used to map the task to a resource in the Application Discovery Service repository.
        public var resourceAttributeList: [MigrationHubClientTypes.ResourceAttribute]?
        /// Task object encapsulating task information.
        public var task: MigrationHubClientTypes.Task?
        /// The timestamp when the task was gathered.
        public var updateDateTime: ClientRuntime.Date?

        public init(
            migrationTaskName: Swift.String? = nil,
            progressUpdateStream: Swift.String? = nil,
            resourceAttributeList: [MigrationHubClientTypes.ResourceAttribute]? = nil,
            task: MigrationHubClientTypes.Task? = nil,
            updateDateTime: ClientRuntime.Date? = nil
        )
        {
            self.migrationTaskName = migrationTaskName
            self.progressUpdateStream = progressUpdateStream
            self.resourceAttributeList = resourceAttributeList
            self.task = task
            self.updateDateTime = updateDateTime
        }
    }

}

extension MigrationHubClientTypes.MigrationTaskSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case migrationTaskName = "MigrationTaskName"
        case progressPercent = "ProgressPercent"
        case progressUpdateStream = "ProgressUpdateStream"
        case status = "Status"
        case statusDetail = "StatusDetail"
        case updateDateTime = "UpdateDateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let migrationTaskName = self.migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let progressPercent = self.progressPercent {
            try encodeContainer.encode(progressPercent, forKey: .progressPercent)
        }
        if let progressUpdateStream = self.progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDetail = self.statusDetail {
            try encodeContainer.encode(statusDetail, forKey: .statusDetail)
        }
        if let updateDateTime = self.updateDateTime {
            try encodeContainer.encodeTimestamp(updateDateTime, format: .epochSeconds, forKey: .updateDateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let progressPercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .progressPercent)
        progressPercent = progressPercentDecoded
        let statusDetailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDetail)
        statusDetail = statusDetailDecoded
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
    }
}

extension MigrationHubClientTypes {
    /// MigrationTaskSummary includes MigrationTaskName, ProgressPercent, ProgressUpdateStream, Status, and UpdateDateTime for each task.
    public struct MigrationTaskSummary: Swift.Equatable {
        /// Unique identifier that references the migration task. Do not store personal data in this field.
        public var migrationTaskName: Swift.String?
        /// Indication of the percentage completion of the task.
        public var progressPercent: Swift.Int?
        /// An AWS resource used for access control. It should uniquely identify the migration tool as it is used for all updates made by the tool.
        public var progressUpdateStream: Swift.String?
        /// Status of the task.
        public var status: MigrationHubClientTypes.Status?
        /// Detail information of what is being done within the overall status state.
        public var statusDetail: Swift.String?
        /// The timestamp when the task was gathered.
        public var updateDateTime: ClientRuntime.Date?

        public init(
            migrationTaskName: Swift.String? = nil,
            progressPercent: Swift.Int? = nil,
            progressUpdateStream: Swift.String? = nil,
            status: MigrationHubClientTypes.Status? = nil,
            statusDetail: Swift.String? = nil,
            updateDateTime: ClientRuntime.Date? = nil
        )
        {
            self.migrationTaskName = migrationTaskName
            self.progressPercent = progressPercent
            self.progressUpdateStream = progressUpdateStream
            self.status = status
            self.statusDetail = statusDetail
            self.updateDateTime = updateDateTime
        }
    }

}

extension NotifyApplicationStateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case dryRun = "DryRun"
        case status = "Status"
        case updateDateTime = "UpdateDateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let dryRun = self.dryRun {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updateDateTime = self.updateDateTime {
            try encodeContainer.encodeTimestamp(updateDateTime, format: .epochSeconds, forKey: .updateDateTime)
        }
    }
}

extension NotifyApplicationStateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct NotifyApplicationStateInput: Swift.Equatable {
    /// The configurationId in Application Discovery Service that uniquely identifies the grouped application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// Optional boolean flag to indicate whether any effect should take place. Used to test if the caller has permission to make the call.
    public var dryRun: Swift.Bool?
    /// Status of the application - Not Started, In-Progress, Complete.
    /// This member is required.
    public var status: MigrationHubClientTypes.ApplicationStatus?
    /// The timestamp when the application state changed.
    public var updateDateTime: ClientRuntime.Date?

    public init(
        applicationId: Swift.String? = nil,
        dryRun: Swift.Bool? = nil,
        status: MigrationHubClientTypes.ApplicationStatus? = nil,
        updateDateTime: ClientRuntime.Date? = nil
    )
    {
        self.applicationId = applicationId
        self.dryRun = dryRun
        self.status = status
        self.updateDateTime = updateDateTime
    }
}

struct NotifyApplicationStateInputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let status: MigrationHubClientTypes.ApplicationStatus?
    let updateDateTime: ClientRuntime.Date?
    let dryRun: Swift.Bool?
}

extension NotifyApplicationStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case dryRun = "DryRun"
        case status = "Status"
        case updateDateTime = "UpdateDateTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubClientTypes.ApplicationStatus.self, forKey: .status)
        status = statusDecoded
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension NotifyApplicationStateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct NotifyApplicationStateOutput: Swift.Equatable {

    public init() { }
}

enum NotifyApplicationStateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DryRunOperation": return try await DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PolicyErrorException": return try await PolicyErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension NotifyMigrationTaskStateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case nextUpdateSeconds = "NextUpdateSeconds"
        case progressUpdateStream = "ProgressUpdateStream"
        case task = "Task"
        case updateDateTime = "UpdateDateTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dryRun = self.dryRun {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let migrationTaskName = self.migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let nextUpdateSeconds = self.nextUpdateSeconds {
            try encodeContainer.encode(nextUpdateSeconds, forKey: .nextUpdateSeconds)
        }
        if let progressUpdateStream = self.progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
        if let task = self.task {
            try encodeContainer.encode(task, forKey: .task)
        }
        if let updateDateTime = self.updateDateTime {
            try encodeContainer.encodeTimestamp(updateDateTime, format: .epochSeconds, forKey: .updateDateTime)
        }
    }
}

extension NotifyMigrationTaskStateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct NotifyMigrationTaskStateInput: Swift.Equatable {
    /// Optional boolean flag to indicate whether any effect should take place. Used to test if the caller has permission to make the call.
    public var dryRun: Swift.Bool?
    /// Unique identifier that references the migration task. Do not store personal data in this field.
    /// This member is required.
    public var migrationTaskName: Swift.String?
    /// Number of seconds after the UpdateDateTime within which the Migration Hub can expect an update. If Migration Hub does not receive an update within the specified interval, then the migration task will be considered stale.
    /// This member is required.
    public var nextUpdateSeconds: Swift.Int?
    /// The name of the ProgressUpdateStream.
    /// This member is required.
    public var progressUpdateStream: Swift.String?
    /// Information about the task's progress and status.
    /// This member is required.
    public var task: MigrationHubClientTypes.Task?
    /// The timestamp when the task was gathered.
    /// This member is required.
    public var updateDateTime: ClientRuntime.Date?

    public init(
        dryRun: Swift.Bool? = nil,
        migrationTaskName: Swift.String? = nil,
        nextUpdateSeconds: Swift.Int? = nil,
        progressUpdateStream: Swift.String? = nil,
        task: MigrationHubClientTypes.Task? = nil,
        updateDateTime: ClientRuntime.Date? = nil
    )
    {
        self.dryRun = dryRun
        self.migrationTaskName = migrationTaskName
        self.nextUpdateSeconds = nextUpdateSeconds
        self.progressUpdateStream = progressUpdateStream
        self.task = task
        self.updateDateTime = updateDateTime
    }
}

struct NotifyMigrationTaskStateInputBody: Swift.Equatable {
    let progressUpdateStream: Swift.String?
    let migrationTaskName: Swift.String?
    let task: MigrationHubClientTypes.Task?
    let updateDateTime: ClientRuntime.Date?
    let nextUpdateSeconds: Swift.Int?
    let dryRun: Swift.Bool?
}

extension NotifyMigrationTaskStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case nextUpdateSeconds = "NextUpdateSeconds"
        case progressUpdateStream = "ProgressUpdateStream"
        case task = "Task"
        case updateDateTime = "UpdateDateTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let taskDecoded = try containerValues.decodeIfPresent(MigrationHubClientTypes.Task.self, forKey: .task)
        task = taskDecoded
        let updateDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateDateTime)
        updateDateTime = updateDateTimeDecoded
        let nextUpdateSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .nextUpdateSeconds)
        nextUpdateSeconds = nextUpdateSecondsDecoded
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension NotifyMigrationTaskStateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct NotifyMigrationTaskStateOutput: Swift.Equatable {

    public init() { }
}

enum NotifyMigrationTaskStateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DryRunOperation": return try await DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PolicyErrorException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PolicyErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception raised when there are problems accessing Application Discovery Service (Application Discovery Service); most likely due to a misconfigured policy or the migrationhub-discovery role is missing or not configured correctly.
public struct PolicyErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PolicyErrorException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct PolicyErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PolicyErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MigrationHubClientTypes.ProgressUpdateStreamSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case progressUpdateStreamName = "ProgressUpdateStreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let progressUpdateStreamName = self.progressUpdateStreamName {
            try encodeContainer.encode(progressUpdateStreamName, forKey: .progressUpdateStreamName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStreamName)
        progressUpdateStreamName = progressUpdateStreamNameDecoded
    }
}

extension MigrationHubClientTypes {
    /// Summary of the AWS resource used for access control that is implicitly linked to your AWS account.
    public struct ProgressUpdateStreamSummary: Swift.Equatable {
        /// The name of the ProgressUpdateStream. Do not store personal data in this field.
        public var progressUpdateStreamName: Swift.String?

        public init(
            progressUpdateStreamName: Swift.String? = nil
        )
        {
            self.progressUpdateStreamName = progressUpdateStreamName
        }
    }

}

extension PutResourceAttributesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
        case resourceAttributeList = "ResourceAttributeList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dryRun = self.dryRun {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let migrationTaskName = self.migrationTaskName {
            try encodeContainer.encode(migrationTaskName, forKey: .migrationTaskName)
        }
        if let progressUpdateStream = self.progressUpdateStream {
            try encodeContainer.encode(progressUpdateStream, forKey: .progressUpdateStream)
        }
        if let resourceAttributeList = resourceAttributeList {
            var resourceAttributeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAttributeList)
            for resourceattribute0 in resourceAttributeList {
                try resourceAttributeListContainer.encode(resourceattribute0)
            }
        }
    }
}

extension PutResourceAttributesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutResourceAttributesInput: Swift.Equatable {
    /// Optional boolean flag to indicate whether any effect should take place. Used to test if the caller has permission to make the call.
    public var dryRun: Swift.Bool?
    /// Unique identifier that references the migration task. Do not store personal data in this field.
    /// This member is required.
    public var migrationTaskName: Swift.String?
    /// The name of the ProgressUpdateStream.
    /// This member is required.
    public var progressUpdateStream: Swift.String?
    /// Information about the resource that is being migrated. This data will be used to map the task to a resource in the Application Discovery Service repository. Takes the object array of ResourceAttribute where the Type field is reserved for the following values: IPV4_ADDRESS | IPV6_ADDRESS | MAC_ADDRESS | FQDN | VM_MANAGER_ID | VM_MANAGED_OBJECT_REFERENCE | VM_NAME | VM_PATH | BIOS_ID | MOTHERBOARD_SERIAL_NUMBER where the identifying value can be a string up to 256 characters.
    ///
    /// * If any "VM" related value is set for a ResourceAttribute object, it is required that VM_MANAGER_ID, as a minimum, is always set. If VM_MANAGER_ID is not set, then all "VM" fields will be discarded and "VM" fields will not be used for matching the migration task to a server in Application Discovery Service repository. See the [Example](https://docs.aws.amazon.com/migrationhub/latest/ug/API_PutResourceAttributes.html#API_PutResourceAttributes_Examples) section below for a use case of specifying "VM" related values.
    ///
    /// * If a server you are trying to match has multiple IP or MAC addresses, you should provide as many as you know in separate type/value pairs passed to the ResourceAttributeList parameter to maximize the chances of matching.
    /// This member is required.
    public var resourceAttributeList: [MigrationHubClientTypes.ResourceAttribute]?

    public init(
        dryRun: Swift.Bool? = nil,
        migrationTaskName: Swift.String? = nil,
        progressUpdateStream: Swift.String? = nil,
        resourceAttributeList: [MigrationHubClientTypes.ResourceAttribute]? = nil
    )
    {
        self.dryRun = dryRun
        self.migrationTaskName = migrationTaskName
        self.progressUpdateStream = progressUpdateStream
        self.resourceAttributeList = resourceAttributeList
    }
}

struct PutResourceAttributesInputBody: Swift.Equatable {
    let progressUpdateStream: Swift.String?
    let migrationTaskName: Swift.String?
    let resourceAttributeList: [MigrationHubClientTypes.ResourceAttribute]?
    let dryRun: Swift.Bool?
}

extension PutResourceAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun = "DryRun"
        case migrationTaskName = "MigrationTaskName"
        case progressUpdateStream = "ProgressUpdateStream"
        case resourceAttributeList = "ResourceAttributeList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let progressUpdateStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .progressUpdateStream)
        progressUpdateStream = progressUpdateStreamDecoded
        let migrationTaskNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .migrationTaskName)
        migrationTaskName = migrationTaskNameDecoded
        let resourceAttributeListContainer = try containerValues.decodeIfPresent([MigrationHubClientTypes.ResourceAttribute?].self, forKey: .resourceAttributeList)
        var resourceAttributeListDecoded0:[MigrationHubClientTypes.ResourceAttribute]? = nil
        if let resourceAttributeListContainer = resourceAttributeListContainer {
            resourceAttributeListDecoded0 = [MigrationHubClientTypes.ResourceAttribute]()
            for structure0 in resourceAttributeListContainer {
                if let structure0 = structure0 {
                    resourceAttributeListDecoded0?.append(structure0)
                }
            }
        }
        resourceAttributeList = resourceAttributeListDecoded0
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension PutResourceAttributesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutResourceAttributesOutput: Swift.Equatable {

    public init() { }
}

enum PutResourceAttributesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DryRunOperation": return try await DryRunOperation(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "HomeRegionNotSetException": return try await HomeRegionNotSetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperation(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MigrationHubClientTypes.ResourceAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(MigrationHubClientTypes.ResourceAttributeType.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension MigrationHubClientTypes {
    /// Attribute associated with a resource. Note the corresponding format required per type listed below: IPV4 x.x.x.x where x is an integer in the range [0,255] IPV6 y : y : y : y : y : y : y : y where y is a hexadecimal between 0 and FFFF. [0, FFFF] MAC_ADDRESS ^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$ FQDN ^[^<>{}\\/?,=\p{Cntrl}]{1,256}$
    public struct ResourceAttribute: Swift.Equatable {
        /// Type of resource.
        /// This member is required.
        public var type: MigrationHubClientTypes.ResourceAttributeType?
        /// Value of the resource type.
        /// This member is required.
        public var value: Swift.String?

        public init(
            type: MigrationHubClientTypes.ResourceAttributeType? = nil,
            value: Swift.String? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }

}

extension MigrationHubClientTypes {
    public enum ResourceAttributeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case biosId
        case fqdn
        case ipv4Address
        case ipv6Address
        case macAddress
        case motherboardSerialNumber
        case vmManagedObjectReference
        case vmManagerId
        case vmName
        case vmPath
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceAttributeType] {
            return [
                .biosId,
                .fqdn,
                .ipv4Address,
                .ipv6Address,
                .macAddress,
                .motherboardSerialNumber,
                .vmManagedObjectReference,
                .vmManagerId,
                .vmName,
                .vmPath,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .biosId: return "BIOS_ID"
            case .fqdn: return "FQDN"
            case .ipv4Address: return "IPV4_ADDRESS"
            case .ipv6Address: return "IPV6_ADDRESS"
            case .macAddress: return "MAC_ADDRESS"
            case .motherboardSerialNumber: return "MOTHERBOARD_SERIAL_NUMBER"
            case .vmManagedObjectReference: return "VM_MANAGED_OBJECT_REFERENCE"
            case .vmManagerId: return "VM_MANAGER_ID"
            case .vmName: return "VM_NAME"
            case .vmPath: return "VM_PATH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceAttributeType(rawValue: rawValue) ?? ResourceAttributeType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception raised when the request references a resource (Application Discovery Service configuration, update stream, migration task, etc.) that does not exist in Application Discovery Service (Application Discovery Service) or in Migration Hub's repository.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception raised when there is an internal, configuration, or dependency error encountered.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MigrationHubClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case notStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .completed,
                .failed,
                .inProgress,
                .notStarted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubClientTypes.Task: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case progressPercent = "ProgressPercent"
        case status = "Status"
        case statusDetail = "StatusDetail"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let progressPercent = self.progressPercent {
            try encodeContainer.encode(progressPercent, forKey: .progressPercent)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDetail = self.statusDetail {
            try encodeContainer.encode(statusDetail, forKey: .statusDetail)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let statusDetailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDetail)
        statusDetail = statusDetailDecoded
        let progressPercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .progressPercent)
        progressPercent = progressPercentDecoded
    }
}

extension MigrationHubClientTypes {
    /// Task object encapsulating task information.
    public struct Task: Swift.Equatable {
        /// Indication of the percentage completion of the task.
        public var progressPercent: Swift.Int?
        /// Status of the task - Not Started, In-Progress, Complete.
        /// This member is required.
        public var status: MigrationHubClientTypes.Status?
        /// Details of task status as notified by a migration tool. A tool might use this field to provide clarifying information about the status that is unique to that tool or that explains an error state.
        public var statusDetail: Swift.String?

        public init(
            progressPercent: Swift.Int? = nil,
            status: MigrationHubClientTypes.Status? = nil,
            statusDetail: Swift.String? = nil
        )
        {
            self.progressPercent = progressPercent
            self.status = status
            self.statusDetail = statusDetail
        }
    }

}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = 0
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A message that provides information about the exception.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The number of seconds the caller should wait before retrying.
        public internal(set) var retryAfterSeconds: Swift.Int = 0
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnauthorizedOperation {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnauthorizedOperationBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception raised to indicate a request was not authorized when the DryRun flag is set to "true".
public struct UnauthorizedOperation: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedOperation" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnauthorizedOperationBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnauthorizedOperationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
