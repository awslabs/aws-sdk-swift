//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension ObservabilityAdminClient {
    /// Paginate over `[ListCentralizationRulesForOrganizationOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCentralizationRulesForOrganizationInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCentralizationRulesForOrganizationOutput`
    public func listCentralizationRulesForOrganizationPaginated(input: ListCentralizationRulesForOrganizationInput) -> ClientRuntime.PaginatorSequence<ListCentralizationRulesForOrganizationInput, ListCentralizationRulesForOrganizationOutput> {
        return ClientRuntime.PaginatorSequence<ListCentralizationRulesForOrganizationInput, ListCentralizationRulesForOrganizationOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listCentralizationRulesForOrganization(input:))
    }
}

extension ListCentralizationRulesForOrganizationInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCentralizationRulesForOrganizationInput {
        return ListCentralizationRulesForOrganizationInput(
            allRegions: self.allRegions,
            maxResults: self.maxResults,
            nextToken: token,
            ruleNamePrefix: self.ruleNamePrefix
        )}
}

extension PaginatorSequence where OperationStackInput == ListCentralizationRulesForOrganizationInput, OperationStackOutput == ListCentralizationRulesForOrganizationOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listCentralizationRulesForOrganizationPaginated`
    /// to access the nested member `[ObservabilityAdminClientTypes.CentralizationRuleSummary]`
    /// - Returns: `[ObservabilityAdminClientTypes.CentralizationRuleSummary]`
    public func centralizationRuleSummaries() async throws -> [ObservabilityAdminClientTypes.CentralizationRuleSummary] {
        return try await self.asyncCompactMap { item in item.centralizationRuleSummaries }
    }
}
extension ObservabilityAdminClient {
    /// Paginate over `[ListResourceTelemetryOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResourceTelemetryInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResourceTelemetryOutput`
    public func listResourceTelemetryPaginated(input: ListResourceTelemetryInput) -> ClientRuntime.PaginatorSequence<ListResourceTelemetryInput, ListResourceTelemetryOutput> {
        return ClientRuntime.PaginatorSequence<ListResourceTelemetryInput, ListResourceTelemetryOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listResourceTelemetry(input:))
    }
}

extension ListResourceTelemetryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResourceTelemetryInput {
        return ListResourceTelemetryInput(
            maxResults: self.maxResults,
            nextToken: token,
            resourceIdentifierPrefix: self.resourceIdentifierPrefix,
            resourceTags: self.resourceTags,
            resourceTypes: self.resourceTypes,
            telemetryConfigurationState: self.telemetryConfigurationState
        )}
}

extension PaginatorSequence where OperationStackInput == ListResourceTelemetryInput, OperationStackOutput == ListResourceTelemetryOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listResourceTelemetryPaginated`
    /// to access the nested member `[ObservabilityAdminClientTypes.TelemetryConfiguration]`
    /// - Returns: `[ObservabilityAdminClientTypes.TelemetryConfiguration]`
    public func telemetryConfigurations() async throws -> [ObservabilityAdminClientTypes.TelemetryConfiguration] {
        return try await self.asyncCompactMap { item in item.telemetryConfigurations }
    }
}
extension ObservabilityAdminClient {
    /// Paginate over `[ListResourceTelemetryForOrganizationOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResourceTelemetryForOrganizationInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResourceTelemetryForOrganizationOutput`
    public func listResourceTelemetryForOrganizationPaginated(input: ListResourceTelemetryForOrganizationInput) -> ClientRuntime.PaginatorSequence<ListResourceTelemetryForOrganizationInput, ListResourceTelemetryForOrganizationOutput> {
        return ClientRuntime.PaginatorSequence<ListResourceTelemetryForOrganizationInput, ListResourceTelemetryForOrganizationOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listResourceTelemetryForOrganization(input:))
    }
}

extension ListResourceTelemetryForOrganizationInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResourceTelemetryForOrganizationInput {
        return ListResourceTelemetryForOrganizationInput(
            accountIdentifiers: self.accountIdentifiers,
            maxResults: self.maxResults,
            nextToken: token,
            resourceIdentifierPrefix: self.resourceIdentifierPrefix,
            resourceTags: self.resourceTags,
            resourceTypes: self.resourceTypes,
            telemetryConfigurationState: self.telemetryConfigurationState
        )}
}

extension PaginatorSequence where OperationStackInput == ListResourceTelemetryForOrganizationInput, OperationStackOutput == ListResourceTelemetryForOrganizationOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listResourceTelemetryForOrganizationPaginated`
    /// to access the nested member `[ObservabilityAdminClientTypes.TelemetryConfiguration]`
    /// - Returns: `[ObservabilityAdminClientTypes.TelemetryConfiguration]`
    public func telemetryConfigurations() async throws -> [ObservabilityAdminClientTypes.TelemetryConfiguration] {
        return try await self.asyncCompactMap { item in item.telemetryConfigurations }
    }
}
extension ObservabilityAdminClient {
    /// Paginate over `[ListS3TableIntegrationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListS3TableIntegrationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListS3TableIntegrationsOutput`
    public func listS3TableIntegrationsPaginated(input: ListS3TableIntegrationsInput) -> ClientRuntime.PaginatorSequence<ListS3TableIntegrationsInput, ListS3TableIntegrationsOutput> {
        return ClientRuntime.PaginatorSequence<ListS3TableIntegrationsInput, ListS3TableIntegrationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listS3TableIntegrations(input:))
    }
}

extension ListS3TableIntegrationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListS3TableIntegrationsInput {
        return ListS3TableIntegrationsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListS3TableIntegrationsInput, OperationStackOutput == ListS3TableIntegrationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listS3TableIntegrationsPaginated`
    /// to access the nested member `[ObservabilityAdminClientTypes.IntegrationSummary]`
    /// - Returns: `[ObservabilityAdminClientTypes.IntegrationSummary]`
    public func integrationSummaries() async throws -> [ObservabilityAdminClientTypes.IntegrationSummary] {
        return try await self.asyncCompactMap { item in item.integrationSummaries }
    }
}
extension ObservabilityAdminClient {
    /// Paginate over `[ListTelemetryRulesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTelemetryRulesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTelemetryRulesOutput`
    public func listTelemetryRulesPaginated(input: ListTelemetryRulesInput) -> ClientRuntime.PaginatorSequence<ListTelemetryRulesInput, ListTelemetryRulesOutput> {
        return ClientRuntime.PaginatorSequence<ListTelemetryRulesInput, ListTelemetryRulesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTelemetryRules(input:))
    }
}

extension ListTelemetryRulesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTelemetryRulesInput {
        return ListTelemetryRulesInput(
            maxResults: self.maxResults,
            nextToken: token,
            ruleNamePrefix: self.ruleNamePrefix
        )}
}

extension PaginatorSequence where OperationStackInput == ListTelemetryRulesInput, OperationStackOutput == ListTelemetryRulesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listTelemetryRulesPaginated`
    /// to access the nested member `[ObservabilityAdminClientTypes.TelemetryRuleSummary]`
    /// - Returns: `[ObservabilityAdminClientTypes.TelemetryRuleSummary]`
    public func telemetryRuleSummaries() async throws -> [ObservabilityAdminClientTypes.TelemetryRuleSummary] {
        return try await self.asyncCompactMap { item in item.telemetryRuleSummaries }
    }
}
extension ObservabilityAdminClient {
    /// Paginate over `[ListTelemetryRulesForOrganizationOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTelemetryRulesForOrganizationInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTelemetryRulesForOrganizationOutput`
    public func listTelemetryRulesForOrganizationPaginated(input: ListTelemetryRulesForOrganizationInput) -> ClientRuntime.PaginatorSequence<ListTelemetryRulesForOrganizationInput, ListTelemetryRulesForOrganizationOutput> {
        return ClientRuntime.PaginatorSequence<ListTelemetryRulesForOrganizationInput, ListTelemetryRulesForOrganizationOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTelemetryRulesForOrganization(input:))
    }
}

extension ListTelemetryRulesForOrganizationInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTelemetryRulesForOrganizationInput {
        return ListTelemetryRulesForOrganizationInput(
            maxResults: self.maxResults,
            nextToken: token,
            ruleNamePrefix: self.ruleNamePrefix,
            sourceAccountIds: self.sourceAccountIds,
            sourceOrganizationUnitIds: self.sourceOrganizationUnitIds
        )}
}

extension PaginatorSequence where OperationStackInput == ListTelemetryRulesForOrganizationInput, OperationStackOutput == ListTelemetryRulesForOrganizationOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listTelemetryRulesForOrganizationPaginated`
    /// to access the nested member `[ObservabilityAdminClientTypes.TelemetryRuleSummary]`
    /// - Returns: `[ObservabilityAdminClientTypes.TelemetryRuleSummary]`
    public func telemetryRuleSummaries() async throws -> [ObservabilityAdminClientTypes.TelemetryRuleSummary] {
        return try await self.asyncCompactMap { item in item.telemetryRuleSummaries }
    }
}
