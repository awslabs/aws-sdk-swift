//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox


public struct DeleteTelemetryRuleForOrganizationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteTelemetryRuleOutput: Swift.Sendable {

    public init() { }
}

public struct GetTelemetryEvaluationStatusForOrganizationInput: Swift.Sendable {

    public init() { }
}

public struct GetTelemetryEvaluationStatusInput: Swift.Sendable {

    public init() { }
}

public struct StartTelemetryEvaluationForOrganizationInput: Swift.Sendable {

    public init() { }
}

public struct StartTelemetryEvaluationForOrganizationOutput: Swift.Sendable {

    public init() { }
}

public struct StartTelemetryEvaluationInput: Swift.Sendable {

    public init() { }
}

public struct StartTelemetryEvaluationOutput: Swift.Sendable {

    public init() { }
}

public struct StopTelemetryEvaluationForOrganizationInput: Swift.Sendable {

    public init() { }
}

public struct StopTelemetryEvaluationForOrganizationOutput: Swift.Sendable {

    public init() { }
}

public struct StopTelemetryEvaluationInput: Swift.Sendable {

    public init() { }
}

public struct StopTelemetryEvaluationOutput: Swift.Sendable {

    public init() { }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

/// Indicates you don't have permissions to perform the requested operation. The user or role that is making the request must have at least one IAM permissions policy attached that grants the required permissions. For more information, see [Access management for Amazon Web Services resources](https://docs.aws.amazon.com/IAM/latest/UserGuide/access.html) in the IAM user guide.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// The name of the exception.
        public internal(set) var amznErrorType: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        amznErrorType: Swift.String? = nil,
        message: Swift.String? = nil
    ) {
        self.properties.amznErrorType = amznErrorType
        self.properties.message = message
    }
}

/// The requested operation conflicts with the current state of the specified resource or with another request.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// Indicates the request has failed to process because of an unknown server error, exception, or failure.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// The name of the exception.
        public internal(set) var amznErrorType: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        amznErrorType: Swift.String? = nil,
        message: Swift.String? = nil
    ) {
        self.properties.amznErrorType = amznErrorType
        self.properties.message = message
    }
}

/// The requested operation would exceed the allowed quota for the specified resource type.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// The name of the exception.
        public internal(set) var amznErrorType: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        amznErrorType: Swift.String? = nil,
        message: Swift.String? = nil
    ) {
        self.properties.amznErrorType = amznErrorType
        self.properties.message = message
    }
}

/// The request throughput limit was exceeded.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// Indicates input validation failed. Check your request parameters and retry the request.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension ObservabilityAdminClientTypes {

    public enum DestinationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cloudwatchLogs
        case sdkUnknown(Swift.String)

        public static var allCases: [DestinationType] {
            return [
                .cloudwatchLogs
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cloudwatchLogs: return "cloud-watch-logs"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ObservabilityAdminClientTypes {

    /// Configuration parameters specific to VPC Flow Logs.
    public struct VPCFlowLogParameters: Swift.Sendable {
        /// The format in which VPC Flow Log entries should be logged.
        public var logFormat: Swift.String?
        /// The maximum interval in seconds between the capture of flow log records.
        public var maxAggregationInterval: Swift.Int?
        /// The type of traffic to log (ACCEPT, REJECT, or ALL).
        public var trafficType: Swift.String?

        public init(
            logFormat: Swift.String? = nil,
            maxAggregationInterval: Swift.Int? = nil,
            trafficType: Swift.String? = nil
        ) {
            self.logFormat = logFormat
            self.maxAggregationInterval = maxAggregationInterval
            self.trafficType = trafficType
        }
    }
}

extension ObservabilityAdminClientTypes {

    /// Configuration specifying where and how telemetry data should be delivered for Amazon Web Services resources.
    public struct TelemetryDestinationConfiguration: Swift.Sendable {
        /// The pattern used to generate the destination path or name, supporting macros like <resourceId> and <accountId>.
        public var destinationPattern: Swift.String?
        /// The type of destination for the telemetry data (e.g., "Amazon CloudWatch Logs", "S3").
        public var destinationType: ObservabilityAdminClientTypes.DestinationType?
        /// The number of days to retain the telemetry data in the destination.
        public var retentionInDays: Swift.Int?
        /// Configuration parameters specific to VPC Flow Logs when VPC is the resource type.
        public var vpcFlowLogParameters: ObservabilityAdminClientTypes.VPCFlowLogParameters?

        public init(
            destinationPattern: Swift.String? = nil,
            destinationType: ObservabilityAdminClientTypes.DestinationType? = nil,
            retentionInDays: Swift.Int? = nil,
            vpcFlowLogParameters: ObservabilityAdminClientTypes.VPCFlowLogParameters? = nil
        ) {
            self.destinationPattern = destinationPattern
            self.destinationType = destinationType
            self.retentionInDays = retentionInDays
            self.vpcFlowLogParameters = vpcFlowLogParameters
        }
    }
}

extension ObservabilityAdminClientTypes {

    public enum ResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsEc2Instance
        case awsEc2Vpc
        case awsLamdbaFunction
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .awsEc2Instance,
                .awsEc2Vpc,
                .awsLamdbaFunction
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsEc2Instance: return "AWS::EC2::Instance"
            case .awsEc2Vpc: return "AWS::EC2::VPC"
            case .awsLamdbaFunction: return "AWS::Lambda::Function"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ObservabilityAdminClientTypes {

    public enum TelemetryType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case logs
        case metrics
        case traces
        case sdkUnknown(Swift.String)

        public static var allCases: [TelemetryType] {
            return [
                .logs,
                .metrics,
                .traces
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .logs: return "Logs"
            case .metrics: return "Metrics"
            case .traces: return "Traces"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ObservabilityAdminClientTypes {

    /// Defines how telemetry should be configured for specific Amazon Web Services resources.
    public struct TelemetryRule: Swift.Sendable {
        /// Configuration specifying where and how the telemetry data should be delivered.
        public var destinationConfiguration: ObservabilityAdminClientTypes.TelemetryDestinationConfiguration?
        /// The type of Amazon Web Services resource to configure telemetry for (e.g., "AWS::EC2::VPC").
        public var resourceType: ObservabilityAdminClientTypes.ResourceType?
        /// The organizational scope to which the rule applies, specified using accounts or organizational units.
        public var scope: Swift.String?
        /// Criteria for selecting which resources the rule applies to, such as resource tags.
        public var selectionCriteria: Swift.String?
        /// The type of telemetry to collect (Logs, Metrics, or Traces).
        /// This member is required.
        public var telemetryType: ObservabilityAdminClientTypes.TelemetryType?

        public init(
            destinationConfiguration: ObservabilityAdminClientTypes.TelemetryDestinationConfiguration? = nil,
            resourceType: ObservabilityAdminClientTypes.ResourceType? = nil,
            scope: Swift.String? = nil,
            selectionCriteria: Swift.String? = nil,
            telemetryType: ObservabilityAdminClientTypes.TelemetryType? = nil
        ) {
            self.destinationConfiguration = destinationConfiguration
            self.resourceType = resourceType
            self.scope = scope
            self.selectionCriteria = selectionCriteria
            self.telemetryType = telemetryType
        }
    }
}

public struct CreateTelemetryRuleInput: Swift.Sendable {
    /// The configuration details for the telemetry rule, including the resource type, telemetry type, destination configuration, and selection criteria for which resources the rule applies to.
    /// This member is required.
    public var rule: ObservabilityAdminClientTypes.TelemetryRule?
    /// A unique name for the telemetry rule being created.
    /// This member is required.
    public var ruleName: Swift.String?
    /// The key-value pairs to associate with the telemetry rule resource for categorization and management purposes.
    public var tags: [Swift.String: Swift.String]?

    public init(
        rule: ObservabilityAdminClientTypes.TelemetryRule? = nil,
        ruleName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.rule = rule
        self.ruleName = ruleName
        self.tags = tags
    }
}

public struct CreateTelemetryRuleOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the created telemetry rule.
    public var ruleArn: Swift.String?

    public init(
        ruleArn: Swift.String? = nil
    ) {
        self.ruleArn = ruleArn
    }
}

public struct CreateTelemetryRuleForOrganizationInput: Swift.Sendable {
    /// The configuration details for the organization-wide telemetry rule, including the resource type, telemetry type, destination configuration, and selection criteria for which resources the rule applies to across the organization.
    /// This member is required.
    public var rule: ObservabilityAdminClientTypes.TelemetryRule?
    /// A unique name for the organization-wide telemetry rule being created.
    /// This member is required.
    public var ruleName: Swift.String?
    /// The key-value pairs to associate with the organization telemetry rule resource for categorization and management purposes.
    public var tags: [Swift.String: Swift.String]?

    public init(
        rule: ObservabilityAdminClientTypes.TelemetryRule? = nil,
        ruleName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.rule = rule
        self.ruleName = ruleName
        self.tags = tags
    }
}

public struct CreateTelemetryRuleForOrganizationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the created organization telemetry rule.
    public var ruleArn: Swift.String?

    public init(
        ruleArn: Swift.String? = nil
    ) {
        self.ruleArn = ruleArn
    }
}

/// The specified resource (such as a telemetry rule) could not be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct DeleteTelemetryRuleInput: Swift.Sendable {
    /// The identifier (name or ARN) of the telemetry rule to delete.
    /// This member is required.
    public var ruleIdentifier: Swift.String?

    public init(
        ruleIdentifier: Swift.String? = nil
    ) {
        self.ruleIdentifier = ruleIdentifier
    }
}

public struct DeleteTelemetryRuleForOrganizationInput: Swift.Sendable {
    /// The identifier (name or ARN) of the organization telemetry rule to delete.
    /// This member is required.
    public var ruleIdentifier: Swift.String?

    public init(
        ruleIdentifier: Swift.String? = nil
    ) {
        self.ruleIdentifier = ruleIdentifier
    }
}

extension ObservabilityAdminClientTypes {

    public enum Status: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failedStart
        case failedStop
        case notStarted
        case running
        case starting
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .failedStart,
                .failedStop,
                .notStarted,
                .running,
                .starting,
                .stopped,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failedStart: return "FAILED_START"
            case .failedStop: return "FAILED_STOP"
            case .notStarted: return "NOT_STARTED"
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetTelemetryEvaluationStatusOutput: Swift.Sendable {
    /// Describes the reason for the failure status. The field will only be populated if Status is FAILED_START or FAILED_STOP.
    public var failureReason: Swift.String?
    /// The onboarding status of the telemetry config feature.
    public var status: ObservabilityAdminClientTypes.Status?

    public init(
        failureReason: Swift.String? = nil,
        status: ObservabilityAdminClientTypes.Status? = nil
    ) {
        self.failureReason = failureReason
        self.status = status
    }
}

public struct GetTelemetryEvaluationStatusForOrganizationOutput: Swift.Sendable {
    /// This field describes the reason for the failure status. The field will only be populated if Status is FAILED_START or FAILED_STOP.
    public var failureReason: Swift.String?
    /// The onboarding status of the telemetry config feature for the organization.
    public var status: ObservabilityAdminClientTypes.Status?

    public init(
        failureReason: Swift.String? = nil,
        status: ObservabilityAdminClientTypes.Status? = nil
    ) {
        self.failureReason = failureReason
        self.status = status
    }
}

public struct GetTelemetryRuleInput: Swift.Sendable {
    /// The identifier (name or ARN) of the telemetry rule to retrieve.
    /// This member is required.
    public var ruleIdentifier: Swift.String?

    public init(
        ruleIdentifier: Swift.String? = nil
    ) {
        self.ruleIdentifier = ruleIdentifier
    }
}

public struct GetTelemetryRuleOutput: Swift.Sendable {
    /// The timestamp when the telemetry rule was created.
    public var createdTimeStamp: Swift.Int?
    /// The timestamp when the telemetry rule was last updated.
    public var lastUpdateTimeStamp: Swift.Int?
    /// The Amazon Resource Name (ARN) of the telemetry rule.
    public var ruleArn: Swift.String?
    /// The name of the telemetry rule.
    public var ruleName: Swift.String?
    /// The configuration details of the telemetry rule.
    public var telemetryRule: ObservabilityAdminClientTypes.TelemetryRule?

    public init(
        createdTimeStamp: Swift.Int? = nil,
        lastUpdateTimeStamp: Swift.Int? = nil,
        ruleArn: Swift.String? = nil,
        ruleName: Swift.String? = nil,
        telemetryRule: ObservabilityAdminClientTypes.TelemetryRule? = nil
    ) {
        self.createdTimeStamp = createdTimeStamp
        self.lastUpdateTimeStamp = lastUpdateTimeStamp
        self.ruleArn = ruleArn
        self.ruleName = ruleName
        self.telemetryRule = telemetryRule
    }
}

public struct GetTelemetryRuleForOrganizationInput: Swift.Sendable {
    /// The identifier (name or ARN) of the organization telemetry rule to retrieve.
    /// This member is required.
    public var ruleIdentifier: Swift.String?

    public init(
        ruleIdentifier: Swift.String? = nil
    ) {
        self.ruleIdentifier = ruleIdentifier
    }
}

public struct GetTelemetryRuleForOrganizationOutput: Swift.Sendable {
    /// The timestamp when the organization telemetry rule was created.
    public var createdTimeStamp: Swift.Int?
    /// The timestamp when the organization telemetry rule was last updated.
    public var lastUpdateTimeStamp: Swift.Int?
    /// The Amazon Resource Name (ARN) of the organization telemetry rule.
    public var ruleArn: Swift.String?
    /// The name of the organization telemetry rule.
    public var ruleName: Swift.String?
    /// The configuration details of the organization telemetry rule.
    public var telemetryRule: ObservabilityAdminClientTypes.TelemetryRule?

    public init(
        createdTimeStamp: Swift.Int? = nil,
        lastUpdateTimeStamp: Swift.Int? = nil,
        ruleArn: Swift.String? = nil,
        ruleName: Swift.String? = nil,
        telemetryRule: ObservabilityAdminClientTypes.TelemetryRule? = nil
    ) {
        self.createdTimeStamp = createdTimeStamp
        self.lastUpdateTimeStamp = lastUpdateTimeStamp
        self.ruleArn = ruleArn
        self.ruleName = ruleName
        self.telemetryRule = telemetryRule
    }
}

extension ObservabilityAdminClientTypes {

    public enum TelemetryState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case notApplicable
        case sdkUnknown(Swift.String)

        public static var allCases: [TelemetryState] {
            return [
                .disabled,
                .enabled,
                .notApplicable
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case .notApplicable: return "NotApplicable"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListResourceTelemetryInput: Swift.Sendable {
    /// A number field used to limit the number of results within the returned list.
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. A previous call generates this token.
    public var nextToken: Swift.String?
    /// A string used to filter resources which have a ResourceIdentifier starting with the ResourceIdentifierPrefix.
    public var resourceIdentifierPrefix: Swift.String?
    /// A key-value pair to filter resources based on tags associated with the resource. For more information about tags, see [What are tags?](https://docs.aws.amazon.com/whitepapers/latest/tagging-best-practices/what-are-tags.html)
    public var resourceTags: [Swift.String: Swift.String]?
    /// A list of resource types used to filter resources supported by telemetry config. If this parameter is provided, the resources will be returned in the same order used in the request.
    public var resourceTypes: [ObservabilityAdminClientTypes.ResourceType]?
    /// A key-value pair to filter resources based on the telemetry type and the state of the telemetry configuration. The key is the telemetry type and the value is the state.
    public var telemetryConfigurationState: [Swift.String: ObservabilityAdminClientTypes.TelemetryState]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceIdentifierPrefix: Swift.String? = nil,
        resourceTags: [Swift.String: Swift.String]? = nil,
        resourceTypes: [ObservabilityAdminClientTypes.ResourceType]? = nil,
        telemetryConfigurationState: [Swift.String: ObservabilityAdminClientTypes.TelemetryState]? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceIdentifierPrefix = resourceIdentifierPrefix
        self.resourceTags = resourceTags
        self.resourceTypes = resourceTypes
        self.telemetryConfigurationState = telemetryConfigurationState
    }
}

extension ObservabilityAdminClientTypes {

    /// A model representing the state of a resource within an account according to telemetry config.
    public struct TelemetryConfiguration: Swift.Sendable {
        /// The account ID which contains the resource managed in telemetry configuration. An example of a valid account ID is 012345678901.
        public var accountIdentifier: Swift.String?
        /// The timestamp of the last change to the telemetry configuration for the resource. For example, 1728679196318.
        public var lastUpdateTimeStamp: Swift.Int?
        /// The identifier of the resource, for example i-0b22a22eec53b9321.
        public var resourceIdentifier: Swift.String?
        /// Tags associated with the resource, for example { Name: "ExampleInstance", Environment: "Development" }.
        public var resourceTags: [Swift.String: Swift.String]?
        /// The type of resource, for example Amazon Web Services::EC2::Instance.
        public var resourceType: ObservabilityAdminClientTypes.ResourceType?
        /// The configuration state for the resource, for example { Logs: NotApplicable; Metrics: Enabled; Traces: NotApplicable; }.
        public var telemetryConfigurationState: [Swift.String: ObservabilityAdminClientTypes.TelemetryState]?

        public init(
            accountIdentifier: Swift.String? = nil,
            lastUpdateTimeStamp: Swift.Int? = nil,
            resourceIdentifier: Swift.String? = nil,
            resourceTags: [Swift.String: Swift.String]? = nil,
            resourceType: ObservabilityAdminClientTypes.ResourceType? = nil,
            telemetryConfigurationState: [Swift.String: ObservabilityAdminClientTypes.TelemetryState]? = nil
        ) {
            self.accountIdentifier = accountIdentifier
            self.lastUpdateTimeStamp = lastUpdateTimeStamp
            self.resourceIdentifier = resourceIdentifier
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.telemetryConfigurationState = telemetryConfigurationState
        }
    }
}

public struct ListResourceTelemetryOutput: Swift.Sendable {
    /// The token for the next set of items to return. A previous call generates this token.
    public var nextToken: Swift.String?
    /// A list of telemetry configurations for Amazon Web Services resources supported by telemetry config in the caller's account.
    public var telemetryConfigurations: [ObservabilityAdminClientTypes.TelemetryConfiguration]?

    public init(
        nextToken: Swift.String? = nil,
        telemetryConfigurations: [ObservabilityAdminClientTypes.TelemetryConfiguration]? = nil
    ) {
        self.nextToken = nextToken
        self.telemetryConfigurations = telemetryConfigurations
    }
}

public struct ListResourceTelemetryForOrganizationInput: Swift.Sendable {
    /// A list of Amazon Web Services accounts used to filter the resources to those associated with the specified accounts.
    public var accountIdentifiers: [Swift.String]?
    /// A number field used to limit the number of results within the returned list.
    public var maxResults: Swift.Int?
    /// The token for the next set of items to return. A previous call provides this token.
    public var nextToken: Swift.String?
    /// A string used to filter resources in the organization which have a ResourceIdentifier starting with the ResourceIdentifierPrefix.
    public var resourceIdentifierPrefix: Swift.String?
    /// A key-value pair to filter resources in the organization based on tags associated with the resource. Fore more information about tags, see [What are tags?](https://docs.aws.amazon.com/whitepapers/latest/tagging-best-practices/what-are-tags.html)
    public var resourceTags: [Swift.String: Swift.String]?
    /// A list of resource types used to filter resources in the organization. If this parameter is provided, the resources will be returned in the same order used in the request.
    public var resourceTypes: [ObservabilityAdminClientTypes.ResourceType]?
    /// A key-value pair to filter resources in the organization based on the telemetry type and the state of the telemetry configuration. The key is the telemetry type and the value is the state.
    public var telemetryConfigurationState: [Swift.String: ObservabilityAdminClientTypes.TelemetryState]?

    public init(
        accountIdentifiers: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceIdentifierPrefix: Swift.String? = nil,
        resourceTags: [Swift.String: Swift.String]? = nil,
        resourceTypes: [ObservabilityAdminClientTypes.ResourceType]? = nil,
        telemetryConfigurationState: [Swift.String: ObservabilityAdminClientTypes.TelemetryState]? = nil
    ) {
        self.accountIdentifiers = accountIdentifiers
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceIdentifierPrefix = resourceIdentifierPrefix
        self.resourceTags = resourceTags
        self.resourceTypes = resourceTypes
        self.telemetryConfigurationState = telemetryConfigurationState
    }
}

public struct ListResourceTelemetryForOrganizationOutput: Swift.Sendable {
    /// The token for the next set of items to return. A previous call provides this token.
    public var nextToken: Swift.String?
    /// A list of telemetry configurations for Amazon Web Services resources supported by telemetry config in the organization.
    public var telemetryConfigurations: [ObservabilityAdminClientTypes.TelemetryConfiguration]?

    public init(
        nextToken: Swift.String? = nil,
        telemetryConfigurations: [ObservabilityAdminClientTypes.TelemetryConfiguration]? = nil
    ) {
        self.nextToken = nextToken
        self.telemetryConfigurations = telemetryConfigurations
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the telemetry rule resource whose tags you want to list.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    ) {
        self.resourceARN = resourceARN
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The list of tags associated with the telemetry rule resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.tags = tags
    }
}

public struct ListTelemetryRulesInput: Swift.Sendable {
    /// The maximum number of telemetry rules to return in a single call.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. A previous call generates this token.
    public var nextToken: Swift.String?
    /// A string to filter telemetry rules whose names begin with the specified prefix.
    public var ruleNamePrefix: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        ruleNamePrefix: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.ruleNamePrefix = ruleNamePrefix
    }
}

extension ObservabilityAdminClientTypes {

    /// A summary of a telemetry rule's key properties.
    public struct TelemetryRuleSummary: Swift.Sendable {
        /// The timestamp when the telemetry rule was created.
        public var createdTimeStamp: Swift.Int?
        /// The timestamp when the telemetry rule was last modified.
        public var lastUpdateTimeStamp: Swift.Int?
        /// The type of Amazon Web Services resource the rule applies to.
        public var resourceType: ObservabilityAdminClientTypes.ResourceType?
        /// The Amazon Resource Name (ARN) of the telemetry rule.
        public var ruleArn: Swift.String?
        /// The name of the telemetry rule.
        public var ruleName: Swift.String?
        /// The type of telemetry (Logs, Metrics, or Traces) the rule configures.
        public var telemetryType: ObservabilityAdminClientTypes.TelemetryType?

        public init(
            createdTimeStamp: Swift.Int? = nil,
            lastUpdateTimeStamp: Swift.Int? = nil,
            resourceType: ObservabilityAdminClientTypes.ResourceType? = nil,
            ruleArn: Swift.String? = nil,
            ruleName: Swift.String? = nil,
            telemetryType: ObservabilityAdminClientTypes.TelemetryType? = nil
        ) {
            self.createdTimeStamp = createdTimeStamp
            self.lastUpdateTimeStamp = lastUpdateTimeStamp
            self.resourceType = resourceType
            self.ruleArn = ruleArn
            self.ruleName = ruleName
            self.telemetryType = telemetryType
        }
    }
}

public struct ListTelemetryRulesOutput: Swift.Sendable {
    /// A token to resume pagination of results.
    public var nextToken: Swift.String?
    /// A list of telemetry rule summaries.
    public var telemetryRuleSummaries: [ObservabilityAdminClientTypes.TelemetryRuleSummary]?

    public init(
        nextToken: Swift.String? = nil,
        telemetryRuleSummaries: [ObservabilityAdminClientTypes.TelemetryRuleSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.telemetryRuleSummaries = telemetryRuleSummaries
    }
}

public struct ListTelemetryRulesForOrganizationInput: Swift.Sendable {
    /// The maximum number of organization telemetry rules to return in a single call.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. A previous call generates this token.
    public var nextToken: Swift.String?
    /// A string to filter organization telemetry rules whose names begin with the specified prefix.
    public var ruleNamePrefix: Swift.String?
    /// The list of account IDs to filter organization telemetry rules by their source accounts.
    public var sourceAccountIds: [Swift.String]?
    /// The list of organizational unit IDs to filter organization telemetry rules by their source organizational units.
    public var sourceOrganizationUnitIds: [Swift.String]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        ruleNamePrefix: Swift.String? = nil,
        sourceAccountIds: [Swift.String]? = nil,
        sourceOrganizationUnitIds: [Swift.String]? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.ruleNamePrefix = ruleNamePrefix
        self.sourceAccountIds = sourceAccountIds
        self.sourceOrganizationUnitIds = sourceOrganizationUnitIds
    }
}

public struct ListTelemetryRulesForOrganizationOutput: Swift.Sendable {
    /// A token to resume pagination of results.
    public var nextToken: Swift.String?
    /// A list of organization telemetry rule summaries.
    public var telemetryRuleSummaries: [ObservabilityAdminClientTypes.TelemetryRuleSummary]?

    public init(
        nextToken: Swift.String? = nil,
        telemetryRuleSummaries: [ObservabilityAdminClientTypes.TelemetryRuleSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.telemetryRuleSummaries = telemetryRuleSummaries
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the telemetry rule resource to tag.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The key-value pairs to add or update for the telemetry rule resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the telemetry rule resource to remove tags from.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The list of tag keys to remove from the telemetry rule resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

public struct UpdateTelemetryRuleInput: Swift.Sendable {
    /// The new configuration details for the telemetry rule.
    /// This member is required.
    public var rule: ObservabilityAdminClientTypes.TelemetryRule?
    /// The identifier (name or ARN) of the telemetry rule to update.
    /// This member is required.
    public var ruleIdentifier: Swift.String?

    public init(
        rule: ObservabilityAdminClientTypes.TelemetryRule? = nil,
        ruleIdentifier: Swift.String? = nil
    ) {
        self.rule = rule
        self.ruleIdentifier = ruleIdentifier
    }
}

public struct UpdateTelemetryRuleOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the updated telemetry rule.
    public var ruleArn: Swift.String?

    public init(
        ruleArn: Swift.String? = nil
    ) {
        self.ruleArn = ruleArn
    }
}

public struct UpdateTelemetryRuleForOrganizationInput: Swift.Sendable {
    /// The new configuration details for the organization telemetry rule, including resource type, telemetry type, and destination configuration.
    /// This member is required.
    public var rule: ObservabilityAdminClientTypes.TelemetryRule?
    /// The identifier (name or ARN) of the organization telemetry rule to update.
    /// This member is required.
    public var ruleIdentifier: Swift.String?

    public init(
        rule: ObservabilityAdminClientTypes.TelemetryRule? = nil,
        ruleIdentifier: Swift.String? = nil
    ) {
        self.rule = rule
        self.ruleIdentifier = ruleIdentifier
    }
}

public struct UpdateTelemetryRuleForOrganizationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the updated organization telemetry rule.
    public var ruleArn: Swift.String?

    public init(
        ruleArn: Swift.String? = nil
    ) {
        self.ruleArn = ruleArn
    }
}

extension CreateTelemetryRuleInput {

    static func urlPathProvider(_ value: CreateTelemetryRuleInput) -> Swift.String? {
        return "/CreateTelemetryRule"
    }
}

extension CreateTelemetryRuleForOrganizationInput {

    static func urlPathProvider(_ value: CreateTelemetryRuleForOrganizationInput) -> Swift.String? {
        return "/CreateTelemetryRuleForOrganization"
    }
}

extension DeleteTelemetryRuleInput {

    static func urlPathProvider(_ value: DeleteTelemetryRuleInput) -> Swift.String? {
        return "/DeleteTelemetryRule"
    }
}

extension DeleteTelemetryRuleForOrganizationInput {

    static func urlPathProvider(_ value: DeleteTelemetryRuleForOrganizationInput) -> Swift.String? {
        return "/DeleteTelemetryRuleForOrganization"
    }
}

extension GetTelemetryEvaluationStatusInput {

    static func urlPathProvider(_ value: GetTelemetryEvaluationStatusInput) -> Swift.String? {
        return "/GetTelemetryEvaluationStatus"
    }
}

extension GetTelemetryEvaluationStatusForOrganizationInput {

    static func urlPathProvider(_ value: GetTelemetryEvaluationStatusForOrganizationInput) -> Swift.String? {
        return "/GetTelemetryEvaluationStatusForOrganization"
    }
}

extension GetTelemetryRuleInput {

    static func urlPathProvider(_ value: GetTelemetryRuleInput) -> Swift.String? {
        return "/GetTelemetryRule"
    }
}

extension GetTelemetryRuleForOrganizationInput {

    static func urlPathProvider(_ value: GetTelemetryRuleForOrganizationInput) -> Swift.String? {
        return "/GetTelemetryRuleForOrganization"
    }
}

extension ListResourceTelemetryInput {

    static func urlPathProvider(_ value: ListResourceTelemetryInput) -> Swift.String? {
        return "/ListResourceTelemetry"
    }
}

extension ListResourceTelemetryForOrganizationInput {

    static func urlPathProvider(_ value: ListResourceTelemetryForOrganizationInput) -> Swift.String? {
        return "/ListResourceTelemetryForOrganization"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/ListTagsForResource"
    }
}

extension ListTelemetryRulesInput {

    static func urlPathProvider(_ value: ListTelemetryRulesInput) -> Swift.String? {
        return "/ListTelemetryRules"
    }
}

extension ListTelemetryRulesForOrganizationInput {

    static func urlPathProvider(_ value: ListTelemetryRulesForOrganizationInput) -> Swift.String? {
        return "/ListTelemetryRulesForOrganization"
    }
}

extension StartTelemetryEvaluationInput {

    static func urlPathProvider(_ value: StartTelemetryEvaluationInput) -> Swift.String? {
        return "/StartTelemetryEvaluation"
    }
}

extension StartTelemetryEvaluationForOrganizationInput {

    static func urlPathProvider(_ value: StartTelemetryEvaluationForOrganizationInput) -> Swift.String? {
        return "/StartTelemetryEvaluationForOrganization"
    }
}

extension StopTelemetryEvaluationInput {

    static func urlPathProvider(_ value: StopTelemetryEvaluationInput) -> Swift.String? {
        return "/StopTelemetryEvaluation"
    }
}

extension StopTelemetryEvaluationForOrganizationInput {

    static func urlPathProvider(_ value: StopTelemetryEvaluationForOrganizationInput) -> Swift.String? {
        return "/StopTelemetryEvaluationForOrganization"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/TagResource"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/UntagResource"
    }
}

extension UpdateTelemetryRuleInput {

    static func urlPathProvider(_ value: UpdateTelemetryRuleInput) -> Swift.String? {
        return "/UpdateTelemetryRule"
    }
}

extension UpdateTelemetryRuleForOrganizationInput {

    static func urlPathProvider(_ value: UpdateTelemetryRuleForOrganizationInput) -> Swift.String? {
        return "/UpdateTelemetryRuleForOrganization"
    }
}

extension CreateTelemetryRuleInput {

    static func write(value: CreateTelemetryRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Rule"].write(value.rule, with: ObservabilityAdminClientTypes.TelemetryRule.write(value:to:))
        try writer["RuleName"].write(value.ruleName)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateTelemetryRuleForOrganizationInput {

    static func write(value: CreateTelemetryRuleForOrganizationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Rule"].write(value.rule, with: ObservabilityAdminClientTypes.TelemetryRule.write(value:to:))
        try writer["RuleName"].write(value.ruleName)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension DeleteTelemetryRuleInput {

    static func write(value: DeleteTelemetryRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RuleIdentifier"].write(value.ruleIdentifier)
    }
}

extension DeleteTelemetryRuleForOrganizationInput {

    static func write(value: DeleteTelemetryRuleForOrganizationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RuleIdentifier"].write(value.ruleIdentifier)
    }
}

extension GetTelemetryRuleInput {

    static func write(value: GetTelemetryRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RuleIdentifier"].write(value.ruleIdentifier)
    }
}

extension GetTelemetryRuleForOrganizationInput {

    static func write(value: GetTelemetryRuleForOrganizationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RuleIdentifier"].write(value.ruleIdentifier)
    }
}

extension ListResourceTelemetryInput {

    static func write(value: ListResourceTelemetryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceIdentifierPrefix"].write(value.resourceIdentifierPrefix)
        try writer["ResourceTags"].writeMap(value.resourceTags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ResourceTypes"].writeList(value.resourceTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<ObservabilityAdminClientTypes.ResourceType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TelemetryConfigurationState"].writeMap(value.telemetryConfigurationState, valueWritingClosure: SmithyReadWrite.WritingClosureBox<ObservabilityAdminClientTypes.TelemetryState>().write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension ListResourceTelemetryForOrganizationInput {

    static func write(value: ListResourceTelemetryForOrganizationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountIdentifiers"].writeList(value.accountIdentifiers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceIdentifierPrefix"].write(value.resourceIdentifierPrefix)
        try writer["ResourceTags"].writeMap(value.resourceTags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ResourceTypes"].writeList(value.resourceTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<ObservabilityAdminClientTypes.ResourceType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TelemetryConfigurationState"].writeMap(value.telemetryConfigurationState, valueWritingClosure: SmithyReadWrite.WritingClosureBox<ObservabilityAdminClientTypes.TelemetryState>().write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
    }
}

extension ListTelemetryRulesInput {

    static func write(value: ListTelemetryRulesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["RuleNamePrefix"].write(value.ruleNamePrefix)
    }
}

extension ListTelemetryRulesForOrganizationInput {

    static func write(value: ListTelemetryRulesForOrganizationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["RuleNamePrefix"].write(value.ruleNamePrefix)
        try writer["SourceAccountIds"].writeList(value.sourceAccountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SourceOrganizationUnitIds"].writeList(value.sourceOrganizationUnitIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateTelemetryRuleInput {

    static func write(value: UpdateTelemetryRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Rule"].write(value.rule, with: ObservabilityAdminClientTypes.TelemetryRule.write(value:to:))
        try writer["RuleIdentifier"].write(value.ruleIdentifier)
    }
}

extension UpdateTelemetryRuleForOrganizationInput {

    static func write(value: UpdateTelemetryRuleForOrganizationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Rule"].write(value.rule, with: ObservabilityAdminClientTypes.TelemetryRule.write(value:to:))
        try writer["RuleIdentifier"].write(value.ruleIdentifier)
    }
}

extension CreateTelemetryRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTelemetryRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTelemetryRuleOutput()
        value.ruleArn = try reader["RuleArn"].readIfPresent()
        return value
    }
}

extension CreateTelemetryRuleForOrganizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTelemetryRuleForOrganizationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTelemetryRuleForOrganizationOutput()
        value.ruleArn = try reader["RuleArn"].readIfPresent()
        return value
    }
}

extension DeleteTelemetryRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTelemetryRuleOutput {
        return DeleteTelemetryRuleOutput()
    }
}

extension DeleteTelemetryRuleForOrganizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTelemetryRuleForOrganizationOutput {
        return DeleteTelemetryRuleForOrganizationOutput()
    }
}

extension GetTelemetryEvaluationStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTelemetryEvaluationStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTelemetryEvaluationStatusOutput()
        value.failureReason = try reader["FailureReason"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension GetTelemetryEvaluationStatusForOrganizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTelemetryEvaluationStatusForOrganizationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTelemetryEvaluationStatusForOrganizationOutput()
        value.failureReason = try reader["FailureReason"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension GetTelemetryRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTelemetryRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTelemetryRuleOutput()
        value.createdTimeStamp = try reader["CreatedTimeStamp"].readIfPresent()
        value.lastUpdateTimeStamp = try reader["LastUpdateTimeStamp"].readIfPresent()
        value.ruleArn = try reader["RuleArn"].readIfPresent()
        value.ruleName = try reader["RuleName"].readIfPresent()
        value.telemetryRule = try reader["TelemetryRule"].readIfPresent(with: ObservabilityAdminClientTypes.TelemetryRule.read(from:))
        return value
    }
}

extension GetTelemetryRuleForOrganizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTelemetryRuleForOrganizationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTelemetryRuleForOrganizationOutput()
        value.createdTimeStamp = try reader["CreatedTimeStamp"].readIfPresent()
        value.lastUpdateTimeStamp = try reader["LastUpdateTimeStamp"].readIfPresent()
        value.ruleArn = try reader["RuleArn"].readIfPresent()
        value.ruleName = try reader["RuleName"].readIfPresent()
        value.telemetryRule = try reader["TelemetryRule"].readIfPresent(with: ObservabilityAdminClientTypes.TelemetryRule.read(from:))
        return value
    }
}

extension ListResourceTelemetryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResourceTelemetryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResourceTelemetryOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.telemetryConfigurations = try reader["TelemetryConfigurations"].readListIfPresent(memberReadingClosure: ObservabilityAdminClientTypes.TelemetryConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListResourceTelemetryForOrganizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResourceTelemetryForOrganizationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResourceTelemetryForOrganizationOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.telemetryConfigurations = try reader["TelemetryConfigurations"].readListIfPresent(memberReadingClosure: ObservabilityAdminClientTypes.TelemetryConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension ListTelemetryRulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTelemetryRulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTelemetryRulesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.telemetryRuleSummaries = try reader["TelemetryRuleSummaries"].readListIfPresent(memberReadingClosure: ObservabilityAdminClientTypes.TelemetryRuleSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTelemetryRulesForOrganizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTelemetryRulesForOrganizationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTelemetryRulesForOrganizationOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.telemetryRuleSummaries = try reader["TelemetryRuleSummaries"].readListIfPresent(memberReadingClosure: ObservabilityAdminClientTypes.TelemetryRuleSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension StartTelemetryEvaluationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartTelemetryEvaluationOutput {
        return StartTelemetryEvaluationOutput()
    }
}

extension StartTelemetryEvaluationForOrganizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartTelemetryEvaluationForOrganizationOutput {
        return StartTelemetryEvaluationForOrganizationOutput()
    }
}

extension StopTelemetryEvaluationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopTelemetryEvaluationOutput {
        return StopTelemetryEvaluationOutput()
    }
}

extension StopTelemetryEvaluationForOrganizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopTelemetryEvaluationForOrganizationOutput {
        return StopTelemetryEvaluationForOrganizationOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateTelemetryRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTelemetryRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateTelemetryRuleOutput()
        value.ruleArn = try reader["RuleArn"].readIfPresent()
        return value
    }
}

extension UpdateTelemetryRuleForOrganizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTelemetryRuleForOrganizationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateTelemetryRuleForOrganizationOutput()
        value.ruleArn = try reader["RuleArn"].readIfPresent()
        return value
    }
}

enum CreateTelemetryRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTelemetryRuleForOrganizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTelemetryRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTelemetryRuleForOrganizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTelemetryEvaluationStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTelemetryEvaluationStatusForOrganizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTelemetryRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTelemetryRuleForOrganizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResourceTelemetryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResourceTelemetryForOrganizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTelemetryRulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTelemetryRulesForOrganizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartTelemetryEvaluationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartTelemetryEvaluationForOrganizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopTelemetryEvaluationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopTelemetryEvaluationForOrganizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTelemetryRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTelemetryRuleForOrganizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = AccessDeniedException()
        if let amznErrorTypeHeaderValue = httpResponse.headers.value(for: "x-amzn-ErrorType") {
            value.properties.amznErrorType = amznErrorTypeHeaderValue
        }
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let amznErrorTypeHeaderValue = httpResponse.headers.value(for: "x-amzn-ErrorType") {
            value.properties.amznErrorType = amznErrorTypeHeaderValue
        }
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ServiceQuotaExceededException()
        if let amznErrorTypeHeaderValue = httpResponse.headers.value(for: "x-amzn-ErrorType") {
            value.properties.amznErrorType = amznErrorTypeHeaderValue
        }
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyRequestsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyRequestsException {
        let reader = baseError.errorBodyReader
        var value = TooManyRequestsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ObservabilityAdminClientTypes.TelemetryRule {

    static func write(value: ObservabilityAdminClientTypes.TelemetryRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationConfiguration"].write(value.destinationConfiguration, with: ObservabilityAdminClientTypes.TelemetryDestinationConfiguration.write(value:to:))
        try writer["ResourceType"].write(value.resourceType)
        try writer["Scope"].write(value.scope)
        try writer["SelectionCriteria"].write(value.selectionCriteria)
        try writer["TelemetryType"].write(value.telemetryType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ObservabilityAdminClientTypes.TelemetryRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ObservabilityAdminClientTypes.TelemetryRule()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.telemetryType = try reader["TelemetryType"].readIfPresent() ?? .sdkUnknown("")
        value.destinationConfiguration = try reader["DestinationConfiguration"].readIfPresent(with: ObservabilityAdminClientTypes.TelemetryDestinationConfiguration.read(from:))
        value.scope = try reader["Scope"].readIfPresent()
        value.selectionCriteria = try reader["SelectionCriteria"].readIfPresent()
        return value
    }
}

extension ObservabilityAdminClientTypes.TelemetryDestinationConfiguration {

    static func write(value: ObservabilityAdminClientTypes.TelemetryDestinationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationPattern"].write(value.destinationPattern)
        try writer["DestinationType"].write(value.destinationType)
        try writer["RetentionInDays"].write(value.retentionInDays)
        try writer["VPCFlowLogParameters"].write(value.vpcFlowLogParameters, with: ObservabilityAdminClientTypes.VPCFlowLogParameters.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ObservabilityAdminClientTypes.TelemetryDestinationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ObservabilityAdminClientTypes.TelemetryDestinationConfiguration()
        value.destinationType = try reader["DestinationType"].readIfPresent()
        value.destinationPattern = try reader["DestinationPattern"].readIfPresent()
        value.retentionInDays = try reader["RetentionInDays"].readIfPresent()
        value.vpcFlowLogParameters = try reader["VPCFlowLogParameters"].readIfPresent(with: ObservabilityAdminClientTypes.VPCFlowLogParameters.read(from:))
        return value
    }
}

extension ObservabilityAdminClientTypes.VPCFlowLogParameters {

    static func write(value: ObservabilityAdminClientTypes.VPCFlowLogParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LogFormat"].write(value.logFormat)
        try writer["MaxAggregationInterval"].write(value.maxAggregationInterval)
        try writer["TrafficType"].write(value.trafficType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ObservabilityAdminClientTypes.VPCFlowLogParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ObservabilityAdminClientTypes.VPCFlowLogParameters()
        value.logFormat = try reader["LogFormat"].readIfPresent()
        value.trafficType = try reader["TrafficType"].readIfPresent()
        value.maxAggregationInterval = try reader["MaxAggregationInterval"].readIfPresent()
        return value
    }
}

extension ObservabilityAdminClientTypes.TelemetryConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> ObservabilityAdminClientTypes.TelemetryConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ObservabilityAdminClientTypes.TelemetryConfiguration()
        value.accountIdentifier = try reader["AccountIdentifier"].readIfPresent()
        value.telemetryConfigurationState = try reader["TelemetryConfigurationState"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosureBox<ObservabilityAdminClientTypes.TelemetryState>().read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.resourceIdentifier = try reader["ResourceIdentifier"].readIfPresent()
        value.resourceTags = try reader["ResourceTags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.lastUpdateTimeStamp = try reader["LastUpdateTimeStamp"].readIfPresent()
        return value
    }
}

extension ObservabilityAdminClientTypes.TelemetryRuleSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ObservabilityAdminClientTypes.TelemetryRuleSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ObservabilityAdminClientTypes.TelemetryRuleSummary()
        value.ruleName = try reader["RuleName"].readIfPresent()
        value.ruleArn = try reader["RuleArn"].readIfPresent()
        value.createdTimeStamp = try reader["CreatedTimeStamp"].readIfPresent()
        value.lastUpdateTimeStamp = try reader["LastUpdateTimeStamp"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.telemetryType = try reader["TelemetryType"].readIfPresent()
        return value
    }
}

public enum ObservabilityAdminClientTypes {}
