//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter


public struct DeleteIdentitySourceOutput: Swift.Sendable {

    public init() { }
}

/// You do not have sufficient access to perform this action. Check your permissions, and try again.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Message for the AccessDeniedException error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension MPAClientTypes {

    public enum ActionCompletionStrategy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case autoCompletionUponApproval
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionCompletionStrategy] {
            return [
                .autoCompletionUponApproval
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .autoCompletionUponApproval: return "AUTO_COMPLETION_UPON_APPROVAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MPAClientTypes {

    /// Strategy for how an approval team grants approval.
    public struct MofNApprovalStrategy: Swift.Sendable {
        /// Minimum number of approvals (M) required for a total number of approvers (N).
        /// This member is required.
        public var minApprovalsRequired: Swift.Int?

        public init(
            minApprovalsRequired: Swift.Int? = nil
        ) {
            self.minApprovalsRequired = minApprovalsRequired
        }
    }
}

extension MPAClientTypes {

    /// Strategy for how an approval team grants approval.
    public enum ApprovalStrategy: Swift.Sendable {
        /// Minimum number of approvals (M) required for a total number of approvers (N).
        case mofn(MPAClientTypes.MofNApprovalStrategy)
        case sdkUnknown(Swift.String)
    }
}

extension MPAClientTypes {

    /// Contains details for how an approval team grants approval.
    public enum ApprovalStrategyResponse: Swift.Sendable {
        /// Minimum number of approvals (M) required for a total number of approvers (N).
        case mofn(MPAClientTypes.MofNApprovalStrategy)
        case sdkUnknown(Swift.String)
    }
}

/// The request cannot be completed because it conflicts with the current state of a resource.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Message for the ConflictException error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The service encountered an internal error. Try your request again. If the problem persists, contact Amazon Web Services Support.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Message for the InternalServerException error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request exceeds the service quota for your account. Request a quota increase or reduce your request size.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Message for the ServiceQuotaExceededException error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Message for the ThrottlingException error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The input fails to satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Message for the ValidationException error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension MPAClientTypes {

    /// Contains details for an approver.
    public struct ApprovalTeamRequestApprover: Swift.Sendable {
        /// ID for the user.
        /// This member is required.
        public var primaryIdentityId: Swift.String?
        /// Amazon Resource Name (ARN) for the identity source. The identity source manages the user authentication for approvers.
        /// This member is required.
        public var primaryIdentitySourceArn: Swift.String?

        public init(
            primaryIdentityId: Swift.String? = nil,
            primaryIdentitySourceArn: Swift.String? = nil
        ) {
            self.primaryIdentityId = primaryIdentityId
            self.primaryIdentitySourceArn = primaryIdentitySourceArn
        }
    }
}

extension MPAClientTypes {

    /// Contains the Amazon Resource Name (ARN) for a policy. Policies define what operations a team that define the permissions for team resources. The protected operation for a service integration might require specific permissions. For more information, see [How other services work with Multi-party approval](https://docs.aws.amazon.com/mpa/latest/userguide/mpa-integrations.html) in the Multi-party approval User Guide.
    public struct PolicyReference: Swift.Sendable {
        /// Amazon Resource Name (ARN) for the policy.
        /// This member is required.
        public var policyArn: Swift.String?

        public init(
            policyArn: Swift.String? = nil
        ) {
            self.policyArn = policyArn
        }
    }
}

public struct CreateApprovalTeamInput: Swift.Sendable {
    /// An ApprovalStrategy object. Contains details for how the team grants approval.
    /// This member is required.
    public var approvalStrategy: MPAClientTypes.ApprovalStrategy?
    /// An array of ApprovalTeamRequesterApprovers objects. Contains details for the approvers in the team.
    /// This member is required.
    public var approvers: [MPAClientTypes.ApprovalTeamRequestApprover]?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services populates this field. What is idempotency? When you make a mutating API request, the request typically returns a result before the operation's asynchronous workflows have completed. Operations might also time out or encounter other server issues before they complete, even though the request has already returned a result. This could make it difficult to determine whether the request succeeded or not, and could lead to multiple retries to ensure that the operation completes successfully. However, if the original request and the subsequent retries are successful, the operation is completed multiple times. This means that you might create more resources than you intended. Idempotency ensures that an API request completes no more than one time. With an idempotent request, if the original request completes successfully, any subsequent retries complete successfully without performing any further actions.
    public var clientToken: Swift.String?
    /// Description for the team.
    /// This member is required.
    public var description: Swift.String?
    /// Name of the team.
    /// This member is required.
    public var name: Swift.String?
    /// An array of PolicyReference objects. Contains a list of policies that define the permissions for team resources. The protected operation for a service integration might require specific permissions. For more information, see [How other services work with Multi-party approval](https://docs.aws.amazon.com/mpa/latest/userguide/mpa-integrations.html) in the Multi-party approval User Guide.
    /// This member is required.
    public var policies: [MPAClientTypes.PolicyReference]?
    /// Tags you want to attach to the team.
    public var tags: [Swift.String: Swift.String]?

    public init(
        approvalStrategy: MPAClientTypes.ApprovalStrategy? = nil,
        approvers: [MPAClientTypes.ApprovalTeamRequestApprover]? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        policies: [MPAClientTypes.PolicyReference]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.approvalStrategy = approvalStrategy
        self.approvers = approvers
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.policies = policies
        self.tags = tags
    }
}

extension CreateApprovalTeamInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateApprovalTeamInput(approvalStrategy: \(Swift.String(describing: approvalStrategy)), approvers: \(Swift.String(describing: approvers)), clientToken: \(Swift.String(describing: clientToken)), name: \(Swift.String(describing: name)), policies: \(Swift.String(describing: policies)), description: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

public struct CreateApprovalTeamOutput: Swift.Sendable {
    /// Amazon Resource Name (ARN) for the team that was created.
    public var arn: Swift.String?
    /// Timestamp when the team was created.
    public var creationTime: Foundation.Date?
    /// Name of the team that was created.
    public var name: Swift.String?
    /// Version ID for the team that was created. When a team is updated, the version ID changes.
    public var versionId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTime: Foundation.Date? = nil,
        name: Swift.String? = nil,
        versionId: Swift.String? = nil
    ) {
        self.arn = arn
        self.creationTime = creationTime
        self.name = name
        self.versionId = versionId
    }
}

/// The specified resource doesn't exist. Check the resource ID, and try again.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Message for the ResourceNotFoundException error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct DeleteInactiveApprovalTeamVersionInput: Swift.Sendable {
    /// Amaazon Resource Name (ARN) for the team.
    /// This member is required.
    public var arn: Swift.String?
    /// Version ID for the team.
    /// This member is required.
    public var versionId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        versionId: Swift.String? = nil
    ) {
        self.arn = arn
        self.versionId = versionId
    }
}

public struct DeleteInactiveApprovalTeamVersionOutput: Swift.Sendable {

    public init() { }
}

public struct GetApprovalTeamInput: Swift.Sendable {
    /// Amazon Resource Name (ARN) for the team.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    ) {
        self.arn = arn
    }
}

extension MPAClientTypes {

    public enum IdentityStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accepted
        case invalid
        case pending
        case rejected
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentityStatus] {
            return [
                .accepted,
                .invalid,
                .pending,
                .rejected
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accepted: return "ACCEPTED"
            case .invalid: return "INVALID"
            case .pending: return "PENDING"
            case .rejected: return "REJECTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MPAClientTypes {

    /// Contains details for an approver.
    public struct GetApprovalTeamResponseApprover: Swift.Sendable {
        /// ID for the approver.
        public var approverId: Swift.String?
        /// ID for the user.
        public var primaryIdentityId: Swift.String?
        /// Amazon Resource Name (ARN) for the identity source. The identity source manages the user authentication for approvers.
        public var primaryIdentitySourceArn: Swift.String?
        /// Status for the identity source. For example, if an approver has accepted a team invitation with a user authentication method managed by the identity source.
        public var primaryIdentityStatus: MPAClientTypes.IdentityStatus?
        /// Timestamp when the approver responded to an approval team invitation.
        public var responseTime: Foundation.Date?

        public init(
            approverId: Swift.String? = nil,
            primaryIdentityId: Swift.String? = nil,
            primaryIdentitySourceArn: Swift.String? = nil,
            primaryIdentityStatus: MPAClientTypes.IdentityStatus? = nil,
            responseTime: Foundation.Date? = nil
        ) {
            self.approverId = approverId
            self.primaryIdentityId = primaryIdentityId
            self.primaryIdentitySourceArn = primaryIdentitySourceArn
            self.primaryIdentityStatus = primaryIdentityStatus
            self.responseTime = responseTime
        }
    }
}

extension MPAClientTypes {

    public enum ApprovalTeamStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleting
        case inactive
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ApprovalTeamStatus] {
            return [
                .active,
                .deleting,
                .inactive,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleting: return "DELETING"
            case .inactive: return "INACTIVE"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MPAClientTypes {

    public enum ApprovalTeamStatusCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleteFailedApproval
        case deleteFailedValidation
        case deletePendingApproval
        case failedActivation
        case failedValidation
        case pendingActivation
        case updateFailedActivation
        case updateFailedApproval
        case updateFailedValidation
        case updatePendingActivation
        case updatePendingApproval
        case validating
        case sdkUnknown(Swift.String)

        public static var allCases: [ApprovalTeamStatusCode] {
            return [
                .deleteFailedApproval,
                .deleteFailedValidation,
                .deletePendingApproval,
                .failedActivation,
                .failedValidation,
                .pendingActivation,
                .updateFailedActivation,
                .updateFailedApproval,
                .updateFailedValidation,
                .updatePendingActivation,
                .updatePendingApproval,
                .validating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleteFailedApproval: return "DELETE_FAILED_APPROVAL"
            case .deleteFailedValidation: return "DELETE_FAILED_VALIDATION"
            case .deletePendingApproval: return "DELETE_PENDING_APPROVAL"
            case .failedActivation: return "FAILED_ACTIVATION"
            case .failedValidation: return "FAILED_VALIDATION"
            case .pendingActivation: return "PENDING_ACTIVATION"
            case .updateFailedActivation: return "UPDATE_FAILED_ACTIVATION"
            case .updateFailedApproval: return "UPDATE_FAILED_APPROVAL"
            case .updateFailedValidation: return "UPDATE_FAILED_VALIDATION"
            case .updatePendingActivation: return "UPDATE_PENDING_ACTIVATION"
            case .updatePendingApproval: return "UPDATE_PENDING_APPROVAL"
            case .validating: return "VALIDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MPAClientTypes {

    /// Contains details for the pending updates for an approval team, if applicable.
    public struct PendingUpdate: Swift.Sendable {
        /// An ApprovalStrategyResponse object. Contains details for how the team grants approval.
        public var approvalStrategy: MPAClientTypes.ApprovalStrategyResponse?
        /// An array of GetApprovalTeamResponseApprover  objects. Contains details for the approvers in the team.
        public var approvers: [MPAClientTypes.GetApprovalTeamResponseApprover]?
        /// Description for the team.
        public var description: Swift.String?
        /// Total number of approvers in the team.
        public var numberOfApprovers: Swift.Int?
        /// Status for the team. For more information, see [Team health](https://docs.aws.amazon.com/mpa/latest/userguide/mpa-health.html) in the Multi-party approval User Guide.
        public var status: MPAClientTypes.ApprovalTeamStatus?
        /// Status code for the update. For more information, see [Team health](https://docs.aws.amazon.com/mpa/latest/userguide/mpa-health.html) in the Multi-party approval User Guide.
        public var statusCode: MPAClientTypes.ApprovalTeamStatusCode?
        /// Message describing the status for the team.
        public var statusMessage: Swift.String?
        /// Timestamp when the update request was initiated.
        public var updateInitiationTime: Foundation.Date?
        /// Version ID for the team.
        public var versionId: Swift.String?

        public init(
            approvalStrategy: MPAClientTypes.ApprovalStrategyResponse? = nil,
            approvers: [MPAClientTypes.GetApprovalTeamResponseApprover]? = nil,
            description: Swift.String? = nil,
            numberOfApprovers: Swift.Int? = nil,
            status: MPAClientTypes.ApprovalTeamStatus? = nil,
            statusCode: MPAClientTypes.ApprovalTeamStatusCode? = nil,
            statusMessage: Swift.String? = nil,
            updateInitiationTime: Foundation.Date? = nil,
            versionId: Swift.String? = nil
        ) {
            self.approvalStrategy = approvalStrategy
            self.approvers = approvers
            self.description = description
            self.numberOfApprovers = numberOfApprovers
            self.status = status
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.updateInitiationTime = updateInitiationTime
            self.versionId = versionId
        }
    }
}

public struct GetApprovalTeamOutput: Swift.Sendable {
    /// An ApprovalStrategyResponse object. Contains details for how the team grants approval.
    public var approvalStrategy: MPAClientTypes.ApprovalStrategyResponse?
    /// An array of GetApprovalTeamResponseApprover  objects. Contains details for the approvers in the team.
    public var approvers: [MPAClientTypes.GetApprovalTeamResponseApprover]?
    /// Amazon Resource Name (ARN) for the team.
    public var arn: Swift.String?
    /// Timestamp when the team was created.
    public var creationTime: Foundation.Date?
    /// Description for the team.
    public var description: Swift.String?
    /// Timestamp when the team was last updated.
    public var lastUpdateTime: Foundation.Date?
    /// Name of the approval team.
    public var name: Swift.String?
    /// Total number of approvers in the team.
    public var numberOfApprovers: Swift.Int?
    /// A PendingUpdate object. Contains details for the pending updates for the team, if applicable.
    public var pendingUpdate: MPAClientTypes.PendingUpdate?
    /// An array of PolicyReference objects. Contains a list of policies that define the permissions for team resources. The protected operation for a service integration might require specific permissions. For more information, see [How other services work with Multi-party approval](https://docs.aws.amazon.com/mpa/latest/userguide/mpa-integrations.html) in the Multi-party approval User Guide.
    public var policies: [MPAClientTypes.PolicyReference]?
    /// Status for the team. For more information, see [Team health](https://docs.aws.amazon.com/mpa/latest/userguide/mpa-health.html) in the Multi-party approval User Guide.
    public var status: MPAClientTypes.ApprovalTeamStatus?
    /// Status code for the approval team. For more information, see [Team health](https://docs.aws.amazon.com/mpa/latest/userguide/mpa-health.html) in the Multi-party approval User Guide.
    public var statusCode: MPAClientTypes.ApprovalTeamStatusCode?
    /// Message describing the status for the team.
    public var statusMessage: Swift.String?
    /// Amazon Resource Name (ARN) for the session.
    public var updateSessionArn: Swift.String?
    /// Version ID for the team.
    public var versionId: Swift.String?

    public init(
        approvalStrategy: MPAClientTypes.ApprovalStrategyResponse? = nil,
        approvers: [MPAClientTypes.GetApprovalTeamResponseApprover]? = nil,
        arn: Swift.String? = nil,
        creationTime: Foundation.Date? = nil,
        description: Swift.String? = nil,
        lastUpdateTime: Foundation.Date? = nil,
        name: Swift.String? = nil,
        numberOfApprovers: Swift.Int? = nil,
        pendingUpdate: MPAClientTypes.PendingUpdate? = nil,
        policies: [MPAClientTypes.PolicyReference]? = nil,
        status: MPAClientTypes.ApprovalTeamStatus? = nil,
        statusCode: MPAClientTypes.ApprovalTeamStatusCode? = nil,
        statusMessage: Swift.String? = nil,
        updateSessionArn: Swift.String? = nil,
        versionId: Swift.String? = nil
    ) {
        self.approvalStrategy = approvalStrategy
        self.approvers = approvers
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.lastUpdateTime = lastUpdateTime
        self.name = name
        self.numberOfApprovers = numberOfApprovers
        self.pendingUpdate = pendingUpdate
        self.policies = policies
        self.status = status
        self.statusCode = statusCode
        self.statusMessage = statusMessage
        self.updateSessionArn = updateSessionArn
        self.versionId = versionId
    }
}

extension GetApprovalTeamOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetApprovalTeamOutput(approvalStrategy: \(Swift.String(describing: approvalStrategy)), approvers: \(Swift.String(describing: approvers)), arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), lastUpdateTime: \(Swift.String(describing: lastUpdateTime)), name: \(Swift.String(describing: name)), numberOfApprovers: \(Swift.String(describing: numberOfApprovers)), pendingUpdate: \(Swift.String(describing: pendingUpdate)), policies: \(Swift.String(describing: policies)), status: \(Swift.String(describing: status)), statusCode: \(Swift.String(describing: statusCode)), statusMessage: \(Swift.String(describing: statusMessage)), updateSessionArn: \(Swift.String(describing: updateSessionArn)), versionId: \(Swift.String(describing: versionId)), description: \"CONTENT_REDACTED\")"}
}

public struct ListApprovalTeamsInput: Swift.Sendable {
    /// The maximum number of items to return in the response. If more results exist than the specified MaxResults value, a token is included in the response so that you can retrieve the remaining results.
    public var maxResults: Swift.Int?
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a next call to the operation to get more output. You can repeat this until the NextToken response element returns null.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension MPAClientTypes {

    /// Contains details for an approval team
    public struct ListApprovalTeamsResponseApprovalTeam: Swift.Sendable {
        /// An ApprovalStrategyResponse object. Contains details for how an approval team grants approval.
        public var approvalStrategy: MPAClientTypes.ApprovalStrategyResponse?
        /// Amazon Resource Name (ARN) for the team.
        public var arn: Swift.String?
        /// Timestamp when the team was created.
        public var creationTime: Foundation.Date?
        /// Description for the team.
        public var description: Swift.String?
        /// Name of the team.
        public var name: Swift.String?
        /// Total number of approvers in the team.
        public var numberOfApprovers: Swift.Int?
        /// Status for the team. For more information, see [Team health](https://docs.aws.amazon.com/mpa/latest/userguide/mpa-health.html) in the Multi-party approval User Guide.
        public var status: MPAClientTypes.ApprovalTeamStatus?
        /// Status code for the team. For more information, see [Team health](https://docs.aws.amazon.com/mpa/latest/userguide/mpa-health.html) in the Multi-party approval User Guide.
        public var statusCode: MPAClientTypes.ApprovalTeamStatusCode?
        /// Message describing the status for the team.
        public var statusMessage: Swift.String?

        public init(
            approvalStrategy: MPAClientTypes.ApprovalStrategyResponse? = nil,
            arn: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            numberOfApprovers: Swift.Int? = nil,
            status: MPAClientTypes.ApprovalTeamStatus? = nil,
            statusCode: MPAClientTypes.ApprovalTeamStatusCode? = nil,
            statusMessage: Swift.String? = nil
        ) {
            self.approvalStrategy = approvalStrategy
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.name = name
            self.numberOfApprovers = numberOfApprovers
            self.status = status
            self.statusCode = statusCode
            self.statusMessage = statusMessage
        }
    }
}

extension MPAClientTypes.ListApprovalTeamsResponseApprovalTeam: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListApprovalTeamsResponseApprovalTeam(approvalStrategy: \(Swift.String(describing: approvalStrategy)), arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), name: \(Swift.String(describing: name)), numberOfApprovers: \(Swift.String(describing: numberOfApprovers)), status: \(Swift.String(describing: status)), statusCode: \(Swift.String(describing: statusCode)), statusMessage: \(Swift.String(describing: statusMessage)), description: \"CONTENT_REDACTED\")"}
}

public struct ListApprovalTeamsOutput: Swift.Sendable {
    /// An array of ListApprovalTeamsResponseApprovalTeam objects. Contains details for approval teams.
    public var approvalTeams: [MPAClientTypes.ListApprovalTeamsResponseApprovalTeam]?
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a next call to the operation to get more output. You can repeat this until the NextToken response element returns null.
    public var nextToken: Swift.String?

    public init(
        approvalTeams: [MPAClientTypes.ListApprovalTeamsResponseApprovalTeam]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.approvalTeams = approvalTeams
        self.nextToken = nextToken
    }
}

public struct StartActiveApprovalTeamDeletionInput: Swift.Sendable {
    /// Amazon Resource Name (ARN) for the team.
    /// This member is required.
    public var arn: Swift.String?
    /// Number of days between when the team approves the delete request and when the team is deleted.
    public var pendingWindowDays: Swift.Int?

    public init(
        arn: Swift.String? = nil,
        pendingWindowDays: Swift.Int? = nil
    ) {
        self.arn = arn
        self.pendingWindowDays = pendingWindowDays
    }
}

public struct StartActiveApprovalTeamDeletionOutput: Swift.Sendable {
    /// Timestamp when the deletion process is scheduled to complete.
    public var deletionCompletionTime: Foundation.Date?
    /// Timestamp when the deletion process was initiated.
    public var deletionStartTime: Foundation.Date?

    public init(
        deletionCompletionTime: Foundation.Date? = nil,
        deletionStartTime: Foundation.Date? = nil
    ) {
        self.deletionCompletionTime = deletionCompletionTime
        self.deletionStartTime = deletionStartTime
    }
}

public struct UpdateApprovalTeamInput: Swift.Sendable {
    /// An ApprovalStrategy object. Contains details for how the team grants approval.
    public var approvalStrategy: MPAClientTypes.ApprovalStrategy?
    /// An array of ApprovalTeamRequestApprover objects. Contains details for the approvers in the team.
    public var approvers: [MPAClientTypes.ApprovalTeamRequestApprover]?
    /// Amazon Resource Name (ARN) for the team.
    /// This member is required.
    public var arn: Swift.String?
    /// Description for the team.
    public var description: Swift.String?

    public init(
        approvalStrategy: MPAClientTypes.ApprovalStrategy? = nil,
        approvers: [MPAClientTypes.ApprovalTeamRequestApprover]? = nil,
        arn: Swift.String? = nil,
        description: Swift.String? = nil
    ) {
        self.approvalStrategy = approvalStrategy
        self.approvers = approvers
        self.arn = arn
        self.description = description
    }
}

extension UpdateApprovalTeamInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateApprovalTeamInput(approvalStrategy: \(Swift.String(describing: approvalStrategy)), approvers: \(Swift.String(describing: approvers)), arn: \(Swift.String(describing: arn)), description: \"CONTENT_REDACTED\")"}
}

public struct UpdateApprovalTeamOutput: Swift.Sendable {
    /// Version ID for the team that was created. When an approval team is updated, the version ID changes.
    public var versionId: Swift.String?

    public init(
        versionId: Swift.String? = nil
    ) {
        self.versionId = versionId
    }
}

public struct GetPolicyVersionInput: Swift.Sendable {
    /// Amazon Resource Name (ARN) for the policy.
    /// This member is required.
    public var policyVersionArn: Swift.String?

    public init(
        policyVersionArn: Swift.String? = nil
    ) {
        self.policyVersionArn = policyVersionArn
    }
}

extension MPAClientTypes {

    public enum PolicyType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsManaged
        case awsRam
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyType] {
            return [
                .awsManaged,
                .awsRam
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsManaged: return "AWS_MANAGED"
            case .awsRam: return "AWS_RAM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MPAClientTypes {

    public enum PolicyStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case attachable
        case deprecated
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyStatus] {
            return [
                .attachable,
                .deprecated
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .attachable: return "ATTACHABLE"
            case .deprecated: return "DEPRECATED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MPAClientTypes {

    /// Contains details for the version of a policy. Policies define what operations a team that define the permissions for team resources. The protected operation for a service integration might require specific permissions. For more information, see [How other services work with Multi-party approval](https://docs.aws.amazon.com/mpa/latest/userguide/mpa-integrations.html) in the Multi-party approval User Guide.
    public struct PolicyVersion: Swift.Sendable {
        /// Amazon Resource Name (ARN) for the team.
        /// This member is required.
        public var arn: Swift.String?
        /// Timestamp when the policy was created.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// Document that contains the policy contents.
        /// This member is required.
        public var document: Swift.String?
        /// Determines if the specified policy is the default for the team.
        /// This member is required.
        public var isDefault: Swift.Bool?
        /// Timestamp when the policy was last updated.
        /// This member is required.
        public var lastUpdatedTime: Foundation.Date?
        /// Name of the policy.
        /// This member is required.
        public var name: Swift.String?
        /// Amazon Resource Name (ARN) for the policy.
        /// This member is required.
        public var policyArn: Swift.String?
        /// The type of policy.
        /// This member is required.
        public var policyType: MPAClientTypes.PolicyType?
        /// Status for the policy. For example, if the policy is [attachable](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_groups_manage_attach-policy.html) or [deprecated](https://docs.aws.amazon.com/access_policies_managed-deprecated.html).
        /// This member is required.
        public var status: MPAClientTypes.PolicyStatus?
        /// Verison ID
        /// This member is required.
        public var versionId: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            document: Swift.String? = nil,
            isDefault: Swift.Bool? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            policyArn: Swift.String? = nil,
            policyType: MPAClientTypes.PolicyType? = nil,
            status: MPAClientTypes.PolicyStatus? = nil,
            versionId: Swift.Int? = nil
        ) {
            self.arn = arn
            self.creationTime = creationTime
            self.document = document
            self.isDefault = isDefault
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.policyArn = policyArn
            self.policyType = policyType
            self.status = status
            self.versionId = versionId
        }
    }
}

extension MPAClientTypes.PolicyVersion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PolicyVersion(arn: \(Swift.String(describing: arn)), creationTime: \(Swift.String(describing: creationTime)), isDefault: \(Swift.String(describing: isDefault)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), name: \(Swift.String(describing: name)), policyArn: \(Swift.String(describing: policyArn)), policyType: \(Swift.String(describing: policyType)), status: \(Swift.String(describing: status)), versionId: \(Swift.String(describing: versionId)), document: \"CONTENT_REDACTED\")"}
}

public struct GetPolicyVersionOutput: Swift.Sendable {
    /// A PolicyVersion object. Contains details for the version of the policy. Policies define the permissions for team resources. The protected operation for a service integration might require specific permissions. For more information, see [How other services work with Multi-party approval](https://docs.aws.amazon.com/mpa/latest/userguide/mpa-integrations.html) in the Multi-party approval User Guide.
    /// This member is required.
    public var policyVersion: MPAClientTypes.PolicyVersion?

    public init(
        policyVersion: MPAClientTypes.PolicyVersion? = nil
    ) {
        self.policyVersion = policyVersion
    }
}

/// The request contains an invalid parameter value.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Message for the InvalidParameterException error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct GetResourcePolicyInput: Swift.Sendable {
    /// Name of the policy.
    /// This member is required.
    public var policyName: Swift.String?
    /// The type of policy.
    /// This member is required.
    public var policyType: MPAClientTypes.PolicyType?
    /// Amazon Resource Name (ARN) for the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        policyName: Swift.String? = nil,
        policyType: MPAClientTypes.PolicyType? = nil,
        resourceArn: Swift.String? = nil
    ) {
        self.policyName = policyName
        self.policyType = policyType
        self.resourceArn = resourceArn
    }
}

public struct GetResourcePolicyOutput: Swift.Sendable {
    /// Document that contains the contents for the policy.
    /// This member is required.
    public var policyDocument: Swift.String?
    /// Name of the policy.
    /// This member is required.
    public var policyName: Swift.String?
    /// The type of policy
    /// This member is required.
    public var policyType: MPAClientTypes.PolicyType?
    /// Amazon Resource Name (ARN) for the policy version.
    public var policyVersionArn: Swift.String?
    /// Amazon Resource Name (ARN) for the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        policyDocument: Swift.String? = nil,
        policyName: Swift.String? = nil,
        policyType: MPAClientTypes.PolicyType? = nil,
        policyVersionArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    ) {
        self.policyDocument = policyDocument
        self.policyName = policyName
        self.policyType = policyType
        self.policyVersionArn = policyVersionArn
        self.resourceArn = resourceArn
    }
}

extension GetResourcePolicyOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourcePolicyOutput(policyName: \(Swift.String(describing: policyName)), policyType: \(Swift.String(describing: policyType)), policyVersionArn: \(Swift.String(describing: policyVersionArn)), resourceArn: \(Swift.String(describing: resourceArn)), policyDocument: \"CONTENT_REDACTED\")"}
}

extension MPAClientTypes {

    /// IAM Identity Center credentials. For more information see, [IAM Identity Center](http://aws.amazon.com/identity-center/) .
    public struct IamIdentityCenter: Swift.Sendable {
        /// Amazon Resource Name (ARN) for the IAM Identity Center instance.
        /// This member is required.
        public var instanceArn: Swift.String?
        /// Amazon Web Services Region where the IAM Identity Center instance is located.
        /// This member is required.
        public var region: Swift.String?

        public init(
            instanceArn: Swift.String? = nil,
            region: Swift.String? = nil
        ) {
            self.instanceArn = instanceArn
            self.region = region
        }
    }
}

extension MPAClientTypes {

    /// Contains details for the resource that provides identities to the identity source. For example, an IAM Identity Center instance.
    public struct IdentitySourceParameters: Swift.Sendable {
        /// IAM Identity Center credentials.
        public var iamIdentityCenter: MPAClientTypes.IamIdentityCenter?

        public init(
            iamIdentityCenter: MPAClientTypes.IamIdentityCenter? = nil
        ) {
            self.iamIdentityCenter = iamIdentityCenter
        }
    }
}

public struct CreateIdentitySourceInput: Swift.Sendable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services populates this field. What is idempotency? When you make a mutating API request, the request typically returns a result before the operation's asynchronous workflows have completed. Operations might also time out or encounter other server issues before they complete, even though the request has already returned a result. This could make it difficult to determine whether the request succeeded or not, and could lead to multiple retries to ensure that the operation completes successfully. However, if the original request and the subsequent retries are successful, the operation is completed multiple times. This means that you might create more resources than you intended. Idempotency ensures that an API request completes no more than one time. With an idempotent request, if the original request completes successfully, any subsequent retries complete successfully without performing any further actions.
    public var clientToken: Swift.String?
    /// A  IdentitySourceParameters object. Contains details for the resource that provides identities to the identity source. For example, an IAM Identity Center instance.
    /// This member is required.
    public var identitySourceParameters: MPAClientTypes.IdentitySourceParameters?
    /// Tag you want to attach to the identity source.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        identitySourceParameters: MPAClientTypes.IdentitySourceParameters? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.clientToken = clientToken
        self.identitySourceParameters = identitySourceParameters
        self.tags = tags
    }
}

extension CreateIdentitySourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateIdentitySourceInput(clientToken: \(Swift.String(describing: clientToken)), identitySourceParameters: \(Swift.String(describing: identitySourceParameters)), tags: \"CONTENT_REDACTED\")"}
}

extension MPAClientTypes {

    public enum IdentitySourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case iamIdentityCenter
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentitySourceType] {
            return [
                .iamIdentityCenter
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .iamIdentityCenter: return "IAM_IDENTITY_CENTER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateIdentitySourceOutput: Swift.Sendable {
    /// Timestamp when the identity source was created.
    public var creationTime: Foundation.Date?
    /// Amazon Resource Name (ARN) for the identity source that was created.
    public var identitySourceArn: Swift.String?
    /// The type of resource that provided identities to the identity source. For example, an IAM Identity Center instance.
    public var identitySourceType: MPAClientTypes.IdentitySourceType?

    public init(
        creationTime: Foundation.Date? = nil,
        identitySourceArn: Swift.String? = nil,
        identitySourceType: MPAClientTypes.IdentitySourceType? = nil
    ) {
        self.creationTime = creationTime
        self.identitySourceArn = identitySourceArn
        self.identitySourceType = identitySourceType
    }
}

public struct DeleteIdentitySourceInput: Swift.Sendable {
    /// Amazon Resource Name (ARN) for identity source.
    /// This member is required.
    public var identitySourceArn: Swift.String?

    public init(
        identitySourceArn: Swift.String? = nil
    ) {
        self.identitySourceArn = identitySourceArn
    }
}

public struct GetIdentitySourceInput: Swift.Sendable {
    /// Amazon Resource Name (ARN) for the identity source.
    /// This member is required.
    public var identitySourceArn: Swift.String?

    public init(
        identitySourceArn: Swift.String? = nil
    ) {
        self.identitySourceArn = identitySourceArn
    }
}

extension MPAClientTypes {

    /// IAM Identity Center credentials. For more information see, [IAM Identity Center](http://aws.amazon.com/identity-center/) .
    public struct IamIdentityCenterForGet: Swift.Sendable {
        /// URL for the approval portal associated with the IAM Identity Center instance.
        public var approvalPortalUrl: Swift.String?
        /// Amazon Resource Name (ARN) for the IAM Identity Center instance.
        public var instanceArn: Swift.String?
        /// Amazon Web Services Region where the IAM Identity Center instance is located.
        public var region: Swift.String?

        public init(
            approvalPortalUrl: Swift.String? = nil,
            instanceArn: Swift.String? = nil,
            region: Swift.String? = nil
        ) {
            self.approvalPortalUrl = approvalPortalUrl
            self.instanceArn = instanceArn
            self.region = region
        }
    }
}

extension MPAClientTypes {

    /// Contains details for the resource that provides identities to the identity source. For example, an IAM Identity Center instance. For more information, see [Identity source](https://docs.aws.amazon.com/mpa/latest/userguide/mpa-concepts.html) in the Multi-party approval User Guide.
    public enum IdentitySourceParametersForGet: Swift.Sendable {
        /// IAM Identity Center credentials.
        case iamidentitycenter(MPAClientTypes.IamIdentityCenterForGet)
        case sdkUnknown(Swift.String)
    }
}

extension MPAClientTypes {

    public enum IdentitySourceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleting
        case error
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentitySourceStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .error
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .error: return "ERROR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MPAClientTypes {

    public enum IdentitySourceStatusCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessDenied
        case deletionFailed
        case idcInstanceNotFound
        case idcInstanceNotValid
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentitySourceStatusCode] {
            return [
                .accessDenied,
                .deletionFailed,
                .idcInstanceNotFound,
                .idcInstanceNotValid
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .deletionFailed: return "DELETION_FAILED"
            case .idcInstanceNotFound: return "IDC_INSTANCE_NOT_FOUND"
            case .idcInstanceNotValid: return "IDC_INSTANCE_NOT_VALID"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetIdentitySourceOutput: Swift.Sendable {
    /// Timestamp when the identity source was created.
    public var creationTime: Foundation.Date?
    /// Amazon Resource Name (ARN) for the identity source.
    public var identitySourceArn: Swift.String?
    /// A  IdentitySourceParameters object. Contains details for the resource that provides identities to the identity source. For example, an IAM Identity Center instance.
    public var identitySourceParameters: MPAClientTypes.IdentitySourceParametersForGet?
    /// The type of resource that provided identities to the identity source. For example, an IAM Identity Center instance.
    public var identitySourceType: MPAClientTypes.IdentitySourceType?
    /// Status for the identity source. For example, if the identity source is ACTIVE.
    public var status: MPAClientTypes.IdentitySourceStatus?
    /// Status code of the identity source.
    public var statusCode: MPAClientTypes.IdentitySourceStatusCode?
    /// Message describing the status for the identity source.
    public var statusMessage: Swift.String?

    public init(
        creationTime: Foundation.Date? = nil,
        identitySourceArn: Swift.String? = nil,
        identitySourceParameters: MPAClientTypes.IdentitySourceParametersForGet? = nil,
        identitySourceType: MPAClientTypes.IdentitySourceType? = nil,
        status: MPAClientTypes.IdentitySourceStatus? = nil,
        statusCode: MPAClientTypes.IdentitySourceStatusCode? = nil,
        statusMessage: Swift.String? = nil
    ) {
        self.creationTime = creationTime
        self.identitySourceArn = identitySourceArn
        self.identitySourceParameters = identitySourceParameters
        self.identitySourceType = identitySourceType
        self.status = status
        self.statusCode = statusCode
        self.statusMessage = statusMessage
    }
}

public struct ListIdentitySourcesInput: Swift.Sendable {
    /// The maximum number of items to return in the response. If more results exist than the specified MaxResults value, a token is included in the response so that you can retrieve the remaining results.
    public var maxResults: Swift.Int?
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a next call to the operation to get more output. You can repeat this until the NextToken response element returns null.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension MPAClientTypes {

    /// IAM Identity Center credentials. For more information see, [IAM Identity Center](http://aws.amazon.com/identity-center/) .
    public struct IamIdentityCenterForList: Swift.Sendable {
        /// URL for the approval portal associated with the IAM Identity Center instance.
        public var approvalPortalUrl: Swift.String?
        /// Amazon Resource Name (ARN) for the IAM Identity Center instance.
        public var instanceArn: Swift.String?
        /// Amazon Web Services Region where the IAM Identity Center instance is located.
        public var region: Swift.String?

        public init(
            approvalPortalUrl: Swift.String? = nil,
            instanceArn: Swift.String? = nil,
            region: Swift.String? = nil
        ) {
            self.approvalPortalUrl = approvalPortalUrl
            self.instanceArn = instanceArn
            self.region = region
        }
    }
}

extension MPAClientTypes {

    /// Contains details for the resource that provides identities to the identity source. For example, an IAM Identity Center instance. For more information, see [Identity source](https://docs.aws.amazon.com/mpa/latest/userguide/mpa-concepts.html) in the Multi-party approval User Guide.
    public enum IdentitySourceParametersForList: Swift.Sendable {
        /// IAM Identity Center credentials.
        case iamidentitycenter(MPAClientTypes.IamIdentityCenterForList)
        case sdkUnknown(Swift.String)
    }
}

extension MPAClientTypes {

    /// Contains details for an identity source. For more information, see [Identity source](https://docs.aws.amazon.com/mpa/latest/userguide/mpa-concepts.html) in the Multi-party approval User Guide.
    public struct IdentitySourceForList: Swift.Sendable {
        /// Timestamp when the identity source was created.
        public var creationTime: Foundation.Date?
        /// Amazon Resource Name (ARN) for the identity source.
        public var identitySourceArn: Swift.String?
        /// A IdentitySourceParametersForList object. Contains details for the resource that provides identities to the identity source. For example, an IAM Identity Center instance.
        public var identitySourceParameters: MPAClientTypes.IdentitySourceParametersForList?
        /// The type of resource that provided identities to the identity source. For example, an IAM Identity Center instance.
        public var identitySourceType: MPAClientTypes.IdentitySourceType?
        /// Status for the identity source. For example, if the identity source is ACTIVE.
        public var status: MPAClientTypes.IdentitySourceStatus?
        /// Status code of the identity source.
        public var statusCode: MPAClientTypes.IdentitySourceStatusCode?
        /// Message describing the status for the identity source.
        public var statusMessage: Swift.String?

        public init(
            creationTime: Foundation.Date? = nil,
            identitySourceArn: Swift.String? = nil,
            identitySourceParameters: MPAClientTypes.IdentitySourceParametersForList? = nil,
            identitySourceType: MPAClientTypes.IdentitySourceType? = nil,
            status: MPAClientTypes.IdentitySourceStatus? = nil,
            statusCode: MPAClientTypes.IdentitySourceStatusCode? = nil,
            statusMessage: Swift.String? = nil
        ) {
            self.creationTime = creationTime
            self.identitySourceArn = identitySourceArn
            self.identitySourceParameters = identitySourceParameters
            self.identitySourceType = identitySourceType
            self.status = status
            self.statusCode = statusCode
            self.statusMessage = statusMessage
        }
    }
}

public struct ListIdentitySourcesOutput: Swift.Sendable {
    /// A IdentitySources. Contains details for identity sources.
    public var identitySources: [MPAClientTypes.IdentitySourceForList]?
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a next call to the operation to get more output. You can repeat this until the NextToken response element returns null.
    public var nextToken: Swift.String?

    public init(
        identitySources: [MPAClientTypes.IdentitySourceForList]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.identitySources = identitySources
        self.nextToken = nextToken
    }
}

public struct ListPoliciesInput: Swift.Sendable {
    /// The maximum number of items to return in the response. If more results exist than the specified MaxResults value, a token is included in the response so that you can retrieve the remaining results.
    public var maxResults: Swift.Int?
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a next call to the operation to get more output. You can repeat this until the NextToken response element returns null.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension MPAClientTypes {

    /// Contains details for a policy. Policies define what operations a team that define the permissions for team resources. The protected operation for a service integration might require specific permissions. For more information, see [How other services work with Multi-party approval](https://docs.aws.amazon.com/mpa/latest/userguide/mpa-integrations.html) in the Multi-party approval User Guide.
    public struct Policy: Swift.Sendable {
        /// Amazon Resource Name (ARN) for the policy.
        /// This member is required.
        public var arn: Swift.String?
        /// Determines if the specified policy is the default for the team.
        /// This member is required.
        public var defaultVersion: Swift.Int?
        /// Name of the policy.
        /// This member is required.
        public var name: Swift.String?
        /// The type of policy.
        /// This member is required.
        public var policyType: MPAClientTypes.PolicyType?

        public init(
            arn: Swift.String? = nil,
            defaultVersion: Swift.Int? = nil,
            name: Swift.String? = nil,
            policyType: MPAClientTypes.PolicyType? = nil
        ) {
            self.arn = arn
            self.defaultVersion = defaultVersion
            self.name = name
            self.policyType = policyType
        }
    }
}

public struct ListPoliciesOutput: Swift.Sendable {
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a next call to the operation to get more output. You can repeat this until the NextToken response element returns null.
    public var nextToken: Swift.String?
    /// An array of Policy objects. Contains a list of policies that define the permissions for team resources. The protected operation for a service integration might require specific permissions. For more information, see [How other services work with Multi-party approval](https://docs.aws.amazon.com/mpa/latest/userguide/mpa-integrations.html) in the Multi-party approval User Guide.
    public var policies: [MPAClientTypes.Policy]?

    public init(
        nextToken: Swift.String? = nil,
        policies: [MPAClientTypes.Policy]? = nil
    ) {
        self.nextToken = nextToken
        self.policies = policies
    }
}

public struct ListPolicyVersionsInput: Swift.Sendable {
    /// The maximum number of items to return in the response. If more results exist than the specified MaxResults value, a token is included in the response so that you can retrieve the remaining results.
    public var maxResults: Swift.Int?
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a next call to the operation to get more output. You can repeat this until the NextToken response element returns null.
    public var nextToken: Swift.String?
    /// Amazon Resource Name (ARN) for the policy.
    /// This member is required.
    public var policyArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        policyArn: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.policyArn = policyArn
    }
}

extension MPAClientTypes {

    /// Contains details for the version of a policy. Policies define what operations a team that define the permissions for team resources. The protected operation for a service integration might require specific permissions. For more information, see [How other services work with Multi-party approval](https://docs.aws.amazon.com/mpa/latest/userguide/mpa-integrations.html) in the Multi-party approval User Guide.
    public struct PolicyVersionSummary: Swift.Sendable {
        /// Amazon Resource Name (ARN) for the team.
        /// This member is required.
        public var arn: Swift.String?
        /// Timestamp when the policy was created.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// Determines if the specified policy is the default for the team.
        /// This member is required.
        public var isDefault: Swift.Bool?
        /// Timestamp when the policy was last updated.
        /// This member is required.
        public var lastUpdatedTime: Foundation.Date?
        /// Name of the policy
        /// This member is required.
        public var name: Swift.String?
        /// Amazon Resource Name (ARN) for the policy.
        /// This member is required.
        public var policyArn: Swift.String?
        /// The type of policy.
        /// This member is required.
        public var policyType: MPAClientTypes.PolicyType?
        /// Status for the policy. For example, if the policy is [attachable](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_groups_manage_attach-policy.html) or [deprecated](https://docs.aws.amazon.com/access_policies_managed-deprecated.html).
        /// This member is required.
        public var status: MPAClientTypes.PolicyStatus?
        /// Version ID for the policy.
        /// This member is required.
        public var versionId: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            isDefault: Swift.Bool? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            policyArn: Swift.String? = nil,
            policyType: MPAClientTypes.PolicyType? = nil,
            status: MPAClientTypes.PolicyStatus? = nil,
            versionId: Swift.Int? = nil
        ) {
            self.arn = arn
            self.creationTime = creationTime
            self.isDefault = isDefault
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.policyArn = policyArn
            self.policyType = policyType
            self.status = status
            self.versionId = versionId
        }
    }
}

public struct ListPolicyVersionsOutput: Swift.Sendable {
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a next call to the operation to get more output. You can repeat this until the NextToken response element returns null.
    public var nextToken: Swift.String?
    /// An array of PolicyVersionSummary objects. Contains details for the version of the policies that define the permissions for team resources. The protected operation for a service integration might require specific permissions. For more information, see [How other services work with Multi-party approval](https://docs.aws.amazon.com/mpa/latest/userguide/mpa-integrations.html) in the Multi-party approval User Guide.
    public var policyVersions: [MPAClientTypes.PolicyVersionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        policyVersions: [MPAClientTypes.PolicyVersionSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.policyVersions = policyVersions
    }
}

public struct ListResourcePoliciesInput: Swift.Sendable {
    /// The maximum number of items to return in the response. If more results exist than the specified MaxResults value, a token is included in the response so that you can retrieve the remaining results.
    public var maxResults: Swift.Int?
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a next call to the operation to get more output. You can repeat this until the NextToken response element returns null.
    public var nextToken: Swift.String?
    /// Amazon Resource Name (ARN) for the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

extension MPAClientTypes {

    /// Contains details about a policy for a resource.
    public struct ListResourcePoliciesResponseResourcePolicy: Swift.Sendable {
        /// Amazon Resource Name (ARN) for policy.
        public var policyArn: Swift.String?
        /// Name of the policy.
        public var policyName: Swift.String?
        /// The type of policy.
        public var policyType: MPAClientTypes.PolicyType?

        public init(
            policyArn: Swift.String? = nil,
            policyName: Swift.String? = nil,
            policyType: MPAClientTypes.PolicyType? = nil
        ) {
            self.policyArn = policyArn
            self.policyName = policyName
            self.policyType = policyType
        }
    }
}

public struct ListResourcePoliciesOutput: Swift.Sendable {
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a next call to the operation to get more output. You can repeat this until the NextToken response element returns null.
    public var nextToken: Swift.String?
    /// An array of ListResourcePoliciesResponseResourcePolicy objects. Contains details about the policy for the resource.
    public var resourcePolicies: [MPAClientTypes.ListResourcePoliciesResponseResourcePolicy]?

    public init(
        nextToken: Swift.String? = nil,
        resourcePolicies: [MPAClientTypes.ListResourcePoliciesResponseResourcePolicy]? = nil
    ) {
        self.nextToken = nextToken
        self.resourcePolicies = resourcePolicies
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// Amazon Resource Name (ARN) for the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    ) {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// Tags attached to the resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.tags = tags
    }
}

extension ListTagsForResourceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutput(tags: \"CONTENT_REDACTED\")"}
}

public struct CancelSessionInput: Swift.Sendable {
    /// Amazon Resource Name (ARN) for the session.
    /// This member is required.
    public var sessionArn: Swift.String?

    public init(
        sessionArn: Swift.String? = nil
    ) {
        self.sessionArn = sessionArn
    }
}

public struct CancelSessionOutput: Swift.Sendable {

    public init() { }
}

public struct GetSessionInput: Swift.Sendable {
    /// Amazon Resource Name (ARN) for the session.
    /// This member is required.
    public var sessionArn: Swift.String?

    public init(
        sessionArn: Swift.String? = nil
    ) {
        self.sessionArn = sessionArn
    }
}

extension MPAClientTypes {

    public enum SessionResponse: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case approved
        case noResponse
        case rejected
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionResponse] {
            return [
                .approved,
                .noResponse,
                .rejected
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .approved: return "APPROVED"
            case .noResponse: return "NO_RESPONSE"
            case .rejected: return "REJECTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MPAClientTypes {

    /// Contains details for an approver response in an approval session.
    public struct GetSessionResponseApproverResponse: Swift.Sendable {
        /// ID for the approver.
        public var approverId: Swift.String?
        /// ID for the identity source. The identity source manages the user authentication for approvers.
        public var identityId: Swift.String?
        /// Amazon Resource Name (ARN) for the identity source. The identity source manages the user authentication for approvers.
        public var identitySourceArn: Swift.String?
        /// Response to the operation request.
        public var response: MPAClientTypes.SessionResponse?
        /// Timestamp when a approver responded to the operation request.
        public var responseTime: Foundation.Date?

        public init(
            approverId: Swift.String? = nil,
            identityId: Swift.String? = nil,
            identitySourceArn: Swift.String? = nil,
            response: MPAClientTypes.SessionResponse? = nil,
            responseTime: Foundation.Date? = nil
        ) {
            self.approverId = approverId
            self.identityId = identityId
            self.identitySourceArn = identitySourceArn
            self.response = response
            self.responseTime = responseTime
        }
    }
}

extension MPAClientTypes {

    public enum SessionExecutionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case executed
        case failed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionExecutionStatus] {
            return [
                .executed,
                .failed,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .executed: return "EXECUTED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MPAClientTypes {

    public enum SessionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case approved
        case cancelled
        case creating
        case failed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionStatus] {
            return [
                .approved,
                .cancelled,
                .creating,
                .failed,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .approved: return "APPROVED"
            case .cancelled: return "CANCELLED"
            case .creating: return "CREATING"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MPAClientTypes {

    public enum SessionStatusCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case configurationChanged
        case expired
        case rejected
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionStatusCode] {
            return [
                .configurationChanged,
                .expired,
                .rejected
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .configurationChanged: return "CONFIGURATION_CHANGED"
            case .expired: return "EXPIRED"
            case .rejected: return "REJECTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetSessionOutput: Swift.Sendable {
    /// Strategy for executing the protected operation. AUTO_COMPLETION_UPON_APPROVAL means the operation is automatically executed using the requester's permissions, if approved.
    public var actionCompletionStrategy: MPAClientTypes.ActionCompletionStrategy?
    /// Name of the protected operation.
    public var actionName: Swift.String?
    /// An ApprovalStrategyResponse object. Contains details for how the team grants approval
    public var approvalStrategy: MPAClientTypes.ApprovalStrategyResponse?
    /// Amazon Resource Name (ARN) for the approval team.
    public var approvalTeamArn: Swift.String?
    /// Name of the approval team.
    public var approvalTeamName: Swift.String?
    /// An array of GetSessionResponseApproverResponse objects. Contains details for approver responses in the session.
    public var approverResponses: [MPAClientTypes.GetSessionResponseApproverResponse]?
    /// Timestamp when the session completed.
    public var completionTime: Foundation.Date?
    /// Description for the session.
    public var description: Swift.String?
    /// Status for the protected operation. For example, if the operation is PENDING.
    public var executionStatus: MPAClientTypes.SessionExecutionStatus?
    /// Timestamp when the session will expire.
    public var expirationTime: Foundation.Date?
    /// Timestamp when the session was initiated.
    public var initiationTime: Foundation.Date?
    /// Metadata for the session.
    public var metadata: [Swift.String: Swift.String]?
    /// Total number of approvers in the session.
    public var numberOfApprovers: Swift.Int?
    /// Amazon Resource Name (ARN) for the protected operation.
    public var protectedResourceArn: Swift.String?
    /// ID for the account that made the operation request.
    public var requesterAccountId: Swift.String?
    /// Message from the account that made the operation request
    public var requesterComment: Swift.String?
    /// [IAM principal](https://docs.aws.amazon.com/IAM/latest/UserGuide/intro-structure.html#intro-structure-request) that made the operation request.
    public var requesterPrincipalArn: Swift.String?
    /// Amazon Web Services Region where the operation request originated.
    public var requesterRegion: Swift.String?
    /// [Service principal](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_principal.html#principal-services) for the service associated with the protected operation.
    public var requesterServicePrincipal: Swift.String?
    /// Amazon Resource Name (ARN) for the session.
    public var sessionArn: Swift.String?
    /// Status for the session. For example, if the team has approved the requested operation.
    public var status: MPAClientTypes.SessionStatus?
    /// Status code of the session.
    public var statusCode: MPAClientTypes.SessionStatusCode?
    /// Message describing the status for session.
    public var statusMessage: Swift.String?

    public init(
        actionCompletionStrategy: MPAClientTypes.ActionCompletionStrategy? = nil,
        actionName: Swift.String? = nil,
        approvalStrategy: MPAClientTypes.ApprovalStrategyResponse? = nil,
        approvalTeamArn: Swift.String? = nil,
        approvalTeamName: Swift.String? = nil,
        approverResponses: [MPAClientTypes.GetSessionResponseApproverResponse]? = nil,
        completionTime: Foundation.Date? = nil,
        description: Swift.String? = nil,
        executionStatus: MPAClientTypes.SessionExecutionStatus? = nil,
        expirationTime: Foundation.Date? = nil,
        initiationTime: Foundation.Date? = nil,
        metadata: [Swift.String: Swift.String]? = nil,
        numberOfApprovers: Swift.Int? = nil,
        protectedResourceArn: Swift.String? = nil,
        requesterAccountId: Swift.String? = nil,
        requesterComment: Swift.String? = nil,
        requesterPrincipalArn: Swift.String? = nil,
        requesterRegion: Swift.String? = nil,
        requesterServicePrincipal: Swift.String? = nil,
        sessionArn: Swift.String? = nil,
        status: MPAClientTypes.SessionStatus? = nil,
        statusCode: MPAClientTypes.SessionStatusCode? = nil,
        statusMessage: Swift.String? = nil
    ) {
        self.actionCompletionStrategy = actionCompletionStrategy
        self.actionName = actionName
        self.approvalStrategy = approvalStrategy
        self.approvalTeamArn = approvalTeamArn
        self.approvalTeamName = approvalTeamName
        self.approverResponses = approverResponses
        self.completionTime = completionTime
        self.description = description
        self.executionStatus = executionStatus
        self.expirationTime = expirationTime
        self.initiationTime = initiationTime
        self.metadata = metadata
        self.numberOfApprovers = numberOfApprovers
        self.protectedResourceArn = protectedResourceArn
        self.requesterAccountId = requesterAccountId
        self.requesterComment = requesterComment
        self.requesterPrincipalArn = requesterPrincipalArn
        self.requesterRegion = requesterRegion
        self.requesterServicePrincipal = requesterServicePrincipal
        self.sessionArn = sessionArn
        self.status = status
        self.statusCode = statusCode
        self.statusMessage = statusMessage
    }
}

extension GetSessionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSessionOutput(actionCompletionStrategy: \(Swift.String(describing: actionCompletionStrategy)), actionName: \(Swift.String(describing: actionName)), approvalStrategy: \(Swift.String(describing: approvalStrategy)), approvalTeamArn: \(Swift.String(describing: approvalTeamArn)), approvalTeamName: \(Swift.String(describing: approvalTeamName)), approverResponses: \(Swift.String(describing: approverResponses)), completionTime: \(Swift.String(describing: completionTime)), executionStatus: \(Swift.String(describing: executionStatus)), expirationTime: \(Swift.String(describing: expirationTime)), initiationTime: \(Swift.String(describing: initiationTime)), numberOfApprovers: \(Swift.String(describing: numberOfApprovers)), protectedResourceArn: \(Swift.String(describing: protectedResourceArn)), requesterAccountId: \(Swift.String(describing: requesterAccountId)), requesterPrincipalArn: \(Swift.String(describing: requesterPrincipalArn)), requesterRegion: \(Swift.String(describing: requesterRegion)), requesterServicePrincipal: \(Swift.String(describing: requesterServicePrincipal)), sessionArn: \(Swift.String(describing: sessionArn)), status: \(Swift.String(describing: status)), statusCode: \(Swift.String(describing: statusCode)), statusMessage: \(Swift.String(describing: statusMessage)), description: \"CONTENT_REDACTED\", metadata: \"CONTENT_REDACTED\", requesterComment: \"CONTENT_REDACTED\")"}
}

extension MPAClientTypes {

    public enum FilterField: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case actionName
        case approvalTeamName
        case initiationTime
        case sessionStatus
        case vote
        case votingTime
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterField] {
            return [
                .actionName,
                .approvalTeamName,
                .initiationTime,
                .sessionStatus,
                .vote,
                .votingTime
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .actionName: return "ActionName"
            case .approvalTeamName: return "ApprovalTeamName"
            case .initiationTime: return "InitiationTime"
            case .sessionStatus: return "SessionStatus"
            case .vote: return "Vote"
            case .votingTime: return "VotingTime"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MPAClientTypes {

    public enum Operator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case between
        case contains
        case doesNotContain
        case equals
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case notEquals
        case sdkUnknown(Swift.String)

        public static var allCases: [Operator] {
            return [
                .between,
                .contains,
                .doesNotContain,
                .equals,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .notEquals
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .doesNotContain: return "NOT_CONTAINS"
            case .equals: return "EQ"
            case .greaterThan: return "GT"
            case .greaterThanOrEqualTo: return "GTE"
            case .lessThan: return "LT"
            case .lessThanOrEqualTo: return "LTE"
            case .notEquals: return "NE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MPAClientTypes {

    /// Contains the filter to apply to requests. You can specify up to 10 filters for a request.
    public struct Filter: Swift.Sendable {
        /// Name of the filter to use. Supported filters The supported filters for [ListSessions] are: ActionName, SessionStatus, and InitationTime.
        public var fieldName: MPAClientTypes.FilterField?
        /// Operator to use for filtering.
        ///
        /// * EQ: Equal to the specified value
        ///
        /// * NE: Not equal to the specified value
        ///
        /// * GT: Greater than the specified value
        ///
        /// * LT: Less than the specified value
        ///
        /// * GTE: Greater than or equal to the specified value
        ///
        /// * LTE: Less than or equal to the specified value
        ///
        /// * CONTAINS: Contains the specified value
        ///
        /// * NOT_CONTAINS: Does not contain the specified value
        ///
        /// * BETWEEN: Between two values, inclusive of the specified values.
        ///
        ///
        /// Supported operators for each filter:
        ///
        /// * ActionName: EQ | NE | CONTAINS | NOT_CONTAINS
        ///
        /// * SessionStatus: EQ | NE
        ///
        /// * InitiationTime: GT | LT | GTE | LTE | BETWEEN
        public var `operator`: MPAClientTypes.Operator?
        /// Value to use for filtering. For the BETWEEN operator, specify values in the format a AND b (AND is case-insensitive).
        public var value: Swift.String?

        public init(
            fieldName: MPAClientTypes.FilterField? = nil,
            `operator`: MPAClientTypes.Operator? = nil,
            value: Swift.String? = nil
        ) {
            self.fieldName = fieldName
            self.`operator` = `operator`
            self.value = value
        }
    }
}

public struct ListSessionsInput: Swift.Sendable {
    /// Amazon Resource Name (ARN) for the approval team.
    /// This member is required.
    public var approvalTeamArn: Swift.String?
    /// An array of Filter objects. Contains the filter to apply when listing sessions.
    public var filters: [MPAClientTypes.Filter]?
    /// The maximum number of items to return in the response. If more results exist than the specified MaxResults value, a token is included in the response so that you can retrieve the remaining results.
    public var maxResults: Swift.Int?
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a next call to the operation to get more output. You can repeat this until the NextToken response element returns null.
    public var nextToken: Swift.String?

    public init(
        approvalTeamArn: Swift.String? = nil,
        filters: [MPAClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.approvalTeamArn = approvalTeamArn
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension MPAClientTypes {

    /// Contains details for an approval session. For more information, see [Session](https://docs.aws.amazon.com/mpa/latest/userguide/mpa-health.html) in the Multi-party approval User Guide
    public struct ListSessionsResponseSession: Swift.Sendable {
        /// Strategy for executing the protected operation. AUTO_COMPLETION_UPON_APPROVAL means the operation is executed automatically using the requester's permissions, if approved.
        public var actionCompletionStrategy: MPAClientTypes.ActionCompletionStrategy?
        /// Name of the protected operation.
        public var actionName: Swift.String?
        /// Amazon Resource Name (ARN) for the approval team.
        public var approvalTeamArn: Swift.String?
        /// Name of the approval team.
        public var approvalTeamName: Swift.String?
        /// Timestamp when the session was completed.
        public var completionTime: Foundation.Date?
        /// Description for the team.
        public var description: Swift.String?
        /// Timestamp when the session was expire.
        public var expirationTime: Foundation.Date?
        /// Timestamp when the session was initiated.
        public var initiationTime: Foundation.Date?
        /// Amazon Resource Name (ARN) for the protected operation.
        public var protectedResourceArn: Swift.String?
        /// ID for the account that made the operation request.
        public var requesterAccountId: Swift.String?
        /// [IAM principal](https://docs.aws.amazon.com/IAM/latest/UserGuide/intro-structure.html#intro-structure-request) that made the operation request.
        public var requesterPrincipalArn: Swift.String?
        /// Amazon Web Services Region where the operation request originated.
        public var requesterRegion: Swift.String?
        /// [Service principal](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_principal.html#principal-services) for the service associated with the protected operation.
        public var requesterServicePrincipal: Swift.String?
        /// Amazon Resource Name (ARN) for the session.
        public var sessionArn: Swift.String?
        /// Status for the protected operation. For example, if the operation is PENDING.
        public var status: MPAClientTypes.SessionStatus?
        /// Status code of the session.
        public var statusCode: MPAClientTypes.SessionStatusCode?
        /// Message describing the status for session.
        public var statusMessage: Swift.String?

        public init(
            actionCompletionStrategy: MPAClientTypes.ActionCompletionStrategy? = nil,
            actionName: Swift.String? = nil,
            approvalTeamArn: Swift.String? = nil,
            approvalTeamName: Swift.String? = nil,
            completionTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            expirationTime: Foundation.Date? = nil,
            initiationTime: Foundation.Date? = nil,
            protectedResourceArn: Swift.String? = nil,
            requesterAccountId: Swift.String? = nil,
            requesterPrincipalArn: Swift.String? = nil,
            requesterRegion: Swift.String? = nil,
            requesterServicePrincipal: Swift.String? = nil,
            sessionArn: Swift.String? = nil,
            status: MPAClientTypes.SessionStatus? = nil,
            statusCode: MPAClientTypes.SessionStatusCode? = nil,
            statusMessage: Swift.String? = nil
        ) {
            self.actionCompletionStrategy = actionCompletionStrategy
            self.actionName = actionName
            self.approvalTeamArn = approvalTeamArn
            self.approvalTeamName = approvalTeamName
            self.completionTime = completionTime
            self.description = description
            self.expirationTime = expirationTime
            self.initiationTime = initiationTime
            self.protectedResourceArn = protectedResourceArn
            self.requesterAccountId = requesterAccountId
            self.requesterPrincipalArn = requesterPrincipalArn
            self.requesterRegion = requesterRegion
            self.requesterServicePrincipal = requesterServicePrincipal
            self.sessionArn = sessionArn
            self.status = status
            self.statusCode = statusCode
            self.statusMessage = statusMessage
        }
    }
}

extension MPAClientTypes.ListSessionsResponseSession: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSessionsResponseSession(actionCompletionStrategy: \(Swift.String(describing: actionCompletionStrategy)), actionName: \(Swift.String(describing: actionName)), approvalTeamArn: \(Swift.String(describing: approvalTeamArn)), approvalTeamName: \(Swift.String(describing: approvalTeamName)), completionTime: \(Swift.String(describing: completionTime)), expirationTime: \(Swift.String(describing: expirationTime)), initiationTime: \(Swift.String(describing: initiationTime)), protectedResourceArn: \(Swift.String(describing: protectedResourceArn)), requesterAccountId: \(Swift.String(describing: requesterAccountId)), requesterPrincipalArn: \(Swift.String(describing: requesterPrincipalArn)), requesterRegion: \(Swift.String(describing: requesterRegion)), requesterServicePrincipal: \(Swift.String(describing: requesterServicePrincipal)), sessionArn: \(Swift.String(describing: sessionArn)), status: \(Swift.String(describing: status)), statusCode: \(Swift.String(describing: statusCode)), statusMessage: \(Swift.String(describing: statusMessage)), description: \"CONTENT_REDACTED\")"}
}

public struct ListSessionsOutput: Swift.Sendable {
    /// If present, indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a next call to the operation to get more output. You can repeat this until the NextToken response element returns null.
    public var nextToken: Swift.String?
    /// An array of ListSessionsResponseSession objects. Contains details for the sessions.
    public var sessions: [MPAClientTypes.ListSessionsResponseSession]?

    public init(
        nextToken: Swift.String? = nil,
        sessions: [MPAClientTypes.ListSessionsResponseSession]? = nil
    ) {
        self.nextToken = nextToken
        self.sessions = sessions
    }
}

/// The request exceeds the maximum number of tags allowed for this resource. Remove some tags, and try again.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Message for the TooManyTagsException error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Name of the resource for the TooManyTagsException error.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// Amazon Resource Name (ARN) for the resource you want to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tags that you have added to the specified resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \"CONTENT_REDACTED\")"}
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// Amazon Resource Name (ARN) for the resource you want to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Array of tag key-value pairs that you want to untag.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \"CONTENT_REDACTED\")"}
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension CancelSessionInput {

    static func urlPathProvider(_ value: CancelSessionInput) -> Swift.String? {
        guard let sessionArn = value.sessionArn else {
            return nil
        }
        return "/sessions/\(sessionArn.urlPercentEncoding())"
    }
}

extension CreateApprovalTeamInput {

    static func urlPathProvider(_ value: CreateApprovalTeamInput) -> Swift.String? {
        return "/approval-teams"
    }
}

extension CreateIdentitySourceInput {

    static func urlPathProvider(_ value: CreateIdentitySourceInput) -> Swift.String? {
        return "/identity-sources"
    }
}

extension DeleteIdentitySourceInput {

    static func urlPathProvider(_ value: DeleteIdentitySourceInput) -> Swift.String? {
        guard let identitySourceArn = value.identitySourceArn else {
            return nil
        }
        return "/identity-sources/\(identitySourceArn.urlPercentEncoding())"
    }
}

extension DeleteInactiveApprovalTeamVersionInput {

    static func urlPathProvider(_ value: DeleteInactiveApprovalTeamVersionInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        guard let versionId = value.versionId else {
            return nil
        }
        return "/approval-teams/\(arn.urlPercentEncoding())/\(versionId.urlPercentEncoding())"
    }
}

extension GetApprovalTeamInput {

    static func urlPathProvider(_ value: GetApprovalTeamInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/approval-teams/\(arn.urlPercentEncoding())"
    }
}

extension GetIdentitySourceInput {

    static func urlPathProvider(_ value: GetIdentitySourceInput) -> Swift.String? {
        guard let identitySourceArn = value.identitySourceArn else {
            return nil
        }
        return "/identity-sources/\(identitySourceArn.urlPercentEncoding())"
    }
}

extension GetPolicyVersionInput {

    static func urlPathProvider(_ value: GetPolicyVersionInput) -> Swift.String? {
        guard let policyVersionArn = value.policyVersionArn else {
            return nil
        }
        return "/policy-versions/\(policyVersionArn.urlPercentEncoding())"
    }
}

extension GetResourcePolicyInput {

    static func urlPathProvider(_ value: GetResourcePolicyInput) -> Swift.String? {
        return "/GetResourcePolicy"
    }
}

extension GetSessionInput {

    static func urlPathProvider(_ value: GetSessionInput) -> Swift.String? {
        guard let sessionArn = value.sessionArn else {
            return nil
        }
        return "/sessions/\(sessionArn.urlPercentEncoding())"
    }
}

extension ListApprovalTeamsInput {

    static func urlPathProvider(_ value: ListApprovalTeamsInput) -> Swift.String? {
        return "/approval-teams"
    }
}

extension ListApprovalTeamsInput {

    static func queryItemProvider(_ value: ListApprovalTeamsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "List", value: nil))
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListIdentitySourcesInput {

    static func urlPathProvider(_ value: ListIdentitySourcesInput) -> Swift.String? {
        return "/identity-sources"
    }
}

extension ListIdentitySourcesInput {

    static func queryItemProvider(_ value: ListIdentitySourcesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "List", value: nil))
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListPoliciesInput {

    static func urlPathProvider(_ value: ListPoliciesInput) -> Swift.String? {
        return "/policies"
    }
}

extension ListPoliciesInput {

    static func queryItemProvider(_ value: ListPoliciesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "List", value: nil))
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListPolicyVersionsInput {

    static func urlPathProvider(_ value: ListPolicyVersionsInput) -> Swift.String? {
        guard let policyArn = value.policyArn else {
            return nil
        }
        return "/policies/\(policyArn.urlPercentEncoding())"
    }
}

extension ListPolicyVersionsInput {

    static func queryItemProvider(_ value: ListPolicyVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "List", value: nil))
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListResourcePoliciesInput {

    static func urlPathProvider(_ value: ListResourcePoliciesInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/resource-policies/\(resourceArn.urlPercentEncoding())"
    }
}

extension ListResourcePoliciesInput {

    static func queryItemProvider(_ value: ListResourcePoliciesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "List", value: nil))
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSessionsInput {

    static func urlPathProvider(_ value: ListSessionsInput) -> Swift.String? {
        guard let approvalTeamArn = value.approvalTeamArn else {
            return nil
        }
        return "/approval-teams/\(approvalTeamArn.urlPercentEncoding())/sessions"
    }
}

extension ListSessionsInput {

    static func queryItemProvider(_ value: ListSessionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "List", value: nil))
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension StartActiveApprovalTeamDeletionInput {

    static func urlPathProvider(_ value: StartActiveApprovalTeamDeletionInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/approval-teams/\(arn.urlPercentEncoding())"
    }
}

extension StartActiveApprovalTeamDeletionInput {

    static func queryItemProvider(_ value: StartActiveApprovalTeamDeletionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "Delete", value: nil))
        return items
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UpdateApprovalTeamInput {

    static func urlPathProvider(_ value: UpdateApprovalTeamInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/approval-teams/\(arn.urlPercentEncoding())"
    }
}

extension CreateApprovalTeamInput {

    static func write(value: CreateApprovalTeamInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApprovalStrategy"].write(value.approvalStrategy, with: MPAClientTypes.ApprovalStrategy.write(value:to:))
        try writer["Approvers"].writeList(value.approvers, memberWritingClosure: MPAClientTypes.ApprovalTeamRequestApprover.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ClientToken"].write(value.clientToken)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["Policies"].writeList(value.policies, memberWritingClosure: MPAClientTypes.PolicyReference.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateIdentitySourceInput {

    static func write(value: CreateIdentitySourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["IdentitySourceParameters"].write(value.identitySourceParameters, with: MPAClientTypes.IdentitySourceParameters.write(value:to:))
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension GetResourcePolicyInput {

    static func write(value: GetResourcePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PolicyName"].write(value.policyName)
        try writer["PolicyType"].write(value.policyType)
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension ListSessionsInput {

    static func write(value: ListSessionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: MPAClientTypes.Filter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension StartActiveApprovalTeamDeletionInput {

    static func write(value: StartActiveApprovalTeamDeletionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PendingWindowDays"].write(value.pendingWindowDays)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateApprovalTeamInput {

    static func write(value: UpdateApprovalTeamInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApprovalStrategy"].write(value.approvalStrategy, with: MPAClientTypes.ApprovalStrategy.write(value:to:))
        try writer["Approvers"].writeList(value.approvers, memberWritingClosure: MPAClientTypes.ApprovalTeamRequestApprover.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Description"].write(value.description)
    }
}

extension CancelSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelSessionOutput {
        return CancelSessionOutput()
    }
}

extension CreateApprovalTeamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateApprovalTeamOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateApprovalTeamOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["Name"].readIfPresent()
        value.versionId = try reader["VersionId"].readIfPresent()
        return value
    }
}

extension CreateIdentitySourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateIdentitySourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateIdentitySourceOutput()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.identitySourceArn = try reader["IdentitySourceArn"].readIfPresent()
        value.identitySourceType = try reader["IdentitySourceType"].readIfPresent()
        return value
    }
}

extension DeleteIdentitySourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteIdentitySourceOutput {
        return DeleteIdentitySourceOutput()
    }
}

extension DeleteInactiveApprovalTeamVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteInactiveApprovalTeamVersionOutput {
        return DeleteInactiveApprovalTeamVersionOutput()
    }
}

extension GetApprovalTeamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetApprovalTeamOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetApprovalTeamOutput()
        value.approvalStrategy = try reader["ApprovalStrategy"].readIfPresent(with: MPAClientTypes.ApprovalStrategyResponse.read(from:))
        value.approvers = try reader["Approvers"].readListIfPresent(memberReadingClosure: MPAClientTypes.GetApprovalTeamResponseApprover.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["Description"].readIfPresent()
        value.lastUpdateTime = try reader["LastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["Name"].readIfPresent()
        value.numberOfApprovers = try reader["NumberOfApprovers"].readIfPresent()
        value.pendingUpdate = try reader["PendingUpdate"].readIfPresent(with: MPAClientTypes.PendingUpdate.read(from:))
        value.policies = try reader["Policies"].readListIfPresent(memberReadingClosure: MPAClientTypes.PolicyReference.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["Status"].readIfPresent()
        value.statusCode = try reader["StatusCode"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.updateSessionArn = try reader["UpdateSessionArn"].readIfPresent()
        value.versionId = try reader["VersionId"].readIfPresent()
        return value
    }
}

extension GetIdentitySourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetIdentitySourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIdentitySourceOutput()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.identitySourceArn = try reader["IdentitySourceArn"].readIfPresent()
        value.identitySourceParameters = try reader["IdentitySourceParameters"].readIfPresent(with: MPAClientTypes.IdentitySourceParametersForGet.read(from:))
        value.identitySourceType = try reader["IdentitySourceType"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusCode = try reader["StatusCode"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        return value
    }
}

extension GetPolicyVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPolicyVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPolicyVersionOutput()
        value.policyVersion = try reader["PolicyVersion"].readIfPresent(with: MPAClientTypes.PolicyVersion.read(from:))
        return value
    }
}

extension GetResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourcePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourcePolicyOutput()
        value.policyDocument = try reader["PolicyDocument"].readIfPresent() ?? ""
        value.policyName = try reader["PolicyName"].readIfPresent() ?? ""
        value.policyType = try reader["PolicyType"].readIfPresent() ?? .sdkUnknown("")
        value.policyVersionArn = try reader["PolicyVersionArn"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent() ?? ""
        return value
    }
}

extension GetSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSessionOutput()
        value.actionCompletionStrategy = try reader["ActionCompletionStrategy"].readIfPresent()
        value.actionName = try reader["ActionName"].readIfPresent()
        value.approvalStrategy = try reader["ApprovalStrategy"].readIfPresent(with: MPAClientTypes.ApprovalStrategyResponse.read(from:))
        value.approvalTeamArn = try reader["ApprovalTeamArn"].readIfPresent()
        value.approvalTeamName = try reader["ApprovalTeamName"].readIfPresent()
        value.approverResponses = try reader["ApproverResponses"].readListIfPresent(memberReadingClosure: MPAClientTypes.GetSessionResponseApproverResponse.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.completionTime = try reader["CompletionTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["Description"].readIfPresent()
        value.executionStatus = try reader["ExecutionStatus"].readIfPresent()
        value.expirationTime = try reader["ExpirationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.initiationTime = try reader["InitiationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.metadata = try reader["Metadata"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.numberOfApprovers = try reader["NumberOfApprovers"].readIfPresent()
        value.protectedResourceArn = try reader["ProtectedResourceArn"].readIfPresent()
        value.requesterAccountId = try reader["RequesterAccountId"].readIfPresent()
        value.requesterComment = try reader["RequesterComment"].readIfPresent()
        value.requesterPrincipalArn = try reader["RequesterPrincipalArn"].readIfPresent()
        value.requesterRegion = try reader["RequesterRegion"].readIfPresent()
        value.requesterServicePrincipal = try reader["RequesterServicePrincipal"].readIfPresent()
        value.sessionArn = try reader["SessionArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusCode = try reader["StatusCode"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        return value
    }
}

extension ListApprovalTeamsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListApprovalTeamsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListApprovalTeamsOutput()
        value.approvalTeams = try reader["ApprovalTeams"].readListIfPresent(memberReadingClosure: MPAClientTypes.ListApprovalTeamsResponseApprovalTeam.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListIdentitySourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListIdentitySourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIdentitySourcesOutput()
        value.identitySources = try reader["IdentitySources"].readListIfPresent(memberReadingClosure: MPAClientTypes.IdentitySourceForList.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListPoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPoliciesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.policies = try reader["Policies"].readListIfPresent(memberReadingClosure: MPAClientTypes.Policy.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListPolicyVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPolicyVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPolicyVersionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.policyVersions = try reader["PolicyVersions"].readListIfPresent(memberReadingClosure: MPAClientTypes.PolicyVersionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListResourcePoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResourcePoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResourcePoliciesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.resourcePolicies = try reader["ResourcePolicies"].readListIfPresent(memberReadingClosure: MPAClientTypes.ListResourcePoliciesResponseResourcePolicy.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSessionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSessionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSessionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.sessions = try reader["Sessions"].readListIfPresent(memberReadingClosure: MPAClientTypes.ListSessionsResponseSession.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension StartActiveApprovalTeamDeletionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartActiveApprovalTeamDeletionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartActiveApprovalTeamDeletionOutput()
        value.deletionCompletionTime = try reader["DeletionCompletionTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.deletionStartTime = try reader["DeletionStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateApprovalTeamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateApprovalTeamOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateApprovalTeamOutput()
        value.versionId = try reader["VersionId"].readIfPresent()
        return value
    }
}

enum CancelSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateApprovalTeamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateIdentitySourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteIdentitySourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteInactiveApprovalTeamVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetApprovalTeamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetIdentitySourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPolicyVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListApprovalTeamsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListIdentitySourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPolicyVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResourcePoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSessionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartActiveApprovalTeamDeletionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateApprovalTeamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidParameterException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidParameterException {
        let reader = baseError.errorBodyReader
        var value = InvalidParameterException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyTagsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyTagsException {
        let reader = baseError.errorBodyReader
        var value = TooManyTagsException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.resourceName = try reader["ResourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MPAClientTypes.ApprovalStrategyResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> MPAClientTypes.ApprovalStrategyResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "MofN":
                return .mofn(try reader["MofN"].read(with: MPAClientTypes.MofNApprovalStrategy.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MPAClientTypes.MofNApprovalStrategy {

    static func write(value: MPAClientTypes.MofNApprovalStrategy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MinApprovalsRequired"].write(value.minApprovalsRequired)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MPAClientTypes.MofNApprovalStrategy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MPAClientTypes.MofNApprovalStrategy()
        value.minApprovalsRequired = try reader["MinApprovalsRequired"].readIfPresent() ?? 0
        return value
    }
}

extension MPAClientTypes.GetApprovalTeamResponseApprover {

    static func read(from reader: SmithyJSON.Reader) throws -> MPAClientTypes.GetApprovalTeamResponseApprover {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MPAClientTypes.GetApprovalTeamResponseApprover()
        value.approverId = try reader["ApproverId"].readIfPresent()
        value.responseTime = try reader["ResponseTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.primaryIdentityId = try reader["PrimaryIdentityId"].readIfPresent()
        value.primaryIdentitySourceArn = try reader["PrimaryIdentitySourceArn"].readIfPresent()
        value.primaryIdentityStatus = try reader["PrimaryIdentityStatus"].readIfPresent()
        return value
    }
}

extension MPAClientTypes.PolicyReference {

    static func write(value: MPAClientTypes.PolicyReference?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PolicyArn"].write(value.policyArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MPAClientTypes.PolicyReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MPAClientTypes.PolicyReference()
        value.policyArn = try reader["PolicyArn"].readIfPresent() ?? ""
        return value
    }
}

extension MPAClientTypes.PendingUpdate {

    static func read(from reader: SmithyJSON.Reader) throws -> MPAClientTypes.PendingUpdate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MPAClientTypes.PendingUpdate()
        value.versionId = try reader["VersionId"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.approvalStrategy = try reader["ApprovalStrategy"].readIfPresent(with: MPAClientTypes.ApprovalStrategyResponse.read(from:))
        value.numberOfApprovers = try reader["NumberOfApprovers"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusCode = try reader["StatusCode"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.approvers = try reader["Approvers"].readListIfPresent(memberReadingClosure: MPAClientTypes.GetApprovalTeamResponseApprover.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.updateInitiationTime = try reader["UpdateInitiationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension MPAClientTypes.IdentitySourceParametersForGet {

    static func read(from reader: SmithyJSON.Reader) throws -> MPAClientTypes.IdentitySourceParametersForGet {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "IamIdentityCenter":
                return .iamidentitycenter(try reader["IamIdentityCenter"].read(with: MPAClientTypes.IamIdentityCenterForGet.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MPAClientTypes.IamIdentityCenterForGet {

    static func read(from reader: SmithyJSON.Reader) throws -> MPAClientTypes.IamIdentityCenterForGet {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MPAClientTypes.IamIdentityCenterForGet()
        value.instanceArn = try reader["InstanceArn"].readIfPresent()
        value.approvalPortalUrl = try reader["ApprovalPortalUrl"].readIfPresent()
        value.region = try reader["Region"].readIfPresent()
        return value
    }
}

extension MPAClientTypes.PolicyVersion {

    static func read(from reader: SmithyJSON.Reader) throws -> MPAClientTypes.PolicyVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MPAClientTypes.PolicyVersion()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.policyArn = try reader["PolicyArn"].readIfPresent() ?? ""
        value.versionId = try reader["VersionId"].readIfPresent() ?? 0
        value.policyType = try reader["PolicyType"].readIfPresent() ?? .sdkUnknown("")
        value.isDefault = try reader["IsDefault"].readIfPresent() ?? false
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.document = try reader["Document"].readIfPresent() ?? ""
        return value
    }
}

extension MPAClientTypes.GetSessionResponseApproverResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> MPAClientTypes.GetSessionResponseApproverResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MPAClientTypes.GetSessionResponseApproverResponse()
        value.approverId = try reader["ApproverId"].readIfPresent()
        value.identitySourceArn = try reader["IdentitySourceArn"].readIfPresent()
        value.identityId = try reader["IdentityId"].readIfPresent()
        value.response = try reader["Response"].readIfPresent()
        value.responseTime = try reader["ResponseTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension MPAClientTypes.ListApprovalTeamsResponseApprovalTeam {

    static func read(from reader: SmithyJSON.Reader) throws -> MPAClientTypes.ListApprovalTeamsResponseApprovalTeam {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MPAClientTypes.ListApprovalTeamsResponseApprovalTeam()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.approvalStrategy = try reader["ApprovalStrategy"].readIfPresent(with: MPAClientTypes.ApprovalStrategyResponse.read(from:))
        value.numberOfApprovers = try reader["NumberOfApprovers"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusCode = try reader["StatusCode"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        return value
    }
}

extension MPAClientTypes.IdentitySourceForList {

    static func read(from reader: SmithyJSON.Reader) throws -> MPAClientTypes.IdentitySourceForList {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MPAClientTypes.IdentitySourceForList()
        value.identitySourceType = try reader["IdentitySourceType"].readIfPresent()
        value.identitySourceParameters = try reader["IdentitySourceParameters"].readIfPresent(with: MPAClientTypes.IdentitySourceParametersForList.read(from:))
        value.identitySourceArn = try reader["IdentitySourceArn"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.status = try reader["Status"].readIfPresent()
        value.statusCode = try reader["StatusCode"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        return value
    }
}

extension MPAClientTypes.IdentitySourceParametersForList {

    static func read(from reader: SmithyJSON.Reader) throws -> MPAClientTypes.IdentitySourceParametersForList {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "IamIdentityCenter":
                return .iamidentitycenter(try reader["IamIdentityCenter"].read(with: MPAClientTypes.IamIdentityCenterForList.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MPAClientTypes.IamIdentityCenterForList {

    static func read(from reader: SmithyJSON.Reader) throws -> MPAClientTypes.IamIdentityCenterForList {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MPAClientTypes.IamIdentityCenterForList()
        value.instanceArn = try reader["InstanceArn"].readIfPresent()
        value.approvalPortalUrl = try reader["ApprovalPortalUrl"].readIfPresent()
        value.region = try reader["Region"].readIfPresent()
        return value
    }
}

extension MPAClientTypes.Policy {

    static func read(from reader: SmithyJSON.Reader) throws -> MPAClientTypes.Policy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MPAClientTypes.Policy()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.defaultVersion = try reader["DefaultVersion"].readIfPresent() ?? 0
        value.policyType = try reader["PolicyType"].readIfPresent() ?? .sdkUnknown("")
        value.name = try reader["Name"].readIfPresent() ?? ""
        return value
    }
}

extension MPAClientTypes.PolicyVersionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> MPAClientTypes.PolicyVersionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MPAClientTypes.PolicyVersionSummary()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.policyArn = try reader["PolicyArn"].readIfPresent() ?? ""
        value.versionId = try reader["VersionId"].readIfPresent() ?? 0
        value.policyType = try reader["PolicyType"].readIfPresent() ?? .sdkUnknown("")
        value.isDefault = try reader["IsDefault"].readIfPresent() ?? false
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension MPAClientTypes.ListResourcePoliciesResponseResourcePolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> MPAClientTypes.ListResourcePoliciesResponseResourcePolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MPAClientTypes.ListResourcePoliciesResponseResourcePolicy()
        value.policyArn = try reader["PolicyArn"].readIfPresent()
        value.policyType = try reader["PolicyType"].readIfPresent()
        value.policyName = try reader["PolicyName"].readIfPresent()
        return value
    }
}

extension MPAClientTypes.ListSessionsResponseSession {

    static func read(from reader: SmithyJSON.Reader) throws -> MPAClientTypes.ListSessionsResponseSession {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MPAClientTypes.ListSessionsResponseSession()
        value.sessionArn = try reader["SessionArn"].readIfPresent()
        value.approvalTeamName = try reader["ApprovalTeamName"].readIfPresent()
        value.approvalTeamArn = try reader["ApprovalTeamArn"].readIfPresent()
        value.initiationTime = try reader["InitiationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.expirationTime = try reader["ExpirationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.completionTime = try reader["CompletionTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["Description"].readIfPresent()
        value.actionName = try reader["ActionName"].readIfPresent()
        value.protectedResourceArn = try reader["ProtectedResourceArn"].readIfPresent()
        value.requesterServicePrincipal = try reader["RequesterServicePrincipal"].readIfPresent()
        value.requesterPrincipalArn = try reader["RequesterPrincipalArn"].readIfPresent()
        value.requesterRegion = try reader["RequesterRegion"].readIfPresent()
        value.requesterAccountId = try reader["RequesterAccountId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusCode = try reader["StatusCode"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.actionCompletionStrategy = try reader["ActionCompletionStrategy"].readIfPresent()
        return value
    }
}

extension MPAClientTypes.ApprovalStrategy {

    static func write(value: MPAClientTypes.ApprovalStrategy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .mofn(mofn):
                try writer["MofN"].write(mofn, with: MPAClientTypes.MofNApprovalStrategy.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension MPAClientTypes.ApprovalTeamRequestApprover {

    static func write(value: MPAClientTypes.ApprovalTeamRequestApprover?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PrimaryIdentityId"].write(value.primaryIdentityId)
        try writer["PrimaryIdentitySourceArn"].write(value.primaryIdentitySourceArn)
    }
}

extension MPAClientTypes.IdentitySourceParameters {

    static func write(value: MPAClientTypes.IdentitySourceParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IamIdentityCenter"].write(value.iamIdentityCenter, with: MPAClientTypes.IamIdentityCenter.write(value:to:))
    }
}

extension MPAClientTypes.IamIdentityCenter {

    static func write(value: MPAClientTypes.IamIdentityCenter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["Region"].write(value.region)
    }
}

extension MPAClientTypes.Filter {

    static func write(value: MPAClientTypes.Filter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FieldName"].write(value.fieldName)
        try writer["Operator"].write(value.`operator`)
        try writer["Value"].write(value.value)
    }
}

public enum MPAClientTypes {}
