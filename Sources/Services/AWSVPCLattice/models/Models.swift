// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The user does not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable, Swift.Error {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VPCLatticeClientTypes.AccessLogSubscriptionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case destinationArn
        case id
        case lastUpdatedAt
        case resourceArn
        case resourceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let destinationArn = self.destinationArn {
            try encodeContainer.encode(destinationArn, forKey: .destinationArn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .dateTime, forKey: .lastUpdatedAt)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let destinationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationArn)
        destinationArn = destinationArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Summary information about an access log subscription.
    public struct AccessLogSubscriptionSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the access log subscription
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the access log subscription was created, specified in ISO-8601 format.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the destination.
        /// This member is required.
        public var destinationArn: Swift.String?
        /// The ID of the access log subscription.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time that the access log subscription was last updated, specified in ISO-8601 format.
        /// This member is required.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the service or service network.
        /// This member is required.
        public var resourceArn: Swift.String?
        /// The ID of the service or service network.
        /// This member is required.
        public var resourceId: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            destinationArn: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            resourceArn: Swift.String? = nil,
            resourceId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.destinationArn = destinationArn
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.resourceArn = resourceArn
            self.resourceId = resourceId
        }
    }

}

extension VPCLatticeClientTypes {
    public enum AuthPolicyState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthPolicyState] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .inactive: return "Inactive"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthPolicyState(rawValue: rawValue) ?? AuthPolicyState.sdkUnknown(rawValue)
        }
    }
}

extension VPCLatticeClientTypes {
    public enum AuthType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsIam
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthType] {
            return [
                .awsIam,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsIam: return "AWS_IAM"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthType(rawValue: rawValue) ?? AuthType.sdkUnknown(rawValue)
        }
    }
}

extension BatchUpdateRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rules
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for ruleupdate0 in rules {
                try rulesContainer.encode(ruleupdate0)
            }
        }
    }
}

extension BatchUpdateRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceIdentifier = serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = listenerIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())/rules"
    }
}

public struct BatchUpdateRuleInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The rules for the specified listener.
    /// This member is required.
    public var rules: [VPCLatticeClientTypes.RuleUpdate]?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init (
        listenerIdentifier: Swift.String? = nil,
        rules: [VPCLatticeClientTypes.RuleUpdate]? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.listenerIdentifier = listenerIdentifier
        self.rules = rules
        self.serviceIdentifier = serviceIdentifier
    }
}

struct BatchUpdateRuleInputBody: Swift.Equatable {
    let rules: [VPCLatticeClientTypes.RuleUpdate]?
}

extension BatchUpdateRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rules
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.RuleUpdate?].self, forKey: .rules)
        var rulesDecoded0:[VPCLatticeClientTypes.RuleUpdate]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [VPCLatticeClientTypes.RuleUpdate]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

extension BatchUpdateRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchUpdateRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchUpdateRuleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchUpdateRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: BatchUpdateRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.successful = output.successful
            self.unsuccessful = output.unsuccessful
        } else {
            self.successful = nil
            self.unsuccessful = nil
        }
    }
}

public struct BatchUpdateRuleOutputResponse: Swift.Equatable {
    /// The rules that were successfully updated.
    public var successful: [VPCLatticeClientTypes.RuleUpdateSuccess]?
    /// The rules that the operation couldn't update.
    public var unsuccessful: [VPCLatticeClientTypes.RuleUpdateFailure]?

    public init (
        successful: [VPCLatticeClientTypes.RuleUpdateSuccess]? = nil,
        unsuccessful: [VPCLatticeClientTypes.RuleUpdateFailure]? = nil
    )
    {
        self.successful = successful
        self.unsuccessful = unsuccessful
    }
}

struct BatchUpdateRuleOutputResponseBody: Swift.Equatable {
    let successful: [VPCLatticeClientTypes.RuleUpdateSuccess]?
    let unsuccessful: [VPCLatticeClientTypes.RuleUpdateFailure]?
}

extension BatchUpdateRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case successful
        case unsuccessful
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.RuleUpdateSuccess?].self, forKey: .successful)
        var successfulDecoded0:[VPCLatticeClientTypes.RuleUpdateSuccess]? = nil
        if let successfulContainer = successfulContainer {
            successfulDecoded0 = [VPCLatticeClientTypes.RuleUpdateSuccess]()
            for structure0 in successfulContainer {
                if let structure0 = structure0 {
                    successfulDecoded0?.append(structure0)
                }
            }
        }
        successful = successfulDecoded0
        let unsuccessfulContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.RuleUpdateFailure?].self, forKey: .unsuccessful)
        var unsuccessfulDecoded0:[VPCLatticeClientTypes.RuleUpdateFailure]? = nil
        if let unsuccessfulContainer = unsuccessfulContainer {
            unsuccessfulDecoded0 = [VPCLatticeClientTypes.RuleUpdateFailure]()
            for structure0 in unsuccessfulContainer {
                if let structure0 = structure0 {
                    unsuccessfulDecoded0?.append(structure0)
                }
            }
        }
        unsuccessful = unsuccessfulDecoded0
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request conflicts with the current state of the resource. Updating or deleting a resource can cause an inconsistent state.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable, Swift.Error {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The resource ID.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The resource type.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CreateAccessLogSubscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case destinationArn
        case resourceIdentifier
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let destinationArn = self.destinationArn {
            try encodeContainer.encode(destinationArn, forKey: .destinationArn)
        }
        if let resourceIdentifier = self.resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAccessLogSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/accesslogsubscriptions"
    }
}

public struct CreateAccessLogSubscriptionInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the destination. The supported destination types are CloudWatch Log groups, Kinesis Data Firehose delivery streams, and Amazon S3 buckets.
    /// This member is required.
    public var destinationArn: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service network or service.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The tags for the access log subscription.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        destinationArn: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.destinationArn = destinationArn
        self.resourceIdentifier = resourceIdentifier
        self.tags = tags
    }
}

struct CreateAccessLogSubscriptionInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let resourceIdentifier: Swift.String?
    let destinationArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateAccessLogSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case destinationArn
        case resourceIdentifier
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let destinationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationArn)
        destinationArn = destinationArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAccessLogSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAccessLogSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateAccessLogSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAccessLogSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: CreateAccessLogSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.destinationArn = output.destinationArn
            self.id = output.id
            self.resourceArn = output.resourceArn
            self.resourceId = output.resourceId
        } else {
            self.arn = nil
            self.destinationArn = nil
            self.id = nil
            self.resourceArn = nil
            self.resourceId = nil
        }
    }
}

public struct CreateAccessLogSubscriptionOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the access log subscription.
    /// This member is required.
    public var arn: Swift.String?
    /// The Amazon Resource Name (ARN) of the log destination.
    /// This member is required.
    public var destinationArn: Swift.String?
    /// The ID of the access log subscription.
    /// This member is required.
    public var id: Swift.String?
    /// The Amazon Resource Name (ARN) of the service network or service.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The ID of the service network or service.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        arn: Swift.String? = nil,
        destinationArn: Swift.String? = nil,
        id: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.destinationArn = destinationArn
        self.id = id
        self.resourceArn = resourceArn
        self.resourceId = resourceId
    }
}

struct CreateAccessLogSubscriptionOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let resourceId: Swift.String?
    let resourceArn: Swift.String?
    let destinationArn: Swift.String?
}

extension CreateAccessLogSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case destinationArn
        case id
        case resourceArn
        case resourceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let destinationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationArn)
        destinationArn = destinationArnDecoded
    }
}

extension CreateListenerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case defaultAction
        case name
        case port
        case `protocol` = "protocol"
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let defaultAction = self.defaultAction {
            try encodeContainer.encode(defaultAction, forKey: .defaultAction)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateListenerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceIdentifier = serviceIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners"
    }
}

public struct CreateListenerInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The action for the default rule. Each listener has a default rule. Each rule consists of a priority, one or more actions, and one or more conditions. The default rule is the rule that's used if no other rules match. Each rule must include exactly one of the following types of actions: forward or fixed-response, and it must be the last action to be performed.
    /// This member is required.
    public var defaultAction: VPCLatticeClientTypes.RuleAction?
    /// The name of the listener. A listener name must be unique within a service. The valid characters are a-z, 0-9, and hyphens (-). You can't use a hyphen as the first or last character, or immediately after another hyphen.
    /// This member is required.
    public var name: Swift.String?
    /// The listener port. You can specify a value from 1 to 65535. For HTTP, the default is 80. For HTTPS, the default is 443.
    public var port: Swift.Int?
    /// The listener protocol HTTP or HTTPS.
    /// This member is required.
    public var `protocol`: VPCLatticeClientTypes.ListenerProtocol?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?
    /// The tags for the listener.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        defaultAction: VPCLatticeClientTypes.RuleAction? = nil,
        name: Swift.String? = nil,
        port: Swift.Int? = nil,
        `protocol`: VPCLatticeClientTypes.ListenerProtocol? = nil,
        serviceIdentifier: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.defaultAction = defaultAction
        self.name = name
        self.port = port
        self.`protocol` = `protocol`
        self.serviceIdentifier = serviceIdentifier
        self.tags = tags
    }
}

struct CreateListenerInputBody: Swift.Equatable {
    let name: Swift.String?
    let `protocol`: VPCLatticeClientTypes.ListenerProtocol?
    let port: Swift.Int?
    let defaultAction: VPCLatticeClientTypes.RuleAction?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateListenerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case defaultAction
        case name
        case port
        case `protocol` = "protocol"
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ListenerProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let defaultActionDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleAction.self, forKey: .defaultAction)
        defaultAction = defaultActionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateListenerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateListenerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateListenerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateListenerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: CreateListenerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.`protocol` = output.`protocol`
            self.arn = output.arn
            self.defaultAction = output.defaultAction
            self.id = output.id
            self.name = output.name
            self.port = output.port
            self.serviceArn = output.serviceArn
            self.serviceId = output.serviceId
        } else {
            self.arn = nil
            self.defaultAction = nil
            self.id = nil
            self.name = nil
            self.port = nil
            self.`protocol` = nil
            self.serviceArn = nil
            self.serviceId = nil
        }
    }
}

public struct CreateListenerOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the listener.
    public var arn: Swift.String?
    /// The action for the default rule.
    public var defaultAction: VPCLatticeClientTypes.RuleAction?
    /// The ID of the listener.
    public var id: Swift.String?
    /// The name of the listener.
    public var name: Swift.String?
    /// The port number of the listener.
    public var port: Swift.Int?
    /// The protocol of the listener.
    public var `protocol`: VPCLatticeClientTypes.ListenerProtocol?
    /// The Amazon Resource Name (ARN) of the service.
    public var serviceArn: Swift.String?
    /// The ID of the service.
    public var serviceId: Swift.String?

    public init (
        arn: Swift.String? = nil,
        defaultAction: VPCLatticeClientTypes.RuleAction? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        port: Swift.Int? = nil,
        `protocol`: VPCLatticeClientTypes.ListenerProtocol? = nil,
        serviceArn: Swift.String? = nil,
        serviceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.defaultAction = defaultAction
        self.id = id
        self.name = name
        self.port = port
        self.`protocol` = `protocol`
        self.serviceArn = serviceArn
        self.serviceId = serviceId
    }
}

struct CreateListenerOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let `protocol`: VPCLatticeClientTypes.ListenerProtocol?
    let port: Swift.Int?
    let serviceArn: Swift.String?
    let serviceId: Swift.String?
    let defaultAction: VPCLatticeClientTypes.RuleAction?
}

extension CreateListenerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case defaultAction
        case id
        case name
        case port
        case `protocol` = "protocol"
        case serviceArn
        case serviceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ListenerProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let defaultActionDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleAction.self, forKey: .defaultAction)
        defaultAction = defaultActionDecoded
    }
}

extension CreateRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case clientToken
        case match
        case name
        case priority
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let match = self.match {
            try encodeContainer.encode(match, forKey: .match)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceIdentifier = serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = listenerIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())/rules"
    }
}

public struct CreateRuleInput: Swift.Equatable {
    /// The action for the default rule.
    /// This member is required.
    public var action: VPCLatticeClientTypes.RuleAction?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The rule match.
    /// This member is required.
    public var match: VPCLatticeClientTypes.RuleMatch?
    /// The name of the rule. The name must be unique within the listener. The valid characters are a-z, 0-9, and hyphens (-). You can't use a hyphen as the first or last character, or immediately after another hyphen.
    /// This member is required.
    public var name: Swift.String?
    /// The priority assigned to the rule. Each rule for a specific listener must have a unique priority. The lower the priority number the higher the priority.
    /// This member is required.
    public var priority: Swift.Int?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?
    /// The tags for the rule.
    public var tags: [Swift.String:Swift.String]?

    public init (
        action: VPCLatticeClientTypes.RuleAction? = nil,
        clientToken: Swift.String? = nil,
        listenerIdentifier: Swift.String? = nil,
        match: VPCLatticeClientTypes.RuleMatch? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil,
        serviceIdentifier: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.action = action
        self.clientToken = clientToken
        self.listenerIdentifier = listenerIdentifier
        self.match = match
        self.name = name
        self.priority = priority
        self.serviceIdentifier = serviceIdentifier
        self.tags = tags
    }
}

struct CreateRuleInputBody: Swift.Equatable {
    let name: Swift.String?
    let match: VPCLatticeClientTypes.RuleMatch?
    let priority: Swift.Int?
    let action: VPCLatticeClientTypes.RuleAction?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case clientToken
        case match
        case name
        case priority
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let matchDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleMatch.self, forKey: .match)
        match = matchDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let actionDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleAction.self, forKey: .action)
        action = actionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateRuleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: CreateRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.action = output.action
            self.arn = output.arn
            self.id = output.id
            self.match = output.match
            self.name = output.name
            self.priority = output.priority
        } else {
            self.action = nil
            self.arn = nil
            self.id = nil
            self.match = nil
            self.name = nil
            self.priority = nil
        }
    }
}

public struct CreateRuleOutputResponse: Swift.Equatable {
    /// The rule action. Each rule must include exactly one of the following types of actions: forward or fixed-response, and it must be the last action to be performed.
    public var action: VPCLatticeClientTypes.RuleAction?
    /// The Amazon Resource Name (ARN) of the rule.
    public var arn: Swift.String?
    /// The ID of the rule.
    public var id: Swift.String?
    /// The rule match. The RuleMatch must be an HttpMatch. This means that the rule should be an exact match on HTTP constraints which are made up of the HTTP method, path, and header.
    public var match: VPCLatticeClientTypes.RuleMatch?
    /// The name of the rule.
    public var name: Swift.String?
    /// The priority assigned to the rule. The lower the priority number the higher the priority.
    public var priority: Swift.Int?

    public init (
        action: VPCLatticeClientTypes.RuleAction? = nil,
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        match: VPCLatticeClientTypes.RuleMatch? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil
    )
    {
        self.action = action
        self.arn = arn
        self.id = id
        self.match = match
        self.name = name
        self.priority = priority
    }
}

struct CreateRuleOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let match: VPCLatticeClientTypes.RuleMatch?
    let priority: Swift.Int?
    let action: VPCLatticeClientTypes.RuleAction?
}

extension CreateRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case arn
        case id
        case match
        case name
        case priority
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let matchDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleMatch.self, forKey: .match)
        match = matchDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let actionDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleAction.self, forKey: .action)
        action = actionDecoded
    }
}

extension CreateServiceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType
        case certificateArn
        case clientToken
        case customDomainName
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authType = self.authType {
            try encodeContainer.encode(authType.rawValue, forKey: .authType)
        }
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let customDomainName = self.customDomainName {
            try encodeContainer.encode(customDomainName, forKey: .customDomainName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/services"
    }
}

public struct CreateServiceInput: Swift.Equatable {
    /// The type of IAM policy.
    ///
    /// * NONE: The resource does not use an IAM policy. This is the default.
    ///
    /// * AWS_IAM: The resource uses an IAM policy. When this type is used, auth is enabled and an auth policy is required.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The Amazon Resource Name (ARN) of the certificate.
    public var certificateArn: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The custom domain name of the service.
    public var customDomainName: Swift.String?
    /// The name of the service. The name must be unique within the account. The valid characters are a-z, 0-9, and hyphens (-). You can't use a hyphen as the first or last character, or immediately after another hyphen.
    /// This member is required.
    public var name: Swift.String?
    /// The tags for the service.
    public var tags: [Swift.String:Swift.String]?

    public init (
        authType: VPCLatticeClientTypes.AuthType? = nil,
        certificateArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        customDomainName: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.authType = authType
        self.certificateArn = certificateArn
        self.clientToken = clientToken
        self.customDomainName = customDomainName
        self.name = name
        self.tags = tags
    }
}

struct CreateServiceInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let customDomainName: Swift.String?
    let certificateArn: Swift.String?
    let authType: VPCLatticeClientTypes.AuthType?
}

extension CreateServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType
        case certificateArn
        case clientToken
        case customDomainName
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let customDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomainName)
        customDomainName = customDomainNameDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.AuthType.self, forKey: .authType)
        authType = authTypeDecoded
    }
}

extension CreateServiceNetworkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType
        case clientToken
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authType = self.authType {
            try encodeContainer.encode(authType.rawValue, forKey: .authType)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateServiceNetworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/servicenetworks"
    }
}

public struct CreateServiceNetworkInput: Swift.Equatable {
    /// The type of IAM policy.
    ///
    /// * NONE: The resource does not use an IAM policy. This is the default.
    ///
    /// * AWS_IAM: The resource uses an IAM policy. When this type is used, auth is enabled and an auth policy is required.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The name of the service network. The name must be unique to the account. The valid characters are a-z, 0-9, and hyphens (-). You can't use a hyphen as the first or last character, or immediately after another hyphen.
    /// This member is required.
    public var name: Swift.String?
    /// The tags for the service network.
    public var tags: [Swift.String:Swift.String]?

    public init (
        authType: VPCLatticeClientTypes.AuthType? = nil,
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.authType = authType
        self.clientToken = clientToken
        self.name = name
        self.tags = tags
    }
}

struct CreateServiceNetworkInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let name: Swift.String?
    let authType: VPCLatticeClientTypes.AuthType?
    let tags: [Swift.String:Swift.String]?
}

extension CreateServiceNetworkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType
        case clientToken
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.AuthType.self, forKey: .authType)
        authType = authTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateServiceNetworkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateServiceNetworkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateServiceNetworkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateServiceNetworkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: CreateServiceNetworkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.authType = output.authType
            self.id = output.id
            self.name = output.name
        } else {
            self.arn = nil
            self.authType = nil
            self.id = nil
            self.name = nil
        }
    }
}

public struct CreateServiceNetworkOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the service network.
    public var arn: Swift.String?
    /// The type of IAM policy.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The ID of the service network.
    public var id: Swift.String?
    /// The name of the service network.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        authType: VPCLatticeClientTypes.AuthType? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.authType = authType
        self.id = id
        self.name = name
    }
}

struct CreateServiceNetworkOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let authType: VPCLatticeClientTypes.AuthType?
}

extension CreateServiceNetworkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case authType
        case id
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.AuthType.self, forKey: .authType)
        authType = authTypeDecoded
    }
}

extension CreateServiceNetworkServiceAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case serviceIdentifier
        case serviceNetworkIdentifier
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let serviceIdentifier = self.serviceIdentifier {
            try encodeContainer.encode(serviceIdentifier, forKey: .serviceIdentifier)
        }
        if let serviceNetworkIdentifier = self.serviceNetworkIdentifier {
            try encodeContainer.encode(serviceNetworkIdentifier, forKey: .serviceNetworkIdentifier)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateServiceNetworkServiceAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/servicenetworkserviceassociations"
    }
}

public struct CreateServiceNetworkServiceAssociationInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service network. You must use the ARN if the resources specified in the operation are in different accounts.
    /// This member is required.
    public var serviceNetworkIdentifier: Swift.String?
    /// The tags for the association.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil,
        serviceNetworkIdentifier: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.serviceIdentifier = serviceIdentifier
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
        self.tags = tags
    }
}

struct CreateServiceNetworkServiceAssociationInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let serviceIdentifier: Swift.String?
    let serviceNetworkIdentifier: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateServiceNetworkServiceAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case serviceIdentifier
        case serviceNetworkIdentifier
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let serviceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceIdentifier)
        serviceIdentifier = serviceIdentifierDecoded
        let serviceNetworkIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceNetworkIdentifier)
        serviceNetworkIdentifier = serviceNetworkIdentifierDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateServiceNetworkServiceAssociationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateServiceNetworkServiceAssociationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateServiceNetworkServiceAssociationOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateServiceNetworkServiceAssociationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: CreateServiceNetworkServiceAssociationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdBy = output.createdBy
            self.customDomainName = output.customDomainName
            self.dnsEntry = output.dnsEntry
            self.id = output.id
            self.status = output.status
        } else {
            self.arn = nil
            self.createdBy = nil
            self.customDomainName = nil
            self.dnsEntry = nil
            self.id = nil
            self.status = nil
        }
    }
}

public struct CreateServiceNetworkServiceAssociationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The account that created the association.
    public var createdBy: Swift.String?
    /// The custom domain name of the service.
    public var customDomainName: Swift.String?
    /// The DNS name of the service.
    public var dnsEntry: VPCLatticeClientTypes.DnsEntry?
    /// The ID of the association.
    public var id: Swift.String?
    /// The operation's status.
    public var status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus?

    public init (
        arn: Swift.String? = nil,
        createdBy: Swift.String? = nil,
        customDomainName: Swift.String? = nil,
        dnsEntry: VPCLatticeClientTypes.DnsEntry? = nil,
        id: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus? = nil
    )
    {
        self.arn = arn
        self.createdBy = createdBy
        self.customDomainName = customDomainName
        self.dnsEntry = dnsEntry
        self.id = id
        self.status = status
    }
}

struct CreateServiceNetworkServiceAssociationOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus?
    let arn: Swift.String?
    let createdBy: Swift.String?
    let customDomainName: Swift.String?
    let dnsEntry: VPCLatticeClientTypes.DnsEntry?
}

extension CreateServiceNetworkServiceAssociationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdBy
        case customDomainName
        case dnsEntry
        case id
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let customDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomainName)
        customDomainName = customDomainNameDecoded
        let dnsEntryDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.DnsEntry.self, forKey: .dnsEntry)
        dnsEntry = dnsEntryDecoded
    }
}

extension CreateServiceNetworkVpcAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case securityGroupIds
        case serviceNetworkIdentifier
        case tags
        case vpcIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let serviceNetworkIdentifier = self.serviceNetworkIdentifier {
            try encodeContainer.encode(serviceNetworkIdentifier, forKey: .serviceNetworkIdentifier)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vpcIdentifier = self.vpcIdentifier {
            try encodeContainer.encode(vpcIdentifier, forKey: .vpcIdentifier)
        }
    }
}

extension CreateServiceNetworkVpcAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/servicenetworkvpcassociations"
    }
}

public struct CreateServiceNetworkVpcAssociationInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The IDs of the security groups. Security groups aren't added by default. You can add a security group to apply network level controls to control which resources in a VPC are allowed to access the service network and its services. For more information, see [Control traffic to resources using security groups](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html) in the Amazon VPC User Guide.
    public var securityGroupIds: [Swift.String]?
    /// The ID or Amazon Resource Name (ARN) of the service network. You must use the ARN when the resources specified in the operation are in different accounts.
    /// This member is required.
    public var serviceNetworkIdentifier: Swift.String?
    /// The tags for the association.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the VPC.
    /// This member is required.
    public var vpcIdentifier: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        serviceNetworkIdentifier: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcIdentifier: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.securityGroupIds = securityGroupIds
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
        self.tags = tags
        self.vpcIdentifier = vpcIdentifier
    }
}

struct CreateServiceNetworkVpcAssociationInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let serviceNetworkIdentifier: Swift.String?
    let vpcIdentifier: Swift.String?
    let securityGroupIds: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateServiceNetworkVpcAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case securityGroupIds
        case serviceNetworkIdentifier
        case tags
        case vpcIdentifier
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let serviceNetworkIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceNetworkIdentifier)
        serviceNetworkIdentifier = serviceNetworkIdentifierDecoded
        let vpcIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcIdentifier)
        vpcIdentifier = vpcIdentifierDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateServiceNetworkVpcAssociationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateServiceNetworkVpcAssociationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateServiceNetworkVpcAssociationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateServiceNetworkVpcAssociationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: CreateServiceNetworkVpcAssociationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdBy = output.createdBy
            self.id = output.id
            self.securityGroupIds = output.securityGroupIds
            self.status = output.status
        } else {
            self.arn = nil
            self.createdBy = nil
            self.id = nil
            self.securityGroupIds = nil
            self.status = nil
        }
    }
}

public struct CreateServiceNetworkVpcAssociationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The account that created the association.
    public var createdBy: Swift.String?
    /// The ID of the association.
    public var id: Swift.String?
    /// The IDs of the security groups.
    public var securityGroupIds: [Swift.String]?
    /// The operation's status.
    public var status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus?

    public init (
        arn: Swift.String? = nil,
        createdBy: Swift.String? = nil,
        id: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus? = nil
    )
    {
        self.arn = arn
        self.createdBy = createdBy
        self.id = id
        self.securityGroupIds = securityGroupIds
        self.status = status
    }
}

struct CreateServiceNetworkVpcAssociationOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus?
    let arn: Swift.String?
    let createdBy: Swift.String?
    let securityGroupIds: [Swift.String]?
}

extension CreateServiceNetworkVpcAssociationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdBy
        case id
        case securityGroupIds
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension CreateServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateServiceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: CreateServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.authType = output.authType
            self.certificateArn = output.certificateArn
            self.customDomainName = output.customDomainName
            self.dnsEntry = output.dnsEntry
            self.id = output.id
            self.name = output.name
            self.status = output.status
        } else {
            self.arn = nil
            self.authType = nil
            self.certificateArn = nil
            self.customDomainName = nil
            self.dnsEntry = nil
            self.id = nil
            self.name = nil
            self.status = nil
        }
    }
}

public struct CreateServiceOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the service.
    public var arn: Swift.String?
    /// The type of IAM policy.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The Amazon Resource Name (ARN) of the certificate.
    public var certificateArn: Swift.String?
    /// The custom domain name of the service.
    public var customDomainName: Swift.String?
    /// The public DNS name of the service.
    public var dnsEntry: VPCLatticeClientTypes.DnsEntry?
    /// The ID of the service.
    public var id: Swift.String?
    /// The name of the service.
    public var name: Swift.String?
    /// The status. If the status is CREATE_FAILED, you will have to delete and recreate the service.
    public var status: VPCLatticeClientTypes.ServiceStatus?

    public init (
        arn: Swift.String? = nil,
        authType: VPCLatticeClientTypes.AuthType? = nil,
        certificateArn: Swift.String? = nil,
        customDomainName: Swift.String? = nil,
        dnsEntry: VPCLatticeClientTypes.DnsEntry? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceStatus? = nil
    )
    {
        self.arn = arn
        self.authType = authType
        self.certificateArn = certificateArn
        self.customDomainName = customDomainName
        self.dnsEntry = dnsEntry
        self.id = id
        self.name = name
        self.status = status
    }
}

struct CreateServiceOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let customDomainName: Swift.String?
    let certificateArn: Swift.String?
    let status: VPCLatticeClientTypes.ServiceStatus?
    let authType: VPCLatticeClientTypes.AuthType?
    let dnsEntry: VPCLatticeClientTypes.DnsEntry?
}

extension CreateServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case authType
        case certificateArn
        case customDomainName
        case dnsEntry
        case id
        case name
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let customDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomainName)
        customDomainName = customDomainNameDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ServiceStatus.self, forKey: .status)
        status = statusDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.AuthType.self, forKey: .authType)
        authType = authTypeDecoded
        let dnsEntryDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.DnsEntry.self, forKey: .dnsEntry)
        dnsEntry = dnsEntryDecoded
    }
}

extension CreateTargetGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case config
        case name
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let config = self.config {
            try encodeContainer.encode(config, forKey: .config)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateTargetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/targetgroups"
    }
}

public struct CreateTargetGroupInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The target group configuration. If type is set to LAMBDA, this parameter doesn't apply.
    public var config: VPCLatticeClientTypes.TargetGroupConfig?
    /// The name of the target group. The name must be unique within the account. The valid characters are a-z, 0-9, and hyphens (-). You can't use a hyphen as the first or last character, or immediately after another hyphen.
    /// This member is required.
    public var name: Swift.String?
    /// The tags for the target group.
    public var tags: [Swift.String:Swift.String]?
    /// The type of target group.
    /// This member is required.
    public var type: VPCLatticeClientTypes.TargetGroupType?

    public init (
        clientToken: Swift.String? = nil,
        config: VPCLatticeClientTypes.TargetGroupConfig? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: VPCLatticeClientTypes.TargetGroupType? = nil
    )
    {
        self.clientToken = clientToken
        self.config = config
        self.name = name
        self.tags = tags
        self.type = type
    }
}

struct CreateTargetGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let type: VPCLatticeClientTypes.TargetGroupType?
    let config: VPCLatticeClientTypes.TargetGroupConfig?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateTargetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case config
        case name
        case tags
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetGroupType.self, forKey: .type)
        type = typeDecoded
        let configDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetGroupConfig.self, forKey: .config)
        config = configDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateTargetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTargetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateTargetGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTargetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: CreateTargetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.config = output.config
            self.id = output.id
            self.name = output.name
            self.status = output.status
            self.type = output.type
        } else {
            self.arn = nil
            self.config = nil
            self.id = nil
            self.name = nil
            self.status = nil
            self.type = nil
        }
    }
}

public struct CreateTargetGroupOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the target group.
    public var arn: Swift.String?
    /// The target group configuration. If type is set to LAMBDA, this parameter doesn't apply.
    public var config: VPCLatticeClientTypes.TargetGroupConfig?
    /// The ID of the target group.
    public var id: Swift.String?
    /// The name of the target group.
    public var name: Swift.String?
    /// The operation's status. You can retry the operation if the status is CREATE_FAILED. However, if you retry it while the status is CREATE_IN_PROGRESS, there is no change in the status.
    public var status: VPCLatticeClientTypes.TargetGroupStatus?
    /// The type of target group.
    public var type: VPCLatticeClientTypes.TargetGroupType?

    public init (
        arn: Swift.String? = nil,
        config: VPCLatticeClientTypes.TargetGroupConfig? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: VPCLatticeClientTypes.TargetGroupStatus? = nil,
        type: VPCLatticeClientTypes.TargetGroupType? = nil
    )
    {
        self.arn = arn
        self.config = config
        self.id = id
        self.name = name
        self.status = status
        self.type = type
    }
}

struct CreateTargetGroupOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let type: VPCLatticeClientTypes.TargetGroupType?
    let config: VPCLatticeClientTypes.TargetGroupConfig?
    let status: VPCLatticeClientTypes.TargetGroupStatus?
}

extension CreateTargetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case config
        case id
        case name
        case status
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetGroupType.self, forKey: .type)
        type = typeDecoded
        let configDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetGroupConfig.self, forKey: .config)
        config = configDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetGroupStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteAccessLogSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accessLogSubscriptionIdentifier = accessLogSubscriptionIdentifier else {
            return nil
        }
        return "/accesslogsubscriptions/\(accessLogSubscriptionIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteAccessLogSubscriptionInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the access log subscription.
    /// This member is required.
    public var accessLogSubscriptionIdentifier: Swift.String?

    public init (
        accessLogSubscriptionIdentifier: Swift.String? = nil
    )
    {
        self.accessLogSubscriptionIdentifier = accessLogSubscriptionIdentifier
    }
}

struct DeleteAccessLogSubscriptionInputBody: Swift.Equatable {
}

extension DeleteAccessLogSubscriptionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAccessLogSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAccessLogSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAccessLogSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAccessLogSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAccessLogSubscriptionOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteAuthPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceIdentifier = resourceIdentifier else {
            return nil
        }
        return "/authpolicy/\(resourceIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteAuthPolicyInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceIdentifier: Swift.String?

    public init (
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
    }
}

struct DeleteAuthPolicyInputBody: Swift.Equatable {
}

extension DeleteAuthPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAuthPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAuthPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAuthPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAuthPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAuthPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteListenerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceIdentifier = serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = listenerIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteListenerInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init (
        listenerIdentifier: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.listenerIdentifier = listenerIdentifier
        self.serviceIdentifier = serviceIdentifier
    }
}

struct DeleteListenerInputBody: Swift.Equatable {
}

extension DeleteListenerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteListenerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteListenerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteListenerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteListenerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteListenerOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/resourcepolicy/\(resourceArn.urlPercentEncoding())"
    }
}

public struct DeleteResourcePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct DeleteResourcePolicyInputBody: Swift.Equatable {
}

extension DeleteResourcePolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteResourcePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourcePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteResourcePolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourcePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResourcePolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceIdentifier = serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = listenerIdentifier else {
            return nil
        }
        guard let ruleIdentifier = ruleIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())/rules/\(ruleIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteRuleInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the rule.
    /// This member is required.
    public var ruleIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init (
        listenerIdentifier: Swift.String? = nil,
        ruleIdentifier: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.listenerIdentifier = listenerIdentifier
        self.ruleIdentifier = ruleIdentifier
        self.serviceIdentifier = serviceIdentifier
    }
}

struct DeleteRuleInputBody: Swift.Equatable {
}

extension DeleteRuleInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteRuleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRuleOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceIdentifier = serviceIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteServiceInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init (
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.serviceIdentifier = serviceIdentifier
    }
}

struct DeleteServiceInputBody: Swift.Equatable {
}

extension DeleteServiceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteServiceNetworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceNetworkIdentifier = serviceNetworkIdentifier else {
            return nil
        }
        return "/servicenetworks/\(serviceNetworkIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteServiceNetworkInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) or ID of the service network.
    /// This member is required.
    public var serviceNetworkIdentifier: Swift.String?

    public init (
        serviceNetworkIdentifier: Swift.String? = nil
    )
    {
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
    }
}

struct DeleteServiceNetworkInputBody: Swift.Equatable {
}

extension DeleteServiceNetworkInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteServiceNetworkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteServiceNetworkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteServiceNetworkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServiceNetworkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteServiceNetworkOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteServiceNetworkServiceAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceNetworkServiceAssociationIdentifier = serviceNetworkServiceAssociationIdentifier else {
            return nil
        }
        return "/servicenetworkserviceassociations/\(serviceNetworkServiceAssociationIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteServiceNetworkServiceAssociationInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the association.
    /// This member is required.
    public var serviceNetworkServiceAssociationIdentifier: Swift.String?

    public init (
        serviceNetworkServiceAssociationIdentifier: Swift.String? = nil
    )
    {
        self.serviceNetworkServiceAssociationIdentifier = serviceNetworkServiceAssociationIdentifier
    }
}

struct DeleteServiceNetworkServiceAssociationInputBody: Swift.Equatable {
}

extension DeleteServiceNetworkServiceAssociationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteServiceNetworkServiceAssociationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteServiceNetworkServiceAssociationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteServiceNetworkServiceAssociationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServiceNetworkServiceAssociationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: DeleteServiceNetworkServiceAssociationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.status = output.status
        } else {
            self.arn = nil
            self.id = nil
            self.status = nil
        }
    }
}

public struct DeleteServiceNetworkServiceAssociationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The ID of the association.
    public var id: Swift.String?
    /// The operation's status. You can retry the operation if the status is DELETE_FAILED. However, if you retry it when the status is DELETE_IN_PROGRESS, there is no change in the status.
    public var status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.status = status
    }
}

struct DeleteServiceNetworkServiceAssociationOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus?
    let arn: Swift.String?
}

extension DeleteServiceNetworkServiceAssociationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteServiceNetworkVpcAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceNetworkVpcAssociationIdentifier = serviceNetworkVpcAssociationIdentifier else {
            return nil
        }
        return "/servicenetworkvpcassociations/\(serviceNetworkVpcAssociationIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteServiceNetworkVpcAssociationInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the association.
    /// This member is required.
    public var serviceNetworkVpcAssociationIdentifier: Swift.String?

    public init (
        serviceNetworkVpcAssociationIdentifier: Swift.String? = nil
    )
    {
        self.serviceNetworkVpcAssociationIdentifier = serviceNetworkVpcAssociationIdentifier
    }
}

struct DeleteServiceNetworkVpcAssociationInputBody: Swift.Equatable {
}

extension DeleteServiceNetworkVpcAssociationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteServiceNetworkVpcAssociationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteServiceNetworkVpcAssociationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteServiceNetworkVpcAssociationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServiceNetworkVpcAssociationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: DeleteServiceNetworkVpcAssociationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.status = output.status
        } else {
            self.arn = nil
            self.id = nil
            self.status = nil
        }
    }
}

public struct DeleteServiceNetworkVpcAssociationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The ID of the association.
    public var id: Swift.String?
    /// The status. You can retry the operation if the status is DELETE_FAILED. However, if you retry it when the status is DELETE_IN_PROGRESS, there is no change in the status.
    public var status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.status = status
    }
}

struct DeleteServiceNetworkVpcAssociationOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus?
    let arn: Swift.String?
}

extension DeleteServiceNetworkVpcAssociationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteServiceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: DeleteServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.name = output.name
            self.status = output.status
        } else {
            self.arn = nil
            self.id = nil
            self.name = nil
            self.status = nil
        }
    }
}

public struct DeleteServiceOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the service.
    public var arn: Swift.String?
    /// The ID of the service.
    public var id: Swift.String?
    /// The name of the service.
    public var name: Swift.String?
    /// The status. You can retry the operation if the status is DELETE_FAILED. However, if you retry it while the status is DELETE_IN_PROGRESS, the status doesn't change.
    public var status: VPCLatticeClientTypes.ServiceStatus?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceStatus? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.name = name
        self.status = status
    }
}

struct DeleteServiceOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let status: VPCLatticeClientTypes.ServiceStatus?
}

extension DeleteServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case name
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ServiceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteTargetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let targetGroupIdentifier = targetGroupIdentifier else {
            return nil
        }
        return "/targetgroups/\(targetGroupIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteTargetGroupInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the target group.
    /// This member is required.
    public var targetGroupIdentifier: Swift.String?

    public init (
        targetGroupIdentifier: Swift.String? = nil
    )
    {
        self.targetGroupIdentifier = targetGroupIdentifier
    }
}

struct DeleteTargetGroupInputBody: Swift.Equatable {
}

extension DeleteTargetGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTargetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTargetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteTargetGroupOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTargetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: DeleteTargetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.status = output.status
        } else {
            self.arn = nil
            self.id = nil
            self.status = nil
        }
    }
}

public struct DeleteTargetGroupOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the target group.
    public var arn: Swift.String?
    /// The ID of the target group.
    public var id: Swift.String?
    /// The status. You can retry the operation if the status is DELETE_FAILED. However, if you retry it while the status is DELETE_IN_PROGRESS, the status doesn't change.
    public var status: VPCLatticeClientTypes.TargetGroupStatus?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        status: VPCLatticeClientTypes.TargetGroupStatus? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.status = status
    }
}

struct DeleteTargetGroupOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let status: VPCLatticeClientTypes.TargetGroupStatus?
}

extension DeleteTargetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetGroupStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeregisterTargetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for target0 in targets {
                try targetsContainer.encode(target0)
            }
        }
    }
}

extension DeregisterTargetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let targetGroupIdentifier = targetGroupIdentifier else {
            return nil
        }
        return "/targetgroups/\(targetGroupIdentifier.urlPercentEncoding())/deregistertargets"
    }
}

public struct DeregisterTargetsInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the target group.
    /// This member is required.
    public var targetGroupIdentifier: Swift.String?
    /// The targets to deregister.
    /// This member is required.
    public var targets: [VPCLatticeClientTypes.Target]?

    public init (
        targetGroupIdentifier: Swift.String? = nil,
        targets: [VPCLatticeClientTypes.Target]? = nil
    )
    {
        self.targetGroupIdentifier = targetGroupIdentifier
        self.targets = targets
    }
}

struct DeregisterTargetsInputBody: Swift.Equatable {
    let targets: [VPCLatticeClientTypes.Target]?
}

extension DeregisterTargetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targets
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetsContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[VPCLatticeClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [VPCLatticeClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
    }
}

extension DeregisterTargetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterTargetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeregisterTargetsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterTargetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: DeregisterTargetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.successful = output.successful
            self.unsuccessful = output.unsuccessful
        } else {
            self.successful = nil
            self.unsuccessful = nil
        }
    }
}

public struct DeregisterTargetsOutputResponse: Swift.Equatable {
    /// The targets that were successfully deregistered.
    public var successful: [VPCLatticeClientTypes.Target]?
    /// The targets that the operation couldn't deregister.
    public var unsuccessful: [VPCLatticeClientTypes.TargetFailure]?

    public init (
        successful: [VPCLatticeClientTypes.Target]? = nil,
        unsuccessful: [VPCLatticeClientTypes.TargetFailure]? = nil
    )
    {
        self.successful = successful
        self.unsuccessful = unsuccessful
    }
}

struct DeregisterTargetsOutputResponseBody: Swift.Equatable {
    let successful: [VPCLatticeClientTypes.Target]?
    let unsuccessful: [VPCLatticeClientTypes.TargetFailure]?
}

extension DeregisterTargetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case successful
        case unsuccessful
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.Target?].self, forKey: .successful)
        var successfulDecoded0:[VPCLatticeClientTypes.Target]? = nil
        if let successfulContainer = successfulContainer {
            successfulDecoded0 = [VPCLatticeClientTypes.Target]()
            for structure0 in successfulContainer {
                if let structure0 = structure0 {
                    successfulDecoded0?.append(structure0)
                }
            }
        }
        successful = successfulDecoded0
        let unsuccessfulContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.TargetFailure?].self, forKey: .unsuccessful)
        var unsuccessfulDecoded0:[VPCLatticeClientTypes.TargetFailure]? = nil
        if let unsuccessfulContainer = unsuccessfulContainer {
            unsuccessfulDecoded0 = [VPCLatticeClientTypes.TargetFailure]()
            for structure0 in unsuccessfulContainer {
                if let structure0 = structure0 {
                    unsuccessfulDecoded0?.append(structure0)
                }
            }
        }
        unsuccessful = unsuccessfulDecoded0
    }
}

extension VPCLatticeClientTypes.DnsEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName
        case hostedZoneId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let hostedZoneId = self.hostedZoneId {
            try encodeContainer.encode(hostedZoneId, forKey: .hostedZoneId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let hostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostedZoneId)
        hostedZoneId = hostedZoneIdDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Describes the DNS information of a service.
    public struct DnsEntry: Swift.Equatable {
        /// The domain name of the service.
        public var domainName: Swift.String?
        /// The ID of the hosted zone.
        public var hostedZoneId: Swift.String?

        public init (
            domainName: Swift.String? = nil,
            hostedZoneId: Swift.String? = nil
        )
        {
            self.domainName = domainName
            self.hostedZoneId = hostedZoneId
        }
    }

}

extension VPCLatticeClientTypes.FixedResponseAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statusCode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode, forKey: .statusCode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Information about an action that returns a custom HTTP response.
    public struct FixedResponseAction: Swift.Equatable {
        /// The HTTP response code.
        /// This member is required.
        public var statusCode: Swift.Int?

        public init (
            statusCode: Swift.Int? = nil
        )
        {
            self.statusCode = statusCode
        }
    }

}

extension VPCLatticeClientTypes.ForwardAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetGroups
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetGroups = targetGroups {
            var targetGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetGroups)
            for weightedtargetgroup0 in targetGroups {
                try targetGroupsContainer.encode(weightedtargetgroup0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetGroupsContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.WeightedTargetGroup?].self, forKey: .targetGroups)
        var targetGroupsDecoded0:[VPCLatticeClientTypes.WeightedTargetGroup]? = nil
        if let targetGroupsContainer = targetGroupsContainer {
            targetGroupsDecoded0 = [VPCLatticeClientTypes.WeightedTargetGroup]()
            for structure0 in targetGroupsContainer {
                if let structure0 = structure0 {
                    targetGroupsDecoded0?.append(structure0)
                }
            }
        }
        targetGroups = targetGroupsDecoded0
    }
}

extension VPCLatticeClientTypes {
    /// Describes a forward action. You can use forward actions to route requests to one or more target groups.
    public struct ForwardAction: Swift.Equatable {
        /// The target groups. Traffic matching the rule is forwarded to the specified target groups. With forward actions, you can assign a weight that controls the prioritization and selection of each target group. This means that requests are distributed to individual target groups based on their weights. For example, if two target groups have the same weight, each target group receives half of the traffic. The default value is 1. This means that if only one target group is provided, there is no need to set the weight; 100% of traffic will go to that target group.
        /// This member is required.
        public var targetGroups: [VPCLatticeClientTypes.WeightedTargetGroup]?

        public init (
            targetGroups: [VPCLatticeClientTypes.WeightedTargetGroup]? = nil
        )
        {
            self.targetGroups = targetGroups
        }
    }

}

extension GetAccessLogSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accessLogSubscriptionIdentifier = accessLogSubscriptionIdentifier else {
            return nil
        }
        return "/accesslogsubscriptions/\(accessLogSubscriptionIdentifier.urlPercentEncoding())"
    }
}

public struct GetAccessLogSubscriptionInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the access log subscription.
    /// This member is required.
    public var accessLogSubscriptionIdentifier: Swift.String?

    public init (
        accessLogSubscriptionIdentifier: Swift.String? = nil
    )
    {
        self.accessLogSubscriptionIdentifier = accessLogSubscriptionIdentifier
    }
}

struct GetAccessLogSubscriptionInputBody: Swift.Equatable {
}

extension GetAccessLogSubscriptionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAccessLogSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAccessLogSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAccessLogSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccessLogSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: GetAccessLogSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.destinationArn = output.destinationArn
            self.id = output.id
            self.lastUpdatedAt = output.lastUpdatedAt
            self.resourceArn = output.resourceArn
            self.resourceId = output.resourceId
        } else {
            self.arn = nil
            self.createdAt = nil
            self.destinationArn = nil
            self.id = nil
            self.lastUpdatedAt = nil
            self.resourceArn = nil
            self.resourceId = nil
        }
    }
}

public struct GetAccessLogSubscriptionOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the access log subscription.
    /// This member is required.
    public var arn: Swift.String?
    /// The date and time that the access log subscription was created, specified in ISO-8601 format.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the access log destination.
    /// This member is required.
    public var destinationArn: Swift.String?
    /// The ID of the access log subscription.
    /// This member is required.
    public var id: Swift.String?
    /// The date and time that the access log subscription was last updated, specified in ISO-8601 format.
    /// This member is required.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the service network or service.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The ID of the service network or service.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        destinationArn: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        resourceArn: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.destinationArn = destinationArn
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.resourceArn = resourceArn
        self.resourceId = resourceId
    }
}

struct GetAccessLogSubscriptionOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let resourceId: Swift.String?
    let resourceArn: Swift.String?
    let destinationArn: Swift.String?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
}

extension GetAccessLogSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case destinationArn
        case id
        case lastUpdatedAt
        case resourceArn
        case resourceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let destinationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationArn)
        destinationArn = destinationArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension GetAuthPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceIdentifier = resourceIdentifier else {
            return nil
        }
        return "/authpolicy/\(resourceIdentifier.urlPercentEncoding())"
    }
}

public struct GetAuthPolicyInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the service network or service.
    /// This member is required.
    public var resourceIdentifier: Swift.String?

    public init (
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
    }
}

struct GetAuthPolicyInputBody: Swift.Equatable {
}

extension GetAuthPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAuthPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAuthPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAuthPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAuthPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: GetAuthPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.lastUpdatedAt = output.lastUpdatedAt
            self.policy = output.policy
            self.state = output.state
        } else {
            self.createdAt = nil
            self.lastUpdatedAt = nil
            self.policy = nil
            self.state = nil
        }
    }
}

public struct GetAuthPolicyOutputResponse: Swift.Equatable {
    /// The date and time that the auth policy was created, specified in ISO-8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The date and time that the auth policy was last updated, specified in ISO-8601 format.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The auth policy.
    public var policy: Swift.String?
    /// The state of the auth policy. The auth policy is only active when the auth type is set to AWS_IAM. If you provide a policy, then authentication and authorization decisions are made based on this policy and the client's IAM policy. If the auth type is NONE, then any auth policy you provide will remain inactive. For more information, see [Create a service network](https://docs.aws.amazon.com/vpc-lattice/latest/ug/service-networks.html#create-service-network) in the Amazon VPC Lattice User Guide.
    public var state: VPCLatticeClientTypes.AuthPolicyState?

    public init (
        createdAt: ClientRuntime.Date? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        policy: Swift.String? = nil,
        state: VPCLatticeClientTypes.AuthPolicyState? = nil
    )
    {
        self.createdAt = createdAt
        self.lastUpdatedAt = lastUpdatedAt
        self.policy = policy
        self.state = state
    }
}

struct GetAuthPolicyOutputResponseBody: Swift.Equatable {
    let policy: Swift.String?
    let state: VPCLatticeClientTypes.AuthPolicyState?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
}

extension GetAuthPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case lastUpdatedAt
        case policy
        case state
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let stateDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.AuthPolicyState.self, forKey: .state)
        state = stateDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension GetListenerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceIdentifier = serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = listenerIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())"
    }
}

public struct GetListenerInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init (
        listenerIdentifier: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.listenerIdentifier = listenerIdentifier
        self.serviceIdentifier = serviceIdentifier
    }
}

struct GetListenerInputBody: Swift.Equatable {
}

extension GetListenerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetListenerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetListenerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetListenerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetListenerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: GetListenerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.`protocol` = output.`protocol`
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.defaultAction = output.defaultAction
            self.id = output.id
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.port = output.port
            self.serviceArn = output.serviceArn
            self.serviceId = output.serviceId
        } else {
            self.arn = nil
            self.createdAt = nil
            self.defaultAction = nil
            self.id = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.port = nil
            self.`protocol` = nil
            self.serviceArn = nil
            self.serviceId = nil
        }
    }
}

public struct GetListenerOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the listener.
    public var arn: Swift.String?
    /// The date and time that the listener was created, specified in ISO-8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The actions for the default listener rule.
    public var defaultAction: VPCLatticeClientTypes.RuleAction?
    /// The ID of the listener.
    public var id: Swift.String?
    /// The date and time that the listener was last updated, specified in ISO-8601 format.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the listener.
    public var name: Swift.String?
    /// The listener port.
    public var port: Swift.Int?
    /// The listener protocol.
    public var `protocol`: VPCLatticeClientTypes.ListenerProtocol?
    /// The Amazon Resource Name (ARN) of the service.
    public var serviceArn: Swift.String?
    /// The ID of the service.
    public var serviceId: Swift.String?

    public init (
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        defaultAction: VPCLatticeClientTypes.RuleAction? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        port: Swift.Int? = nil,
        `protocol`: VPCLatticeClientTypes.ListenerProtocol? = nil,
        serviceArn: Swift.String? = nil,
        serviceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.defaultAction = defaultAction
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.port = port
        self.`protocol` = `protocol`
        self.serviceArn = serviceArn
        self.serviceId = serviceId
    }
}

struct GetListenerOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let `protocol`: VPCLatticeClientTypes.ListenerProtocol?
    let port: Swift.Int?
    let serviceArn: Swift.String?
    let serviceId: Swift.String?
    let defaultAction: VPCLatticeClientTypes.RuleAction?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
}

extension GetListenerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case defaultAction
        case id
        case lastUpdatedAt
        case name
        case port
        case `protocol` = "protocol"
        case serviceArn
        case serviceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ListenerProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let defaultActionDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleAction.self, forKey: .defaultAction)
        defaultAction = defaultActionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension GetResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/resourcepolicy/\(resourceArn.urlPercentEncoding())"
    }
}

public struct GetResourcePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the service network or service.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct GetResourcePolicyInputBody: Swift.Equatable {
}

extension GetResourcePolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetResourcePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourcePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetResourcePolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourcePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: GetResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetResourcePolicyOutputResponse: Swift.Equatable {
    /// An IAM policy.
    public var policy: Swift.String?

    public init (
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

struct GetResourcePolicyOutputResponseBody: Swift.Equatable {
    let policy: Swift.String?
}

extension GetResourcePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GetRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceIdentifier = serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = listenerIdentifier else {
            return nil
        }
        guard let ruleIdentifier = ruleIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())/rules/\(ruleIdentifier.urlPercentEncoding())"
    }
}

public struct GetRuleInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the listener rule.
    /// This member is required.
    public var ruleIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init (
        listenerIdentifier: Swift.String? = nil,
        ruleIdentifier: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.listenerIdentifier = listenerIdentifier
        self.ruleIdentifier = ruleIdentifier
        self.serviceIdentifier = serviceIdentifier
    }
}

struct GetRuleInputBody: Swift.Equatable {
}

extension GetRuleInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetRuleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: GetRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.action = output.action
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.id = output.id
            self.isDefault = output.isDefault
            self.lastUpdatedAt = output.lastUpdatedAt
            self.match = output.match
            self.name = output.name
            self.priority = output.priority
        } else {
            self.action = nil
            self.arn = nil
            self.createdAt = nil
            self.id = nil
            self.isDefault = nil
            self.lastUpdatedAt = nil
            self.match = nil
            self.name = nil
            self.priority = nil
        }
    }
}

public struct GetRuleOutputResponse: Swift.Equatable {
    /// The action for the default rule.
    public var action: VPCLatticeClientTypes.RuleAction?
    /// The Amazon Resource Name (ARN) of the listener.
    public var arn: Swift.String?
    /// The date and time that the listener rule was created, specified in ISO-8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The ID of the listener.
    public var id: Swift.String?
    /// Indicates whether this is the default rule.
    public var isDefault: Swift.Bool?
    /// The date and time that the listener rule was last updated, specified in ISO-8601 format.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The rule match.
    public var match: VPCLatticeClientTypes.RuleMatch?
    /// The name of the listener.
    public var name: Swift.String?
    /// The priority level for the specified rule.
    public var priority: Swift.Int?

    public init (
        action: VPCLatticeClientTypes.RuleAction? = nil,
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        isDefault: Swift.Bool? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        match: VPCLatticeClientTypes.RuleMatch? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil
    )
    {
        self.action = action
        self.arn = arn
        self.createdAt = createdAt
        self.id = id
        self.isDefault = isDefault
        self.lastUpdatedAt = lastUpdatedAt
        self.match = match
        self.name = name
        self.priority = priority
    }
}

struct GetRuleOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let isDefault: Swift.Bool?
    let match: VPCLatticeClientTypes.RuleMatch?
    let priority: Swift.Int?
    let action: VPCLatticeClientTypes.RuleAction?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
}

extension GetRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case arn
        case createdAt
        case id
        case isDefault
        case lastUpdatedAt
        case match
        case name
        case priority
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let isDefaultDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDefault)
        isDefault = isDefaultDecoded
        let matchDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleMatch.self, forKey: .match)
        match = matchDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let actionDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleAction.self, forKey: .action)
        action = actionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension GetServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceIdentifier = serviceIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())"
    }
}

public struct GetServiceInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init (
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.serviceIdentifier = serviceIdentifier
    }
}

struct GetServiceInputBody: Swift.Equatable {
}

extension GetServiceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetServiceNetworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceNetworkIdentifier = serviceNetworkIdentifier else {
            return nil
        }
        return "/servicenetworks/\(serviceNetworkIdentifier.urlPercentEncoding())"
    }
}

public struct GetServiceNetworkInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the service network.
    /// This member is required.
    public var serviceNetworkIdentifier: Swift.String?

    public init (
        serviceNetworkIdentifier: Swift.String? = nil
    )
    {
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
    }
}

struct GetServiceNetworkInputBody: Swift.Equatable {
}

extension GetServiceNetworkInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetServiceNetworkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServiceNetworkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetServiceNetworkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceNetworkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: GetServiceNetworkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.authType = output.authType
            self.createdAt = output.createdAt
            self.id = output.id
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.numberOfAssociatedServices = output.numberOfAssociatedServices
            self.numberOfAssociatedVPCs = output.numberOfAssociatedVPCs
        } else {
            self.arn = nil
            self.authType = nil
            self.createdAt = nil
            self.id = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.numberOfAssociatedServices = nil
            self.numberOfAssociatedVPCs = nil
        }
    }
}

public struct GetServiceNetworkOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the service network.
    public var arn: Swift.String?
    /// The type of IAM policy.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The date and time that the service network was created, specified in ISO-8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The ID of the service network.
    public var id: Swift.String?
    /// The date and time of the last update, specified in ISO-8601 format.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the service network.
    public var name: Swift.String?
    /// The number of services associated with the service network.
    public var numberOfAssociatedServices: Swift.Int?
    /// The number of VPCs associated with the service network.
    public var numberOfAssociatedVPCs: Swift.Int?

    public init (
        arn: Swift.String? = nil,
        authType: VPCLatticeClientTypes.AuthType? = nil,
        createdAt: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        numberOfAssociatedServices: Swift.Int? = nil,
        numberOfAssociatedVPCs: Swift.Int? = nil
    )
    {
        self.arn = arn
        self.authType = authType
        self.createdAt = createdAt
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.numberOfAssociatedServices = numberOfAssociatedServices
        self.numberOfAssociatedVPCs = numberOfAssociatedVPCs
    }
}

struct GetServiceNetworkOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
    let arn: Swift.String?
    let authType: VPCLatticeClientTypes.AuthType?
    let numberOfAssociatedVPCs: Swift.Int?
    let numberOfAssociatedServices: Swift.Int?
}

extension GetServiceNetworkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case authType
        case createdAt
        case id
        case lastUpdatedAt
        case name
        case numberOfAssociatedServices
        case numberOfAssociatedVPCs
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.AuthType.self, forKey: .authType)
        authType = authTypeDecoded
        let numberOfAssociatedVPCsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfAssociatedVPCs)
        numberOfAssociatedVPCs = numberOfAssociatedVPCsDecoded
        let numberOfAssociatedServicesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfAssociatedServices)
        numberOfAssociatedServices = numberOfAssociatedServicesDecoded
    }
}

extension GetServiceNetworkServiceAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceNetworkServiceAssociationIdentifier = serviceNetworkServiceAssociationIdentifier else {
            return nil
        }
        return "/servicenetworkserviceassociations/\(serviceNetworkServiceAssociationIdentifier.urlPercentEncoding())"
    }
}

public struct GetServiceNetworkServiceAssociationInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the association.
    /// This member is required.
    public var serviceNetworkServiceAssociationIdentifier: Swift.String?

    public init (
        serviceNetworkServiceAssociationIdentifier: Swift.String? = nil
    )
    {
        self.serviceNetworkServiceAssociationIdentifier = serviceNetworkServiceAssociationIdentifier
    }
}

struct GetServiceNetworkServiceAssociationInputBody: Swift.Equatable {
}

extension GetServiceNetworkServiceAssociationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetServiceNetworkServiceAssociationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServiceNetworkServiceAssociationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetServiceNetworkServiceAssociationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceNetworkServiceAssociationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: GetServiceNetworkServiceAssociationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.customDomainName = output.customDomainName
            self.dnsEntry = output.dnsEntry
            self.failureCode = output.failureCode
            self.failureMessage = output.failureMessage
            self.id = output.id
            self.serviceArn = output.serviceArn
            self.serviceId = output.serviceId
            self.serviceName = output.serviceName
            self.serviceNetworkArn = output.serviceNetworkArn
            self.serviceNetworkId = output.serviceNetworkId
            self.serviceNetworkName = output.serviceNetworkName
            self.status = output.status
        } else {
            self.arn = nil
            self.createdAt = nil
            self.createdBy = nil
            self.customDomainName = nil
            self.dnsEntry = nil
            self.failureCode = nil
            self.failureMessage = nil
            self.id = nil
            self.serviceArn = nil
            self.serviceId = nil
            self.serviceName = nil
            self.serviceNetworkArn = nil
            self.serviceNetworkId = nil
            self.serviceNetworkName = nil
            self.status = nil
        }
    }
}

public struct GetServiceNetworkServiceAssociationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The date and time that the association was created, specified in ISO-8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The account that created the association.
    public var createdBy: Swift.String?
    /// The custom domain name of the service.
    public var customDomainName: Swift.String?
    /// The DNS name of the service.
    public var dnsEntry: VPCLatticeClientTypes.DnsEntry?
    /// The failure code.
    public var failureCode: Swift.String?
    /// The failure message.
    public var failureMessage: Swift.String?
    /// The ID of the service network and service association.
    public var id: Swift.String?
    /// The Amazon Resource Name (ARN) of the service.
    public var serviceArn: Swift.String?
    /// The ID of the service.
    public var serviceId: Swift.String?
    /// The name of the service.
    public var serviceName: Swift.String?
    /// The Amazon Resource Name (ARN) of the service network.
    public var serviceNetworkArn: Swift.String?
    /// The ID of the service network.
    public var serviceNetworkId: Swift.String?
    /// The name of the service network.
    public var serviceNetworkName: Swift.String?
    /// The status of the association.
    public var status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus?

    public init (
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        customDomainName: Swift.String? = nil,
        dnsEntry: VPCLatticeClientTypes.DnsEntry? = nil,
        failureCode: Swift.String? = nil,
        failureMessage: Swift.String? = nil,
        id: Swift.String? = nil,
        serviceArn: Swift.String? = nil,
        serviceId: Swift.String? = nil,
        serviceName: Swift.String? = nil,
        serviceNetworkArn: Swift.String? = nil,
        serviceNetworkId: Swift.String? = nil,
        serviceNetworkName: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.customDomainName = customDomainName
        self.dnsEntry = dnsEntry
        self.failureCode = failureCode
        self.failureMessage = failureMessage
        self.id = id
        self.serviceArn = serviceArn
        self.serviceId = serviceId
        self.serviceName = serviceName
        self.serviceNetworkArn = serviceNetworkArn
        self.serviceNetworkId = serviceNetworkId
        self.serviceNetworkName = serviceNetworkName
        self.status = status
    }
}

struct GetServiceNetworkServiceAssociationOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus?
    let arn: Swift.String?
    let createdBy: Swift.String?
    let createdAt: ClientRuntime.Date?
    let serviceId: Swift.String?
    let serviceName: Swift.String?
    let serviceArn: Swift.String?
    let serviceNetworkId: Swift.String?
    let serviceNetworkName: Swift.String?
    let serviceNetworkArn: Swift.String?
    let dnsEntry: VPCLatticeClientTypes.DnsEntry?
    let customDomainName: Swift.String?
    let failureMessage: Swift.String?
    let failureCode: Swift.String?
}

extension GetServiceNetworkServiceAssociationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case createdBy
        case customDomainName
        case dnsEntry
        case failureCode
        case failureMessage
        case id
        case serviceArn
        case serviceId
        case serviceName
        case serviceNetworkArn
        case serviceNetworkId
        case serviceNetworkName
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let serviceNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceNetworkId)
        serviceNetworkId = serviceNetworkIdDecoded
        let serviceNetworkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceNetworkName)
        serviceNetworkName = serviceNetworkNameDecoded
        let serviceNetworkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceNetworkArn)
        serviceNetworkArn = serviceNetworkArnDecoded
        let dnsEntryDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.DnsEntry.self, forKey: .dnsEntry)
        dnsEntry = dnsEntryDecoded
        let customDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomainName)
        customDomainName = customDomainNameDecoded
        let failureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
    }
}

extension GetServiceNetworkVpcAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceNetworkVpcAssociationIdentifier = serviceNetworkVpcAssociationIdentifier else {
            return nil
        }
        return "/servicenetworkvpcassociations/\(serviceNetworkVpcAssociationIdentifier.urlPercentEncoding())"
    }
}

public struct GetServiceNetworkVpcAssociationInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the association.
    /// This member is required.
    public var serviceNetworkVpcAssociationIdentifier: Swift.String?

    public init (
        serviceNetworkVpcAssociationIdentifier: Swift.String? = nil
    )
    {
        self.serviceNetworkVpcAssociationIdentifier = serviceNetworkVpcAssociationIdentifier
    }
}

struct GetServiceNetworkVpcAssociationInputBody: Swift.Equatable {
}

extension GetServiceNetworkVpcAssociationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetServiceNetworkVpcAssociationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServiceNetworkVpcAssociationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetServiceNetworkVpcAssociationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceNetworkVpcAssociationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: GetServiceNetworkVpcAssociationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.failureCode = output.failureCode
            self.failureMessage = output.failureMessage
            self.id = output.id
            self.lastUpdatedAt = output.lastUpdatedAt
            self.securityGroupIds = output.securityGroupIds
            self.serviceNetworkArn = output.serviceNetworkArn
            self.serviceNetworkId = output.serviceNetworkId
            self.serviceNetworkName = output.serviceNetworkName
            self.status = output.status
            self.vpcId = output.vpcId
        } else {
            self.arn = nil
            self.createdAt = nil
            self.createdBy = nil
            self.failureCode = nil
            self.failureMessage = nil
            self.id = nil
            self.lastUpdatedAt = nil
            self.securityGroupIds = nil
            self.serviceNetworkArn = nil
            self.serviceNetworkId = nil
            self.serviceNetworkName = nil
            self.status = nil
            self.vpcId = nil
        }
    }
}

public struct GetServiceNetworkVpcAssociationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The date and time that the association was created, specified in ISO-8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The account that created the association.
    public var createdBy: Swift.String?
    /// The failure code.
    public var failureCode: Swift.String?
    /// The failure message.
    public var failureMessage: Swift.String?
    /// The ID of the specified association between the service network and the VPC.
    public var id: Swift.String?
    /// The date and time that the association was last updated, specified in ISO-8601 format.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The IDs of the security groups.
    public var securityGroupIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the service network.
    public var serviceNetworkArn: Swift.String?
    /// The ID of the service network.
    public var serviceNetworkId: Swift.String?
    /// The name of the service network.
    public var serviceNetworkName: Swift.String?
    /// The status of the association.
    public var status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus?
    /// The ID of the VPC.
    public var vpcId: Swift.String?

    public init (
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        failureCode: Swift.String? = nil,
        failureMessage: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        securityGroupIds: [Swift.String]? = nil,
        serviceNetworkArn: Swift.String? = nil,
        serviceNetworkId: Swift.String? = nil,
        serviceNetworkName: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.failureCode = failureCode
        self.failureMessage = failureMessage
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.securityGroupIds = securityGroupIds
        self.serviceNetworkArn = serviceNetworkArn
        self.serviceNetworkId = serviceNetworkId
        self.serviceNetworkName = serviceNetworkName
        self.status = status
        self.vpcId = vpcId
    }
}

struct GetServiceNetworkVpcAssociationOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus?
    let arn: Swift.String?
    let createdBy: Swift.String?
    let createdAt: ClientRuntime.Date?
    let serviceNetworkId: Swift.String?
    let serviceNetworkName: Swift.String?
    let serviceNetworkArn: Swift.String?
    let vpcId: Swift.String?
    let securityGroupIds: [Swift.String]?
    let failureMessage: Swift.String?
    let failureCode: Swift.String?
    let lastUpdatedAt: ClientRuntime.Date?
}

extension GetServiceNetworkVpcAssociationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case createdBy
        case failureCode
        case failureMessage
        case id
        case lastUpdatedAt
        case securityGroupIds
        case serviceNetworkArn
        case serviceNetworkId
        case serviceNetworkName
        case status
        case vpcId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let serviceNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceNetworkId)
        serviceNetworkId = serviceNetworkIdDecoded
        let serviceNetworkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceNetworkName)
        serviceNetworkName = serviceNetworkNameDecoded
        let serviceNetworkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceNetworkArn)
        serviceNetworkArn = serviceNetworkArnDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let failureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension GetServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetServiceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: GetServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.authType = output.authType
            self.certificateArn = output.certificateArn
            self.createdAt = output.createdAt
            self.customDomainName = output.customDomainName
            self.dnsEntry = output.dnsEntry
            self.failureCode = output.failureCode
            self.failureMessage = output.failureMessage
            self.id = output.id
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.status = output.status
        } else {
            self.arn = nil
            self.authType = nil
            self.certificateArn = nil
            self.createdAt = nil
            self.customDomainName = nil
            self.dnsEntry = nil
            self.failureCode = nil
            self.failureMessage = nil
            self.id = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.status = nil
        }
    }
}

public struct GetServiceOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the service.
    public var arn: Swift.String?
    /// The type of IAM policy.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The Amazon Resource Name (ARN) of the certificate.
    public var certificateArn: Swift.String?
    /// The date and time that the service was created, specified in ISO-8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The custom domain name of the service.
    public var customDomainName: Swift.String?
    /// The DNS name of the service.
    public var dnsEntry: VPCLatticeClientTypes.DnsEntry?
    /// The failure code.
    public var failureCode: Swift.String?
    /// The failure message.
    public var failureMessage: Swift.String?
    /// The ID of the service.
    public var id: Swift.String?
    /// The date and time that the service was last updated, specified in ISO-8601 format.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the service.
    public var name: Swift.String?
    /// The status of the service.
    public var status: VPCLatticeClientTypes.ServiceStatus?

    public init (
        arn: Swift.String? = nil,
        authType: VPCLatticeClientTypes.AuthType? = nil,
        certificateArn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        customDomainName: Swift.String? = nil,
        dnsEntry: VPCLatticeClientTypes.DnsEntry? = nil,
        failureCode: Swift.String? = nil,
        failureMessage: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceStatus? = nil
    )
    {
        self.arn = arn
        self.authType = authType
        self.certificateArn = certificateArn
        self.createdAt = createdAt
        self.customDomainName = customDomainName
        self.dnsEntry = dnsEntry
        self.failureCode = failureCode
        self.failureMessage = failureMessage
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.status = status
    }
}

struct GetServiceOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
    let dnsEntry: VPCLatticeClientTypes.DnsEntry?
    let customDomainName: Swift.String?
    let certificateArn: Swift.String?
    let status: VPCLatticeClientTypes.ServiceStatus?
    let authType: VPCLatticeClientTypes.AuthType?
    let failureCode: Swift.String?
    let failureMessage: Swift.String?
}

extension GetServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case authType
        case certificateArn
        case createdAt
        case customDomainName
        case dnsEntry
        case failureCode
        case failureMessage
        case id
        case lastUpdatedAt
        case name
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let dnsEntryDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.DnsEntry.self, forKey: .dnsEntry)
        dnsEntry = dnsEntryDecoded
        let customDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomainName)
        customDomainName = customDomainNameDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ServiceStatus.self, forKey: .status)
        status = statusDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.AuthType.self, forKey: .authType)
        authType = authTypeDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
    }
}

extension GetTargetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let targetGroupIdentifier = targetGroupIdentifier else {
            return nil
        }
        return "/targetgroups/\(targetGroupIdentifier.urlPercentEncoding())"
    }
}

public struct GetTargetGroupInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the target group.
    /// This member is required.
    public var targetGroupIdentifier: Swift.String?

    public init (
        targetGroupIdentifier: Swift.String? = nil
    )
    {
        self.targetGroupIdentifier = targetGroupIdentifier
    }
}

struct GetTargetGroupInputBody: Swift.Equatable {
}

extension GetTargetGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetTargetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTargetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetTargetGroupOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTargetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: GetTargetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.config = output.config
            self.createdAt = output.createdAt
            self.failureCode = output.failureCode
            self.failureMessage = output.failureMessage
            self.id = output.id
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.serviceArns = output.serviceArns
            self.status = output.status
            self.type = output.type
        } else {
            self.arn = nil
            self.config = nil
            self.createdAt = nil
            self.failureCode = nil
            self.failureMessage = nil
            self.id = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.serviceArns = nil
            self.status = nil
            self.type = nil
        }
    }
}

public struct GetTargetGroupOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the target group.
    public var arn: Swift.String?
    /// The target group configuration.
    public var config: VPCLatticeClientTypes.TargetGroupConfig?
    /// The date and time that the target group was created, specified in ISO-8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The failure code.
    public var failureCode: Swift.String?
    /// The failure message.
    public var failureMessage: Swift.String?
    /// The ID of the target group.
    public var id: Swift.String?
    /// The date and time that the target group was last updated, specified in ISO-8601 format.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the target group.
    public var name: Swift.String?
    /// The Amazon Resource Names (ARNs) of the service.
    public var serviceArns: [Swift.String]?
    /// The status.
    public var status: VPCLatticeClientTypes.TargetGroupStatus?
    /// The target group type.
    public var type: VPCLatticeClientTypes.TargetGroupType?

    public init (
        arn: Swift.String? = nil,
        config: VPCLatticeClientTypes.TargetGroupConfig? = nil,
        createdAt: ClientRuntime.Date? = nil,
        failureCode: Swift.String? = nil,
        failureMessage: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        serviceArns: [Swift.String]? = nil,
        status: VPCLatticeClientTypes.TargetGroupStatus? = nil,
        type: VPCLatticeClientTypes.TargetGroupType? = nil
    )
    {
        self.arn = arn
        self.config = config
        self.createdAt = createdAt
        self.failureCode = failureCode
        self.failureMessage = failureMessage
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.serviceArns = serviceArns
        self.status = status
        self.type = type
    }
}

struct GetTargetGroupOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let type: VPCLatticeClientTypes.TargetGroupType?
    let config: VPCLatticeClientTypes.TargetGroupConfig?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
    let status: VPCLatticeClientTypes.TargetGroupStatus?
    let serviceArns: [Swift.String]?
    let failureMessage: Swift.String?
    let failureCode: Swift.String?
}

extension GetTargetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case config
        case createdAt
        case failureCode
        case failureMessage
        case id
        case lastUpdatedAt
        case name
        case serviceArns
        case status
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetGroupType.self, forKey: .type)
        type = typeDecoded
        let configDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetGroupConfig.self, forKey: .config)
        config = configDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetGroupStatus.self, forKey: .status)
        status = statusDecoded
        let serviceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .serviceArns)
        var serviceArnsDecoded0:[Swift.String]? = nil
        if let serviceArnsContainer = serviceArnsContainer {
            serviceArnsDecoded0 = [Swift.String]()
            for string0 in serviceArnsContainer {
                if let string0 = string0 {
                    serviceArnsDecoded0?.append(string0)
                }
            }
        }
        serviceArns = serviceArnsDecoded0
        let failureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
    }
}

extension VPCLatticeClientTypes.HeaderMatch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case caseSensitive
        case match
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let caseSensitive = self.caseSensitive {
            try encodeContainer.encode(caseSensitive, forKey: .caseSensitive)
        }
        if let match = self.match {
            try encodeContainer.encode(match, forKey: .match)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let matchDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.HeaderMatchType.self, forKey: .match)
        match = matchDecoded
        let caseSensitiveDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .caseSensitive)
        caseSensitive = caseSensitiveDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Describes the constraints for a header match. Matches incoming requests with rule based on request header value before applying rule action.
    public struct HeaderMatch: Swift.Equatable {
        /// Indicates whether the match is case sensitive. Defaults to false.
        public var caseSensitive: Swift.Bool?
        /// The header match type.
        /// This member is required.
        public var match: VPCLatticeClientTypes.HeaderMatchType?
        /// The name of the header.
        /// This member is required.
        public var name: Swift.String?

        public init (
            caseSensitive: Swift.Bool? = nil,
            match: VPCLatticeClientTypes.HeaderMatchType? = nil,
            name: Swift.String? = nil
        )
        {
            self.caseSensitive = caseSensitive
            self.match = match
            self.name = name
        }
    }

}

extension VPCLatticeClientTypes.HeaderMatchType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contains
        case exact
        case `prefix` = "prefix"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .contains(contains):
                try container.encode(contains, forKey: .contains)
            case let .exact(exact):
                try container.encode(exact, forKey: .exact)
            case let .`prefix`(`prefix`):
                try container.encode(`prefix`, forKey: .`prefix`)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let exactDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .exact)
        if let exact = exactDecoded {
            self = .exact(exact)
            return
        }
        let prefixDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .prefix)
        if let `prefix` = prefixDecoded {
            self = .`prefix`(`prefix`)
            return
        }
        let containsDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .contains)
        if let contains = containsDecoded {
            self = .contains(contains)
            return
        }
        self = .sdkUnknown("")
    }
}

extension VPCLatticeClientTypes {
    /// Describes a header match type. Only one can be provided.
    public enum HeaderMatchType: Swift.Equatable {
        /// Specifies an exact type match.
        case exact(Swift.String)
        /// Specifies a prefix type match. Matches the value with the prefix.
        case `prefix`(Swift.String)
        /// Specifies a contains type match.
        case contains(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension VPCLatticeClientTypes.HealthCheckConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
        case healthCheckIntervalSeconds
        case healthCheckTimeoutSeconds
        case healthyThresholdCount
        case matcher
        case path
        case port
        case `protocol` = "protocol"
        case protocolVersion
        case unhealthyThresholdCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let healthCheckIntervalSeconds = self.healthCheckIntervalSeconds {
            try encodeContainer.encode(healthCheckIntervalSeconds, forKey: .healthCheckIntervalSeconds)
        }
        if let healthCheckTimeoutSeconds = self.healthCheckTimeoutSeconds {
            try encodeContainer.encode(healthCheckTimeoutSeconds, forKey: .healthCheckTimeoutSeconds)
        }
        if let healthyThresholdCount = self.healthyThresholdCount {
            try encodeContainer.encode(healthyThresholdCount, forKey: .healthyThresholdCount)
        }
        if let matcher = self.matcher {
            try encodeContainer.encode(matcher, forKey: .matcher)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let protocolVersion = self.protocolVersion {
            try encodeContainer.encode(protocolVersion.rawValue, forKey: .protocolVersion)
        }
        if let unhealthyThresholdCount = self.unhealthyThresholdCount {
            try encodeContainer.encode(unhealthyThresholdCount, forKey: .unhealthyThresholdCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetGroupProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let protocolVersionDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.HealthCheckProtocolVersion.self, forKey: .protocolVersion)
        protocolVersion = protocolVersionDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let healthCheckIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthCheckIntervalSeconds)
        healthCheckIntervalSeconds = healthCheckIntervalSecondsDecoded
        let healthCheckTimeoutSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthCheckTimeoutSeconds)
        healthCheckTimeoutSeconds = healthCheckTimeoutSecondsDecoded
        let healthyThresholdCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthyThresholdCount)
        healthyThresholdCount = healthyThresholdCountDecoded
        let unhealthyThresholdCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unhealthyThresholdCount)
        unhealthyThresholdCount = unhealthyThresholdCountDecoded
        let matcherDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.Matcher.self, forKey: .matcher)
        matcher = matcherDecoded
    }
}

extension VPCLatticeClientTypes {
    /// The health check configuration of a target group. Health check configurations aren't used for LAMBDA and ALB target groups.
    public struct HealthCheckConfig: Swift.Equatable {
        /// Indicates whether health checking is enabled.
        public var enabled: Swift.Bool?
        /// The approximate amount of time, in seconds, between health checks of an individual target. The range is 5–300 seconds. The default is 30 seconds.
        public var healthCheckIntervalSeconds: Swift.Int?
        /// The amount of time, in seconds, to wait before reporting a target as unhealthy. The range is 1–120 seconds. The default is 5 seconds.
        public var healthCheckTimeoutSeconds: Swift.Int?
        /// The number of consecutive successful health checks required before considering an unhealthy target healthy. The range is 2–10. The default is 5.
        public var healthyThresholdCount: Swift.Int?
        /// The codes to use when checking for a successful response from a target. These are called Success codes in the console.
        public var matcher: VPCLatticeClientTypes.Matcher?
        /// The destination for health checks on the targets. If the protocol version is HTTP/1.1 or HTTP/2, specify a valid URI (for example, /path?query). The default path is /. Health checks are not supported if the protocol version is gRPC, however, you can choose HTTP/1.1 or HTTP/2 and specify a valid URI.
        public var path: Swift.String?
        /// The port used when performing health checks on targets. The default setting is the port that a target receives traffic on.
        public var port: Swift.Int?
        /// The protocol used when performing health checks on targets. The possible protocols are HTTP and HTTPS. The default is HTTP.
        public var `protocol`: VPCLatticeClientTypes.TargetGroupProtocol?
        /// The protocol version used when performing health checks on targets. The possible protocol versions are HTTP1 and HTTP2.
        public var protocolVersion: VPCLatticeClientTypes.HealthCheckProtocolVersion?
        /// The number of consecutive failed health checks required before considering a target unhealthy. The range is 2–10. The default is 2.
        public var unhealthyThresholdCount: Swift.Int?

        public init (
            enabled: Swift.Bool? = nil,
            healthCheckIntervalSeconds: Swift.Int? = nil,
            healthCheckTimeoutSeconds: Swift.Int? = nil,
            healthyThresholdCount: Swift.Int? = nil,
            matcher: VPCLatticeClientTypes.Matcher? = nil,
            path: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: VPCLatticeClientTypes.TargetGroupProtocol? = nil,
            protocolVersion: VPCLatticeClientTypes.HealthCheckProtocolVersion? = nil,
            unhealthyThresholdCount: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.healthCheckIntervalSeconds = healthCheckIntervalSeconds
            self.healthCheckTimeoutSeconds = healthCheckTimeoutSeconds
            self.healthyThresholdCount = healthyThresholdCount
            self.matcher = matcher
            self.path = path
            self.port = port
            self.`protocol` = `protocol`
            self.protocolVersion = protocolVersion
            self.unhealthyThresholdCount = unhealthyThresholdCount
        }
    }

}

extension VPCLatticeClientTypes {
    public enum HealthCheckProtocolVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Indicates use of HTTP/1.1 to send requests to target
        case http1
        /// Indicates use of HTTP/2 to send requests to target
        case http2
        case sdkUnknown(Swift.String)

        public static var allCases: [HealthCheckProtocolVersion] {
            return [
                .http1,
                .http2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .http1: return "HTTP1"
            case .http2: return "HTTP2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HealthCheckProtocolVersion(rawValue: rawValue) ?? HealthCheckProtocolVersion.sdkUnknown(rawValue)
        }
    }
}

extension VPCLatticeClientTypes.HttpMatch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headerMatches
        case method
        case pathMatch
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let headerMatches = headerMatches {
            var headerMatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .headerMatches)
            for headermatch0 in headerMatches {
                try headerMatchesContainer.encode(headermatch0)
            }
        }
        if let method = self.method {
            try encodeContainer.encode(method, forKey: .method)
        }
        if let pathMatch = self.pathMatch {
            try encodeContainer.encode(pathMatch, forKey: .pathMatch)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let methodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .method)
        method = methodDecoded
        let pathMatchDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.PathMatch.self, forKey: .pathMatch)
        pathMatch = pathMatchDecoded
        let headerMatchesContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.HeaderMatch?].self, forKey: .headerMatches)
        var headerMatchesDecoded0:[VPCLatticeClientTypes.HeaderMatch]? = nil
        if let headerMatchesContainer = headerMatchesContainer {
            headerMatchesDecoded0 = [VPCLatticeClientTypes.HeaderMatch]()
            for structure0 in headerMatchesContainer {
                if let structure0 = structure0 {
                    headerMatchesDecoded0?.append(structure0)
                }
            }
        }
        headerMatches = headerMatchesDecoded0
    }
}

extension VPCLatticeClientTypes {
    /// Describes criteria that can be applied to incoming requests.
    public struct HttpMatch: Swift.Equatable {
        /// The header matches. Matches incoming requests with rule based on request header value before applying rule action.
        public var headerMatches: [VPCLatticeClientTypes.HeaderMatch]?
        /// The HTTP method type.
        public var method: Swift.String?
        /// The path match.
        public var pathMatch: VPCLatticeClientTypes.PathMatch?

        public init (
            headerMatches: [VPCLatticeClientTypes.HeaderMatch]? = nil,
            method: Swift.String? = nil,
            pathMatch: VPCLatticeClientTypes.PathMatch? = nil
        )
        {
            self.headerMatches = headerMatches
            self.method = method
            self.pathMatch = pathMatch
        }
    }

}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = nil
        }
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An unexpected error occurred while processing the request.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable, Swift.Error {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?
    /// The number of seconds to wait before retrying.
    public var retryAfterSeconds: Swift.Int?

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VPCLatticeClientTypes {
    public enum IpAddressType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Indicates IPv4 address type
        case ipv4
        /// Indicates IPv6 address type
        case ipv6
        case sdkUnknown(Swift.String)

        public static var allCases: [IpAddressType] {
            return [
                .ipv4,
                .ipv6,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ipv4: return "IPV4"
            case .ipv6: return "IPV6"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IpAddressType(rawValue: rawValue) ?? IpAddressType.sdkUnknown(rawValue)
        }
    }
}

extension ListAccessLogSubscriptionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceIdentifier = resourceIdentifier else {
                let message = "Creating a URL Query Item failed. resourceIdentifier is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let resourceIdentifierQueryItem = ClientRuntime.URLQueryItem(name: "resourceIdentifier".urlPercentEncoding(), value: Swift.String(resourceIdentifier).urlPercentEncoding())
            items.append(resourceIdentifierQueryItem)
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListAccessLogSubscriptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/accesslogsubscriptions"
    }
}

public struct ListAccessLogSubscriptionsInput: Swift.Equatable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service network or service.
    /// This member is required.
    public var resourceIdentifier: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceIdentifier = resourceIdentifier
    }
}

struct ListAccessLogSubscriptionsInputBody: Swift.Equatable {
}

extension ListAccessLogSubscriptionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAccessLogSubscriptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAccessLogSubscriptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAccessLogSubscriptionsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccessLogSubscriptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: ListAccessLogSubscriptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccessLogSubscriptionsOutputResponse: Swift.Equatable {
    /// The access log subscriptions.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.AccessLogSubscriptionSummary]?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        items: [VPCLatticeClientTypes.AccessLogSubscriptionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListAccessLogSubscriptionsOutputResponseBody: Swift.Equatable {
    let items: [VPCLatticeClientTypes.AccessLogSubscriptionSummary]?
    let nextToken: Swift.String?
}

extension ListAccessLogSubscriptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.AccessLogSubscriptionSummary?].self, forKey: .items)
        var itemsDecoded0:[VPCLatticeClientTypes.AccessLogSubscriptionSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [VPCLatticeClientTypes.AccessLogSubscriptionSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListListenersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListListenersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceIdentifier = serviceIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners"
    }
}

public struct ListListenersInput: Swift.Equatable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceIdentifier = serviceIdentifier
    }
}

struct ListListenersInputBody: Swift.Equatable {
}

extension ListListenersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListListenersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListListenersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListListenersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListListenersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: ListListenersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListListenersOutputResponse: Swift.Equatable {
    /// Information about the listeners.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.ListenerSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        items: [VPCLatticeClientTypes.ListenerSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListListenersOutputResponseBody: Swift.Equatable {
    let items: [VPCLatticeClientTypes.ListenerSummary]?
    let nextToken: Swift.String?
}

extension ListListenersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.ListenerSummary?].self, forKey: .items)
        var itemsDecoded0:[VPCLatticeClientTypes.ListenerSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [VPCLatticeClientTypes.ListenerSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRulesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceIdentifier = serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = listenerIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())/rules"
    }
}

public struct ListRulesInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init (
        listenerIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.listenerIdentifier = listenerIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceIdentifier = serviceIdentifier
    }
}

struct ListRulesInputBody: Swift.Equatable {
}

extension ListRulesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListRulesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: ListRulesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListRulesOutputResponse: Swift.Equatable {
    /// Information about the rules.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.RuleSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        items: [VPCLatticeClientTypes.RuleSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListRulesOutputResponseBody: Swift.Equatable {
    let items: [VPCLatticeClientTypes.RuleSummary]?
    let nextToken: Swift.String?
}

extension ListRulesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.RuleSummary?].self, forKey: .items)
        var itemsDecoded0:[VPCLatticeClientTypes.RuleSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [VPCLatticeClientTypes.RuleSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListServiceNetworkServiceAssociationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let serviceNetworkIdentifier = serviceNetworkIdentifier {
                let serviceNetworkIdentifierQueryItem = ClientRuntime.URLQueryItem(name: "serviceNetworkIdentifier".urlPercentEncoding(), value: Swift.String(serviceNetworkIdentifier).urlPercentEncoding())
                items.append(serviceNetworkIdentifierQueryItem)
            }
            if let serviceIdentifier = serviceIdentifier {
                let serviceIdentifierQueryItem = ClientRuntime.URLQueryItem(name: "serviceIdentifier".urlPercentEncoding(), value: Swift.String(serviceIdentifier).urlPercentEncoding())
                items.append(serviceIdentifierQueryItem)
            }
            return items
        }
    }
}

extension ListServiceNetworkServiceAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/servicenetworkserviceassociations"
    }
}

public struct ListServiceNetworkServiceAssociationsInput: Swift.Equatable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    public var serviceIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service network.
    public var serviceNetworkIdentifier: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil,
        serviceNetworkIdentifier: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceIdentifier = serviceIdentifier
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
    }
}

struct ListServiceNetworkServiceAssociationsInputBody: Swift.Equatable {
}

extension ListServiceNetworkServiceAssociationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListServiceNetworkServiceAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServiceNetworkServiceAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListServiceNetworkServiceAssociationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServiceNetworkServiceAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: ListServiceNetworkServiceAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListServiceNetworkServiceAssociationsOutputResponse: Swift.Equatable {
    /// Information about the associations.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.ServiceNetworkServiceAssociationSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        items: [VPCLatticeClientTypes.ServiceNetworkServiceAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListServiceNetworkServiceAssociationsOutputResponseBody: Swift.Equatable {
    let items: [VPCLatticeClientTypes.ServiceNetworkServiceAssociationSummary]?
    let nextToken: Swift.String?
}

extension ListServiceNetworkServiceAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.ServiceNetworkServiceAssociationSummary?].self, forKey: .items)
        var itemsDecoded0:[VPCLatticeClientTypes.ServiceNetworkServiceAssociationSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [VPCLatticeClientTypes.ServiceNetworkServiceAssociationSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListServiceNetworkVpcAssociationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let serviceNetworkIdentifier = serviceNetworkIdentifier {
                let serviceNetworkIdentifierQueryItem = ClientRuntime.URLQueryItem(name: "serviceNetworkIdentifier".urlPercentEncoding(), value: Swift.String(serviceNetworkIdentifier).urlPercentEncoding())
                items.append(serviceNetworkIdentifierQueryItem)
            }
            if let vpcIdentifier = vpcIdentifier {
                let vpcIdentifierQueryItem = ClientRuntime.URLQueryItem(name: "vpcIdentifier".urlPercentEncoding(), value: Swift.String(vpcIdentifier).urlPercentEncoding())
                items.append(vpcIdentifierQueryItem)
            }
            return items
        }
    }
}

extension ListServiceNetworkVpcAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/servicenetworkvpcassociations"
    }
}

public struct ListServiceNetworkVpcAssociationsInput: Swift.Equatable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service network.
    public var serviceNetworkIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the VPC.
    public var vpcIdentifier: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceNetworkIdentifier: Swift.String? = nil,
        vpcIdentifier: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
        self.vpcIdentifier = vpcIdentifier
    }
}

struct ListServiceNetworkVpcAssociationsInputBody: Swift.Equatable {
}

extension ListServiceNetworkVpcAssociationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListServiceNetworkVpcAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServiceNetworkVpcAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListServiceNetworkVpcAssociationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServiceNetworkVpcAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: ListServiceNetworkVpcAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListServiceNetworkVpcAssociationsOutputResponse: Swift.Equatable {
    /// Information about the associations.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.ServiceNetworkVpcAssociationSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        items: [VPCLatticeClientTypes.ServiceNetworkVpcAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListServiceNetworkVpcAssociationsOutputResponseBody: Swift.Equatable {
    let items: [VPCLatticeClientTypes.ServiceNetworkVpcAssociationSummary]?
    let nextToken: Swift.String?
}

extension ListServiceNetworkVpcAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.ServiceNetworkVpcAssociationSummary?].self, forKey: .items)
        var itemsDecoded0:[VPCLatticeClientTypes.ServiceNetworkVpcAssociationSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [VPCLatticeClientTypes.ServiceNetworkVpcAssociationSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListServiceNetworksInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListServiceNetworksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/servicenetworks"
    }
}

public struct ListServiceNetworksInput: Swift.Equatable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListServiceNetworksInputBody: Swift.Equatable {
}

extension ListServiceNetworksInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListServiceNetworksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServiceNetworksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListServiceNetworksOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServiceNetworksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: ListServiceNetworksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListServiceNetworksOutputResponse: Swift.Equatable {
    /// Information about the service networks.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.ServiceNetworkSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        items: [VPCLatticeClientTypes.ServiceNetworkSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListServiceNetworksOutputResponseBody: Swift.Equatable {
    let items: [VPCLatticeClientTypes.ServiceNetworkSummary]?
    let nextToken: Swift.String?
}

extension ListServiceNetworksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.ServiceNetworkSummary?].self, forKey: .items)
        var itemsDecoded0:[VPCLatticeClientTypes.ServiceNetworkSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [VPCLatticeClientTypes.ServiceNetworkSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListServicesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListServicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/services"
    }
}

public struct ListServicesInput: Swift.Equatable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListServicesInputBody: Swift.Equatable {
}

extension ListServicesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListServicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListServicesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: ListServicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListServicesOutputResponse: Swift.Equatable {
    /// The services.
    public var items: [VPCLatticeClientTypes.ServiceSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        items: [VPCLatticeClientTypes.ServiceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListServicesOutputResponseBody: Swift.Equatable {
    let items: [VPCLatticeClientTypes.ServiceSummary]?
    let nextToken: Swift.String?
}

extension ListServicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.ServiceSummary?].self, forKey: .items)
        var itemsDecoded0:[VPCLatticeClientTypes.ServiceSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [VPCLatticeClientTypes.ServiceSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListTargetGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let vpcIdentifier = vpcIdentifier {
                let vpcIdentifierQueryItem = ClientRuntime.URLQueryItem(name: "vpcIdentifier".urlPercentEncoding(), value: Swift.String(vpcIdentifier).urlPercentEncoding())
                items.append(vpcIdentifierQueryItem)
            }
            if let targetGroupType = targetGroupType {
                let targetGroupTypeQueryItem = ClientRuntime.URLQueryItem(name: "targetGroupType".urlPercentEncoding(), value: Swift.String(targetGroupType.rawValue).urlPercentEncoding())
                items.append(targetGroupTypeQueryItem)
            }
            return items
        }
    }
}

extension ListTargetGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/targetgroups"
    }
}

public struct ListTargetGroupsInput: Swift.Equatable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The target group type.
    public var targetGroupType: VPCLatticeClientTypes.TargetGroupType?
    /// The ID or Amazon Resource Name (ARN) of the service.
    public var vpcIdentifier: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        targetGroupType: VPCLatticeClientTypes.TargetGroupType? = nil,
        vpcIdentifier: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.targetGroupType = targetGroupType
        self.vpcIdentifier = vpcIdentifier
    }
}

struct ListTargetGroupsInputBody: Swift.Equatable {
}

extension ListTargetGroupsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTargetGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTargetGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTargetGroupsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTargetGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: ListTargetGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListTargetGroupsOutputResponse: Swift.Equatable {
    /// Information about the target groups.
    public var items: [VPCLatticeClientTypes.TargetGroupSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        items: [VPCLatticeClientTypes.TargetGroupSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListTargetGroupsOutputResponseBody: Swift.Equatable {
    let items: [VPCLatticeClientTypes.TargetGroupSummary]?
    let nextToken: Swift.String?
}

extension ListTargetGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.TargetGroupSummary?].self, forKey: .items)
        var itemsDecoded0:[VPCLatticeClientTypes.TargetGroupSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [VPCLatticeClientTypes.TargetGroupSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTargetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for target0 in targets {
                try targetsContainer.encode(target0)
            }
        }
    }
}

extension ListTargetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListTargetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let targetGroupIdentifier = targetGroupIdentifier else {
            return nil
        }
        return "/targetgroups/\(targetGroupIdentifier.urlPercentEncoding())/listtargets"
    }
}

public struct ListTargetsInput: Swift.Equatable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the target group.
    /// This member is required.
    public var targetGroupIdentifier: Swift.String?
    /// The targets to list.
    public var targets: [VPCLatticeClientTypes.Target]?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        targetGroupIdentifier: Swift.String? = nil,
        targets: [VPCLatticeClientTypes.Target]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.targetGroupIdentifier = targetGroupIdentifier
        self.targets = targets
    }
}

struct ListTargetsInputBody: Swift.Equatable {
    let targets: [VPCLatticeClientTypes.Target]?
}

extension ListTargetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targets
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetsContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[VPCLatticeClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [VPCLatticeClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
    }
}

extension ListTargetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTargetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTargetsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTargetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: ListTargetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListTargetsOutputResponse: Swift.Equatable {
    /// Information about the targets.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.TargetSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init (
        items: [VPCLatticeClientTypes.TargetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListTargetsOutputResponseBody: Swift.Equatable {
    let items: [VPCLatticeClientTypes.TargetSummary]?
    let nextToken: Swift.String?
}

extension ListTargetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.TargetSummary?].self, forKey: .items)
        var itemsDecoded0:[VPCLatticeClientTypes.TargetSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [VPCLatticeClientTypes.TargetSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension VPCLatticeClientTypes {
    public enum ListenerProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Indicates HTTP protocol
        case http
        /// Indicates HTTPS protocol
        case https
        case sdkUnknown(Swift.String)

        public static var allCases: [ListenerProtocol] {
            return [
                .http,
                .https,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case .https: return "HTTPS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ListenerProtocol(rawValue: rawValue) ?? ListenerProtocol.sdkUnknown(rawValue)
        }
    }
}

extension VPCLatticeClientTypes.ListenerSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case id
        case lastUpdatedAt
        case name
        case port
        case `protocol` = "protocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .dateTime, forKey: .lastUpdatedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ListenerProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Summary information about a listener.
    public struct ListenerSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the listener.
        public var arn: Swift.String?
        /// The date and time that the listener was created, specified in ISO-8601 format.
        public var createdAt: ClientRuntime.Date?
        /// The ID of the listener.
        public var id: Swift.String?
        /// The date and time that the listener was last updated, specified in ISO-8601 format.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the listener.
        public var name: Swift.String?
        /// The listener port.
        public var port: Swift.Int?
        /// The listener protocol.
        public var `protocol`: VPCLatticeClientTypes.ListenerProtocol?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: VPCLatticeClientTypes.ListenerProtocol? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.port = port
            self.`protocol` = `protocol`
        }
    }

}

extension VPCLatticeClientTypes.Matcher: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case httpcode = "httpCode"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .httpcode(httpcode):
                try container.encode(httpcode, forKey: .httpcode)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let httpcodeDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .httpcode)
        if let httpcode = httpcodeDecoded {
            self = .httpcode(httpcode)
            return
        }
        self = .sdkUnknown("")
    }
}

extension VPCLatticeClientTypes {
    /// The codes to use when checking for a successful response from a target for health checks.
    public enum Matcher: Swift.Equatable {
        /// The HTTP code to use when checking for a successful response from a target.
        case httpcode(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension VPCLatticeClientTypes.PathMatch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case caseSensitive
        case match
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let caseSensitive = self.caseSensitive {
            try encodeContainer.encode(caseSensitive, forKey: .caseSensitive)
        }
        if let match = self.match {
            try encodeContainer.encode(match, forKey: .match)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let matchDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.PathMatchType.self, forKey: .match)
        match = matchDecoded
        let caseSensitiveDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .caseSensitive)
        caseSensitive = caseSensitiveDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Describes the conditions that can be applied when matching a path for incoming requests.
    public struct PathMatch: Swift.Equatable {
        /// Indicates whether the match is case sensitive. Defaults to false.
        public var caseSensitive: Swift.Bool?
        /// The type of path match.
        /// This member is required.
        public var match: VPCLatticeClientTypes.PathMatchType?

        public init (
            caseSensitive: Swift.Bool? = nil,
            match: VPCLatticeClientTypes.PathMatchType? = nil
        )
        {
            self.caseSensitive = caseSensitive
            self.match = match
        }
    }

}

extension VPCLatticeClientTypes.PathMatchType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exact
        case `prefix` = "prefix"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .exact(exact):
                try container.encode(exact, forKey: .exact)
            case let .`prefix`(`prefix`):
                try container.encode(`prefix`, forKey: .`prefix`)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let exactDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .exact)
        if let exact = exactDecoded {
            self = .exact(exact)
            return
        }
        let prefixDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .prefix)
        if let `prefix` = prefixDecoded {
            self = .`prefix`(`prefix`)
            return
        }
        self = .sdkUnknown("")
    }
}

extension VPCLatticeClientTypes {
    /// Describes a path match type. Each rule can include only one of the following types of paths.
    public enum PathMatchType: Swift.Equatable {
        /// An exact match of the path.
        case exact(Swift.String)
        /// A prefix match of the path.
        case `prefix`(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension PutAuthPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

extension PutAuthPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceIdentifier = resourceIdentifier else {
            return nil
        }
        return "/authpolicy/\(resourceIdentifier.urlPercentEncoding())"
    }
}

public struct PutAuthPolicyInput: Swift.Equatable {
    /// The auth policy. The policy string in JSON must not contain newlines or blank lines.
    /// This member is required.
    public var policy: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service network or service for which the policy is created.
    /// This member is required.
    public var resourceIdentifier: Swift.String?

    public init (
        policy: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.policy = policy
        self.resourceIdentifier = resourceIdentifier
    }
}

struct PutAuthPolicyInputBody: Swift.Equatable {
    let policy: Swift.String?
}

extension PutAuthPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutAuthPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutAuthPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutAuthPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutAuthPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: PutAuthPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.state = output.state
        } else {
            self.policy = nil
            self.state = nil
        }
    }
}

public struct PutAuthPolicyOutputResponse: Swift.Equatable {
    /// The auth policy. The policy string in JSON must not contain newlines or blank lines.
    public var policy: Swift.String?
    /// The state of the auth policy. The auth policy is only active when the auth type is set to AWS_IAM. If you provide a policy, then authentication and authorization decisions are made based on this policy and the client's IAM policy. If the Auth type is NONE, then, any auth policy you provide will remain inactive. For more information, see [Create a service network](https://docs.aws.amazon.com/vpc-lattice/latest/ug/service-networks.html#create-service-network) in the Amazon VPC Lattice User Guide.
    public var state: VPCLatticeClientTypes.AuthPolicyState?

    public init (
        policy: Swift.String? = nil,
        state: VPCLatticeClientTypes.AuthPolicyState? = nil
    )
    {
        self.policy = policy
        self.state = state
    }
}

struct PutAuthPolicyOutputResponseBody: Swift.Equatable {
    let policy: Swift.String?
    let state: VPCLatticeClientTypes.AuthPolicyState?
}

extension PutAuthPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
        case state
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let stateDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.AuthPolicyState.self, forKey: .state)
        state = stateDecoded
    }
}

extension PutResourcePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

extension PutResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/resourcepolicy/\(resourceArn.urlPercentEncoding())"
    }
}

public struct PutResourcePolicyInput: Swift.Equatable {
    /// An IAM policy. The policy string in JSON must not contain newlines or blank lines.
    /// This member is required.
    public var policy: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service network or service for which the policy is created.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        policy: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.policy = policy
        self.resourceArn = resourceArn
    }
}

struct PutResourcePolicyInputBody: Swift.Equatable {
    let policy: Swift.String?
}

extension PutResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutResourcePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutResourcePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutResourcePolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutResourcePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutResourcePolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension RegisterTargetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for target0 in targets {
                try targetsContainer.encode(target0)
            }
        }
    }
}

extension RegisterTargetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let targetGroupIdentifier = targetGroupIdentifier else {
            return nil
        }
        return "/targetgroups/\(targetGroupIdentifier.urlPercentEncoding())/registertargets"
    }
}

public struct RegisterTargetsInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the target group.
    /// This member is required.
    public var targetGroupIdentifier: Swift.String?
    /// The targets.
    /// This member is required.
    public var targets: [VPCLatticeClientTypes.Target]?

    public init (
        targetGroupIdentifier: Swift.String? = nil,
        targets: [VPCLatticeClientTypes.Target]? = nil
    )
    {
        self.targetGroupIdentifier = targetGroupIdentifier
        self.targets = targets
    }
}

struct RegisterTargetsInputBody: Swift.Equatable {
    let targets: [VPCLatticeClientTypes.Target]?
}

extension RegisterTargetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targets
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetsContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[VPCLatticeClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [VPCLatticeClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
    }
}

extension RegisterTargetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterTargetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RegisterTargetsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterTargetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: RegisterTargetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.successful = output.successful
            self.unsuccessful = output.unsuccessful
        } else {
            self.successful = nil
            self.unsuccessful = nil
        }
    }
}

public struct RegisterTargetsOutputResponse: Swift.Equatable {
    /// The targets that were successfully registered.
    public var successful: [VPCLatticeClientTypes.Target]?
    /// The targets that were not registered.
    public var unsuccessful: [VPCLatticeClientTypes.TargetFailure]?

    public init (
        successful: [VPCLatticeClientTypes.Target]? = nil,
        unsuccessful: [VPCLatticeClientTypes.TargetFailure]? = nil
    )
    {
        self.successful = successful
        self.unsuccessful = unsuccessful
    }
}

struct RegisterTargetsOutputResponseBody: Swift.Equatable {
    let successful: [VPCLatticeClientTypes.Target]?
    let unsuccessful: [VPCLatticeClientTypes.TargetFailure]?
}

extension RegisterTargetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case successful
        case unsuccessful
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.Target?].self, forKey: .successful)
        var successfulDecoded0:[VPCLatticeClientTypes.Target]? = nil
        if let successfulContainer = successfulContainer {
            successfulDecoded0 = [VPCLatticeClientTypes.Target]()
            for structure0 in successfulContainer {
                if let structure0 = structure0 {
                    successfulDecoded0?.append(structure0)
                }
            }
        }
        successful = successfulDecoded0
        let unsuccessfulContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.TargetFailure?].self, forKey: .unsuccessful)
        var unsuccessfulDecoded0:[VPCLatticeClientTypes.TargetFailure]? = nil
        if let unsuccessfulContainer = unsuccessfulContainer {
            unsuccessfulDecoded0 = [VPCLatticeClientTypes.TargetFailure]()
            for structure0 in unsuccessfulContainer {
                if let structure0 = structure0 {
                    unsuccessfulDecoded0?.append(structure0)
                }
            }
        }
        unsuccessful = unsuccessfulDecoded0
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request references a resource that does not exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable, Swift.Error {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The resource ID.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The resource type.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension VPCLatticeClientTypes.RuleAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fixedresponse = "fixedResponse"
        case forward
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .fixedresponse(fixedresponse):
                try container.encode(fixedresponse, forKey: .fixedresponse)
            case let .forward(forward):
                try container.encode(forward, forKey: .forward)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let forwardDecoded = try values.decodeIfPresent(VPCLatticeClientTypes.ForwardAction.self, forKey: .forward)
        if let forward = forwardDecoded {
            self = .forward(forward)
            return
        }
        let fixedresponseDecoded = try values.decodeIfPresent(VPCLatticeClientTypes.FixedResponseAction.self, forKey: .fixedresponse)
        if let fixedresponse = fixedresponseDecoded {
            self = .fixedresponse(fixedresponse)
            return
        }
        self = .sdkUnknown("")
    }
}

extension VPCLatticeClientTypes {
    /// Describes the action for a rule. Each rule must include exactly one of the following types of actions: forward or fixed-response, and it must be the last action to be performed.
    public enum RuleAction: Swift.Equatable {
        /// The forward action. Traffic that matches the rule is forwarded to the specified target groups.
        case forward(VPCLatticeClientTypes.ForwardAction)
        /// Describes the rule action that returns a custom HTTP response.
        case fixedresponse(VPCLatticeClientTypes.FixedResponseAction)
        case sdkUnknown(Swift.String)
    }

}

extension VPCLatticeClientTypes.RuleMatch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case httpmatch = "httpMatch"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .httpmatch(httpmatch):
                try container.encode(httpmatch, forKey: .httpmatch)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let httpmatchDecoded = try values.decodeIfPresent(VPCLatticeClientTypes.HttpMatch.self, forKey: .httpmatch)
        if let httpmatch = httpmatchDecoded {
            self = .httpmatch(httpmatch)
            return
        }
        self = .sdkUnknown("")
    }
}

extension VPCLatticeClientTypes {
    /// Describes a rule match.
    public enum RuleMatch: Swift.Equatable {
        /// The HTTP criteria that a rule must match.
        case httpmatch(VPCLatticeClientTypes.HttpMatch)
        case sdkUnknown(Swift.String)
    }

}

extension VPCLatticeClientTypes.RuleSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case id
        case isDefault
        case lastUpdatedAt
        case name
        case priority
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let isDefault = self.isDefault {
            try encodeContainer.encode(isDefault, forKey: .isDefault)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .dateTime, forKey: .lastUpdatedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let isDefaultDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDefault)
        isDefault = isDefaultDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Summary information about the listener rule.
    public struct RuleSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the rule.
        public var arn: Swift.String?
        /// The date and time that the listener rule was created, specified in ISO-8601 format.
        public var createdAt: ClientRuntime.Date?
        /// The ID of the rule.
        public var id: Swift.String?
        /// Indicates whether this is the default rule. Listener rules are created when you create a listener. Each listener has a default rule for checking connection requests.
        public var isDefault: Swift.Bool?
        /// The date and time that the listener rule was last updated, specified in ISO-8601 format.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the rule.
        public var name: Swift.String?
        /// The priority of the rule.
        public var priority: Swift.Int?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            isDefault: Swift.Bool? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            priority: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.isDefault = isDefault
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.priority = priority
        }
    }

}

extension VPCLatticeClientTypes.RuleUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case match
        case priority
        case ruleIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let match = self.match {
            try encodeContainer.encode(match, forKey: .match)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let ruleIdentifier = self.ruleIdentifier {
            try encodeContainer.encode(ruleIdentifier, forKey: .ruleIdentifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleIdentifier)
        ruleIdentifier = ruleIdentifierDecoded
        let matchDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleMatch.self, forKey: .match)
        match = matchDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let actionDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleAction.self, forKey: .action)
        action = actionDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Represents an object when updating a rule.
    public struct RuleUpdate: Swift.Equatable {
        /// The rule action.
        public var action: VPCLatticeClientTypes.RuleAction?
        /// The rule match.
        public var match: VPCLatticeClientTypes.RuleMatch?
        /// The rule priority. A listener can't have multiple rules with the same priority.
        public var priority: Swift.Int?
        /// The ID or Amazon Resource Name (ARN) of the rule.
        /// This member is required.
        public var ruleIdentifier: Swift.String?

        public init (
            action: VPCLatticeClientTypes.RuleAction? = nil,
            match: VPCLatticeClientTypes.RuleMatch? = nil,
            priority: Swift.Int? = nil,
            ruleIdentifier: Swift.String? = nil
        )
        {
            self.action = action
            self.match = match
            self.priority = priority
            self.ruleIdentifier = ruleIdentifier
        }
    }

}

extension VPCLatticeClientTypes.RuleUpdateFailure: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureCode
        case failureMessage
        case ruleIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureCode = self.failureCode {
            try encodeContainer.encode(failureCode, forKey: .failureCode)
        }
        if let failureMessage = self.failureMessage {
            try encodeContainer.encode(failureMessage, forKey: .failureMessage)
        }
        if let ruleIdentifier = self.ruleIdentifier {
            try encodeContainer.encode(ruleIdentifier, forKey: .ruleIdentifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleIdentifier)
        ruleIdentifier = ruleIdentifierDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Describes a rule update that failed.
    public struct RuleUpdateFailure: Swift.Equatable {
        /// The failure code.
        public var failureCode: Swift.String?
        /// The failure message.
        public var failureMessage: Swift.String?
        /// The ID or Amazon Resource Name (ARN) of the rule.
        public var ruleIdentifier: Swift.String?

        public init (
            failureCode: Swift.String? = nil,
            failureMessage: Swift.String? = nil,
            ruleIdentifier: Swift.String? = nil
        )
        {
            self.failureCode = failureCode
            self.failureMessage = failureMessage
            self.ruleIdentifier = ruleIdentifier
        }
    }

}

extension VPCLatticeClientTypes.RuleUpdateSuccess: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case arn
        case id
        case isDefault
        case match
        case name
        case priority
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let isDefault = self.isDefault {
            try encodeContainer.encode(isDefault, forKey: .isDefault)
        }
        if let match = self.match {
            try encodeContainer.encode(match, forKey: .match)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let isDefaultDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDefault)
        isDefault = isDefaultDecoded
        let matchDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleMatch.self, forKey: .match)
        match = matchDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let actionDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleAction.self, forKey: .action)
        action = actionDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Describes a successful rule update.
    public struct RuleUpdateSuccess: Swift.Equatable {
        /// The action for the default rule.
        public var action: VPCLatticeClientTypes.RuleAction?
        /// The Amazon Resource Name (ARN) of the listener.
        public var arn: Swift.String?
        /// The ID of the listener.
        public var id: Swift.String?
        /// Indicates whether this is the default rule.
        public var isDefault: Swift.Bool?
        /// The rule match.
        public var match: VPCLatticeClientTypes.RuleMatch?
        /// The name of the listener.
        public var name: Swift.String?
        /// The rule priority.
        public var priority: Swift.Int?

        public init (
            action: VPCLatticeClientTypes.RuleAction? = nil,
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            isDefault: Swift.Bool? = nil,
            match: VPCLatticeClientTypes.RuleMatch? = nil,
            name: Swift.String? = nil,
            priority: Swift.Int? = nil
        )
        {
            self.action = action
            self.arn = arn
            self.id = id
            self.isDefault = isDefault
            self.match = match
            self.name = name
            self.priority = priority
        }
    }

}

extension VPCLatticeClientTypes {
    public enum ServiceNetworkServiceAssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// ServiceNetwork and Service association is active
        case active
        /// ServiceNetwork and Service association creation failed.
        case createFailed
        /// ServiceNetwork and Service association creation in progress
        case createInProgress
        /// ServiceNetwork and Service association deletion failed
        case deleteFailed
        /// ServiceNetwork and Service association deletion in progress
        case deleteInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceNetworkServiceAssociationStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleteFailed,
                .deleteInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceNetworkServiceAssociationStatus(rawValue: rawValue) ?? ServiceNetworkServiceAssociationStatus.sdkUnknown(rawValue)
        }
    }
}

extension VPCLatticeClientTypes.ServiceNetworkServiceAssociationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case createdBy
        case customDomainName
        case dnsEntry
        case id
        case serviceArn
        case serviceId
        case serviceName
        case serviceNetworkArn
        case serviceNetworkId
        case serviceNetworkName
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let customDomainName = self.customDomainName {
            try encodeContainer.encode(customDomainName, forKey: .customDomainName)
        }
        if let dnsEntry = self.dnsEntry {
            try encodeContainer.encode(dnsEntry, forKey: .dnsEntry)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let serviceArn = self.serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
        if let serviceId = self.serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let serviceNetworkArn = self.serviceNetworkArn {
            try encodeContainer.encode(serviceNetworkArn, forKey: .serviceNetworkArn)
        }
        if let serviceNetworkId = self.serviceNetworkId {
            try encodeContainer.encode(serviceNetworkId, forKey: .serviceNetworkId)
        }
        if let serviceNetworkName = self.serviceNetworkName {
            try encodeContainer.encode(serviceNetworkName, forKey: .serviceNetworkName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let serviceNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceNetworkId)
        serviceNetworkId = serviceNetworkIdDecoded
        let serviceNetworkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceNetworkName)
        serviceNetworkName = serviceNetworkNameDecoded
        let serviceNetworkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceNetworkArn)
        serviceNetworkArn = serviceNetworkArnDecoded
        let dnsEntryDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.DnsEntry.self, forKey: .dnsEntry)
        dnsEntry = dnsEntryDecoded
        let customDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomainName)
        customDomainName = customDomainNameDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Summary information about the association between a service network and a service.
    public struct ServiceNetworkServiceAssociationSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the association.
        public var arn: Swift.String?
        /// The date and time that the association was created, specified in ISO-8601 format.
        public var createdAt: ClientRuntime.Date?
        /// The account that created the association.
        public var createdBy: Swift.String?
        /// The custom domain name of the service.
        public var customDomainName: Swift.String?
        /// DNS information about the service.
        public var dnsEntry: VPCLatticeClientTypes.DnsEntry?
        /// The ID of the association.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of the service.
        public var serviceArn: Swift.String?
        /// The ID of the service.
        public var serviceId: Swift.String?
        /// The name of the service.
        public var serviceName: Swift.String?
        /// The Amazon Resource Name (ARN) of the service network.
        public var serviceNetworkArn: Swift.String?
        /// The ID of the service network.
        public var serviceNetworkId: Swift.String?
        /// The name of the service network.
        public var serviceNetworkName: Swift.String?
        /// The status. If the deletion fails, try to delete again.
        public var status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            customDomainName: Swift.String? = nil,
            dnsEntry: VPCLatticeClientTypes.DnsEntry? = nil,
            id: Swift.String? = nil,
            serviceArn: Swift.String? = nil,
            serviceId: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            serviceNetworkArn: Swift.String? = nil,
            serviceNetworkId: Swift.String? = nil,
            serviceNetworkName: Swift.String? = nil,
            status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.customDomainName = customDomainName
            self.dnsEntry = dnsEntry
            self.id = id
            self.serviceArn = serviceArn
            self.serviceId = serviceId
            self.serviceName = serviceName
            self.serviceNetworkArn = serviceNetworkArn
            self.serviceNetworkId = serviceNetworkId
            self.serviceNetworkName = serviceNetworkName
            self.status = status
        }
    }

}

extension VPCLatticeClientTypes.ServiceNetworkSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case id
        case lastUpdatedAt
        case name
        case numberOfAssociatedServices
        case numberOfAssociatedVPCs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .dateTime, forKey: .lastUpdatedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let numberOfAssociatedServices = self.numberOfAssociatedServices {
            try encodeContainer.encode(numberOfAssociatedServices, forKey: .numberOfAssociatedServices)
        }
        if let numberOfAssociatedVPCs = self.numberOfAssociatedVPCs {
            try encodeContainer.encode(numberOfAssociatedVPCs, forKey: .numberOfAssociatedVPCs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let numberOfAssociatedVPCsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfAssociatedVPCs)
        numberOfAssociatedVPCs = numberOfAssociatedVPCsDecoded
        let numberOfAssociatedServicesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfAssociatedServices)
        numberOfAssociatedServices = numberOfAssociatedServicesDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Summary information about a service network.
    public struct ServiceNetworkSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the service network.
        public var arn: Swift.String?
        /// The date and time that the service network was created, specified in ISO-8601 format.
        public var createdAt: ClientRuntime.Date?
        /// The ID of the service network.
        public var id: Swift.String?
        /// The date and time that the service network was last updated, specified in ISO-8601 format.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the service network.
        public var name: Swift.String?
        /// The number of services associated with the service network.
        public var numberOfAssociatedServices: Swift.Int?
        /// The number of VPCs associated with the service network.
        public var numberOfAssociatedVPCs: Swift.Int?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            numberOfAssociatedServices: Swift.Int? = nil,
            numberOfAssociatedVPCs: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.numberOfAssociatedServices = numberOfAssociatedServices
            self.numberOfAssociatedVPCs = numberOfAssociatedVPCs
        }
    }

}

extension VPCLatticeClientTypes {
    public enum ServiceNetworkVpcAssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// ServiceNetwork and Vpc association is active
        case active
        /// ServiceNetwork and Vpc association creation failed.
        case createFailed
        /// ServiceNetwork and Vpc association creation in progress
        case createInProgress
        /// ServiceNetwork and Vpc association deletion failed
        case deleteFailed
        /// ServiceNetwork and Vpc association deletion in progress
        case deleteInProgress
        /// ServiceNetwork and Vpc association update failed
        case updateFailed
        /// ServiceNetwork and Vpc association update in progress
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceNetworkVpcAssociationStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleteFailed,
                .deleteInProgress,
                .updateFailed,
                .updateInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceNetworkVpcAssociationStatus(rawValue: rawValue) ?? ServiceNetworkVpcAssociationStatus.sdkUnknown(rawValue)
        }
    }
}

extension VPCLatticeClientTypes.ServiceNetworkVpcAssociationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case createdBy
        case id
        case lastUpdatedAt
        case serviceNetworkArn
        case serviceNetworkId
        case serviceNetworkName
        case status
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .dateTime, forKey: .lastUpdatedAt)
        }
        if let serviceNetworkArn = self.serviceNetworkArn {
            try encodeContainer.encode(serviceNetworkArn, forKey: .serviceNetworkArn)
        }
        if let serviceNetworkId = self.serviceNetworkId {
            try encodeContainer.encode(serviceNetworkId, forKey: .serviceNetworkId)
        }
        if let serviceNetworkName = self.serviceNetworkName {
            try encodeContainer.encode(serviceNetworkName, forKey: .serviceNetworkName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let serviceNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceNetworkId)
        serviceNetworkId = serviceNetworkIdDecoded
        let serviceNetworkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceNetworkName)
        serviceNetworkName = serviceNetworkNameDecoded
        let serviceNetworkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceNetworkArn)
        serviceNetworkArn = serviceNetworkArnDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Summary information about an association between a service network and a VPC.
    public struct ServiceNetworkVpcAssociationSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the association.
        public var arn: Swift.String?
        /// The date and time that the association was created, specified in ISO-8601 format.
        public var createdAt: ClientRuntime.Date?
        /// The account that created the association.
        public var createdBy: Swift.String?
        /// The ID of the association.
        public var id: Swift.String?
        /// The date and time that the association was last updated, specified in ISO-8601 format.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the service network.
        public var serviceNetworkArn: Swift.String?
        /// The ID of the service network.
        public var serviceNetworkId: Swift.String?
        /// The name of the service network.
        public var serviceNetworkName: Swift.String?
        /// The status.
        public var status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus?
        /// The ID of the VPC.
        public var vpcId: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            serviceNetworkArn: Swift.String? = nil,
            serviceNetworkId: Swift.String? = nil,
            serviceNetworkName: Swift.String? = nil,
            status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.serviceNetworkArn = serviceNetworkArn
            self.serviceNetworkId = serviceNetworkId
            self.serviceNetworkName = serviceNetworkName
            self.status = status
            self.vpcId = vpcId
        }
    }

}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.resourceId = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable, Swift.Error {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the service quota that was exceeded.
    /// This member is required.
    public var quotaCode: Swift.String?
    /// The resource ID.
    public var resourceId: Swift.String?
    /// The resource type.
    /// This member is required.
    public var resourceType: Swift.String?
    /// The service code.
    /// This member is required.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case resourceId
        case resourceType
        case serviceCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension VPCLatticeClientTypes {
    public enum ServiceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Service is active.
        case active
        /// Service creation failed
        case createFailed
        /// Service creation in progress.
        case createInProgress
        /// Service deletion failed.
        case deleteFailed
        /// Service deletion in progress
        case deleteInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleteFailed,
                .deleteInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceStatus(rawValue: rawValue) ?? ServiceStatus.sdkUnknown(rawValue)
        }
    }
}

extension VPCLatticeClientTypes.ServiceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case customDomainName
        case dnsEntry
        case id
        case lastUpdatedAt
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let customDomainName = self.customDomainName {
            try encodeContainer.encode(customDomainName, forKey: .customDomainName)
        }
        if let dnsEntry = self.dnsEntry {
            try encodeContainer.encode(dnsEntry, forKey: .dnsEntry)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .dateTime, forKey: .lastUpdatedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let dnsEntryDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.DnsEntry.self, forKey: .dnsEntry)
        dnsEntry = dnsEntryDecoded
        let customDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomainName)
        customDomainName = customDomainNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ServiceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Summary information about a service.
    public struct ServiceSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the service.
        public var arn: Swift.String?
        /// The date and time that the service was created, specified in ISO-8601 format.
        public var createdAt: ClientRuntime.Date?
        /// The custom domain name of the service.
        public var customDomainName: Swift.String?
        /// DNS information about the service.
        public var dnsEntry: VPCLatticeClientTypes.DnsEntry?
        /// The ID of the service.
        public var id: Swift.String?
        /// The date and time that the service was last updated. The format is ISO-8601.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the service.
        public var name: Swift.String?
        /// The status.
        public var status: VPCLatticeClientTypes.ServiceStatus?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            customDomainName: Swift.String? = nil,
            dnsEntry: VPCLatticeClientTypes.DnsEntry? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: VPCLatticeClientTypes.ServiceStatus? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.customDomainName = customDomainName
            self.dnsEntry = dnsEntry
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.status = status
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags for the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension VPCLatticeClientTypes.Target: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case port
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Describes a target.
    public struct Target: Swift.Equatable {
        /// The ID of the target. If the target type of the target group is INSTANCE, this is an instance ID. If the target type is IP , this is an IP address. If the target type is LAMBDA, this is the ARN of the Lambda function. If the target type is ALB, this is the ARN of the Application Load Balancer.
        /// This member is required.
        public var id: Swift.String?
        /// The port on which the target is listening. For HTTP, the default is 80. For HTTPS, the default is 443.
        public var port: Swift.Int?

        public init (
            id: Swift.String? = nil,
            port: Swift.Int? = nil
        )
        {
            self.id = id
            self.port = port
        }
    }

}

extension VPCLatticeClientTypes.TargetFailure: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureCode
        case failureMessage
        case id
        case port
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureCode = self.failureCode {
            try encodeContainer.encode(failureCode, forKey: .failureCode)
        }
        if let failureMessage = self.failureMessage {
            try encodeContainer.encode(failureMessage, forKey: .failureMessage)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Describes a target failure.
    public struct TargetFailure: Swift.Equatable {
        /// The failure code.
        public var failureCode: Swift.String?
        /// The failure message.
        public var failureMessage: Swift.String?
        /// The ID of the target. If the target type of the target group is INSTANCE, this is an instance ID. If the target type is IP , this is an IP address. If the target type is LAMBDA, this is the ARN of the Lambda function. If the target type is ALB, this is the ARN of the Application Load Balancer.
        public var id: Swift.String?
        /// The port on which the target is listening. This parameter doesn't apply if the target is a Lambda function.
        public var port: Swift.Int?

        public init (
            failureCode: Swift.String? = nil,
            failureMessage: Swift.String? = nil,
            id: Swift.String? = nil,
            port: Swift.Int? = nil
        )
        {
            self.failureCode = failureCode
            self.failureMessage = failureMessage
            self.id = id
            self.port = port
        }
    }

}

extension VPCLatticeClientTypes.TargetGroupConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthCheck
        case ipAddressType
        case port
        case `protocol` = "protocol"
        case protocolVersion
        case vpcIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let healthCheck = self.healthCheck {
            try encodeContainer.encode(healthCheck, forKey: .healthCheck)
        }
        if let ipAddressType = self.ipAddressType {
            try encodeContainer.encode(ipAddressType.rawValue, forKey: .ipAddressType)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let protocolVersion = self.protocolVersion {
            try encodeContainer.encode(protocolVersion.rawValue, forKey: .protocolVersion)
        }
        if let vpcIdentifier = self.vpcIdentifier {
            try encodeContainer.encode(vpcIdentifier, forKey: .vpcIdentifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetGroupProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let protocolVersionDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetGroupProtocolVersion.self, forKey: .protocolVersion)
        protocolVersion = protocolVersionDecoded
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let vpcIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcIdentifier)
        vpcIdentifier = vpcIdentifierDecoded
        let healthCheckDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.HealthCheckConfig.self, forKey: .healthCheck)
        healthCheck = healthCheckDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Describes the configuration of a target group. Lambda functions don't support target group configuration.
    public struct TargetGroupConfig: Swift.Equatable {
        /// The health check configuration.
        public var healthCheck: VPCLatticeClientTypes.HealthCheckConfig?
        /// The type of IP address used for the target group. The possible values are ipv4 and ipv6. This is an optional parameter. If not specified, the IP address type defaults to ipv4.
        public var ipAddressType: VPCLatticeClientTypes.IpAddressType?
        /// The port on which the targets are listening. For HTTP, the default is 80. For HTTPS, the default is 443
        /// This member is required.
        public var port: Swift.Int?
        /// The protocol to use for routing traffic to the targets. Default is the protocol of a target group.
        /// This member is required.
        public var `protocol`: VPCLatticeClientTypes.TargetGroupProtocol?
        /// The protocol version. Default value is HTTP1.
        public var protocolVersion: VPCLatticeClientTypes.TargetGroupProtocolVersion?
        /// The ID of the VPC.
        /// This member is required.
        public var vpcIdentifier: Swift.String?

        public init (
            healthCheck: VPCLatticeClientTypes.HealthCheckConfig? = nil,
            ipAddressType: VPCLatticeClientTypes.IpAddressType? = nil,
            port: Swift.Int? = nil,
            `protocol`: VPCLatticeClientTypes.TargetGroupProtocol? = nil,
            protocolVersion: VPCLatticeClientTypes.TargetGroupProtocolVersion? = nil,
            vpcIdentifier: Swift.String? = nil
        )
        {
            self.healthCheck = healthCheck
            self.ipAddressType = ipAddressType
            self.port = port
            self.`protocol` = `protocol`
            self.protocolVersion = protocolVersion
            self.vpcIdentifier = vpcIdentifier
        }
    }

}

extension VPCLatticeClientTypes {
    public enum TargetGroupProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Indicates HTTP protocol
        case http
        /// Indicates HTTPS protocol
        case https
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetGroupProtocol] {
            return [
                .http,
                .https,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case .https: return "HTTPS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetGroupProtocol(rawValue: rawValue) ?? TargetGroupProtocol.sdkUnknown(rawValue)
        }
    }
}

extension VPCLatticeClientTypes {
    public enum TargetGroupProtocolVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Indicates use of gRPC to send requests to target
        case grpc
        /// Indicates use of HTTP/1.1 to send requests to target
        case http1
        /// Indicates use of HTTP/2 to send requests to target
        case http2
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetGroupProtocolVersion] {
            return [
                .grpc,
                .http1,
                .http2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .grpc: return "GRPC"
            case .http1: return "HTTP1"
            case .http2: return "HTTP2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetGroupProtocolVersion(rawValue: rawValue) ?? TargetGroupProtocolVersion.sdkUnknown(rawValue)
        }
    }
}

extension VPCLatticeClientTypes {
    public enum TargetGroupStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// TargetGroup is active
        case active
        /// TargetGroup creation failed.
        case createFailed
        /// TargetGroup creation in progress
        case createInProgress
        /// TargetGroup deletion failed
        case deleteFailed
        /// TargetGroup deletion in progress
        case deleteInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetGroupStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleteFailed,
                .deleteInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetGroupStatus(rawValue: rawValue) ?? TargetGroupStatus.sdkUnknown(rawValue)
        }
    }
}

extension VPCLatticeClientTypes.TargetGroupSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case id
        case ipAddressType
        case lastUpdatedAt
        case name
        case port
        case `protocol` = "protocol"
        case serviceArns
        case status
        case type
        case vpcIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let ipAddressType = self.ipAddressType {
            try encodeContainer.encode(ipAddressType.rawValue, forKey: .ipAddressType)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .dateTime, forKey: .lastUpdatedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let serviceArns = serviceArns {
            var serviceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serviceArns)
            for servicearn0 in serviceArns {
                try serviceArnsContainer.encode(servicearn0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let vpcIdentifier = self.vpcIdentifier {
            try encodeContainer.encode(vpcIdentifier, forKey: .vpcIdentifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetGroupType.self, forKey: .type)
        type = typeDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetGroupProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let vpcIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcIdentifier)
        vpcIdentifier = vpcIdentifierDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetGroupStatus.self, forKey: .status)
        status = statusDecoded
        let serviceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .serviceArns)
        var serviceArnsDecoded0:[Swift.String]? = nil
        if let serviceArnsContainer = serviceArnsContainer {
            serviceArnsDecoded0 = [Swift.String]()
            for string0 in serviceArnsContainer {
                if let string0 = string0 {
                    serviceArnsDecoded0?.append(string0)
                }
            }
        }
        serviceArns = serviceArnsDecoded0
    }
}

extension VPCLatticeClientTypes {
    /// Summary information about a target group.
    public struct TargetGroupSummary: Swift.Equatable {
        /// The ARN (Amazon Resource Name) of the target group.
        public var arn: Swift.String?
        /// The date and time that the target group was created, specified in ISO-8601 format.
        public var createdAt: ClientRuntime.Date?
        /// The ID of the target group.
        public var id: Swift.String?
        /// The type of IP address used for the target group. The possible values are ipv4 and ipv6. This is an optional parameter. If not specified, the IP address type defaults to ipv4.
        public var ipAddressType: VPCLatticeClientTypes.IpAddressType?
        /// The date and time that the target group was last updated, specified in ISO-8601 format.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the target group.
        public var name: Swift.String?
        /// The port of the target group.
        public var port: Swift.Int?
        /// The protocol of the target group.
        public var `protocol`: VPCLatticeClientTypes.TargetGroupProtocol?
        /// The list of Amazon Resource Names (ARNs) of the service.
        public var serviceArns: [Swift.String]?
        /// The status.
        public var status: VPCLatticeClientTypes.TargetGroupStatus?
        /// The target group type.
        public var type: VPCLatticeClientTypes.TargetGroupType?
        /// The ID of the VPC of the target group.
        public var vpcIdentifier: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            ipAddressType: VPCLatticeClientTypes.IpAddressType? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: VPCLatticeClientTypes.TargetGroupProtocol? = nil,
            serviceArns: [Swift.String]? = nil,
            status: VPCLatticeClientTypes.TargetGroupStatus? = nil,
            type: VPCLatticeClientTypes.TargetGroupType? = nil,
            vpcIdentifier: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.ipAddressType = ipAddressType
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.port = port
            self.`protocol` = `protocol`
            self.serviceArns = serviceArns
            self.status = status
            self.type = type
            self.vpcIdentifier = vpcIdentifier
        }
    }

}

extension VPCLatticeClientTypes {
    public enum TargetGroupType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Indicates target in this target group is an ALB
        case alb
        /// Indicates targets in this target group are EC2 instances
        case instance
        /// Indicates targets in this target group are IP
        case ip
        /// Indicates targets in this target group are Lambda
        case lambda
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetGroupType] {
            return [
                .alb,
                .instance,
                .ip,
                .lambda,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alb: return "ALB"
            case .instance: return "INSTANCE"
            case .ip: return "IP"
            case .lambda: return "LAMBDA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetGroupType(rawValue: rawValue) ?? TargetGroupType.sdkUnknown(rawValue)
        }
    }
}

extension VPCLatticeClientTypes {
    public enum TargetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// The target is deregistering and connection draining is in process.
        case draining
        /// The target is healthy.
        case healthy
        /// The initial health check is in progress.
        case initial
        /// Health checks are disabled.
        case unavailable
        /// The target failed the health check.
        case unhealthy
        /// The target group is not used in a listener rule.
        case unused
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetStatus] {
            return [
                .draining,
                .healthy,
                .initial,
                .unavailable,
                .unhealthy,
                .unused,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .draining: return "DRAINING"
            case .healthy: return "HEALTHY"
            case .initial: return "INITIAL"
            case .unavailable: return "UNAVAILABLE"
            case .unhealthy: return "UNHEALTHY"
            case .unused: return "UNUSED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetStatus(rawValue: rawValue) ?? TargetStatus.sdkUnknown(rawValue)
        }
    }
}

extension VPCLatticeClientTypes.TargetSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case port
        case reasonCode
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let reasonCode = self.reasonCode {
            try encodeContainer.encode(reasonCode, forKey: .reasonCode)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetStatus.self, forKey: .status)
        status = statusDecoded
        let reasonCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reasonCode)
        reasonCode = reasonCodeDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Summary information about a target.
    public struct TargetSummary: Swift.Equatable {
        /// The ID of the target. If the target type of the target group is INSTANCE, this is an instance ID. If the target type is IP , this is an IP address. If the target type is LAMBDA, this is the ARN of the Lambda function. If the target type is ALB, this is the ARN of the Application Load Balancer.
        public var id: Swift.String?
        /// The port on which the target is listening.
        public var port: Swift.Int?
        /// The code for why the target status is what it is.
        public var reasonCode: Swift.String?
        /// The status of the target.
        ///
        /// * Draining: The target is being deregistered. No new connections will be sent to this target while current connections are being drained. Default draining time is 5 minutes.
        ///
        /// * Unavailable: Health checks are unavailable for the target group.
        ///
        /// * Healthy: The target is healthy.
        ///
        /// * Unhealthy: The target is unhealthy.
        ///
        /// * Initial: Initial health checks on the target are being performed.
        ///
        /// * Unused: Target group is not used in a service.
        public var status: VPCLatticeClientTypes.TargetStatus?

        public init (
            id: Swift.String? = nil,
            port: Swift.Int? = nil,
            reasonCode: Swift.String? = nil,
            status: VPCLatticeClientTypes.TargetStatus? = nil
        )
        {
            self.id = id
            self.port = port
            self.reasonCode = reasonCode
            self.status = status
        }
    }

}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = nil
        }
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The limit on the number of requests per second was exceeded.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable, Swift.Error {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = true
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the service quota that was exceeded.
    public var quotaCode: Swift.String?
    /// The number of seconds to wait before retrying.
    public var retryAfterSeconds: Swift.Int?
    /// The service code.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.retryAfterSeconds = retryAfterSeconds
        self.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys of the tags to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateAccessLogSubscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationArn = self.destinationArn {
            try encodeContainer.encode(destinationArn, forKey: .destinationArn)
        }
    }
}

extension UpdateAccessLogSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accessLogSubscriptionIdentifier = accessLogSubscriptionIdentifier else {
            return nil
        }
        return "/accesslogsubscriptions/\(accessLogSubscriptionIdentifier.urlPercentEncoding())"
    }
}

public struct UpdateAccessLogSubscriptionInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the access log subscription.
    /// This member is required.
    public var accessLogSubscriptionIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) of the access log destination.
    /// This member is required.
    public var destinationArn: Swift.String?

    public init (
        accessLogSubscriptionIdentifier: Swift.String? = nil,
        destinationArn: Swift.String? = nil
    )
    {
        self.accessLogSubscriptionIdentifier = accessLogSubscriptionIdentifier
        self.destinationArn = destinationArn
    }
}

struct UpdateAccessLogSubscriptionInputBody: Swift.Equatable {
    let destinationArn: Swift.String?
}

extension UpdateAccessLogSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationArn)
        destinationArn = destinationArnDecoded
    }
}

extension UpdateAccessLogSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAccessLogSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateAccessLogSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAccessLogSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: UpdateAccessLogSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.destinationArn = output.destinationArn
            self.id = output.id
            self.resourceArn = output.resourceArn
            self.resourceId = output.resourceId
        } else {
            self.arn = nil
            self.destinationArn = nil
            self.id = nil
            self.resourceArn = nil
            self.resourceId = nil
        }
    }
}

public struct UpdateAccessLogSubscriptionOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the access log subscription.
    /// This member is required.
    public var arn: Swift.String?
    /// The Amazon Resource Name (ARN) of the access log destination.
    /// This member is required.
    public var destinationArn: Swift.String?
    /// The ID of the access log subscription.
    /// This member is required.
    public var id: Swift.String?
    /// The Amazon Resource Name (ARN) of the access log subscription.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        arn: Swift.String? = nil,
        destinationArn: Swift.String? = nil,
        id: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.destinationArn = destinationArn
        self.id = id
        self.resourceArn = resourceArn
        self.resourceId = resourceId
    }
}

struct UpdateAccessLogSubscriptionOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let resourceId: Swift.String?
    let resourceArn: Swift.String?
    let destinationArn: Swift.String?
}

extension UpdateAccessLogSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case destinationArn
        case id
        case resourceArn
        case resourceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let destinationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationArn)
        destinationArn = destinationArnDecoded
    }
}

extension UpdateListenerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultAction
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultAction = self.defaultAction {
            try encodeContainer.encode(defaultAction, forKey: .defaultAction)
        }
    }
}

extension UpdateListenerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceIdentifier = serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = listenerIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())"
    }
}

public struct UpdateListenerInput: Swift.Equatable {
    /// The action for the default rule.
    /// This member is required.
    public var defaultAction: VPCLatticeClientTypes.RuleAction?
    /// The ID or Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init (
        defaultAction: VPCLatticeClientTypes.RuleAction? = nil,
        listenerIdentifier: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.defaultAction = defaultAction
        self.listenerIdentifier = listenerIdentifier
        self.serviceIdentifier = serviceIdentifier
    }
}

struct UpdateListenerInputBody: Swift.Equatable {
    let defaultAction: VPCLatticeClientTypes.RuleAction?
}

extension UpdateListenerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultAction
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultActionDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleAction.self, forKey: .defaultAction)
        defaultAction = defaultActionDecoded
    }
}

extension UpdateListenerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateListenerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateListenerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateListenerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: UpdateListenerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.`protocol` = output.`protocol`
            self.arn = output.arn
            self.defaultAction = output.defaultAction
            self.id = output.id
            self.name = output.name
            self.port = output.port
            self.serviceArn = output.serviceArn
            self.serviceId = output.serviceId
        } else {
            self.arn = nil
            self.defaultAction = nil
            self.id = nil
            self.name = nil
            self.port = nil
            self.`protocol` = nil
            self.serviceArn = nil
            self.serviceId = nil
        }
    }
}

public struct UpdateListenerOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the listener.
    public var arn: Swift.String?
    /// The action for the default rule.
    public var defaultAction: VPCLatticeClientTypes.RuleAction?
    /// The ID of the listener.
    public var id: Swift.String?
    /// The name of the listener.
    public var name: Swift.String?
    /// The listener port.
    public var port: Swift.Int?
    /// The protocol of the listener.
    public var `protocol`: VPCLatticeClientTypes.ListenerProtocol?
    /// The Amazon Resource Name (ARN) of the service.
    public var serviceArn: Swift.String?
    /// The ID of the service.
    public var serviceId: Swift.String?

    public init (
        arn: Swift.String? = nil,
        defaultAction: VPCLatticeClientTypes.RuleAction? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        port: Swift.Int? = nil,
        `protocol`: VPCLatticeClientTypes.ListenerProtocol? = nil,
        serviceArn: Swift.String? = nil,
        serviceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.defaultAction = defaultAction
        self.id = id
        self.name = name
        self.port = port
        self.`protocol` = `protocol`
        self.serviceArn = serviceArn
        self.serviceId = serviceId
    }
}

struct UpdateListenerOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let `protocol`: VPCLatticeClientTypes.ListenerProtocol?
    let port: Swift.Int?
    let serviceArn: Swift.String?
    let serviceId: Swift.String?
    let defaultAction: VPCLatticeClientTypes.RuleAction?
}

extension UpdateListenerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case defaultAction
        case id
        case name
        case port
        case `protocol` = "protocol"
        case serviceArn
        case serviceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ListenerProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let defaultActionDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleAction.self, forKey: .defaultAction)
        defaultAction = defaultActionDecoded
    }
}

extension UpdateRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case match
        case priority
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let match = self.match {
            try encodeContainer.encode(match, forKey: .match)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
    }
}

extension UpdateRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceIdentifier = serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = listenerIdentifier else {
            return nil
        }
        guard let ruleIdentifier = ruleIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())/rules/\(ruleIdentifier.urlPercentEncoding())"
    }
}

public struct UpdateRuleInput: Swift.Equatable {
    /// Information about the action for the specified listener rule.
    public var action: VPCLatticeClientTypes.RuleAction?
    /// The ID or Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The rule match.
    public var match: VPCLatticeClientTypes.RuleMatch?
    /// The rule priority. A listener can't have multiple rules with the same priority.
    public var priority: Swift.Int?
    /// The ID or Amazon Resource Name (ARN) of the rule.
    /// This member is required.
    public var ruleIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init (
        action: VPCLatticeClientTypes.RuleAction? = nil,
        listenerIdentifier: Swift.String? = nil,
        match: VPCLatticeClientTypes.RuleMatch? = nil,
        priority: Swift.Int? = nil,
        ruleIdentifier: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.action = action
        self.listenerIdentifier = listenerIdentifier
        self.match = match
        self.priority = priority
        self.ruleIdentifier = ruleIdentifier
        self.serviceIdentifier = serviceIdentifier
    }
}

struct UpdateRuleInputBody: Swift.Equatable {
    let match: VPCLatticeClientTypes.RuleMatch?
    let priority: Swift.Int?
    let action: VPCLatticeClientTypes.RuleAction?
}

extension UpdateRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case match
        case priority
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let matchDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleMatch.self, forKey: .match)
        match = matchDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let actionDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleAction.self, forKey: .action)
        action = actionDecoded
    }
}

extension UpdateRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateRuleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: UpdateRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.action = output.action
            self.arn = output.arn
            self.id = output.id
            self.isDefault = output.isDefault
            self.match = output.match
            self.name = output.name
            self.priority = output.priority
        } else {
            self.action = nil
            self.arn = nil
            self.id = nil
            self.isDefault = nil
            self.match = nil
            self.name = nil
            self.priority = nil
        }
    }
}

public struct UpdateRuleOutputResponse: Swift.Equatable {
    /// Information about the action for the specified listener rule.
    public var action: VPCLatticeClientTypes.RuleAction?
    /// The Amazon Resource Name (ARN) of the listener.
    public var arn: Swift.String?
    /// The ID of the listener.
    public var id: Swift.String?
    /// Indicates whether this is the default rule.
    public var isDefault: Swift.Bool?
    /// The rule match.
    public var match: VPCLatticeClientTypes.RuleMatch?
    /// The name of the listener.
    public var name: Swift.String?
    /// The rule priority.
    public var priority: Swift.Int?

    public init (
        action: VPCLatticeClientTypes.RuleAction? = nil,
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        isDefault: Swift.Bool? = nil,
        match: VPCLatticeClientTypes.RuleMatch? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil
    )
    {
        self.action = action
        self.arn = arn
        self.id = id
        self.isDefault = isDefault
        self.match = match
        self.name = name
        self.priority = priority
    }
}

struct UpdateRuleOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let isDefault: Swift.Bool?
    let match: VPCLatticeClientTypes.RuleMatch?
    let priority: Swift.Int?
    let action: VPCLatticeClientTypes.RuleAction?
}

extension UpdateRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case arn
        case id
        case isDefault
        case match
        case name
        case priority
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let isDefaultDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDefault)
        isDefault = isDefaultDecoded
        let matchDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleMatch.self, forKey: .match)
        match = matchDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let actionDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleAction.self, forKey: .action)
        action = actionDecoded
    }
}

extension UpdateServiceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType
        case certificateArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authType = self.authType {
            try encodeContainer.encode(authType.rawValue, forKey: .authType)
        }
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
    }
}

extension UpdateServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceIdentifier = serviceIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())"
    }
}

public struct UpdateServiceInput: Swift.Equatable {
    /// The type of IAM policy.
    ///
    /// * NONE: The resource does not use an IAM policy. This is the default.
    ///
    /// * AWS_IAM: The resource uses an IAM policy. When this type is used, auth is enabled and an auth policy is required.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The Amazon Resource Name (ARN) of the certificate.
    public var certificateArn: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init (
        authType: VPCLatticeClientTypes.AuthType? = nil,
        certificateArn: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.authType = authType
        self.certificateArn = certificateArn
        self.serviceIdentifier = serviceIdentifier
    }
}

struct UpdateServiceInputBody: Swift.Equatable {
    let certificateArn: Swift.String?
    let authType: VPCLatticeClientTypes.AuthType?
}

extension UpdateServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType
        case certificateArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.AuthType.self, forKey: .authType)
        authType = authTypeDecoded
    }
}

extension UpdateServiceNetworkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authType = self.authType {
            try encodeContainer.encode(authType.rawValue, forKey: .authType)
        }
    }
}

extension UpdateServiceNetworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceNetworkIdentifier = serviceNetworkIdentifier else {
            return nil
        }
        return "/servicenetworks/\(serviceNetworkIdentifier.urlPercentEncoding())"
    }
}

public struct UpdateServiceNetworkInput: Swift.Equatable {
    /// The type of IAM policy.
    ///
    /// * NONE: The resource does not use an IAM policy. This is the default.
    ///
    /// * AWS_IAM: The resource uses an IAM policy. When this type is used, auth is enabled and an auth policy is required.
    /// This member is required.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The ID or Amazon Resource Name (ARN) of the service network.
    /// This member is required.
    public var serviceNetworkIdentifier: Swift.String?

    public init (
        authType: VPCLatticeClientTypes.AuthType? = nil,
        serviceNetworkIdentifier: Swift.String? = nil
    )
    {
        self.authType = authType
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
    }
}

struct UpdateServiceNetworkInputBody: Swift.Equatable {
    let authType: VPCLatticeClientTypes.AuthType?
}

extension UpdateServiceNetworkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authTypeDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.AuthType.self, forKey: .authType)
        authType = authTypeDecoded
    }
}

extension UpdateServiceNetworkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateServiceNetworkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateServiceNetworkOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServiceNetworkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: UpdateServiceNetworkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.authType = output.authType
            self.id = output.id
            self.name = output.name
        } else {
            self.arn = nil
            self.authType = nil
            self.id = nil
            self.name = nil
        }
    }
}

public struct UpdateServiceNetworkOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the service network.
    public var arn: Swift.String?
    /// The type of IAM policy.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The ID of the service network.
    public var id: Swift.String?
    /// The name of the service network.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        authType: VPCLatticeClientTypes.AuthType? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.authType = authType
        self.id = id
        self.name = name
    }
}

struct UpdateServiceNetworkOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let authType: VPCLatticeClientTypes.AuthType?
}

extension UpdateServiceNetworkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case authType
        case id
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.AuthType.self, forKey: .authType)
        authType = authTypeDecoded
    }
}

extension UpdateServiceNetworkVpcAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
    }
}

extension UpdateServiceNetworkVpcAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceNetworkVpcAssociationIdentifier = serviceNetworkVpcAssociationIdentifier else {
            return nil
        }
        return "/servicenetworkvpcassociations/\(serviceNetworkVpcAssociationIdentifier.urlPercentEncoding())"
    }
}

public struct UpdateServiceNetworkVpcAssociationInput: Swift.Equatable {
    /// The IDs of the security groups.
    /// This member is required.
    public var securityGroupIds: [Swift.String]?
    /// The ID or Amazon Resource Name (ARN) of the association.
    /// This member is required.
    public var serviceNetworkVpcAssociationIdentifier: Swift.String?

    public init (
        securityGroupIds: [Swift.String]? = nil,
        serviceNetworkVpcAssociationIdentifier: Swift.String? = nil
    )
    {
        self.securityGroupIds = securityGroupIds
        self.serviceNetworkVpcAssociationIdentifier = serviceNetworkVpcAssociationIdentifier
    }
}

struct UpdateServiceNetworkVpcAssociationInputBody: Swift.Equatable {
    let securityGroupIds: [Swift.String]?
}

extension UpdateServiceNetworkVpcAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension UpdateServiceNetworkVpcAssociationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateServiceNetworkVpcAssociationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateServiceNetworkVpcAssociationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServiceNetworkVpcAssociationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: UpdateServiceNetworkVpcAssociationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdBy = output.createdBy
            self.id = output.id
            self.securityGroupIds = output.securityGroupIds
            self.status = output.status
        } else {
            self.arn = nil
            self.createdBy = nil
            self.id = nil
            self.securityGroupIds = nil
            self.status = nil
        }
    }
}

public struct UpdateServiceNetworkVpcAssociationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The account that created the association.
    public var createdBy: Swift.String?
    /// The ID of the association.
    public var id: Swift.String?
    /// The IDs of the security groups.
    public var securityGroupIds: [Swift.String]?
    /// The status. You can retry the operation if the status is DELETE_FAILED. However, if you retry it while the status is DELETE_IN_PROGRESS, there is no change in the status.
    public var status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus?

    public init (
        arn: Swift.String? = nil,
        createdBy: Swift.String? = nil,
        id: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus? = nil
    )
    {
        self.arn = arn
        self.createdBy = createdBy
        self.id = id
        self.securityGroupIds = securityGroupIds
        self.status = status
    }
}

struct UpdateServiceNetworkVpcAssociationOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus?
    let createdBy: Swift.String?
    let securityGroupIds: [Swift.String]?
}

extension UpdateServiceNetworkVpcAssociationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdBy
        case id
        case securityGroupIds
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension UpdateServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateServiceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: UpdateServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.authType = output.authType
            self.certificateArn = output.certificateArn
            self.customDomainName = output.customDomainName
            self.id = output.id
            self.name = output.name
        } else {
            self.arn = nil
            self.authType = nil
            self.certificateArn = nil
            self.customDomainName = nil
            self.id = nil
            self.name = nil
        }
    }
}

public struct UpdateServiceOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the service.
    public var arn: Swift.String?
    /// The type of IAM policy.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The Amazon Resource Name (ARN) of the certificate.
    public var certificateArn: Swift.String?
    /// The custom domain name of the service.
    public var customDomainName: Swift.String?
    /// The ID of the service.
    public var id: Swift.String?
    /// The name of the service.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        authType: VPCLatticeClientTypes.AuthType? = nil,
        certificateArn: Swift.String? = nil,
        customDomainName: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.authType = authType
        self.certificateArn = certificateArn
        self.customDomainName = customDomainName
        self.id = id
        self.name = name
    }
}

struct UpdateServiceOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let customDomainName: Swift.String?
    let certificateArn: Swift.String?
    let authType: VPCLatticeClientTypes.AuthType?
}

extension UpdateServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case authType
        case certificateArn
        case customDomainName
        case id
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let customDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomainName)
        customDomainName = customDomainNameDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.AuthType.self, forKey: .authType)
        authType = authTypeDecoded
    }
}

extension UpdateTargetGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthCheck
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let healthCheck = self.healthCheck {
            try encodeContainer.encode(healthCheck, forKey: .healthCheck)
        }
    }
}

extension UpdateTargetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let targetGroupIdentifier = targetGroupIdentifier else {
            return nil
        }
        return "/targetgroups/\(targetGroupIdentifier.urlPercentEncoding())"
    }
}

public struct UpdateTargetGroupInput: Swift.Equatable {
    /// The health check configuration.
    /// This member is required.
    public var healthCheck: VPCLatticeClientTypes.HealthCheckConfig?
    /// The ID or Amazon Resource Name (ARN) of the target group.
    /// This member is required.
    public var targetGroupIdentifier: Swift.String?

    public init (
        healthCheck: VPCLatticeClientTypes.HealthCheckConfig? = nil,
        targetGroupIdentifier: Swift.String? = nil
    )
    {
        self.healthCheck = healthCheck
        self.targetGroupIdentifier = targetGroupIdentifier
    }
}

struct UpdateTargetGroupInputBody: Swift.Equatable {
    let healthCheck: VPCLatticeClientTypes.HealthCheckConfig?
}

extension UpdateTargetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthCheck
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let healthCheckDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.HealthCheckConfig.self, forKey: .healthCheck)
        healthCheck = healthCheckDecoded
    }
}

extension UpdateTargetGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTargetGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateTargetGroupOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTargetGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: UpdateTargetGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.config = output.config
            self.id = output.id
            self.name = output.name
            self.status = output.status
            self.type = output.type
        } else {
            self.arn = nil
            self.config = nil
            self.id = nil
            self.name = nil
            self.status = nil
            self.type = nil
        }
    }
}

public struct UpdateTargetGroupOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the target group.
    public var arn: Swift.String?
    /// The target group configuration.
    public var config: VPCLatticeClientTypes.TargetGroupConfig?
    /// The ID of the target group.
    public var id: Swift.String?
    /// The name of the target group.
    public var name: Swift.String?
    /// The status.
    public var status: VPCLatticeClientTypes.TargetGroupStatus?
    /// The target group type.
    public var type: VPCLatticeClientTypes.TargetGroupType?

    public init (
        arn: Swift.String? = nil,
        config: VPCLatticeClientTypes.TargetGroupConfig? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: VPCLatticeClientTypes.TargetGroupStatus? = nil,
        type: VPCLatticeClientTypes.TargetGroupType? = nil
    )
    {
        self.arn = arn
        self.config = config
        self.id = id
        self.name = name
        self.status = status
        self.type = type
    }
}

struct UpdateTargetGroupOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let type: VPCLatticeClientTypes.TargetGroupType?
    let config: VPCLatticeClientTypes.TargetGroupConfig?
    let status: VPCLatticeClientTypes.TargetGroupStatus?
}

extension UpdateTargetGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case config
        case id
        case name
        case status
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetGroupType.self, forKey: .type)
        type = typeDecoded
        let configDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetGroupConfig.self, forKey: .config)
        config = configDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetGroupStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let data = try httpResponse.body.toData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.fieldList = output.fieldList
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fieldList = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input does not satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable, Swift.Error {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The fields that failed validation.
    public var fieldList: [VPCLatticeClientTypes.ValidationExceptionField]?
    /// This member is required.
    public var message: Swift.String?
    /// The reason.
    /// This member is required.
    public var reason: VPCLatticeClientTypes.ValidationExceptionReason?

    public init (
        fieldList: [VPCLatticeClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: VPCLatticeClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.fieldList = fieldList
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: VPCLatticeClientTypes.ValidationExceptionReason?
    let fieldList: [VPCLatticeClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList
        case message
        case reason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[VPCLatticeClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [VPCLatticeClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension VPCLatticeClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Describes a validation failure.
    public struct ValidationExceptionField: Swift.Equatable {
        /// Additional details about why the validation failed.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the validation exception.
        /// This member is required.
        public var name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension VPCLatticeClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension VPCLatticeClientTypes.WeightedTargetGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetGroupIdentifier
        case weight
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetGroupIdentifier = self.targetGroupIdentifier {
            try encodeContainer.encode(targetGroupIdentifier, forKey: .targetGroupIdentifier)
        }
        if let weight = self.weight {
            try encodeContainer.encode(weight, forKey: .weight)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetGroupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetGroupIdentifier)
        targetGroupIdentifier = targetGroupIdentifierDecoded
        let weightDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .weight)
        weight = weightDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Describes the weight of a target group.
    public struct WeightedTargetGroup: Swift.Equatable {
        /// The ID or Amazon Resource Name (ARN) of the target group.
        /// This member is required.
        public var targetGroupIdentifier: Swift.String?
        /// Only required if you specify multiple target groups for a forward action. The "weight" determines how requests are distributed to the target group. For example, if you specify two target groups, each with a weight of 10, each target group receives half the requests. If you specify two target groups, one with a weight of 10 and the other with a weight of 20, the target group with a weight of 20 receives twice as many requests as the other target group. If there's only one target group specified, then the default value is 100.
        public var weight: Swift.Int?

        public init (
            targetGroupIdentifier: Swift.String? = nil,
            weight: Swift.Int? = nil
        )
        {
            self.targetGroupIdentifier = targetGroupIdentifier
            self.weight = weight
        }
    }

}
