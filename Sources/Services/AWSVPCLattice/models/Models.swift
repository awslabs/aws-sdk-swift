// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime
import SmithyJSON
import SmithyReadWrite

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The user does not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension VPCLatticeClientTypes.AccessLogSubscriptionSummary {

    static func write(value: VPCLatticeClientTypes.AccessLogSubscriptionSummary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["createdAt"].writeTimestamp(value.createdAt, format: .dateTime)
        try writer["destinationArn"].write(value.destinationArn)
        try writer["id"].write(value.id)
        try writer["lastUpdatedAt"].writeTimestamp(value.lastUpdatedAt, format: .dateTime)
        try writer["resourceArn"].write(value.resourceArn)
        try writer["resourceId"].write(value.resourceId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.AccessLogSubscriptionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.AccessLogSubscriptionSummary()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.resourceId = try reader["resourceId"].readIfPresent()
        value.resourceArn = try reader["resourceArn"].readIfPresent()
        value.destinationArn = try reader["destinationArn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension VPCLatticeClientTypes {
    /// Summary information about an access log subscription.
    public struct AccessLogSubscriptionSummary {
        /// The Amazon Resource Name (ARN) of the access log subscription
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the access log subscription was created, specified in ISO-8601 format.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the destination.
        /// This member is required.
        public var destinationArn: Swift.String?
        /// The ID of the access log subscription.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time that the access log subscription was last updated, specified in ISO-8601 format.
        /// This member is required.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the service or service network.
        /// This member is required.
        public var resourceArn: Swift.String?
        /// The ID of the service or service network.
        /// This member is required.
        public var resourceId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            destinationArn: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            resourceArn: Swift.String? = nil,
            resourceId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.destinationArn = destinationArn
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.resourceArn = resourceArn
            self.resourceId = resourceId
        }
    }

}

extension VPCLatticeClientTypes {

    public enum AuthPolicyState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthPolicyState] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .inactive: return "Inactive"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VPCLatticeClientTypes {

    public enum AuthType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsIam
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthType] {
            return [
                .awsIam,
                .none,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsIam: return "AWS_IAM"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BatchUpdateRuleInput {

    static func urlPathProvider(_ value: BatchUpdateRuleInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = value.listenerIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())/rules"
    }
}

extension BatchUpdateRuleInput {

    static func write(value: BatchUpdateRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["rules"].writeList(value.rules, memberWritingClosure: VPCLatticeClientTypes.RuleUpdate.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct BatchUpdateRuleInput {
    /// The ID or Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The rules for the specified listener.
    /// This member is required.
    public var rules: [VPCLatticeClientTypes.RuleUpdate]?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        listenerIdentifier: Swift.String? = nil,
        rules: [VPCLatticeClientTypes.RuleUpdate]? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.listenerIdentifier = listenerIdentifier
        self.rules = rules
        self.serviceIdentifier = serviceIdentifier
    }
}

extension BatchUpdateRuleOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> BatchUpdateRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchUpdateRuleOutput()
        value.successful = try reader["successful"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.RuleUpdateSuccess.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.unsuccessful = try reader["unsuccessful"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.RuleUpdateFailure.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct BatchUpdateRuleOutput {
    /// The rules that were successfully updated.
    public var successful: [VPCLatticeClientTypes.RuleUpdateSuccess]?
    /// The rules that the operation couldn't update.
    public var unsuccessful: [VPCLatticeClientTypes.RuleUpdateFailure]?

    public init(
        successful: [VPCLatticeClientTypes.RuleUpdateSuccess]? = nil,
        unsuccessful: [VPCLatticeClientTypes.RuleUpdateFailure]? = nil
    )
    {
        self.successful = successful
        self.unsuccessful = unsuccessful
    }
}

enum BatchUpdateRuleOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The request conflicts with the current state of the resource. Updating or deleting a resource can cause an inconsistent state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The resource ID.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

extension CreateAccessLogSubscriptionInput {

    static func urlPathProvider(_ value: CreateAccessLogSubscriptionInput) -> Swift.String? {
        return "/accesslogsubscriptions"
    }
}

extension CreateAccessLogSubscriptionInput {

    static func write(value: CreateAccessLogSubscriptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["destinationArn"].write(value.destinationArn)
        try writer["resourceIdentifier"].write(value.resourceIdentifier)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateAccessLogSubscriptionInput {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the destination. The supported destination types are CloudWatch Log groups, Kinesis Data Firehose delivery streams, and Amazon S3 buckets.
    /// This member is required.
    public var destinationArn: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service network or service.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The tags for the access log subscription.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        destinationArn: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.destinationArn = destinationArn
        self.resourceIdentifier = resourceIdentifier
        self.tags = tags
    }
}

extension CreateAccessLogSubscriptionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateAccessLogSubscriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAccessLogSubscriptionOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.destinationArn = try reader["destinationArn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.resourceArn = try reader["resourceArn"].readIfPresent()
        value.resourceId = try reader["resourceId"].readIfPresent()
        return value
    }
}

public struct CreateAccessLogSubscriptionOutput {
    /// The Amazon Resource Name (ARN) of the access log subscription.
    /// This member is required.
    public var arn: Swift.String?
    /// The Amazon Resource Name (ARN) of the log destination.
    /// This member is required.
    public var destinationArn: Swift.String?
    /// The ID of the access log subscription.
    /// This member is required.
    public var id: Swift.String?
    /// The Amazon Resource Name (ARN) of the service network or service.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The ID of the service network or service.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        destinationArn: Swift.String? = nil,
        id: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.destinationArn = destinationArn
        self.id = id
        self.resourceArn = resourceArn
        self.resourceId = resourceId
    }
}

enum CreateAccessLogSubscriptionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateListenerInput {

    static func urlPathProvider(_ value: CreateListenerInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners"
    }
}

extension CreateListenerInput {

    static func write(value: CreateListenerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["defaultAction"].write(value.defaultAction, with: VPCLatticeClientTypes.RuleAction.write(value:to:))
        try writer["name"].write(value.name)
        try writer["port"].write(value.port)
        try writer["protocol"].write(value.`protocol`)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateListenerInput {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The action for the default rule. Each listener has a default rule. Each rule consists of a priority, one or more actions, and one or more conditions. The default rule is the rule that's used if no other rules match. Each rule must include exactly one of the following types of actions: forward or fixed-response, and it must be the last action to be performed.
    /// This member is required.
    public var defaultAction: VPCLatticeClientTypes.RuleAction?
    /// The name of the listener. A listener name must be unique within a service. The valid characters are a-z, 0-9, and hyphens (-). You can't use a hyphen as the first or last character, or immediately after another hyphen.
    /// This member is required.
    public var name: Swift.String?
    /// The listener port. You can specify a value from 1 to 65535. For HTTP, the default is 80. For HTTPS, the default is 443.
    public var port: Swift.Int?
    /// The listener protocol HTTP or HTTPS.
    /// This member is required.
    public var `protocol`: VPCLatticeClientTypes.ListenerProtocol?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?
    /// The tags for the listener.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        defaultAction: VPCLatticeClientTypes.RuleAction? = nil,
        name: Swift.String? = nil,
        port: Swift.Int? = nil,
        `protocol`: VPCLatticeClientTypes.ListenerProtocol? = nil,
        serviceIdentifier: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.defaultAction = defaultAction
        self.name = name
        self.port = port
        self.`protocol` = `protocol`
        self.serviceIdentifier = serviceIdentifier
        self.tags = tags
    }
}

extension CreateListenerOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateListenerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateListenerOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.defaultAction = try reader["defaultAction"].readIfPresent(with: VPCLatticeClientTypes.RuleAction.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.port = try reader["port"].readIfPresent()
        value.`protocol` = try reader["protocol"].readIfPresent()
        value.serviceArn = try reader["serviceArn"].readIfPresent()
        value.serviceId = try reader["serviceId"].readIfPresent()
        return value
    }
}

public struct CreateListenerOutput {
    /// The Amazon Resource Name (ARN) of the listener.
    public var arn: Swift.String?
    /// The action for the default rule.
    public var defaultAction: VPCLatticeClientTypes.RuleAction?
    /// The ID of the listener.
    public var id: Swift.String?
    /// The name of the listener.
    public var name: Swift.String?
    /// The port number of the listener.
    public var port: Swift.Int?
    /// The protocol of the listener.
    public var `protocol`: VPCLatticeClientTypes.ListenerProtocol?
    /// The Amazon Resource Name (ARN) of the service.
    public var serviceArn: Swift.String?
    /// The ID of the service.
    public var serviceId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        defaultAction: VPCLatticeClientTypes.RuleAction? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        port: Swift.Int? = nil,
        `protocol`: VPCLatticeClientTypes.ListenerProtocol? = nil,
        serviceArn: Swift.String? = nil,
        serviceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.defaultAction = defaultAction
        self.id = id
        self.name = name
        self.port = port
        self.`protocol` = `protocol`
        self.serviceArn = serviceArn
        self.serviceId = serviceId
    }
}

enum CreateListenerOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateRuleInput {

    static func urlPathProvider(_ value: CreateRuleInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = value.listenerIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())/rules"
    }
}

extension CreateRuleInput {

    static func write(value: CreateRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action, with: VPCLatticeClientTypes.RuleAction.write(value:to:))
        try writer["clientToken"].write(value.clientToken)
        try writer["match"].write(value.match, with: VPCLatticeClientTypes.RuleMatch.write(value:to:))
        try writer["name"].write(value.name)
        try writer["priority"].write(value.priority)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateRuleInput {
    /// The action for the default rule.
    /// This member is required.
    public var action: VPCLatticeClientTypes.RuleAction?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The rule match.
    /// This member is required.
    public var match: VPCLatticeClientTypes.RuleMatch?
    /// The name of the rule. The name must be unique within the listener. The valid characters are a-z, 0-9, and hyphens (-). You can't use a hyphen as the first or last character, or immediately after another hyphen.
    /// This member is required.
    public var name: Swift.String?
    /// The priority assigned to the rule. Each rule for a specific listener must have a unique priority. The lower the priority number the higher the priority.
    /// This member is required.
    public var priority: Swift.Int?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?
    /// The tags for the rule.
    public var tags: [Swift.String:Swift.String]?

    public init(
        action: VPCLatticeClientTypes.RuleAction? = nil,
        clientToken: Swift.String? = nil,
        listenerIdentifier: Swift.String? = nil,
        match: VPCLatticeClientTypes.RuleMatch? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil,
        serviceIdentifier: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.action = action
        self.clientToken = clientToken
        self.listenerIdentifier = listenerIdentifier
        self.match = match
        self.name = name
        self.priority = priority
        self.serviceIdentifier = serviceIdentifier
        self.tags = tags
    }
}

extension CreateRuleOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRuleOutput()
        value.action = try reader["action"].readIfPresent(with: VPCLatticeClientTypes.RuleAction.read(from:))
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.match = try reader["match"].readIfPresent(with: VPCLatticeClientTypes.RuleMatch.read(from:))
        value.name = try reader["name"].readIfPresent()
        value.priority = try reader["priority"].readIfPresent()
        return value
    }
}

public struct CreateRuleOutput {
    /// The rule action. Each rule must include exactly one of the following types of actions: forward or fixed-response, and it must be the last action to be performed.
    public var action: VPCLatticeClientTypes.RuleAction?
    /// The Amazon Resource Name (ARN) of the rule.
    public var arn: Swift.String?
    /// The ID of the rule.
    public var id: Swift.String?
    /// The rule match. The RuleMatch must be an HttpMatch. This means that the rule should be an exact match on HTTP constraints which are made up of the HTTP method, path, and header.
    public var match: VPCLatticeClientTypes.RuleMatch?
    /// The name of the rule.
    public var name: Swift.String?
    /// The priority assigned to the rule. The lower the priority number the higher the priority.
    public var priority: Swift.Int?

    public init(
        action: VPCLatticeClientTypes.RuleAction? = nil,
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        match: VPCLatticeClientTypes.RuleMatch? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil
    )
    {
        self.action = action
        self.arn = arn
        self.id = id
        self.match = match
        self.name = name
        self.priority = priority
    }
}

enum CreateRuleOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateServiceInput {

    static func urlPathProvider(_ value: CreateServiceInput) -> Swift.String? {
        return "/services"
    }
}

extension CreateServiceInput {

    static func write(value: CreateServiceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authType"].write(value.authType)
        try writer["certificateArn"].write(value.certificateArn)
        try writer["clientToken"].write(value.clientToken)
        try writer["customDomainName"].write(value.customDomainName)
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateServiceInput {
    /// The type of IAM policy.
    ///
    /// * NONE: The resource does not use an IAM policy. This is the default.
    ///
    /// * AWS_IAM: The resource uses an IAM policy. When this type is used, auth is enabled and an auth policy is required.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The Amazon Resource Name (ARN) of the certificate.
    public var certificateArn: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The custom domain name of the service.
    public var customDomainName: Swift.String?
    /// The name of the service. The name must be unique within the account. The valid characters are a-z, 0-9, and hyphens (-). You can't use a hyphen as the first or last character, or immediately after another hyphen.
    /// This member is required.
    public var name: Swift.String?
    /// The tags for the service.
    public var tags: [Swift.String:Swift.String]?

    public init(
        authType: VPCLatticeClientTypes.AuthType? = nil,
        certificateArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        customDomainName: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.authType = authType
        self.certificateArn = certificateArn
        self.clientToken = clientToken
        self.customDomainName = customDomainName
        self.name = name
        self.tags = tags
    }
}

extension CreateServiceNetworkInput {

    static func urlPathProvider(_ value: CreateServiceNetworkInput) -> Swift.String? {
        return "/servicenetworks"
    }
}

extension CreateServiceNetworkInput {

    static func write(value: CreateServiceNetworkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authType"].write(value.authType)
        try writer["clientToken"].write(value.clientToken)
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateServiceNetworkInput {
    /// The type of IAM policy.
    ///
    /// * NONE: The resource does not use an IAM policy. This is the default.
    ///
    /// * AWS_IAM: The resource uses an IAM policy. When this type is used, auth is enabled and an auth policy is required.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The name of the service network. The name must be unique to the account. The valid characters are a-z, 0-9, and hyphens (-). You can't use a hyphen as the first or last character, or immediately after another hyphen.
    /// This member is required.
    public var name: Swift.String?
    /// The tags for the service network.
    public var tags: [Swift.String:Swift.String]?

    public init(
        authType: VPCLatticeClientTypes.AuthType? = nil,
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.authType = authType
        self.clientToken = clientToken
        self.name = name
        self.tags = tags
    }
}

extension CreateServiceNetworkOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateServiceNetworkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateServiceNetworkOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.authType = try reader["authType"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

public struct CreateServiceNetworkOutput {
    /// The Amazon Resource Name (ARN) of the service network.
    public var arn: Swift.String?
    /// The type of IAM policy.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The ID of the service network.
    public var id: Swift.String?
    /// The name of the service network.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        authType: VPCLatticeClientTypes.AuthType? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.authType = authType
        self.id = id
        self.name = name
    }
}

enum CreateServiceNetworkOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateServiceNetworkServiceAssociationInput {

    static func urlPathProvider(_ value: CreateServiceNetworkServiceAssociationInput) -> Swift.String? {
        return "/servicenetworkserviceassociations"
    }
}

extension CreateServiceNetworkServiceAssociationInput {

    static func write(value: CreateServiceNetworkServiceAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["serviceIdentifier"].write(value.serviceIdentifier)
        try writer["serviceNetworkIdentifier"].write(value.serviceNetworkIdentifier)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateServiceNetworkServiceAssociationInput {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service network. You must use the ARN if the resources specified in the operation are in different accounts.
    /// This member is required.
    public var serviceNetworkIdentifier: Swift.String?
    /// The tags for the association.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil,
        serviceNetworkIdentifier: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.serviceIdentifier = serviceIdentifier
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
        self.tags = tags
    }
}

extension CreateServiceNetworkServiceAssociationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateServiceNetworkServiceAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateServiceNetworkServiceAssociationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.customDomainName = try reader["customDomainName"].readIfPresent()
        value.dnsEntry = try reader["dnsEntry"].readIfPresent(with: VPCLatticeClientTypes.DnsEntry.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

public struct CreateServiceNetworkServiceAssociationOutput {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The account that created the association.
    public var createdBy: Swift.String?
    /// The custom domain name of the service.
    public var customDomainName: Swift.String?
    /// The DNS name of the service.
    public var dnsEntry: VPCLatticeClientTypes.DnsEntry?
    /// The ID of the association.
    public var id: Swift.String?
    /// The operation's status.
    public var status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus?

    public init(
        arn: Swift.String? = nil,
        createdBy: Swift.String? = nil,
        customDomainName: Swift.String? = nil,
        dnsEntry: VPCLatticeClientTypes.DnsEntry? = nil,
        id: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus? = nil
    )
    {
        self.arn = arn
        self.createdBy = createdBy
        self.customDomainName = customDomainName
        self.dnsEntry = dnsEntry
        self.id = id
        self.status = status
    }
}

enum CreateServiceNetworkServiceAssociationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateServiceNetworkVpcAssociationInput {

    static func urlPathProvider(_ value: CreateServiceNetworkVpcAssociationInput) -> Swift.String? {
        return "/servicenetworkvpcassociations"
    }
}

extension CreateServiceNetworkVpcAssociationInput {

    static func write(value: CreateServiceNetworkVpcAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["serviceNetworkIdentifier"].write(value.serviceNetworkIdentifier)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["vpcIdentifier"].write(value.vpcIdentifier)
    }
}

public struct CreateServiceNetworkVpcAssociationInput {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The IDs of the security groups. Security groups aren't added by default. You can add a security group to apply network level controls to control which resources in a VPC are allowed to access the service network and its services. For more information, see [Control traffic to resources using security groups](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html) in the Amazon VPC User Guide.
    public var securityGroupIds: [Swift.String]?
    /// The ID or Amazon Resource Name (ARN) of the service network. You must use the ARN when the resources specified in the operation are in different accounts.
    /// This member is required.
    public var serviceNetworkIdentifier: Swift.String?
    /// The tags for the association.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the VPC.
    /// This member is required.
    public var vpcIdentifier: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        serviceNetworkIdentifier: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcIdentifier: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.securityGroupIds = securityGroupIds
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
        self.tags = tags
        self.vpcIdentifier = vpcIdentifier
    }
}

extension CreateServiceNetworkVpcAssociationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateServiceNetworkVpcAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateServiceNetworkVpcAssociationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

public struct CreateServiceNetworkVpcAssociationOutput {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The account that created the association.
    public var createdBy: Swift.String?
    /// The ID of the association.
    public var id: Swift.String?
    /// The IDs of the security groups.
    public var securityGroupIds: [Swift.String]?
    /// The operation's status.
    public var status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus?

    public init(
        arn: Swift.String? = nil,
        createdBy: Swift.String? = nil,
        id: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus? = nil
    )
    {
        self.arn = arn
        self.createdBy = createdBy
        self.id = id
        self.securityGroupIds = securityGroupIds
        self.status = status
    }
}

enum CreateServiceNetworkVpcAssociationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateServiceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateServiceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateServiceOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.authType = try reader["authType"].readIfPresent()
        value.certificateArn = try reader["certificateArn"].readIfPresent()
        value.customDomainName = try reader["customDomainName"].readIfPresent()
        value.dnsEntry = try reader["dnsEntry"].readIfPresent(with: VPCLatticeClientTypes.DnsEntry.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

public struct CreateServiceOutput {
    /// The Amazon Resource Name (ARN) of the service.
    public var arn: Swift.String?
    /// The type of IAM policy.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The Amazon Resource Name (ARN) of the certificate.
    public var certificateArn: Swift.String?
    /// The custom domain name of the service.
    public var customDomainName: Swift.String?
    /// The public DNS name of the service.
    public var dnsEntry: VPCLatticeClientTypes.DnsEntry?
    /// The ID of the service.
    public var id: Swift.String?
    /// The name of the service.
    public var name: Swift.String?
    /// The status. If the status is CREATE_FAILED, you will have to delete and recreate the service.
    public var status: VPCLatticeClientTypes.ServiceStatus?

    public init(
        arn: Swift.String? = nil,
        authType: VPCLatticeClientTypes.AuthType? = nil,
        certificateArn: Swift.String? = nil,
        customDomainName: Swift.String? = nil,
        dnsEntry: VPCLatticeClientTypes.DnsEntry? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceStatus? = nil
    )
    {
        self.arn = arn
        self.authType = authType
        self.certificateArn = certificateArn
        self.customDomainName = customDomainName
        self.dnsEntry = dnsEntry
        self.id = id
        self.name = name
        self.status = status
    }
}

enum CreateServiceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateTargetGroupInput {

    static func urlPathProvider(_ value: CreateTargetGroupInput) -> Swift.String? {
        return "/targetgroups"
    }
}

extension CreateTargetGroupInput {

    static func write(value: CreateTargetGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["config"].write(value.config, with: VPCLatticeClientTypes.TargetGroupConfig.write(value:to:))
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["type"].write(value.type)
    }
}

public struct CreateTargetGroupInput {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The target group configuration. If type is set to LAMBDA, this parameter doesn't apply.
    public var config: VPCLatticeClientTypes.TargetGroupConfig?
    /// The name of the target group. The name must be unique within the account. The valid characters are a-z, 0-9, and hyphens (-). You can't use a hyphen as the first or last character, or immediately after another hyphen.
    /// This member is required.
    public var name: Swift.String?
    /// The tags for the target group.
    public var tags: [Swift.String:Swift.String]?
    /// The type of target group.
    /// This member is required.
    public var type: VPCLatticeClientTypes.TargetGroupType?

    public init(
        clientToken: Swift.String? = nil,
        config: VPCLatticeClientTypes.TargetGroupConfig? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: VPCLatticeClientTypes.TargetGroupType? = nil
    )
    {
        self.clientToken = clientToken
        self.config = config
        self.name = name
        self.tags = tags
        self.type = type
    }
}

extension CreateTargetGroupOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateTargetGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTargetGroupOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.config = try reader["config"].readIfPresent(with: VPCLatticeClientTypes.TargetGroupConfig.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

public struct CreateTargetGroupOutput {
    /// The Amazon Resource Name (ARN) of the target group.
    public var arn: Swift.String?
    /// The target group configuration. If type is set to LAMBDA, this parameter doesn't apply.
    public var config: VPCLatticeClientTypes.TargetGroupConfig?
    /// The ID of the target group.
    public var id: Swift.String?
    /// The name of the target group.
    public var name: Swift.String?
    /// The operation's status. You can retry the operation if the status is CREATE_FAILED. However, if you retry it while the status is CREATE_IN_PROGRESS, there is no change in the status.
    public var status: VPCLatticeClientTypes.TargetGroupStatus?
    /// The type of target group.
    public var type: VPCLatticeClientTypes.TargetGroupType?

    public init(
        arn: Swift.String? = nil,
        config: VPCLatticeClientTypes.TargetGroupConfig? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: VPCLatticeClientTypes.TargetGroupStatus? = nil,
        type: VPCLatticeClientTypes.TargetGroupType? = nil
    )
    {
        self.arn = arn
        self.config = config
        self.id = id
        self.name = name
        self.status = status
        self.type = type
    }
}

enum CreateTargetGroupOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteAccessLogSubscriptionInput {

    static func urlPathProvider(_ value: DeleteAccessLogSubscriptionInput) -> Swift.String? {
        guard let accessLogSubscriptionIdentifier = value.accessLogSubscriptionIdentifier else {
            return nil
        }
        return "/accesslogsubscriptions/\(accessLogSubscriptionIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteAccessLogSubscriptionInput {
    /// The ID or Amazon Resource Name (ARN) of the access log subscription.
    /// This member is required.
    public var accessLogSubscriptionIdentifier: Swift.String?

    public init(
        accessLogSubscriptionIdentifier: Swift.String? = nil
    )
    {
        self.accessLogSubscriptionIdentifier = accessLogSubscriptionIdentifier
    }
}

extension DeleteAccessLogSubscriptionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteAccessLogSubscriptionOutput {
        return DeleteAccessLogSubscriptionOutput()
    }
}

public struct DeleteAccessLogSubscriptionOutput {

    public init() { }
}

enum DeleteAccessLogSubscriptionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteAuthPolicyInput {

    static func urlPathProvider(_ value: DeleteAuthPolicyInput) -> Swift.String? {
        guard let resourceIdentifier = value.resourceIdentifier else {
            return nil
        }
        return "/authpolicy/\(resourceIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteAuthPolicyInput {
    /// The ID or Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceIdentifier: Swift.String?

    public init(
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
    }
}

extension DeleteAuthPolicyOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteAuthPolicyOutput {
        return DeleteAuthPolicyOutput()
    }
}

public struct DeleteAuthPolicyOutput {

    public init() { }
}

enum DeleteAuthPolicyOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteListenerInput {

    static func urlPathProvider(_ value: DeleteListenerInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = value.listenerIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteListenerInput {
    /// The ID or Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        listenerIdentifier: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.listenerIdentifier = listenerIdentifier
        self.serviceIdentifier = serviceIdentifier
    }
}

extension DeleteListenerOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteListenerOutput {
        return DeleteListenerOutput()
    }
}

public struct DeleteListenerOutput {

    public init() { }
}

enum DeleteListenerOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteResourcePolicyInput {

    static func urlPathProvider(_ value: DeleteResourcePolicyInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/resourcepolicy/\(resourceArn.urlPercentEncoding())"
    }
}

public struct DeleteResourcePolicyInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

extension DeleteResourcePolicyOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteResourcePolicyOutput {
        return DeleteResourcePolicyOutput()
    }
}

public struct DeleteResourcePolicyOutput {

    public init() { }
}

enum DeleteResourcePolicyOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteRuleInput {

    static func urlPathProvider(_ value: DeleteRuleInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = value.listenerIdentifier else {
            return nil
        }
        guard let ruleIdentifier = value.ruleIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())/rules/\(ruleIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteRuleInput {
    /// The ID or Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the rule.
    /// This member is required.
    public var ruleIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        listenerIdentifier: Swift.String? = nil,
        ruleIdentifier: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.listenerIdentifier = listenerIdentifier
        self.ruleIdentifier = ruleIdentifier
        self.serviceIdentifier = serviceIdentifier
    }
}

extension DeleteRuleOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteRuleOutput {
        return DeleteRuleOutput()
    }
}

public struct DeleteRuleOutput {

    public init() { }
}

enum DeleteRuleOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteServiceInput {

    static func urlPathProvider(_ value: DeleteServiceInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteServiceInput {
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.serviceIdentifier = serviceIdentifier
    }
}

extension DeleteServiceNetworkInput {

    static func urlPathProvider(_ value: DeleteServiceNetworkInput) -> Swift.String? {
        guard let serviceNetworkIdentifier = value.serviceNetworkIdentifier else {
            return nil
        }
        return "/servicenetworks/\(serviceNetworkIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteServiceNetworkInput {
    /// The Amazon Resource Name (ARN) or ID of the service network.
    /// This member is required.
    public var serviceNetworkIdentifier: Swift.String?

    public init(
        serviceNetworkIdentifier: Swift.String? = nil
    )
    {
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
    }
}

extension DeleteServiceNetworkOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteServiceNetworkOutput {
        return DeleteServiceNetworkOutput()
    }
}

public struct DeleteServiceNetworkOutput {

    public init() { }
}

enum DeleteServiceNetworkOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteServiceNetworkServiceAssociationInput {

    static func urlPathProvider(_ value: DeleteServiceNetworkServiceAssociationInput) -> Swift.String? {
        guard let serviceNetworkServiceAssociationIdentifier = value.serviceNetworkServiceAssociationIdentifier else {
            return nil
        }
        return "/servicenetworkserviceassociations/\(serviceNetworkServiceAssociationIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteServiceNetworkServiceAssociationInput {
    /// The ID or Amazon Resource Name (ARN) of the association.
    /// This member is required.
    public var serviceNetworkServiceAssociationIdentifier: Swift.String?

    public init(
        serviceNetworkServiceAssociationIdentifier: Swift.String? = nil
    )
    {
        self.serviceNetworkServiceAssociationIdentifier = serviceNetworkServiceAssociationIdentifier
    }
}

extension DeleteServiceNetworkServiceAssociationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteServiceNetworkServiceAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteServiceNetworkServiceAssociationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

public struct DeleteServiceNetworkServiceAssociationOutput {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The ID of the association.
    public var id: Swift.String?
    /// The operation's status. You can retry the operation if the status is DELETE_FAILED. However, if you retry it when the status is DELETE_IN_PROGRESS, there is no change in the status.
    public var status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.status = status
    }
}

enum DeleteServiceNetworkServiceAssociationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteServiceNetworkVpcAssociationInput {

    static func urlPathProvider(_ value: DeleteServiceNetworkVpcAssociationInput) -> Swift.String? {
        guard let serviceNetworkVpcAssociationIdentifier = value.serviceNetworkVpcAssociationIdentifier else {
            return nil
        }
        return "/servicenetworkvpcassociations/\(serviceNetworkVpcAssociationIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteServiceNetworkVpcAssociationInput {
    /// The ID or Amazon Resource Name (ARN) of the association.
    /// This member is required.
    public var serviceNetworkVpcAssociationIdentifier: Swift.String?

    public init(
        serviceNetworkVpcAssociationIdentifier: Swift.String? = nil
    )
    {
        self.serviceNetworkVpcAssociationIdentifier = serviceNetworkVpcAssociationIdentifier
    }
}

extension DeleteServiceNetworkVpcAssociationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteServiceNetworkVpcAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteServiceNetworkVpcAssociationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

public struct DeleteServiceNetworkVpcAssociationOutput {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The ID of the association.
    public var id: Swift.String?
    /// The status. You can retry the operation if the status is DELETE_FAILED. However, if you retry it when the status is DELETE_IN_PROGRESS, there is no change in the status.
    public var status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.status = status
    }
}

enum DeleteServiceNetworkVpcAssociationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteServiceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteServiceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteServiceOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

public struct DeleteServiceOutput {
    /// The Amazon Resource Name (ARN) of the service.
    public var arn: Swift.String?
    /// The ID of the service.
    public var id: Swift.String?
    /// The name of the service.
    public var name: Swift.String?
    /// The status. You can retry the operation if the status is DELETE_FAILED. However, if you retry it while the status is DELETE_IN_PROGRESS, the status doesn't change.
    public var status: VPCLatticeClientTypes.ServiceStatus?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceStatus? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.name = name
        self.status = status
    }
}

enum DeleteServiceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteTargetGroupInput {

    static func urlPathProvider(_ value: DeleteTargetGroupInput) -> Swift.String? {
        guard let targetGroupIdentifier = value.targetGroupIdentifier else {
            return nil
        }
        return "/targetgroups/\(targetGroupIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteTargetGroupInput {
    /// The ID or Amazon Resource Name (ARN) of the target group.
    /// This member is required.
    public var targetGroupIdentifier: Swift.String?

    public init(
        targetGroupIdentifier: Swift.String? = nil
    )
    {
        self.targetGroupIdentifier = targetGroupIdentifier
    }
}

extension DeleteTargetGroupOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteTargetGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteTargetGroupOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

public struct DeleteTargetGroupOutput {
    /// The Amazon Resource Name (ARN) of the target group.
    public var arn: Swift.String?
    /// The ID of the target group.
    public var id: Swift.String?
    /// The status. You can retry the operation if the status is DELETE_FAILED. However, if you retry it while the status is DELETE_IN_PROGRESS, the status doesn't change.
    public var status: VPCLatticeClientTypes.TargetGroupStatus?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        status: VPCLatticeClientTypes.TargetGroupStatus? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.status = status
    }
}

enum DeleteTargetGroupOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeregisterTargetsInput {

    static func urlPathProvider(_ value: DeregisterTargetsInput) -> Swift.String? {
        guard let targetGroupIdentifier = value.targetGroupIdentifier else {
            return nil
        }
        return "/targetgroups/\(targetGroupIdentifier.urlPercentEncoding())/deregistertargets"
    }
}

extension DeregisterTargetsInput {

    static func write(value: DeregisterTargetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["targets"].writeList(value.targets, memberWritingClosure: VPCLatticeClientTypes.Target.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct DeregisterTargetsInput {
    /// The ID or Amazon Resource Name (ARN) of the target group.
    /// This member is required.
    public var targetGroupIdentifier: Swift.String?
    /// The targets to deregister.
    /// This member is required.
    public var targets: [VPCLatticeClientTypes.Target]?

    public init(
        targetGroupIdentifier: Swift.String? = nil,
        targets: [VPCLatticeClientTypes.Target]? = nil
    )
    {
        self.targetGroupIdentifier = targetGroupIdentifier
        self.targets = targets
    }
}

extension DeregisterTargetsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeregisterTargetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeregisterTargetsOutput()
        value.successful = try reader["successful"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.Target.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.unsuccessful = try reader["unsuccessful"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.TargetFailure.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct DeregisterTargetsOutput {
    /// The targets that were successfully deregistered.
    public var successful: [VPCLatticeClientTypes.Target]?
    /// The targets that the operation couldn't deregister.
    public var unsuccessful: [VPCLatticeClientTypes.TargetFailure]?

    public init(
        successful: [VPCLatticeClientTypes.Target]? = nil,
        unsuccessful: [VPCLatticeClientTypes.TargetFailure]? = nil
    )
    {
        self.successful = successful
        self.unsuccessful = unsuccessful
    }
}

enum DeregisterTargetsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension VPCLatticeClientTypes.DnsEntry {

    static func write(value: VPCLatticeClientTypes.DnsEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["domainName"].write(value.domainName)
        try writer["hostedZoneId"].write(value.hostedZoneId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.DnsEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.DnsEntry()
        value.domainName = try reader["domainName"].readIfPresent()
        value.hostedZoneId = try reader["hostedZoneId"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes {
    /// Describes the DNS information of a service.
    public struct DnsEntry {
        /// The domain name of the service.
        public var domainName: Swift.String?
        /// The ID of the hosted zone.
        public var hostedZoneId: Swift.String?

        public init(
            domainName: Swift.String? = nil,
            hostedZoneId: Swift.String? = nil
        )
        {
            self.domainName = domainName
            self.hostedZoneId = hostedZoneId
        }
    }

}

extension VPCLatticeClientTypes.FixedResponseAction {

    static func write(value: VPCLatticeClientTypes.FixedResponseAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["statusCode"].write(value.statusCode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.FixedResponseAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.FixedResponseAction()
        value.statusCode = try reader["statusCode"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes {
    /// Information about an action that returns a custom HTTP response.
    public struct FixedResponseAction {
        /// The HTTP response code.
        /// This member is required.
        public var statusCode: Swift.Int?

        public init(
            statusCode: Swift.Int? = nil
        )
        {
            self.statusCode = statusCode
        }
    }

}

extension VPCLatticeClientTypes.ForwardAction {

    static func write(value: VPCLatticeClientTypes.ForwardAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["targetGroups"].writeList(value.targetGroups, memberWritingClosure: VPCLatticeClientTypes.WeightedTargetGroup.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.ForwardAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.ForwardAction()
        value.targetGroups = try reader["targetGroups"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.WeightedTargetGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension VPCLatticeClientTypes {
    /// Describes a forward action. You can use forward actions to route requests to one or more target groups.
    public struct ForwardAction {
        /// The target groups. Traffic matching the rule is forwarded to the specified target groups. With forward actions, you can assign a weight that controls the prioritization and selection of each target group. This means that requests are distributed to individual target groups based on their weights. For example, if two target groups have the same weight, each target group receives half of the traffic. The default value is 1. This means that if only one target group is provided, there is no need to set the weight; 100% of traffic will go to that target group.
        /// This member is required.
        public var targetGroups: [VPCLatticeClientTypes.WeightedTargetGroup]?

        public init(
            targetGroups: [VPCLatticeClientTypes.WeightedTargetGroup]? = nil
        )
        {
            self.targetGroups = targetGroups
        }
    }

}

extension GetAccessLogSubscriptionInput {

    static func urlPathProvider(_ value: GetAccessLogSubscriptionInput) -> Swift.String? {
        guard let accessLogSubscriptionIdentifier = value.accessLogSubscriptionIdentifier else {
            return nil
        }
        return "/accesslogsubscriptions/\(accessLogSubscriptionIdentifier.urlPercentEncoding())"
    }
}

public struct GetAccessLogSubscriptionInput {
    /// The ID or Amazon Resource Name (ARN) of the access log subscription.
    /// This member is required.
    public var accessLogSubscriptionIdentifier: Swift.String?

    public init(
        accessLogSubscriptionIdentifier: Swift.String? = nil
    )
    {
        self.accessLogSubscriptionIdentifier = accessLogSubscriptionIdentifier
    }
}

extension GetAccessLogSubscriptionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetAccessLogSubscriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAccessLogSubscriptionOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.destinationArn = try reader["destinationArn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: .dateTime)
        value.resourceArn = try reader["resourceArn"].readIfPresent()
        value.resourceId = try reader["resourceId"].readIfPresent()
        return value
    }
}

public struct GetAccessLogSubscriptionOutput {
    /// The Amazon Resource Name (ARN) of the access log subscription.
    /// This member is required.
    public var arn: Swift.String?
    /// The date and time that the access log subscription was created, specified in ISO-8601 format.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the access log destination.
    /// This member is required.
    public var destinationArn: Swift.String?
    /// The ID of the access log subscription.
    /// This member is required.
    public var id: Swift.String?
    /// The date and time that the access log subscription was last updated, specified in ISO-8601 format.
    /// This member is required.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the service network or service.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The ID of the service network or service.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        destinationArn: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        resourceArn: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.destinationArn = destinationArn
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.resourceArn = resourceArn
        self.resourceId = resourceId
    }
}

enum GetAccessLogSubscriptionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetAuthPolicyInput {

    static func urlPathProvider(_ value: GetAuthPolicyInput) -> Swift.String? {
        guard let resourceIdentifier = value.resourceIdentifier else {
            return nil
        }
        return "/authpolicy/\(resourceIdentifier.urlPercentEncoding())"
    }
}

public struct GetAuthPolicyInput {
    /// The ID or Amazon Resource Name (ARN) of the service network or service.
    /// This member is required.
    public var resourceIdentifier: Swift.String?

    public init(
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
    }
}

extension GetAuthPolicyOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetAuthPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAuthPolicyOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: .dateTime)
        value.policy = try reader["policy"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        return value
    }
}

public struct GetAuthPolicyOutput {
    /// The date and time that the auth policy was created, specified in ISO-8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The date and time that the auth policy was last updated, specified in ISO-8601 format.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The auth policy.
    public var policy: Swift.String?
    /// The state of the auth policy. The auth policy is only active when the auth type is set to Amazon Web Services_IAM. If you provide a policy, then authentication and authorization decisions are made based on this policy and the client's IAM policy. If the auth type is NONE, then any auth policy you provide will remain inactive. For more information, see [Create a service network](https://docs.aws.amazon.com/vpc-lattice/latest/ug/service-networks.html#create-service-network) in the Amazon VPC Lattice User Guide.
    public var state: VPCLatticeClientTypes.AuthPolicyState?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        policy: Swift.String? = nil,
        state: VPCLatticeClientTypes.AuthPolicyState? = nil
    )
    {
        self.createdAt = createdAt
        self.lastUpdatedAt = lastUpdatedAt
        self.policy = policy
        self.state = state
    }
}

enum GetAuthPolicyOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetListenerInput {

    static func urlPathProvider(_ value: GetListenerInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = value.listenerIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())"
    }
}

public struct GetListenerInput {
    /// The ID or Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        listenerIdentifier: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.listenerIdentifier = listenerIdentifier
        self.serviceIdentifier = serviceIdentifier
    }
}

extension GetListenerOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetListenerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetListenerOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.defaultAction = try reader["defaultAction"].readIfPresent(with: VPCLatticeClientTypes.RuleAction.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: .dateTime)
        value.name = try reader["name"].readIfPresent()
        value.port = try reader["port"].readIfPresent()
        value.`protocol` = try reader["protocol"].readIfPresent()
        value.serviceArn = try reader["serviceArn"].readIfPresent()
        value.serviceId = try reader["serviceId"].readIfPresent()
        return value
    }
}

public struct GetListenerOutput {
    /// The Amazon Resource Name (ARN) of the listener.
    public var arn: Swift.String?
    /// The date and time that the listener was created, specified in ISO-8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The actions for the default listener rule.
    public var defaultAction: VPCLatticeClientTypes.RuleAction?
    /// The ID of the listener.
    public var id: Swift.String?
    /// The date and time that the listener was last updated, specified in ISO-8601 format.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the listener.
    public var name: Swift.String?
    /// The listener port.
    public var port: Swift.Int?
    /// The listener protocol.
    public var `protocol`: VPCLatticeClientTypes.ListenerProtocol?
    /// The Amazon Resource Name (ARN) of the service.
    public var serviceArn: Swift.String?
    /// The ID of the service.
    public var serviceId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        defaultAction: VPCLatticeClientTypes.RuleAction? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        port: Swift.Int? = nil,
        `protocol`: VPCLatticeClientTypes.ListenerProtocol? = nil,
        serviceArn: Swift.String? = nil,
        serviceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.defaultAction = defaultAction
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.port = port
        self.`protocol` = `protocol`
        self.serviceArn = serviceArn
        self.serviceId = serviceId
    }
}

enum GetListenerOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetResourcePolicyInput {

    static func urlPathProvider(_ value: GetResourcePolicyInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/resourcepolicy/\(resourceArn.urlPercentEncoding())"
    }
}

public struct GetResourcePolicyInput {
    /// An IAM policy.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

extension GetResourcePolicyOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetResourcePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourcePolicyOutput()
        value.policy = try reader["policy"].readIfPresent()
        return value
    }
}

public struct GetResourcePolicyOutput {
    /// The Amazon Resource Name (ARN) of the service network or service.
    public var policy: Swift.String?

    public init(
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

enum GetResourcePolicyOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetRuleInput {

    static func urlPathProvider(_ value: GetRuleInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = value.listenerIdentifier else {
            return nil
        }
        guard let ruleIdentifier = value.ruleIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())/rules/\(ruleIdentifier.urlPercentEncoding())"
    }
}

public struct GetRuleInput {
    /// The ID or Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the listener rule.
    /// This member is required.
    public var ruleIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        listenerIdentifier: Swift.String? = nil,
        ruleIdentifier: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.listenerIdentifier = listenerIdentifier
        self.ruleIdentifier = ruleIdentifier
        self.serviceIdentifier = serviceIdentifier
    }
}

extension GetRuleOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRuleOutput()
        value.action = try reader["action"].readIfPresent(with: VPCLatticeClientTypes.RuleAction.read(from:))
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.id = try reader["id"].readIfPresent()
        value.isDefault = try reader["isDefault"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: .dateTime)
        value.match = try reader["match"].readIfPresent(with: VPCLatticeClientTypes.RuleMatch.read(from:))
        value.name = try reader["name"].readIfPresent()
        value.priority = try reader["priority"].readIfPresent()
        return value
    }
}

public struct GetRuleOutput {
    /// The action for the default rule.
    public var action: VPCLatticeClientTypes.RuleAction?
    /// The Amazon Resource Name (ARN) of the listener.
    public var arn: Swift.String?
    /// The date and time that the listener rule was created, specified in ISO-8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The ID of the listener.
    public var id: Swift.String?
    /// Indicates whether this is the default rule.
    public var isDefault: Swift.Bool?
    /// The date and time that the listener rule was last updated, specified in ISO-8601 format.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The rule match.
    public var match: VPCLatticeClientTypes.RuleMatch?
    /// The name of the listener.
    public var name: Swift.String?
    /// The priority level for the specified rule.
    public var priority: Swift.Int?

    public init(
        action: VPCLatticeClientTypes.RuleAction? = nil,
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        isDefault: Swift.Bool? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        match: VPCLatticeClientTypes.RuleMatch? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil
    )
    {
        self.action = action
        self.arn = arn
        self.createdAt = createdAt
        self.id = id
        self.isDefault = isDefault
        self.lastUpdatedAt = lastUpdatedAt
        self.match = match
        self.name = name
        self.priority = priority
    }
}

enum GetRuleOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetServiceInput {

    static func urlPathProvider(_ value: GetServiceInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())"
    }
}

public struct GetServiceInput {
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.serviceIdentifier = serviceIdentifier
    }
}

extension GetServiceNetworkInput {

    static func urlPathProvider(_ value: GetServiceNetworkInput) -> Swift.String? {
        guard let serviceNetworkIdentifier = value.serviceNetworkIdentifier else {
            return nil
        }
        return "/servicenetworks/\(serviceNetworkIdentifier.urlPercentEncoding())"
    }
}

public struct GetServiceNetworkInput {
    /// The ID or Amazon Resource Name (ARN) of the service network.
    /// This member is required.
    public var serviceNetworkIdentifier: Swift.String?

    public init(
        serviceNetworkIdentifier: Swift.String? = nil
    )
    {
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
    }
}

extension GetServiceNetworkOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetServiceNetworkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetServiceNetworkOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.authType = try reader["authType"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.id = try reader["id"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: .dateTime)
        value.name = try reader["name"].readIfPresent()
        value.numberOfAssociatedServices = try reader["numberOfAssociatedServices"].readIfPresent()
        value.numberOfAssociatedVPCs = try reader["numberOfAssociatedVPCs"].readIfPresent()
        return value
    }
}

public struct GetServiceNetworkOutput {
    /// The Amazon Resource Name (ARN) of the service network.
    public var arn: Swift.String?
    /// The type of IAM policy.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The date and time that the service network was created, specified in ISO-8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The ID of the service network.
    public var id: Swift.String?
    /// The date and time of the last update, specified in ISO-8601 format.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the service network.
    public var name: Swift.String?
    /// The number of services associated with the service network.
    public var numberOfAssociatedServices: Swift.Int?
    /// The number of VPCs associated with the service network.
    public var numberOfAssociatedVPCs: Swift.Int?

    public init(
        arn: Swift.String? = nil,
        authType: VPCLatticeClientTypes.AuthType? = nil,
        createdAt: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        numberOfAssociatedServices: Swift.Int? = nil,
        numberOfAssociatedVPCs: Swift.Int? = nil
    )
    {
        self.arn = arn
        self.authType = authType
        self.createdAt = createdAt
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.numberOfAssociatedServices = numberOfAssociatedServices
        self.numberOfAssociatedVPCs = numberOfAssociatedVPCs
    }
}

enum GetServiceNetworkOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetServiceNetworkServiceAssociationInput {

    static func urlPathProvider(_ value: GetServiceNetworkServiceAssociationInput) -> Swift.String? {
        guard let serviceNetworkServiceAssociationIdentifier = value.serviceNetworkServiceAssociationIdentifier else {
            return nil
        }
        return "/servicenetworkserviceassociations/\(serviceNetworkServiceAssociationIdentifier.urlPercentEncoding())"
    }
}

public struct GetServiceNetworkServiceAssociationInput {
    /// The ID or Amazon Resource Name (ARN) of the association.
    /// This member is required.
    public var serviceNetworkServiceAssociationIdentifier: Swift.String?

    public init(
        serviceNetworkServiceAssociationIdentifier: Swift.String? = nil
    )
    {
        self.serviceNetworkServiceAssociationIdentifier = serviceNetworkServiceAssociationIdentifier
    }
}

extension GetServiceNetworkServiceAssociationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetServiceNetworkServiceAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetServiceNetworkServiceAssociationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.customDomainName = try reader["customDomainName"].readIfPresent()
        value.dnsEntry = try reader["dnsEntry"].readIfPresent(with: VPCLatticeClientTypes.DnsEntry.read(from:))
        value.failureCode = try reader["failureCode"].readIfPresent()
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.serviceArn = try reader["serviceArn"].readIfPresent()
        value.serviceId = try reader["serviceId"].readIfPresent()
        value.serviceName = try reader["serviceName"].readIfPresent()
        value.serviceNetworkArn = try reader["serviceNetworkArn"].readIfPresent()
        value.serviceNetworkId = try reader["serviceNetworkId"].readIfPresent()
        value.serviceNetworkName = try reader["serviceNetworkName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

public struct GetServiceNetworkServiceAssociationOutput {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The date and time that the association was created, specified in ISO-8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The account that created the association.
    public var createdBy: Swift.String?
    /// The custom domain name of the service.
    public var customDomainName: Swift.String?
    /// The DNS name of the service.
    public var dnsEntry: VPCLatticeClientTypes.DnsEntry?
    /// The failure code.
    public var failureCode: Swift.String?
    /// The failure message.
    public var failureMessage: Swift.String?
    /// The ID of the service network and service association.
    public var id: Swift.String?
    /// The Amazon Resource Name (ARN) of the service.
    public var serviceArn: Swift.String?
    /// The ID of the service.
    public var serviceId: Swift.String?
    /// The name of the service.
    public var serviceName: Swift.String?
    /// The Amazon Resource Name (ARN) of the service network.
    public var serviceNetworkArn: Swift.String?
    /// The ID of the service network.
    public var serviceNetworkId: Swift.String?
    /// The name of the service network.
    public var serviceNetworkName: Swift.String?
    /// The status of the association.
    public var status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus?

    public init(
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        customDomainName: Swift.String? = nil,
        dnsEntry: VPCLatticeClientTypes.DnsEntry? = nil,
        failureCode: Swift.String? = nil,
        failureMessage: Swift.String? = nil,
        id: Swift.String? = nil,
        serviceArn: Swift.String? = nil,
        serviceId: Swift.String? = nil,
        serviceName: Swift.String? = nil,
        serviceNetworkArn: Swift.String? = nil,
        serviceNetworkId: Swift.String? = nil,
        serviceNetworkName: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.customDomainName = customDomainName
        self.dnsEntry = dnsEntry
        self.failureCode = failureCode
        self.failureMessage = failureMessage
        self.id = id
        self.serviceArn = serviceArn
        self.serviceId = serviceId
        self.serviceName = serviceName
        self.serviceNetworkArn = serviceNetworkArn
        self.serviceNetworkId = serviceNetworkId
        self.serviceNetworkName = serviceNetworkName
        self.status = status
    }
}

enum GetServiceNetworkServiceAssociationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetServiceNetworkVpcAssociationInput {

    static func urlPathProvider(_ value: GetServiceNetworkVpcAssociationInput) -> Swift.String? {
        guard let serviceNetworkVpcAssociationIdentifier = value.serviceNetworkVpcAssociationIdentifier else {
            return nil
        }
        return "/servicenetworkvpcassociations/\(serviceNetworkVpcAssociationIdentifier.urlPercentEncoding())"
    }
}

public struct GetServiceNetworkVpcAssociationInput {
    /// The ID or Amazon Resource Name (ARN) of the association.
    /// This member is required.
    public var serviceNetworkVpcAssociationIdentifier: Swift.String?

    public init(
        serviceNetworkVpcAssociationIdentifier: Swift.String? = nil
    )
    {
        self.serviceNetworkVpcAssociationIdentifier = serviceNetworkVpcAssociationIdentifier
    }
}

extension GetServiceNetworkVpcAssociationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetServiceNetworkVpcAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetServiceNetworkVpcAssociationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.failureCode = try reader["failureCode"].readIfPresent()
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: .dateTime)
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.serviceNetworkArn = try reader["serviceNetworkArn"].readIfPresent()
        value.serviceNetworkId = try reader["serviceNetworkId"].readIfPresent()
        value.serviceNetworkName = try reader["serviceNetworkName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.vpcId = try reader["vpcId"].readIfPresent()
        return value
    }
}

public struct GetServiceNetworkVpcAssociationOutput {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The date and time that the association was created, specified in ISO-8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The account that created the association.
    public var createdBy: Swift.String?
    /// The failure code.
    public var failureCode: Swift.String?
    /// The failure message.
    public var failureMessage: Swift.String?
    /// The ID of the specified association between the service network and the VPC.
    public var id: Swift.String?
    /// The date and time that the association was last updated, specified in ISO-8601 format.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The IDs of the security groups.
    public var securityGroupIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the service network.
    public var serviceNetworkArn: Swift.String?
    /// The ID of the service network.
    public var serviceNetworkId: Swift.String?
    /// The name of the service network.
    public var serviceNetworkName: Swift.String?
    /// The status of the association.
    public var status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus?
    /// The ID of the VPC.
    public var vpcId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        failureCode: Swift.String? = nil,
        failureMessage: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        securityGroupIds: [Swift.String]? = nil,
        serviceNetworkArn: Swift.String? = nil,
        serviceNetworkId: Swift.String? = nil,
        serviceNetworkName: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.failureCode = failureCode
        self.failureMessage = failureMessage
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.securityGroupIds = securityGroupIds
        self.serviceNetworkArn = serviceNetworkArn
        self.serviceNetworkId = serviceNetworkId
        self.serviceNetworkName = serviceNetworkName
        self.status = status
        self.vpcId = vpcId
    }
}

enum GetServiceNetworkVpcAssociationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetServiceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetServiceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetServiceOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.authType = try reader["authType"].readIfPresent()
        value.certificateArn = try reader["certificateArn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.customDomainName = try reader["customDomainName"].readIfPresent()
        value.dnsEntry = try reader["dnsEntry"].readIfPresent(with: VPCLatticeClientTypes.DnsEntry.read(from:))
        value.failureCode = try reader["failureCode"].readIfPresent()
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: .dateTime)
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

public struct GetServiceOutput {
    /// The Amazon Resource Name (ARN) of the service.
    public var arn: Swift.String?
    /// The type of IAM policy.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The Amazon Resource Name (ARN) of the certificate.
    public var certificateArn: Swift.String?
    /// The date and time that the service was created, specified in ISO-8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The custom domain name of the service.
    public var customDomainName: Swift.String?
    /// The DNS name of the service.
    public var dnsEntry: VPCLatticeClientTypes.DnsEntry?
    /// The failure code.
    public var failureCode: Swift.String?
    /// The failure message.
    public var failureMessage: Swift.String?
    /// The ID of the service.
    public var id: Swift.String?
    /// The date and time that the service was last updated, specified in ISO-8601 format.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the service.
    public var name: Swift.String?
    /// The status of the service.
    public var status: VPCLatticeClientTypes.ServiceStatus?

    public init(
        arn: Swift.String? = nil,
        authType: VPCLatticeClientTypes.AuthType? = nil,
        certificateArn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        customDomainName: Swift.String? = nil,
        dnsEntry: VPCLatticeClientTypes.DnsEntry? = nil,
        failureCode: Swift.String? = nil,
        failureMessage: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceStatus? = nil
    )
    {
        self.arn = arn
        self.authType = authType
        self.certificateArn = certificateArn
        self.createdAt = createdAt
        self.customDomainName = customDomainName
        self.dnsEntry = dnsEntry
        self.failureCode = failureCode
        self.failureMessage = failureMessage
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.status = status
    }
}

enum GetServiceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetTargetGroupInput {

    static func urlPathProvider(_ value: GetTargetGroupInput) -> Swift.String? {
        guard let targetGroupIdentifier = value.targetGroupIdentifier else {
            return nil
        }
        return "/targetgroups/\(targetGroupIdentifier.urlPercentEncoding())"
    }
}

public struct GetTargetGroupInput {
    /// The ID or Amazon Resource Name (ARN) of the target group.
    /// This member is required.
    public var targetGroupIdentifier: Swift.String?

    public init(
        targetGroupIdentifier: Swift.String? = nil
    )
    {
        self.targetGroupIdentifier = targetGroupIdentifier
    }
}

extension GetTargetGroupOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetTargetGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTargetGroupOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.config = try reader["config"].readIfPresent(with: VPCLatticeClientTypes.TargetGroupConfig.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.failureCode = try reader["failureCode"].readIfPresent()
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: .dateTime)
        value.name = try reader["name"].readIfPresent()
        value.serviceArns = try reader["serviceArns"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

public struct GetTargetGroupOutput {
    /// The Amazon Resource Name (ARN) of the target group.
    public var arn: Swift.String?
    /// The target group configuration.
    public var config: VPCLatticeClientTypes.TargetGroupConfig?
    /// The date and time that the target group was created, specified in ISO-8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The failure code.
    public var failureCode: Swift.String?
    /// The failure message.
    public var failureMessage: Swift.String?
    /// The ID of the target group.
    public var id: Swift.String?
    /// The date and time that the target group was last updated, specified in ISO-8601 format.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the target group.
    public var name: Swift.String?
    /// The Amazon Resource Names (ARNs) of the service.
    public var serviceArns: [Swift.String]?
    /// The status.
    public var status: VPCLatticeClientTypes.TargetGroupStatus?
    /// The target group type.
    public var type: VPCLatticeClientTypes.TargetGroupType?

    public init(
        arn: Swift.String? = nil,
        config: VPCLatticeClientTypes.TargetGroupConfig? = nil,
        createdAt: ClientRuntime.Date? = nil,
        failureCode: Swift.String? = nil,
        failureMessage: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        serviceArns: [Swift.String]? = nil,
        status: VPCLatticeClientTypes.TargetGroupStatus? = nil,
        type: VPCLatticeClientTypes.TargetGroupType? = nil
    )
    {
        self.arn = arn
        self.config = config
        self.createdAt = createdAt
        self.failureCode = failureCode
        self.failureMessage = failureMessage
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.serviceArns = serviceArns
        self.status = status
        self.type = type
    }
}

enum GetTargetGroupOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension VPCLatticeClientTypes.HeaderMatch {

    static func write(value: VPCLatticeClientTypes.HeaderMatch?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["caseSensitive"].write(value.caseSensitive)
        try writer["match"].write(value.match, with: VPCLatticeClientTypes.HeaderMatchType.write(value:to:))
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.HeaderMatch {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.HeaderMatch()
        value.name = try reader["name"].readIfPresent()
        value.match = try reader["match"].readIfPresent(with: VPCLatticeClientTypes.HeaderMatchType.read(from:))
        value.caseSensitive = try reader["caseSensitive"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes {
    /// Describes the constraints for a header match. Matches incoming requests with rule based on request header value before applying rule action.
    public struct HeaderMatch {
        /// Indicates whether the match is case sensitive. Defaults to false.
        public var caseSensitive: Swift.Bool?
        /// The header match type.
        /// This member is required.
        public var match: VPCLatticeClientTypes.HeaderMatchType?
        /// The name of the header.
        /// This member is required.
        public var name: Swift.String?

        public init(
            caseSensitive: Swift.Bool? = nil,
            match: VPCLatticeClientTypes.HeaderMatchType? = nil,
            name: Swift.String? = nil
        )
        {
            self.caseSensitive = caseSensitive
            self.match = match
            self.name = name
        }
    }

}

extension VPCLatticeClientTypes.HeaderMatchType {

    static func write(value: VPCLatticeClientTypes.HeaderMatchType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .contains(contains):
                try writer["contains"].write(contains)
            case let .exact(exact):
                try writer["exact"].write(exact)
            case let .`prefix`(`prefix`):
                try writer["prefix"].write(`prefix`)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.HeaderMatchType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "exact":
                return .exact(try reader["exact"].read())
            case "prefix":
                return .`prefix`(try reader["prefix"].read())
            case "contains":
                return .contains(try reader["contains"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension VPCLatticeClientTypes {
    /// Describes a header match type. Only one can be provided.
    public enum HeaderMatchType {
        /// Specifies an exact type match.
        case exact(Swift.String)
        /// Specifies a prefix type match. Matches the value with the prefix.
        case `prefix`(Swift.String)
        /// Specifies a contains type match.
        case contains(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension VPCLatticeClientTypes.HealthCheckConfig {

    static func write(value: VPCLatticeClientTypes.HealthCheckConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enabled"].write(value.enabled)
        try writer["healthCheckIntervalSeconds"].write(value.healthCheckIntervalSeconds)
        try writer["healthCheckTimeoutSeconds"].write(value.healthCheckTimeoutSeconds)
        try writer["healthyThresholdCount"].write(value.healthyThresholdCount)
        try writer["matcher"].write(value.matcher, with: VPCLatticeClientTypes.Matcher.write(value:to:))
        try writer["path"].write(value.path)
        try writer["port"].write(value.port)
        try writer["protocol"].write(value.`protocol`)
        try writer["protocolVersion"].write(value.protocolVersion)
        try writer["unhealthyThresholdCount"].write(value.unhealthyThresholdCount)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.HealthCheckConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.HealthCheckConfig()
        value.enabled = try reader["enabled"].readIfPresent()
        value.`protocol` = try reader["protocol"].readIfPresent()
        value.protocolVersion = try reader["protocolVersion"].readIfPresent()
        value.port = try reader["port"].readIfPresent()
        value.path = try reader["path"].readIfPresent()
        value.healthCheckIntervalSeconds = try reader["healthCheckIntervalSeconds"].readIfPresent()
        value.healthCheckTimeoutSeconds = try reader["healthCheckTimeoutSeconds"].readIfPresent()
        value.healthyThresholdCount = try reader["healthyThresholdCount"].readIfPresent()
        value.unhealthyThresholdCount = try reader["unhealthyThresholdCount"].readIfPresent()
        value.matcher = try reader["matcher"].readIfPresent(with: VPCLatticeClientTypes.Matcher.read(from:))
        return value
    }
}

extension VPCLatticeClientTypes {
    /// The health check configuration of a target group. Health check configurations aren't used for LAMBDA and ALB target groups.
    public struct HealthCheckConfig {
        /// Indicates whether health checking is enabled.
        public var enabled: Swift.Bool?
        /// The approximate amount of time, in seconds, between health checks of an individual target. The range is 5300 seconds. The default is 30 seconds.
        public var healthCheckIntervalSeconds: Swift.Int?
        /// The amount of time, in seconds, to wait before reporting a target as unhealthy. The range is 1120 seconds. The default is 5 seconds.
        public var healthCheckTimeoutSeconds: Swift.Int?
        /// The number of consecutive successful health checks required before considering an unhealthy target healthy. The range is 210. The default is 5.
        public var healthyThresholdCount: Swift.Int?
        /// The codes to use when checking for a successful response from a target. These are called Success codes in the console.
        public var matcher: VPCLatticeClientTypes.Matcher?
        /// The destination for health checks on the targets. If the protocol version is HTTP/1.1 or HTTP/2, specify a valid URI (for example, /path?query). The default path is /. Health checks are not supported if the protocol version is gRPC, however, you can choose HTTP/1.1 or HTTP/2 and specify a valid URI.
        public var path: Swift.String?
        /// The port used when performing health checks on targets. The default setting is the port that a target receives traffic on.
        public var port: Swift.Int?
        /// The protocol used when performing health checks on targets. The possible protocols are HTTP and HTTPS. The default is HTTP.
        public var `protocol`: VPCLatticeClientTypes.TargetGroupProtocol?
        /// The protocol version used when performing health checks on targets. The possible protocol versions are HTTP1 and HTTP2.
        public var protocolVersion: VPCLatticeClientTypes.HealthCheckProtocolVersion?
        /// The number of consecutive failed health checks required before considering a target unhealthy. The range is 210. The default is 2.
        public var unhealthyThresholdCount: Swift.Int?

        public init(
            enabled: Swift.Bool? = nil,
            healthCheckIntervalSeconds: Swift.Int? = nil,
            healthCheckTimeoutSeconds: Swift.Int? = nil,
            healthyThresholdCount: Swift.Int? = nil,
            matcher: VPCLatticeClientTypes.Matcher? = nil,
            path: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: VPCLatticeClientTypes.TargetGroupProtocol? = nil,
            protocolVersion: VPCLatticeClientTypes.HealthCheckProtocolVersion? = nil,
            unhealthyThresholdCount: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.healthCheckIntervalSeconds = healthCheckIntervalSeconds
            self.healthCheckTimeoutSeconds = healthCheckTimeoutSeconds
            self.healthyThresholdCount = healthyThresholdCount
            self.matcher = matcher
            self.path = path
            self.port = port
            self.`protocol` = `protocol`
            self.protocolVersion = protocolVersion
            self.unhealthyThresholdCount = unhealthyThresholdCount
        }
    }

}

extension VPCLatticeClientTypes {

    public enum HealthCheckProtocolVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Indicates use of HTTP/1.1 to send requests to target
        case http1
        /// Indicates use of HTTP/2 to send requests to target
        case http2
        case sdkUnknown(Swift.String)

        public static var allCases: [HealthCheckProtocolVersion] {
            return [
                .http1,
                .http2,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .http1: return "HTTP1"
            case .http2: return "HTTP2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VPCLatticeClientTypes.HttpMatch {

    static func write(value: VPCLatticeClientTypes.HttpMatch?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["headerMatches"].writeList(value.headerMatches, memberWritingClosure: VPCLatticeClientTypes.HeaderMatch.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["method"].write(value.method)
        try writer["pathMatch"].write(value.pathMatch, with: VPCLatticeClientTypes.PathMatch.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.HttpMatch {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.HttpMatch()
        value.method = try reader["method"].readIfPresent()
        value.pathMatch = try reader["pathMatch"].readIfPresent(with: VPCLatticeClientTypes.PathMatch.read(from:))
        value.headerMatches = try reader["headerMatches"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.HeaderMatch.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension VPCLatticeClientTypes {
    /// Describes criteria that can be applied to incoming requests.
    public struct HttpMatch {
        /// The header matches. Matches incoming requests with rule based on request header value before applying rule action.
        public var headerMatches: [VPCLatticeClientTypes.HeaderMatch]?
        /// The HTTP method type.
        public var method: Swift.String?
        /// The path match.
        public var pathMatch: VPCLatticeClientTypes.PathMatch?

        public init(
            headerMatches: [VPCLatticeClientTypes.HeaderMatch]? = nil,
            method: Swift.String? = nil,
            pathMatch: VPCLatticeClientTypes.PathMatch? = nil
        )
        {
            self.headerMatches = headerMatches
            self.method = method
            self.pathMatch = pathMatch
        }
    }

}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// An unexpected error occurred while processing the request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The number of seconds to wait before retrying.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

extension VPCLatticeClientTypes {

    public enum IpAddressType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Indicates IPv4 address type
        case ipv4
        /// Indicates IPv6 address type
        case ipv6
        case sdkUnknown(Swift.String)

        public static var allCases: [IpAddressType] {
            return [
                .ipv4,
                .ipv6,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ipv4: return "IPV4"
            case .ipv6: return "IPV6"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VPCLatticeClientTypes {

    public enum LambdaEventStructureVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// This is the default lambda event structure version
        case v1
        /// Indicates use of lambda event structure version 2
        case v2
        case sdkUnknown(Swift.String)

        public static var allCases: [LambdaEventStructureVersion] {
            return [
                .v1,
                .v2,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .v1: return "V1"
            case .v2: return "V2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ListAccessLogSubscriptionsInput {

    static func queryItemProvider(_ value: ListAccessLogSubscriptionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let resourceIdentifier = value.resourceIdentifier else {
            let message = "Creating a URL Query Item failed. resourceIdentifier is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        let resourceIdentifierQueryItem = ClientRuntime.SDKURLQueryItem(name: "resourceIdentifier".urlPercentEncoding(), value: Swift.String(resourceIdentifier).urlPercentEncoding())
        items.append(resourceIdentifierQueryItem)
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListAccessLogSubscriptionsInput {

    static func urlPathProvider(_ value: ListAccessLogSubscriptionsInput) -> Swift.String? {
        return "/accesslogsubscriptions"
    }
}

public struct ListAccessLogSubscriptionsInput {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service network or service.
    /// This member is required.
    public var resourceIdentifier: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceIdentifier = resourceIdentifier
    }
}

extension ListAccessLogSubscriptionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListAccessLogSubscriptionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAccessLogSubscriptionsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.AccessLogSubscriptionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListAccessLogSubscriptionsOutput {
    /// The access log subscriptions.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.AccessLogSubscriptionSummary]?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.AccessLogSubscriptionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

enum ListAccessLogSubscriptionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListListenersInput {

    static func queryItemProvider(_ value: ListListenersInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListListenersInput {

    static func urlPathProvider(_ value: ListListenersInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners"
    }
}

public struct ListListenersInput {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceIdentifier = serviceIdentifier
    }
}

extension ListListenersOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListListenersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListListenersOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.ListenerSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListListenersOutput {
    /// Information about the listeners.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.ListenerSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.ListenerSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

enum ListListenersOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListRulesInput {

    static func queryItemProvider(_ value: ListRulesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListRulesInput {

    static func urlPathProvider(_ value: ListRulesInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = value.listenerIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())/rules"
    }
}

public struct ListRulesInput {
    /// The ID or Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        listenerIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.listenerIdentifier = listenerIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceIdentifier = serviceIdentifier
    }
}

extension ListRulesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListRulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRulesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.RuleSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListRulesOutput {
    /// Information about the rules.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.RuleSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.RuleSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

enum ListRulesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListServiceNetworkServiceAssociationsInput {

    static func queryItemProvider(_ value: ListServiceNetworkServiceAssociationsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let serviceNetworkIdentifier = value.serviceNetworkIdentifier {
            let serviceNetworkIdentifierQueryItem = ClientRuntime.SDKURLQueryItem(name: "serviceNetworkIdentifier".urlPercentEncoding(), value: Swift.String(serviceNetworkIdentifier).urlPercentEncoding())
            items.append(serviceNetworkIdentifierQueryItem)
        }
        if let serviceIdentifier = value.serviceIdentifier {
            let serviceIdentifierQueryItem = ClientRuntime.SDKURLQueryItem(name: "serviceIdentifier".urlPercentEncoding(), value: Swift.String(serviceIdentifier).urlPercentEncoding())
            items.append(serviceIdentifierQueryItem)
        }
        return items
    }
}

extension ListServiceNetworkServiceAssociationsInput {

    static func urlPathProvider(_ value: ListServiceNetworkServiceAssociationsInput) -> Swift.String? {
        return "/servicenetworkserviceassociations"
    }
}

public struct ListServiceNetworkServiceAssociationsInput {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    public var serviceIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service network.
    public var serviceNetworkIdentifier: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil,
        serviceNetworkIdentifier: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceIdentifier = serviceIdentifier
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
    }
}

extension ListServiceNetworkServiceAssociationsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListServiceNetworkServiceAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListServiceNetworkServiceAssociationsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.ServiceNetworkServiceAssociationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListServiceNetworkServiceAssociationsOutput {
    /// Information about the associations.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.ServiceNetworkServiceAssociationSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.ServiceNetworkServiceAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

enum ListServiceNetworkServiceAssociationsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListServiceNetworkVpcAssociationsInput {

    static func queryItemProvider(_ value: ListServiceNetworkVpcAssociationsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let serviceNetworkIdentifier = value.serviceNetworkIdentifier {
            let serviceNetworkIdentifierQueryItem = ClientRuntime.SDKURLQueryItem(name: "serviceNetworkIdentifier".urlPercentEncoding(), value: Swift.String(serviceNetworkIdentifier).urlPercentEncoding())
            items.append(serviceNetworkIdentifierQueryItem)
        }
        if let vpcIdentifier = value.vpcIdentifier {
            let vpcIdentifierQueryItem = ClientRuntime.SDKURLQueryItem(name: "vpcIdentifier".urlPercentEncoding(), value: Swift.String(vpcIdentifier).urlPercentEncoding())
            items.append(vpcIdentifierQueryItem)
        }
        return items
    }
}

extension ListServiceNetworkVpcAssociationsInput {

    static func urlPathProvider(_ value: ListServiceNetworkVpcAssociationsInput) -> Swift.String? {
        return "/servicenetworkvpcassociations"
    }
}

public struct ListServiceNetworkVpcAssociationsInput {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service network.
    public var serviceNetworkIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the VPC.
    public var vpcIdentifier: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceNetworkIdentifier: Swift.String? = nil,
        vpcIdentifier: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
        self.vpcIdentifier = vpcIdentifier
    }
}

extension ListServiceNetworkVpcAssociationsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListServiceNetworkVpcAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListServiceNetworkVpcAssociationsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.ServiceNetworkVpcAssociationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListServiceNetworkVpcAssociationsOutput {
    /// Information about the associations.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.ServiceNetworkVpcAssociationSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.ServiceNetworkVpcAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

enum ListServiceNetworkVpcAssociationsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListServiceNetworksInput {

    static func queryItemProvider(_ value: ListServiceNetworksInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListServiceNetworksInput {

    static func urlPathProvider(_ value: ListServiceNetworksInput) -> Swift.String? {
        return "/servicenetworks"
    }
}

public struct ListServiceNetworksInput {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListServiceNetworksOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListServiceNetworksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListServiceNetworksOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.ServiceNetworkSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListServiceNetworksOutput {
    /// Information about the service networks.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.ServiceNetworkSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.ServiceNetworkSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

enum ListServiceNetworksOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListServicesInput {

    static func queryItemProvider(_ value: ListServicesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListServicesInput {

    static func urlPathProvider(_ value: ListServicesInput) -> Swift.String? {
        return "/services"
    }
}

public struct ListServicesInput {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListServicesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListServicesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListServicesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.ServiceSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListServicesOutput {
    /// The services.
    public var items: [VPCLatticeClientTypes.ServiceSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.ServiceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

enum ListServicesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct ListTagsForResourceOutput {
    /// The tags.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListTargetGroupsInput {

    static func queryItemProvider(_ value: ListTargetGroupsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let vpcIdentifier = value.vpcIdentifier {
            let vpcIdentifierQueryItem = ClientRuntime.SDKURLQueryItem(name: "vpcIdentifier".urlPercentEncoding(), value: Swift.String(vpcIdentifier).urlPercentEncoding())
            items.append(vpcIdentifierQueryItem)
        }
        if let targetGroupType = value.targetGroupType {
            let targetGroupTypeQueryItem = ClientRuntime.SDKURLQueryItem(name: "targetGroupType".urlPercentEncoding(), value: Swift.String(targetGroupType.rawValue).urlPercentEncoding())
            items.append(targetGroupTypeQueryItem)
        }
        return items
    }
}

extension ListTargetGroupsInput {

    static func urlPathProvider(_ value: ListTargetGroupsInput) -> Swift.String? {
        return "/targetgroups"
    }
}

public struct ListTargetGroupsInput {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The target group type.
    public var targetGroupType: VPCLatticeClientTypes.TargetGroupType?
    /// The ID or Amazon Resource Name (ARN) of the service.
    public var vpcIdentifier: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        targetGroupType: VPCLatticeClientTypes.TargetGroupType? = nil,
        vpcIdentifier: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.targetGroupType = targetGroupType
        self.vpcIdentifier = vpcIdentifier
    }
}

extension ListTargetGroupsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListTargetGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTargetGroupsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.TargetGroupSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListTargetGroupsOutput {
    /// Information about the target groups.
    public var items: [VPCLatticeClientTypes.TargetGroupSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.TargetGroupSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

enum ListTargetGroupsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListTargetsInput {

    static func queryItemProvider(_ value: ListTargetsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListTargetsInput {

    static func urlPathProvider(_ value: ListTargetsInput) -> Swift.String? {
        guard let targetGroupIdentifier = value.targetGroupIdentifier else {
            return nil
        }
        return "/targetgroups/\(targetGroupIdentifier.urlPercentEncoding())/listtargets"
    }
}

extension ListTargetsInput {

    static func write(value: ListTargetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["targets"].writeList(value.targets, memberWritingClosure: VPCLatticeClientTypes.Target.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct ListTargetsInput {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the target group.
    /// This member is required.
    public var targetGroupIdentifier: Swift.String?
    /// The targets to list.
    public var targets: [VPCLatticeClientTypes.Target]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        targetGroupIdentifier: Swift.String? = nil,
        targets: [VPCLatticeClientTypes.Target]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.targetGroupIdentifier = targetGroupIdentifier
        self.targets = targets
    }
}

extension ListTargetsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListTargetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTargetsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.TargetSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListTargetsOutput {
    /// Information about the targets.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.TargetSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.TargetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

enum ListTargetsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension VPCLatticeClientTypes {

    public enum ListenerProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Indicates HTTP protocol
        case http
        /// Indicates HTTPS protocol
        case https
        case sdkUnknown(Swift.String)

        public static var allCases: [ListenerProtocol] {
            return [
                .http,
                .https,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case .https: return "HTTPS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VPCLatticeClientTypes.ListenerSummary {

    static func write(value: VPCLatticeClientTypes.ListenerSummary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["createdAt"].writeTimestamp(value.createdAt, format: .dateTime)
        try writer["id"].write(value.id)
        try writer["lastUpdatedAt"].writeTimestamp(value.lastUpdatedAt, format: .dateTime)
        try writer["name"].write(value.name)
        try writer["port"].write(value.port)
        try writer["protocol"].write(value.`protocol`)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.ListenerSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.ListenerSummary()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.`protocol` = try reader["protocol"].readIfPresent()
        value.port = try reader["port"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension VPCLatticeClientTypes {
    /// Summary information about a listener.
    public struct ListenerSummary {
        /// The Amazon Resource Name (ARN) of the listener.
        public var arn: Swift.String?
        /// The date and time that the listener was created, specified in ISO-8601 format.
        public var createdAt: ClientRuntime.Date?
        /// The ID of the listener.
        public var id: Swift.String?
        /// The date and time that the listener was last updated, specified in ISO-8601 format.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the listener.
        public var name: Swift.String?
        /// The listener port.
        public var port: Swift.Int?
        /// The listener protocol.
        public var `protocol`: VPCLatticeClientTypes.ListenerProtocol?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: VPCLatticeClientTypes.ListenerProtocol? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.port = port
            self.`protocol` = `protocol`
        }
    }

}

extension VPCLatticeClientTypes.Matcher {

    static func write(value: VPCLatticeClientTypes.Matcher?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .httpcode(httpcode):
                try writer["httpCode"].write(httpcode)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.Matcher {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "httpCode":
                return .httpcode(try reader["httpCode"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension VPCLatticeClientTypes {
    /// The codes to use when checking for a successful response from a target for health checks.
    public enum Matcher {
        /// The HTTP code to use when checking for a successful response from a target.
        case httpcode(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension VPCLatticeClientTypes.PathMatch {

    static func write(value: VPCLatticeClientTypes.PathMatch?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["caseSensitive"].write(value.caseSensitive)
        try writer["match"].write(value.match, with: VPCLatticeClientTypes.PathMatchType.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.PathMatch {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.PathMatch()
        value.match = try reader["match"].readIfPresent(with: VPCLatticeClientTypes.PathMatchType.read(from:))
        value.caseSensitive = try reader["caseSensitive"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes {
    /// Describes the conditions that can be applied when matching a path for incoming requests.
    public struct PathMatch {
        /// Indicates whether the match is case sensitive. Defaults to false.
        public var caseSensitive: Swift.Bool?
        /// The type of path match.
        /// This member is required.
        public var match: VPCLatticeClientTypes.PathMatchType?

        public init(
            caseSensitive: Swift.Bool? = nil,
            match: VPCLatticeClientTypes.PathMatchType? = nil
        )
        {
            self.caseSensitive = caseSensitive
            self.match = match
        }
    }

}

extension VPCLatticeClientTypes.PathMatchType {

    static func write(value: VPCLatticeClientTypes.PathMatchType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .exact(exact):
                try writer["exact"].write(exact)
            case let .`prefix`(`prefix`):
                try writer["prefix"].write(`prefix`)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.PathMatchType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "exact":
                return .exact(try reader["exact"].read())
            case "prefix":
                return .`prefix`(try reader["prefix"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension VPCLatticeClientTypes {
    /// Describes a path match type. Each rule can include only one of the following types of paths.
    public enum PathMatchType {
        /// An exact match of the path.
        case exact(Swift.String)
        /// A prefix match of the path.
        case `prefix`(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension PutAuthPolicyInput {

    static func urlPathProvider(_ value: PutAuthPolicyInput) -> Swift.String? {
        guard let resourceIdentifier = value.resourceIdentifier else {
            return nil
        }
        return "/authpolicy/\(resourceIdentifier.urlPercentEncoding())"
    }
}

extension PutAuthPolicyInput {

    static func write(value: PutAuthPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["policy"].write(value.policy)
    }
}

public struct PutAuthPolicyInput {
    /// The auth policy.
    /// This member is required.
    public var policy: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service network or service for which the policy is created.
    /// This member is required.
    public var resourceIdentifier: Swift.String?

    public init(
        policy: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.policy = policy
        self.resourceIdentifier = resourceIdentifier
    }
}

extension PutAuthPolicyOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> PutAuthPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutAuthPolicyOutput()
        value.policy = try reader["policy"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        return value
    }
}

public struct PutAuthPolicyOutput {
    /// The auth policy.
    public var policy: Swift.String?
    /// The state of the auth policy. The auth policy is only active when the auth type is set to Amazon Web Services_IAM. If you provide a policy, then authentication and authorization decisions are made based on this policy and the client's IAM policy. If the Auth type is NONE, then, any auth policy you provide will remain inactive. For more information, see [Create a service network](https://docs.aws.amazon.com/vpc-lattice/latest/ug/service-networks.html#create-service-network) in the Amazon VPC Lattice User Guide.
    public var state: VPCLatticeClientTypes.AuthPolicyState?

    public init(
        policy: Swift.String? = nil,
        state: VPCLatticeClientTypes.AuthPolicyState? = nil
    )
    {
        self.policy = policy
        self.state = state
    }
}

enum PutAuthPolicyOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension PutResourcePolicyInput {

    static func urlPathProvider(_ value: PutResourcePolicyInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/resourcepolicy/\(resourceArn.urlPercentEncoding())"
    }
}

extension PutResourcePolicyInput {

    static func write(value: PutResourcePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["policy"].write(value.policy)
    }
}

public struct PutResourcePolicyInput {
    /// An IAM policy.
    /// This member is required.
    public var policy: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service network or service for which the policy is created.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        policy: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.policy = policy
        self.resourceArn = resourceArn
    }
}

extension PutResourcePolicyOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> PutResourcePolicyOutput {
        return PutResourcePolicyOutput()
    }
}

public struct PutResourcePolicyOutput {

    public init() { }
}

enum PutResourcePolicyOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension RegisterTargetsInput {

    static func urlPathProvider(_ value: RegisterTargetsInput) -> Swift.String? {
        guard let targetGroupIdentifier = value.targetGroupIdentifier else {
            return nil
        }
        return "/targetgroups/\(targetGroupIdentifier.urlPercentEncoding())/registertargets"
    }
}

extension RegisterTargetsInput {

    static func write(value: RegisterTargetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["targets"].writeList(value.targets, memberWritingClosure: VPCLatticeClientTypes.Target.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct RegisterTargetsInput {
    /// The ID or Amazon Resource Name (ARN) of the target group.
    /// This member is required.
    public var targetGroupIdentifier: Swift.String?
    /// The targets.
    /// This member is required.
    public var targets: [VPCLatticeClientTypes.Target]?

    public init(
        targetGroupIdentifier: Swift.String? = nil,
        targets: [VPCLatticeClientTypes.Target]? = nil
    )
    {
        self.targetGroupIdentifier = targetGroupIdentifier
        self.targets = targets
    }
}

extension RegisterTargetsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> RegisterTargetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterTargetsOutput()
        value.successful = try reader["successful"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.Target.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.unsuccessful = try reader["unsuccessful"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.TargetFailure.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct RegisterTargetsOutput {
    /// The targets that were successfully registered.
    public var successful: [VPCLatticeClientTypes.Target]?
    /// The targets that were not registered.
    public var unsuccessful: [VPCLatticeClientTypes.TargetFailure]?

    public init(
        successful: [VPCLatticeClientTypes.Target]? = nil,
        unsuccessful: [VPCLatticeClientTypes.TargetFailure]? = nil
    )
    {
        self.successful = successful
        self.unsuccessful = unsuccessful
    }
}

enum RegisterTargetsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The request references a resource that does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The resource ID.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

extension VPCLatticeClientTypes.RuleAction {

    static func write(value: VPCLatticeClientTypes.RuleAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .fixedresponse(fixedresponse):
                try writer["fixedResponse"].write(fixedresponse, with: VPCLatticeClientTypes.FixedResponseAction.write(value:to:))
            case let .forward(forward):
                try writer["forward"].write(forward, with: VPCLatticeClientTypes.ForwardAction.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.RuleAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "forward":
                return .forward(try reader["forward"].read(with: VPCLatticeClientTypes.ForwardAction.read(from:)))
            case "fixedResponse":
                return .fixedresponse(try reader["fixedResponse"].read(with: VPCLatticeClientTypes.FixedResponseAction.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension VPCLatticeClientTypes {
    /// Describes the action for a rule. Each rule must include exactly one of the following types of actions: forward or fixed-response, and it must be the last action to be performed.
    public enum RuleAction {
        /// The forward action. Traffic that matches the rule is forwarded to the specified target groups.
        case forward(VPCLatticeClientTypes.ForwardAction)
        /// Describes the rule action that returns a custom HTTP response.
        case fixedresponse(VPCLatticeClientTypes.FixedResponseAction)
        case sdkUnknown(Swift.String)
    }

}

extension VPCLatticeClientTypes.RuleMatch {

    static func write(value: VPCLatticeClientTypes.RuleMatch?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .httpmatch(httpmatch):
                try writer["httpMatch"].write(httpmatch, with: VPCLatticeClientTypes.HttpMatch.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.RuleMatch {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "httpMatch":
                return .httpmatch(try reader["httpMatch"].read(with: VPCLatticeClientTypes.HttpMatch.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension VPCLatticeClientTypes {
    /// Describes a rule match.
    public enum RuleMatch {
        /// The HTTP criteria that a rule must match.
        case httpmatch(VPCLatticeClientTypes.HttpMatch)
        case sdkUnknown(Swift.String)
    }

}

extension VPCLatticeClientTypes.RuleSummary {

    static func write(value: VPCLatticeClientTypes.RuleSummary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["createdAt"].writeTimestamp(value.createdAt, format: .dateTime)
        try writer["id"].write(value.id)
        try writer["isDefault"].write(value.isDefault)
        try writer["lastUpdatedAt"].writeTimestamp(value.lastUpdatedAt, format: .dateTime)
        try writer["name"].write(value.name)
        try writer["priority"].write(value.priority)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.RuleSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.RuleSummary()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.isDefault = try reader["isDefault"].readIfPresent()
        value.priority = try reader["priority"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension VPCLatticeClientTypes {
    /// Summary information about the listener rule.
    public struct RuleSummary {
        /// The Amazon Resource Name (ARN) of the rule.
        public var arn: Swift.String?
        /// The date and time that the listener rule was created, specified in ISO-8601 format.
        public var createdAt: ClientRuntime.Date?
        /// The ID of the rule.
        public var id: Swift.String?
        /// Indicates whether this is the default rule. Listener rules are created when you create a listener. Each listener has a default rule for checking connection requests.
        public var isDefault: Swift.Bool?
        /// The date and time that the listener rule was last updated, specified in ISO-8601 format.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the rule.
        public var name: Swift.String?
        /// The priority of the rule.
        public var priority: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            isDefault: Swift.Bool? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            priority: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.isDefault = isDefault
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.priority = priority
        }
    }

}

extension VPCLatticeClientTypes.RuleUpdate {

    static func write(value: VPCLatticeClientTypes.RuleUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action, with: VPCLatticeClientTypes.RuleAction.write(value:to:))
        try writer["match"].write(value.match, with: VPCLatticeClientTypes.RuleMatch.write(value:to:))
        try writer["priority"].write(value.priority)
        try writer["ruleIdentifier"].write(value.ruleIdentifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.RuleUpdate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.RuleUpdate()
        value.ruleIdentifier = try reader["ruleIdentifier"].readIfPresent()
        value.match = try reader["match"].readIfPresent(with: VPCLatticeClientTypes.RuleMatch.read(from:))
        value.priority = try reader["priority"].readIfPresent()
        value.action = try reader["action"].readIfPresent(with: VPCLatticeClientTypes.RuleAction.read(from:))
        return value
    }
}

extension VPCLatticeClientTypes {
    /// Represents an object when updating a rule.
    public struct RuleUpdate {
        /// The rule action.
        public var action: VPCLatticeClientTypes.RuleAction?
        /// The rule match.
        public var match: VPCLatticeClientTypes.RuleMatch?
        /// The rule priority. A listener can't have multiple rules with the same priority.
        public var priority: Swift.Int?
        /// The ID or Amazon Resource Name (ARN) of the rule.
        /// This member is required.
        public var ruleIdentifier: Swift.String?

        public init(
            action: VPCLatticeClientTypes.RuleAction? = nil,
            match: VPCLatticeClientTypes.RuleMatch? = nil,
            priority: Swift.Int? = nil,
            ruleIdentifier: Swift.String? = nil
        )
        {
            self.action = action
            self.match = match
            self.priority = priority
            self.ruleIdentifier = ruleIdentifier
        }
    }

}

extension VPCLatticeClientTypes.RuleUpdateFailure {

    static func write(value: VPCLatticeClientTypes.RuleUpdateFailure?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["failureCode"].write(value.failureCode)
        try writer["failureMessage"].write(value.failureMessage)
        try writer["ruleIdentifier"].write(value.ruleIdentifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.RuleUpdateFailure {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.RuleUpdateFailure()
        value.ruleIdentifier = try reader["ruleIdentifier"].readIfPresent()
        value.failureCode = try reader["failureCode"].readIfPresent()
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes {
    /// Describes a rule update that failed.
    public struct RuleUpdateFailure {
        /// The failure code.
        public var failureCode: Swift.String?
        /// The failure message.
        public var failureMessage: Swift.String?
        /// The ID or Amazon Resource Name (ARN) of the rule.
        public var ruleIdentifier: Swift.String?

        public init(
            failureCode: Swift.String? = nil,
            failureMessage: Swift.String? = nil,
            ruleIdentifier: Swift.String? = nil
        )
        {
            self.failureCode = failureCode
            self.failureMessage = failureMessage
            self.ruleIdentifier = ruleIdentifier
        }
    }

}

extension VPCLatticeClientTypes.RuleUpdateSuccess {

    static func write(value: VPCLatticeClientTypes.RuleUpdateSuccess?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action, with: VPCLatticeClientTypes.RuleAction.write(value:to:))
        try writer["arn"].write(value.arn)
        try writer["id"].write(value.id)
        try writer["isDefault"].write(value.isDefault)
        try writer["match"].write(value.match, with: VPCLatticeClientTypes.RuleMatch.write(value:to:))
        try writer["name"].write(value.name)
        try writer["priority"].write(value.priority)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.RuleUpdateSuccess {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.RuleUpdateSuccess()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.isDefault = try reader["isDefault"].readIfPresent()
        value.match = try reader["match"].readIfPresent(with: VPCLatticeClientTypes.RuleMatch.read(from:))
        value.priority = try reader["priority"].readIfPresent()
        value.action = try reader["action"].readIfPresent(with: VPCLatticeClientTypes.RuleAction.read(from:))
        return value
    }
}

extension VPCLatticeClientTypes {
    /// Describes a successful rule update.
    public struct RuleUpdateSuccess {
        /// The action for the default rule.
        public var action: VPCLatticeClientTypes.RuleAction?
        /// The Amazon Resource Name (ARN) of the listener.
        public var arn: Swift.String?
        /// The ID of the listener.
        public var id: Swift.String?
        /// Indicates whether this is the default rule.
        public var isDefault: Swift.Bool?
        /// The rule match.
        public var match: VPCLatticeClientTypes.RuleMatch?
        /// The name of the listener.
        public var name: Swift.String?
        /// The rule priority.
        public var priority: Swift.Int?

        public init(
            action: VPCLatticeClientTypes.RuleAction? = nil,
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            isDefault: Swift.Bool? = nil,
            match: VPCLatticeClientTypes.RuleMatch? = nil,
            name: Swift.String? = nil,
            priority: Swift.Int? = nil
        )
        {
            self.action = action
            self.arn = arn
            self.id = id
            self.isDefault = isDefault
            self.match = match
            self.name = name
            self.priority = priority
        }
    }

}

extension VPCLatticeClientTypes {

    public enum ServiceNetworkServiceAssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// ServiceNetwork and Service association is active
        case active
        /// ServiceNetwork and Service association creation failed.
        case createFailed
        /// ServiceNetwork and Service association creation in progress
        case createInProgress
        /// ServiceNetwork and Service association deletion failed
        case deleteFailed
        /// ServiceNetwork and Service association deletion in progress
        case deleteInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceNetworkServiceAssociationStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleteFailed,
                .deleteInProgress,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VPCLatticeClientTypes.ServiceNetworkServiceAssociationSummary {

    static func write(value: VPCLatticeClientTypes.ServiceNetworkServiceAssociationSummary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["createdAt"].writeTimestamp(value.createdAt, format: .dateTime)
        try writer["createdBy"].write(value.createdBy)
        try writer["customDomainName"].write(value.customDomainName)
        try writer["dnsEntry"].write(value.dnsEntry, with: VPCLatticeClientTypes.DnsEntry.write(value:to:))
        try writer["id"].write(value.id)
        try writer["serviceArn"].write(value.serviceArn)
        try writer["serviceId"].write(value.serviceId)
        try writer["serviceName"].write(value.serviceName)
        try writer["serviceNetworkArn"].write(value.serviceNetworkArn)
        try writer["serviceNetworkId"].write(value.serviceNetworkId)
        try writer["serviceNetworkName"].write(value.serviceNetworkName)
        try writer["status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.ServiceNetworkServiceAssociationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.ServiceNetworkServiceAssociationSummary()
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.serviceId = try reader["serviceId"].readIfPresent()
        value.serviceName = try reader["serviceName"].readIfPresent()
        value.serviceArn = try reader["serviceArn"].readIfPresent()
        value.serviceNetworkId = try reader["serviceNetworkId"].readIfPresent()
        value.serviceNetworkName = try reader["serviceNetworkName"].readIfPresent()
        value.serviceNetworkArn = try reader["serviceNetworkArn"].readIfPresent()
        value.dnsEntry = try reader["dnsEntry"].readIfPresent(with: VPCLatticeClientTypes.DnsEntry.read(from:))
        value.customDomainName = try reader["customDomainName"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes {
    /// Summary information about the association between a service network and a service.
    public struct ServiceNetworkServiceAssociationSummary {
        /// The Amazon Resource Name (ARN) of the association.
        public var arn: Swift.String?
        /// The date and time that the association was created, specified in ISO-8601 format.
        public var createdAt: ClientRuntime.Date?
        /// The account that created the association.
        public var createdBy: Swift.String?
        /// The custom domain name of the service.
        public var customDomainName: Swift.String?
        /// DNS information about the service.
        public var dnsEntry: VPCLatticeClientTypes.DnsEntry?
        /// The ID of the association.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of the service.
        public var serviceArn: Swift.String?
        /// The ID of the service.
        public var serviceId: Swift.String?
        /// The name of the service.
        public var serviceName: Swift.String?
        /// The Amazon Resource Name (ARN) of the service network.
        public var serviceNetworkArn: Swift.String?
        /// The ID of the service network.
        public var serviceNetworkId: Swift.String?
        /// The name of the service network.
        public var serviceNetworkName: Swift.String?
        /// The status. If the deletion fails, try to delete again.
        public var status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            customDomainName: Swift.String? = nil,
            dnsEntry: VPCLatticeClientTypes.DnsEntry? = nil,
            id: Swift.String? = nil,
            serviceArn: Swift.String? = nil,
            serviceId: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            serviceNetworkArn: Swift.String? = nil,
            serviceNetworkId: Swift.String? = nil,
            serviceNetworkName: Swift.String? = nil,
            status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.customDomainName = customDomainName
            self.dnsEntry = dnsEntry
            self.id = id
            self.serviceArn = serviceArn
            self.serviceId = serviceId
            self.serviceName = serviceName
            self.serviceNetworkArn = serviceNetworkArn
            self.serviceNetworkId = serviceNetworkId
            self.serviceNetworkName = serviceNetworkName
            self.status = status
        }
    }

}

extension VPCLatticeClientTypes.ServiceNetworkSummary {

    static func write(value: VPCLatticeClientTypes.ServiceNetworkSummary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["createdAt"].writeTimestamp(value.createdAt, format: .dateTime)
        try writer["id"].write(value.id)
        try writer["lastUpdatedAt"].writeTimestamp(value.lastUpdatedAt, format: .dateTime)
        try writer["name"].write(value.name)
        try writer["numberOfAssociatedServices"].write(value.numberOfAssociatedServices)
        try writer["numberOfAssociatedVPCs"].write(value.numberOfAssociatedVPCs)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.ServiceNetworkSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.ServiceNetworkSummary()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: .dateTime)
        value.numberOfAssociatedVPCs = try reader["numberOfAssociatedVPCs"].readIfPresent()
        value.numberOfAssociatedServices = try reader["numberOfAssociatedServices"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes {
    /// Summary information about a service network.
    public struct ServiceNetworkSummary {
        /// The Amazon Resource Name (ARN) of the service network.
        public var arn: Swift.String?
        /// The date and time that the service network was created, specified in ISO-8601 format.
        public var createdAt: ClientRuntime.Date?
        /// The ID of the service network.
        public var id: Swift.String?
        /// The date and time that the service network was last updated, specified in ISO-8601 format.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the service network.
        public var name: Swift.String?
        /// The number of services associated with the service network.
        public var numberOfAssociatedServices: Swift.Int?
        /// The number of VPCs associated with the service network.
        public var numberOfAssociatedVPCs: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            numberOfAssociatedServices: Swift.Int? = nil,
            numberOfAssociatedVPCs: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.numberOfAssociatedServices = numberOfAssociatedServices
            self.numberOfAssociatedVPCs = numberOfAssociatedVPCs
        }
    }

}

extension VPCLatticeClientTypes {

    public enum ServiceNetworkVpcAssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// ServiceNetwork and Vpc association is active
        case active
        /// ServiceNetwork and Vpc association creation failed.
        case createFailed
        /// ServiceNetwork and Vpc association creation in progress
        case createInProgress
        /// ServiceNetwork and Vpc association deletion failed
        case deleteFailed
        /// ServiceNetwork and Vpc association deletion in progress
        case deleteInProgress
        /// ServiceNetwork and Vpc association update failed
        case updateFailed
        /// ServiceNetwork and Vpc association update in progress
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceNetworkVpcAssociationStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleteFailed,
                .deleteInProgress,
                .updateFailed,
                .updateInProgress,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VPCLatticeClientTypes.ServiceNetworkVpcAssociationSummary {

    static func write(value: VPCLatticeClientTypes.ServiceNetworkVpcAssociationSummary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["createdAt"].writeTimestamp(value.createdAt, format: .dateTime)
        try writer["createdBy"].write(value.createdBy)
        try writer["id"].write(value.id)
        try writer["lastUpdatedAt"].writeTimestamp(value.lastUpdatedAt, format: .dateTime)
        try writer["serviceNetworkArn"].write(value.serviceNetworkArn)
        try writer["serviceNetworkId"].write(value.serviceNetworkId)
        try writer["serviceNetworkName"].write(value.serviceNetworkName)
        try writer["status"].write(value.status)
        try writer["vpcId"].write(value.vpcId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.ServiceNetworkVpcAssociationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.ServiceNetworkVpcAssociationSummary()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.serviceNetworkId = try reader["serviceNetworkId"].readIfPresent()
        value.serviceNetworkName = try reader["serviceNetworkName"].readIfPresent()
        value.serviceNetworkArn = try reader["serviceNetworkArn"].readIfPresent()
        value.vpcId = try reader["vpcId"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension VPCLatticeClientTypes {
    /// Summary information about an association between a service network and a VPC.
    public struct ServiceNetworkVpcAssociationSummary {
        /// The Amazon Resource Name (ARN) of the association.
        public var arn: Swift.String?
        /// The date and time that the association was created, specified in ISO-8601 format.
        public var createdAt: ClientRuntime.Date?
        /// The account that created the association.
        public var createdBy: Swift.String?
        /// The ID of the association.
        public var id: Swift.String?
        /// The date and time that the association was last updated, specified in ISO-8601 format.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the service network.
        public var serviceNetworkArn: Swift.String?
        /// The ID of the service network.
        public var serviceNetworkId: Swift.String?
        /// The name of the service network.
        public var serviceNetworkName: Swift.String?
        /// The status.
        public var status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus?
        /// The ID of the VPC.
        public var vpcId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            serviceNetworkArn: Swift.String? = nil,
            serviceNetworkId: Swift.String? = nil,
            serviceNetworkName: Swift.String? = nil,
            status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.serviceNetworkArn = serviceNetworkArn
            self.serviceNetworkId = serviceNetworkId
            self.serviceNetworkName = serviceNetworkName
            self.status = status
            self.vpcId = vpcId
        }
    }

}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the service quota that was exceeded.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The resource ID.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
        /// The service code.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

extension VPCLatticeClientTypes {

    public enum ServiceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Service is active.
        case active
        /// Service creation failed
        case createFailed
        /// Service creation in progress.
        case createInProgress
        /// Service deletion failed.
        case deleteFailed
        /// Service deletion in progress
        case deleteInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleteFailed,
                .deleteInProgress,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VPCLatticeClientTypes.ServiceSummary {

    static func write(value: VPCLatticeClientTypes.ServiceSummary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["createdAt"].writeTimestamp(value.createdAt, format: .dateTime)
        try writer["customDomainName"].write(value.customDomainName)
        try writer["dnsEntry"].write(value.dnsEntry, with: VPCLatticeClientTypes.DnsEntry.write(value:to:))
        try writer["id"].write(value.id)
        try writer["lastUpdatedAt"].writeTimestamp(value.lastUpdatedAt, format: .dateTime)
        try writer["name"].write(value.name)
        try writer["status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.ServiceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.ServiceSummary()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: .dateTime)
        value.dnsEntry = try reader["dnsEntry"].readIfPresent(with: VPCLatticeClientTypes.DnsEntry.read(from:))
        value.customDomainName = try reader["customDomainName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes {
    /// Summary information about a service.
    public struct ServiceSummary {
        /// The Amazon Resource Name (ARN) of the service.
        public var arn: Swift.String?
        /// The date and time that the service was created, specified in ISO-8601 format.
        public var createdAt: ClientRuntime.Date?
        /// The custom domain name of the service.
        public var customDomainName: Swift.String?
        /// DNS information about the service.
        public var dnsEntry: VPCLatticeClientTypes.DnsEntry?
        /// The ID of the service.
        public var id: Swift.String?
        /// The date and time that the service was last updated. The format is ISO-8601.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the service.
        public var name: Swift.String?
        /// The status.
        public var status: VPCLatticeClientTypes.ServiceStatus?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            customDomainName: Swift.String? = nil,
            dnsEntry: VPCLatticeClientTypes.DnsEntry? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: VPCLatticeClientTypes.ServiceStatus? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.customDomainName = customDomainName
            self.dnsEntry = dnsEntry
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.status = status
        }
    }

}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags for the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

public struct TagResourceOutput {

    public init() { }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension VPCLatticeClientTypes.Target {

    static func write(value: VPCLatticeClientTypes.Target?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
        try writer["port"].write(value.port)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.Target {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.Target()
        value.id = try reader["id"].readIfPresent()
        value.port = try reader["port"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes {
    /// Describes a target.
    public struct Target {
        /// The ID of the target. If the target type of the target group is INSTANCE, this is an instance ID. If the target type is IP , this is an IP address. If the target type is LAMBDA, this is the ARN of the Lambda function. If the target type is ALB, this is the ARN of the Application Load Balancer.
        /// This member is required.
        public var id: Swift.String?
        /// The port on which the target is listening. For HTTP, the default is 80. For HTTPS, the default is 443.
        public var port: Swift.Int?

        public init(
            id: Swift.String? = nil,
            port: Swift.Int? = nil
        )
        {
            self.id = id
            self.port = port
        }
    }

}

extension VPCLatticeClientTypes.TargetFailure {

    static func write(value: VPCLatticeClientTypes.TargetFailure?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["failureCode"].write(value.failureCode)
        try writer["failureMessage"].write(value.failureMessage)
        try writer["id"].write(value.id)
        try writer["port"].write(value.port)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.TargetFailure {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.TargetFailure()
        value.id = try reader["id"].readIfPresent()
        value.port = try reader["port"].readIfPresent()
        value.failureCode = try reader["failureCode"].readIfPresent()
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes {
    /// Describes a target failure.
    public struct TargetFailure {
        /// The failure code.
        public var failureCode: Swift.String?
        /// The failure message.
        public var failureMessage: Swift.String?
        /// The ID of the target. If the target type of the target group is INSTANCE, this is an instance ID. If the target type is IP , this is an IP address. If the target type is LAMBDA, this is the ARN of the Lambda function. If the target type is ALB, this is the ARN of the Application Load Balancer.
        public var id: Swift.String?
        /// The port on which the target is listening. This parameter doesn't apply if the target is a Lambda function.
        public var port: Swift.Int?

        public init(
            failureCode: Swift.String? = nil,
            failureMessage: Swift.String? = nil,
            id: Swift.String? = nil,
            port: Swift.Int? = nil
        )
        {
            self.failureCode = failureCode
            self.failureMessage = failureMessage
            self.id = id
            self.port = port
        }
    }

}

extension VPCLatticeClientTypes.TargetGroupConfig {

    static func write(value: VPCLatticeClientTypes.TargetGroupConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["healthCheck"].write(value.healthCheck, with: VPCLatticeClientTypes.HealthCheckConfig.write(value:to:))
        try writer["ipAddressType"].write(value.ipAddressType)
        try writer["lambdaEventStructureVersion"].write(value.lambdaEventStructureVersion)
        try writer["port"].write(value.port)
        try writer["protocol"].write(value.`protocol`)
        try writer["protocolVersion"].write(value.protocolVersion)
        try writer["vpcIdentifier"].write(value.vpcIdentifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.TargetGroupConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.TargetGroupConfig()
        value.port = try reader["port"].readIfPresent()
        value.`protocol` = try reader["protocol"].readIfPresent()
        value.protocolVersion = try reader["protocolVersion"].readIfPresent()
        value.ipAddressType = try reader["ipAddressType"].readIfPresent()
        value.vpcIdentifier = try reader["vpcIdentifier"].readIfPresent()
        value.healthCheck = try reader["healthCheck"].readIfPresent(with: VPCLatticeClientTypes.HealthCheckConfig.read(from:))
        value.lambdaEventStructureVersion = try reader["lambdaEventStructureVersion"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes {
    /// Describes the configuration of a target group. Lambda functions don't support target group configuration.
    public struct TargetGroupConfig {
        /// The health check configuration.
        public var healthCheck: VPCLatticeClientTypes.HealthCheckConfig?
        /// The type of IP address used for the target group. The possible values are ipv4 and ipv6. This is an optional parameter. If not specified, the IP address type defaults to ipv4.
        public var ipAddressType: VPCLatticeClientTypes.IpAddressType?
        /// Lambda event structure version
        public var lambdaEventStructureVersion: VPCLatticeClientTypes.LambdaEventStructureVersion?
        /// The port on which the targets are listening. For HTTP, the default is 80. For HTTPS, the default is 443
        public var port: Swift.Int?
        /// The protocol to use for routing traffic to the targets. Default is the protocol of a target group.
        public var `protocol`: VPCLatticeClientTypes.TargetGroupProtocol?
        /// The protocol version. Default value is HTTP1.
        public var protocolVersion: VPCLatticeClientTypes.TargetGroupProtocolVersion?
        /// The ID of the VPC.
        public var vpcIdentifier: Swift.String?

        public init(
            healthCheck: VPCLatticeClientTypes.HealthCheckConfig? = nil,
            ipAddressType: VPCLatticeClientTypes.IpAddressType? = nil,
            lambdaEventStructureVersion: VPCLatticeClientTypes.LambdaEventStructureVersion? = nil,
            port: Swift.Int? = nil,
            `protocol`: VPCLatticeClientTypes.TargetGroupProtocol? = nil,
            protocolVersion: VPCLatticeClientTypes.TargetGroupProtocolVersion? = nil,
            vpcIdentifier: Swift.String? = nil
        )
        {
            self.healthCheck = healthCheck
            self.ipAddressType = ipAddressType
            self.lambdaEventStructureVersion = lambdaEventStructureVersion
            self.port = port
            self.`protocol` = `protocol`
            self.protocolVersion = protocolVersion
            self.vpcIdentifier = vpcIdentifier
        }
    }

}

extension VPCLatticeClientTypes {

    public enum TargetGroupProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Indicates HTTP protocol
        case http
        /// Indicates HTTPS protocol
        case https
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetGroupProtocol] {
            return [
                .http,
                .https,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case .https: return "HTTPS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VPCLatticeClientTypes {

    public enum TargetGroupProtocolVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Indicates use of gRPC to send requests to target
        case grpc
        /// Indicates use of HTTP/1.1 to send requests to target
        case http1
        /// Indicates use of HTTP/2 to send requests to target
        case http2
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetGroupProtocolVersion] {
            return [
                .grpc,
                .http1,
                .http2,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .grpc: return "GRPC"
            case .http1: return "HTTP1"
            case .http2: return "HTTP2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VPCLatticeClientTypes {

    public enum TargetGroupStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// TargetGroup is active
        case active
        /// TargetGroup creation failed.
        case createFailed
        /// TargetGroup creation in progress
        case createInProgress
        /// TargetGroup deletion failed
        case deleteFailed
        /// TargetGroup deletion in progress
        case deleteInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetGroupStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleteFailed,
                .deleteInProgress,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VPCLatticeClientTypes.TargetGroupSummary {

    static func write(value: VPCLatticeClientTypes.TargetGroupSummary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["createdAt"].writeTimestamp(value.createdAt, format: .dateTime)
        try writer["id"].write(value.id)
        try writer["ipAddressType"].write(value.ipAddressType)
        try writer["lambdaEventStructureVersion"].write(value.lambdaEventStructureVersion)
        try writer["lastUpdatedAt"].writeTimestamp(value.lastUpdatedAt, format: .dateTime)
        try writer["name"].write(value.name)
        try writer["port"].write(value.port)
        try writer["protocol"].write(value.`protocol`)
        try writer["serviceArns"].writeList(value.serviceArns, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["status"].write(value.status)
        try writer["type"].write(value.type)
        try writer["vpcIdentifier"].write(value.vpcIdentifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.TargetGroupSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.TargetGroupSummary()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.port = try reader["port"].readIfPresent()
        value.`protocol` = try reader["protocol"].readIfPresent()
        value.ipAddressType = try reader["ipAddressType"].readIfPresent()
        value.vpcIdentifier = try reader["vpcIdentifier"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: .dateTime)
        value.status = try reader["status"].readIfPresent()
        value.serviceArns = try reader["serviceArns"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lambdaEventStructureVersion = try reader["lambdaEventStructureVersion"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes {
    /// Summary information about a target group.
    public struct TargetGroupSummary {
        /// The ARN (Amazon Resource Name) of the target group.
        public var arn: Swift.String?
        /// The date and time that the target group was created, specified in ISO-8601 format.
        public var createdAt: ClientRuntime.Date?
        /// The ID of the target group.
        public var id: Swift.String?
        /// The type of IP address used for the target group. The possible values are ipv4 and ipv6. This is an optional parameter. If not specified, the IP address type defaults to ipv4.
        public var ipAddressType: VPCLatticeClientTypes.IpAddressType?
        /// Lambda event structure version
        public var lambdaEventStructureVersion: VPCLatticeClientTypes.LambdaEventStructureVersion?
        /// The date and time that the target group was last updated, specified in ISO-8601 format.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the target group.
        public var name: Swift.String?
        /// The port of the target group.
        public var port: Swift.Int?
        /// The protocol of the target group.
        public var `protocol`: VPCLatticeClientTypes.TargetGroupProtocol?
        /// The list of Amazon Resource Names (ARNs) of the service.
        public var serviceArns: [Swift.String]?
        /// The status.
        public var status: VPCLatticeClientTypes.TargetGroupStatus?
        /// The target group type.
        public var type: VPCLatticeClientTypes.TargetGroupType?
        /// The ID of the VPC of the target group.
        public var vpcIdentifier: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            ipAddressType: VPCLatticeClientTypes.IpAddressType? = nil,
            lambdaEventStructureVersion: VPCLatticeClientTypes.LambdaEventStructureVersion? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: VPCLatticeClientTypes.TargetGroupProtocol? = nil,
            serviceArns: [Swift.String]? = nil,
            status: VPCLatticeClientTypes.TargetGroupStatus? = nil,
            type: VPCLatticeClientTypes.TargetGroupType? = nil,
            vpcIdentifier: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.ipAddressType = ipAddressType
            self.lambdaEventStructureVersion = lambdaEventStructureVersion
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.port = port
            self.`protocol` = `protocol`
            self.serviceArns = serviceArns
            self.status = status
            self.type = type
            self.vpcIdentifier = vpcIdentifier
        }
    }

}

extension VPCLatticeClientTypes {

    public enum TargetGroupType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Indicates target in this target group is an ALB
        case alb
        /// Indicates targets in this target group are EC2 instances
        case instance
        /// Indicates targets in this target group are IP
        case ip
        /// Indicates targets in this target group are Lambda
        case lambda
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetGroupType] {
            return [
                .alb,
                .instance,
                .ip,
                .lambda,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .alb: return "ALB"
            case .instance: return "INSTANCE"
            case .ip: return "IP"
            case .lambda: return "LAMBDA"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VPCLatticeClientTypes {

    public enum TargetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// The target is deregistering and connection draining is in process.
        case draining
        /// The target is healthy.
        case healthy
        /// The initial health check is in progress.
        case initial
        /// Health checks are disabled.
        case unavailable
        /// The target failed the health check.
        case unhealthy
        /// The target group is not used in a listener rule.
        case unused
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetStatus] {
            return [
                .draining,
                .healthy,
                .initial,
                .unavailable,
                .unhealthy,
                .unused,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .draining: return "DRAINING"
            case .healthy: return "HEALTHY"
            case .initial: return "INITIAL"
            case .unavailable: return "UNAVAILABLE"
            case .unhealthy: return "UNHEALTHY"
            case .unused: return "UNUSED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VPCLatticeClientTypes.TargetSummary {

    static func write(value: VPCLatticeClientTypes.TargetSummary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
        try writer["port"].write(value.port)
        try writer["reasonCode"].write(value.reasonCode)
        try writer["status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.TargetSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.TargetSummary()
        value.id = try reader["id"].readIfPresent()
        value.port = try reader["port"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.reasonCode = try reader["reasonCode"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes {
    /// Summary information about a target.
    public struct TargetSummary {
        /// The ID of the target. If the target type of the target group is INSTANCE, this is an instance ID. If the target type is IP , this is an IP address. If the target type is LAMBDA, this is the ARN of the Lambda function. If the target type is ALB, this is the ARN of the Application Load Balancer.
        public var id: Swift.String?
        /// The port on which the target is listening.
        public var port: Swift.Int?
        /// The code for why the target status is what it is.
        public var reasonCode: Swift.String?
        /// The status of the target.
        ///
        /// * Draining: The target is being deregistered. No new connections will be sent to this target while current connections are being drained. Default draining time is 5 minutes.
        ///
        /// * Unavailable: Health checks are unavailable for the target group.
        ///
        /// * Healthy: The target is healthy.
        ///
        /// * Unhealthy: The target is unhealthy.
        ///
        /// * Initial: Initial health checks on the target are being performed.
        ///
        /// * Unused: Target group is not used in a service.
        public var status: VPCLatticeClientTypes.TargetStatus?

        public init(
            id: Swift.String? = nil,
            port: Swift.Int? = nil,
            reasonCode: Swift.String? = nil,
            status: VPCLatticeClientTypes.TargetStatus? = nil
        )
        {
            self.id = id
            self.port = port
            self.reasonCode = reasonCode
            self.status = status
        }
    }

}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The limit on the number of requests per second was exceeded.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the service quota that was exceeded.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The number of seconds to wait before retrying.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
        /// The service code.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys of the tags to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

public struct UntagResourceOutput {

    public init() { }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateAccessLogSubscriptionInput {

    static func urlPathProvider(_ value: UpdateAccessLogSubscriptionInput) -> Swift.String? {
        guard let accessLogSubscriptionIdentifier = value.accessLogSubscriptionIdentifier else {
            return nil
        }
        return "/accesslogsubscriptions/\(accessLogSubscriptionIdentifier.urlPercentEncoding())"
    }
}

extension UpdateAccessLogSubscriptionInput {

    static func write(value: UpdateAccessLogSubscriptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destinationArn"].write(value.destinationArn)
    }
}

public struct UpdateAccessLogSubscriptionInput {
    /// The ID or Amazon Resource Name (ARN) of the access log subscription.
    /// This member is required.
    public var accessLogSubscriptionIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) of the access log destination.
    /// This member is required.
    public var destinationArn: Swift.String?

    public init(
        accessLogSubscriptionIdentifier: Swift.String? = nil,
        destinationArn: Swift.String? = nil
    )
    {
        self.accessLogSubscriptionIdentifier = accessLogSubscriptionIdentifier
        self.destinationArn = destinationArn
    }
}

extension UpdateAccessLogSubscriptionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateAccessLogSubscriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAccessLogSubscriptionOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.destinationArn = try reader["destinationArn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.resourceArn = try reader["resourceArn"].readIfPresent()
        value.resourceId = try reader["resourceId"].readIfPresent()
        return value
    }
}

public struct UpdateAccessLogSubscriptionOutput {
    /// The Amazon Resource Name (ARN) of the access log subscription.
    /// This member is required.
    public var arn: Swift.String?
    /// The Amazon Resource Name (ARN) of the access log destination.
    /// This member is required.
    public var destinationArn: Swift.String?
    /// The ID of the access log subscription.
    /// This member is required.
    public var id: Swift.String?
    /// The Amazon Resource Name (ARN) of the access log subscription.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        destinationArn: Swift.String? = nil,
        id: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.destinationArn = destinationArn
        self.id = id
        self.resourceArn = resourceArn
        self.resourceId = resourceId
    }
}

enum UpdateAccessLogSubscriptionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateListenerInput {

    static func urlPathProvider(_ value: UpdateListenerInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = value.listenerIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())"
    }
}

extension UpdateListenerInput {

    static func write(value: UpdateListenerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["defaultAction"].write(value.defaultAction, with: VPCLatticeClientTypes.RuleAction.write(value:to:))
    }
}

public struct UpdateListenerInput {
    /// The action for the default rule.
    /// This member is required.
    public var defaultAction: VPCLatticeClientTypes.RuleAction?
    /// The ID or Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        defaultAction: VPCLatticeClientTypes.RuleAction? = nil,
        listenerIdentifier: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.defaultAction = defaultAction
        self.listenerIdentifier = listenerIdentifier
        self.serviceIdentifier = serviceIdentifier
    }
}

extension UpdateListenerOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateListenerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateListenerOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.defaultAction = try reader["defaultAction"].readIfPresent(with: VPCLatticeClientTypes.RuleAction.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.port = try reader["port"].readIfPresent()
        value.`protocol` = try reader["protocol"].readIfPresent()
        value.serviceArn = try reader["serviceArn"].readIfPresent()
        value.serviceId = try reader["serviceId"].readIfPresent()
        return value
    }
}

public struct UpdateListenerOutput {
    /// The Amazon Resource Name (ARN) of the listener.
    public var arn: Swift.String?
    /// The action for the default rule.
    public var defaultAction: VPCLatticeClientTypes.RuleAction?
    /// The ID of the listener.
    public var id: Swift.String?
    /// The name of the listener.
    public var name: Swift.String?
    /// The listener port.
    public var port: Swift.Int?
    /// The protocol of the listener.
    public var `protocol`: VPCLatticeClientTypes.ListenerProtocol?
    /// The Amazon Resource Name (ARN) of the service.
    public var serviceArn: Swift.String?
    /// The ID of the service.
    public var serviceId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        defaultAction: VPCLatticeClientTypes.RuleAction? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        port: Swift.Int? = nil,
        `protocol`: VPCLatticeClientTypes.ListenerProtocol? = nil,
        serviceArn: Swift.String? = nil,
        serviceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.defaultAction = defaultAction
        self.id = id
        self.name = name
        self.port = port
        self.`protocol` = `protocol`
        self.serviceArn = serviceArn
        self.serviceId = serviceId
    }
}

enum UpdateListenerOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateRuleInput {

    static func urlPathProvider(_ value: UpdateRuleInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = value.listenerIdentifier else {
            return nil
        }
        guard let ruleIdentifier = value.ruleIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())/rules/\(ruleIdentifier.urlPercentEncoding())"
    }
}

extension UpdateRuleInput {

    static func write(value: UpdateRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action, with: VPCLatticeClientTypes.RuleAction.write(value:to:))
        try writer["match"].write(value.match, with: VPCLatticeClientTypes.RuleMatch.write(value:to:))
        try writer["priority"].write(value.priority)
    }
}

public struct UpdateRuleInput {
    /// Information about the action for the specified listener rule.
    public var action: VPCLatticeClientTypes.RuleAction?
    /// The ID or Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The rule match.
    public var match: VPCLatticeClientTypes.RuleMatch?
    /// The rule priority. A listener can't have multiple rules with the same priority.
    public var priority: Swift.Int?
    /// The ID or Amazon Resource Name (ARN) of the rule.
    /// This member is required.
    public var ruleIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        action: VPCLatticeClientTypes.RuleAction? = nil,
        listenerIdentifier: Swift.String? = nil,
        match: VPCLatticeClientTypes.RuleMatch? = nil,
        priority: Swift.Int? = nil,
        ruleIdentifier: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.action = action
        self.listenerIdentifier = listenerIdentifier
        self.match = match
        self.priority = priority
        self.ruleIdentifier = ruleIdentifier
        self.serviceIdentifier = serviceIdentifier
    }
}

extension UpdateRuleOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateRuleOutput()
        value.action = try reader["action"].readIfPresent(with: VPCLatticeClientTypes.RuleAction.read(from:))
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.isDefault = try reader["isDefault"].readIfPresent()
        value.match = try reader["match"].readIfPresent(with: VPCLatticeClientTypes.RuleMatch.read(from:))
        value.name = try reader["name"].readIfPresent()
        value.priority = try reader["priority"].readIfPresent()
        return value
    }
}

public struct UpdateRuleOutput {
    /// Information about the action for the specified listener rule.
    public var action: VPCLatticeClientTypes.RuleAction?
    /// The Amazon Resource Name (ARN) of the listener.
    public var arn: Swift.String?
    /// The ID of the listener.
    public var id: Swift.String?
    /// Indicates whether this is the default rule.
    public var isDefault: Swift.Bool?
    /// The rule match.
    public var match: VPCLatticeClientTypes.RuleMatch?
    /// The name of the listener.
    public var name: Swift.String?
    /// The rule priority.
    public var priority: Swift.Int?

    public init(
        action: VPCLatticeClientTypes.RuleAction? = nil,
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        isDefault: Swift.Bool? = nil,
        match: VPCLatticeClientTypes.RuleMatch? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil
    )
    {
        self.action = action
        self.arn = arn
        self.id = id
        self.isDefault = isDefault
        self.match = match
        self.name = name
        self.priority = priority
    }
}

enum UpdateRuleOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateServiceInput {

    static func urlPathProvider(_ value: UpdateServiceInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())"
    }
}

extension UpdateServiceInput {

    static func write(value: UpdateServiceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authType"].write(value.authType)
        try writer["certificateArn"].write(value.certificateArn)
    }
}

public struct UpdateServiceInput {
    /// The type of IAM policy.
    ///
    /// * NONE: The resource does not use an IAM policy. This is the default.
    ///
    /// * AWS_IAM: The resource uses an IAM policy. When this type is used, auth is enabled and an auth policy is required.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The Amazon Resource Name (ARN) of the certificate.
    public var certificateArn: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        authType: VPCLatticeClientTypes.AuthType? = nil,
        certificateArn: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.authType = authType
        self.certificateArn = certificateArn
        self.serviceIdentifier = serviceIdentifier
    }
}

extension UpdateServiceNetworkInput {

    static func urlPathProvider(_ value: UpdateServiceNetworkInput) -> Swift.String? {
        guard let serviceNetworkIdentifier = value.serviceNetworkIdentifier else {
            return nil
        }
        return "/servicenetworks/\(serviceNetworkIdentifier.urlPercentEncoding())"
    }
}

extension UpdateServiceNetworkInput {

    static func write(value: UpdateServiceNetworkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authType"].write(value.authType)
    }
}

public struct UpdateServiceNetworkInput {
    /// The type of IAM policy.
    ///
    /// * NONE: The resource does not use an IAM policy. This is the default.
    ///
    /// * AWS_IAM: The resource uses an IAM policy. When this type is used, auth is enabled and an auth policy is required.
    /// This member is required.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The ID or Amazon Resource Name (ARN) of the service network.
    /// This member is required.
    public var serviceNetworkIdentifier: Swift.String?

    public init(
        authType: VPCLatticeClientTypes.AuthType? = nil,
        serviceNetworkIdentifier: Swift.String? = nil
    )
    {
        self.authType = authType
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
    }
}

extension UpdateServiceNetworkOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateServiceNetworkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateServiceNetworkOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.authType = try reader["authType"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

public struct UpdateServiceNetworkOutput {
    /// The Amazon Resource Name (ARN) of the service network.
    public var arn: Swift.String?
    /// The type of IAM policy.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The ID of the service network.
    public var id: Swift.String?
    /// The name of the service network.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        authType: VPCLatticeClientTypes.AuthType? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.authType = authType
        self.id = id
        self.name = name
    }
}

enum UpdateServiceNetworkOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateServiceNetworkVpcAssociationInput {

    static func urlPathProvider(_ value: UpdateServiceNetworkVpcAssociationInput) -> Swift.String? {
        guard let serviceNetworkVpcAssociationIdentifier = value.serviceNetworkVpcAssociationIdentifier else {
            return nil
        }
        return "/servicenetworkvpcassociations/\(serviceNetworkVpcAssociationIdentifier.urlPercentEncoding())"
    }
}

extension UpdateServiceNetworkVpcAssociationInput {

    static func write(value: UpdateServiceNetworkVpcAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct UpdateServiceNetworkVpcAssociationInput {
    /// The IDs of the security groups. Once you add a security group, it cannot be removed.
    /// This member is required.
    public var securityGroupIds: [Swift.String]?
    /// The ID or Amazon Resource Name (ARN) of the association.
    /// This member is required.
    public var serviceNetworkVpcAssociationIdentifier: Swift.String?

    public init(
        securityGroupIds: [Swift.String]? = nil,
        serviceNetworkVpcAssociationIdentifier: Swift.String? = nil
    )
    {
        self.securityGroupIds = securityGroupIds
        self.serviceNetworkVpcAssociationIdentifier = serviceNetworkVpcAssociationIdentifier
    }
}

extension UpdateServiceNetworkVpcAssociationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateServiceNetworkVpcAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateServiceNetworkVpcAssociationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

public struct UpdateServiceNetworkVpcAssociationOutput {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The account that created the association.
    public var createdBy: Swift.String?
    /// The ID of the association.
    public var id: Swift.String?
    /// The IDs of the security groups.
    public var securityGroupIds: [Swift.String]?
    /// The status. You can retry the operation if the status is DELETE_FAILED. However, if you retry it while the status is DELETE_IN_PROGRESS, there is no change in the status.
    public var status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus?

    public init(
        arn: Swift.String? = nil,
        createdBy: Swift.String? = nil,
        id: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus? = nil
    )
    {
        self.arn = arn
        self.createdBy = createdBy
        self.id = id
        self.securityGroupIds = securityGroupIds
        self.status = status
    }
}

enum UpdateServiceNetworkVpcAssociationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateServiceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateServiceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateServiceOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.authType = try reader["authType"].readIfPresent()
        value.certificateArn = try reader["certificateArn"].readIfPresent()
        value.customDomainName = try reader["customDomainName"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

public struct UpdateServiceOutput {
    /// The Amazon Resource Name (ARN) of the service.
    public var arn: Swift.String?
    /// The type of IAM policy.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The Amazon Resource Name (ARN) of the certificate.
    public var certificateArn: Swift.String?
    /// The custom domain name of the service.
    public var customDomainName: Swift.String?
    /// The ID of the service.
    public var id: Swift.String?
    /// The name of the service.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        authType: VPCLatticeClientTypes.AuthType? = nil,
        certificateArn: Swift.String? = nil,
        customDomainName: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.authType = authType
        self.certificateArn = certificateArn
        self.customDomainName = customDomainName
        self.id = id
        self.name = name
    }
}

enum UpdateServiceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateTargetGroupInput {

    static func urlPathProvider(_ value: UpdateTargetGroupInput) -> Swift.String? {
        guard let targetGroupIdentifier = value.targetGroupIdentifier else {
            return nil
        }
        return "/targetgroups/\(targetGroupIdentifier.urlPercentEncoding())"
    }
}

extension UpdateTargetGroupInput {

    static func write(value: UpdateTargetGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["healthCheck"].write(value.healthCheck, with: VPCLatticeClientTypes.HealthCheckConfig.write(value:to:))
    }
}

public struct UpdateTargetGroupInput {
    /// The health check configuration.
    /// This member is required.
    public var healthCheck: VPCLatticeClientTypes.HealthCheckConfig?
    /// The ID or Amazon Resource Name (ARN) of the target group.
    /// This member is required.
    public var targetGroupIdentifier: Swift.String?

    public init(
        healthCheck: VPCLatticeClientTypes.HealthCheckConfig? = nil,
        targetGroupIdentifier: Swift.String? = nil
    )
    {
        self.healthCheck = healthCheck
        self.targetGroupIdentifier = targetGroupIdentifier
    }
}

extension UpdateTargetGroupOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateTargetGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateTargetGroupOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.config = try reader["config"].readIfPresent(with: VPCLatticeClientTypes.TargetGroupConfig.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

public struct UpdateTargetGroupOutput {
    /// The Amazon Resource Name (ARN) of the target group.
    public var arn: Swift.String?
    /// The target group configuration.
    public var config: VPCLatticeClientTypes.TargetGroupConfig?
    /// The ID of the target group.
    public var id: Swift.String?
    /// The name of the target group.
    public var name: Swift.String?
    /// The status.
    public var status: VPCLatticeClientTypes.TargetGroupStatus?
    /// The target group type.
    public var type: VPCLatticeClientTypes.TargetGroupType?

    public init(
        arn: Swift.String? = nil,
        config: VPCLatticeClientTypes.TargetGroupConfig? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: VPCLatticeClientTypes.TargetGroupStatus? = nil,
        type: VPCLatticeClientTypes.TargetGroupType? = nil
    )
    {
        self.arn = arn
        self.config = config
        self.id = id
        self.name = name
        self.status = status
        self.type = type
    }
}

enum UpdateTargetGroupOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

public enum VPCLatticeClientTypes {}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.reason = try reader["reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The input does not satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The fields that failed validation.
        public internal(set) var fieldList: [VPCLatticeClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason.
        /// This member is required.
        public internal(set) var reason: VPCLatticeClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [VPCLatticeClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: VPCLatticeClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension VPCLatticeClientTypes.ValidationExceptionField {

    static func write(value: VPCLatticeClientTypes.ValidationExceptionField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["message"].write(value.message)
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes {
    /// Describes a validation failure.
    public struct ValidationExceptionField {
        /// Additional details about why the validation failed.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the validation exception.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension VPCLatticeClientTypes {

    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VPCLatticeClientTypes.WeightedTargetGroup {

    static func write(value: VPCLatticeClientTypes.WeightedTargetGroup?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["targetGroupIdentifier"].write(value.targetGroupIdentifier)
        try writer["weight"].write(value.weight)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.WeightedTargetGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.WeightedTargetGroup()
        value.targetGroupIdentifier = try reader["targetGroupIdentifier"].readIfPresent()
        value.weight = try reader["weight"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes {
    /// Describes the weight of a target group.
    public struct WeightedTargetGroup {
        /// The ID or Amazon Resource Name (ARN) of the target group.
        /// This member is required.
        public var targetGroupIdentifier: Swift.String?
        /// Only required if you specify multiple target groups for a forward action. The "weight" determines how requests are distributed to the target group. For example, if you specify two target groups, each with a weight of 10, each target group receives half the requests. If you specify two target groups, one with a weight of 10 and the other with a weight of 20, the target group with a weight of 20 receives twice as many requests as the other target group. If there's only one target group specified, then the default value is 100.
        public var weight: Swift.Int?

        public init(
            targetGroupIdentifier: Swift.String? = nil,
            weight: Swift.Int? = nil
        )
        {
            self.targetGroupIdentifier = targetGroupIdentifier
            self.weight = weight
        }
    }

}
