// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The user does not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VPCLatticeClientTypes.AccessLogSubscriptionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case destinationArn
        case id
        case lastUpdatedAt
        case resourceArn
        case resourceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let destinationArn = self.destinationArn {
            try encodeContainer.encode(destinationArn, forKey: .destinationArn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .dateTime, forKey: .lastUpdatedAt)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let destinationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationArn)
        destinationArn = destinationArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Summary information about an access log subscription.
    public struct AccessLogSubscriptionSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the access log subscription
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the access log subscription was created, specified in ISO-8601 format.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the destination.
        /// This member is required.
        public var destinationArn: Swift.String?
        /// The ID of the access log subscription.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time that the access log subscription was last updated, specified in ISO-8601 format.
        /// This member is required.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the service or service network.
        /// This member is required.
        public var resourceArn: Swift.String?
        /// The ID of the service or service network.
        /// This member is required.
        public var resourceId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            destinationArn: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            resourceArn: Swift.String? = nil,
            resourceId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.destinationArn = destinationArn
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.resourceArn = resourceArn
            self.resourceId = resourceId
        }
    }

}

extension VPCLatticeClientTypes {
    public enum AuthPolicyState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthPolicyState] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .inactive: return "Inactive"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthPolicyState(rawValue: rawValue) ?? AuthPolicyState.sdkUnknown(rawValue)
        }
    }
}

extension VPCLatticeClientTypes {
    public enum AuthType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsIam
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthType] {
            return [
                .awsIam,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsIam: return "AWS_IAM"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthType(rawValue: rawValue) ?? AuthType.sdkUnknown(rawValue)
        }
    }
}

extension BatchUpdateRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rules
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for ruleupdate0 in rules {
                try rulesContainer.encode(ruleupdate0)
            }
        }
    }
}

extension BatchUpdateRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceIdentifier = serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = listenerIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())/rules"
    }
}

public struct BatchUpdateRuleInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The rules for the specified listener.
    /// This member is required.
    public var rules: [VPCLatticeClientTypes.RuleUpdate]?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        listenerIdentifier: Swift.String? = nil,
        rules: [VPCLatticeClientTypes.RuleUpdate]? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.listenerIdentifier = listenerIdentifier
        self.rules = rules
        self.serviceIdentifier = serviceIdentifier
    }
}

struct BatchUpdateRuleInputBody: Swift.Equatable {
    let rules: [VPCLatticeClientTypes.RuleUpdate]?
}

extension BatchUpdateRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rules
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.RuleUpdate?].self, forKey: .rules)
        var rulesDecoded0:[VPCLatticeClientTypes.RuleUpdate]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [VPCLatticeClientTypes.RuleUpdate]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

extension BatchUpdateRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchUpdateRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.successful = output.successful
            self.unsuccessful = output.unsuccessful
        } else {
            self.successful = nil
            self.unsuccessful = nil
        }
    }
}

public struct BatchUpdateRuleOutput: Swift.Equatable {
    /// The rules that were successfully updated.
    public var successful: [VPCLatticeClientTypes.RuleUpdateSuccess]?
    /// The rules that the operation couldn't update.
    public var unsuccessful: [VPCLatticeClientTypes.RuleUpdateFailure]?

    public init(
        successful: [VPCLatticeClientTypes.RuleUpdateSuccess]? = nil,
        unsuccessful: [VPCLatticeClientTypes.RuleUpdateFailure]? = nil
    )
    {
        self.successful = successful
        self.unsuccessful = unsuccessful
    }
}

struct BatchUpdateRuleOutputBody: Swift.Equatable {
    let successful: [VPCLatticeClientTypes.RuleUpdateSuccess]?
    let unsuccessful: [VPCLatticeClientTypes.RuleUpdateFailure]?
}

extension BatchUpdateRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case successful
        case unsuccessful
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.RuleUpdateSuccess?].self, forKey: .successful)
        var successfulDecoded0:[VPCLatticeClientTypes.RuleUpdateSuccess]? = nil
        if let successfulContainer = successfulContainer {
            successfulDecoded0 = [VPCLatticeClientTypes.RuleUpdateSuccess]()
            for structure0 in successfulContainer {
                if let structure0 = structure0 {
                    successfulDecoded0?.append(structure0)
                }
            }
        }
        successful = successfulDecoded0
        let unsuccessfulContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.RuleUpdateFailure?].self, forKey: .unsuccessful)
        var unsuccessfulDecoded0:[VPCLatticeClientTypes.RuleUpdateFailure]? = nil
        if let unsuccessfulContainer = unsuccessfulContainer {
            unsuccessfulDecoded0 = [VPCLatticeClientTypes.RuleUpdateFailure]()
            for structure0 in unsuccessfulContainer {
                if let structure0 = structure0 {
                    unsuccessfulDecoded0?.append(structure0)
                }
            }
        }
        unsuccessful = unsuccessfulDecoded0
    }
}

enum BatchUpdateRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request conflicts with the current state of the resource. Updating or deleting a resource can cause an inconsistent state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The resource ID.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CreateAccessLogSubscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case destinationArn
        case resourceIdentifier
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let destinationArn = self.destinationArn {
            try encodeContainer.encode(destinationArn, forKey: .destinationArn)
        }
        if let resourceIdentifier = self.resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAccessLogSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/accesslogsubscriptions"
    }
}

public struct CreateAccessLogSubscriptionInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the destination. The supported destination types are CloudWatch Log groups, Kinesis Data Firehose delivery streams, and Amazon S3 buckets.
    /// This member is required.
    public var destinationArn: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service network or service.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The tags for the access log subscription.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        destinationArn: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.destinationArn = destinationArn
        self.resourceIdentifier = resourceIdentifier
        self.tags = tags
    }
}

struct CreateAccessLogSubscriptionInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let resourceIdentifier: Swift.String?
    let destinationArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateAccessLogSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case destinationArn
        case resourceIdentifier
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let destinationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationArn)
        destinationArn = destinationArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAccessLogSubscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAccessLogSubscriptionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.destinationArn = output.destinationArn
            self.id = output.id
            self.resourceArn = output.resourceArn
            self.resourceId = output.resourceId
        } else {
            self.arn = nil
            self.destinationArn = nil
            self.id = nil
            self.resourceArn = nil
            self.resourceId = nil
        }
    }
}

public struct CreateAccessLogSubscriptionOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the access log subscription.
    /// This member is required.
    public var arn: Swift.String?
    /// The Amazon Resource Name (ARN) of the log destination.
    /// This member is required.
    public var destinationArn: Swift.String?
    /// The ID of the access log subscription.
    /// This member is required.
    public var id: Swift.String?
    /// The Amazon Resource Name (ARN) of the service network or service.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The ID of the service network or service.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        destinationArn: Swift.String? = nil,
        id: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.destinationArn = destinationArn
        self.id = id
        self.resourceArn = resourceArn
        self.resourceId = resourceId
    }
}

struct CreateAccessLogSubscriptionOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let resourceId: Swift.String?
    let resourceArn: Swift.String?
    let destinationArn: Swift.String?
}

extension CreateAccessLogSubscriptionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case destinationArn
        case id
        case resourceArn
        case resourceId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let destinationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationArn)
        destinationArn = destinationArnDecoded
    }
}

enum CreateAccessLogSubscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateListenerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case defaultAction
        case name
        case port
        case `protocol` = "protocol"
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let defaultAction = self.defaultAction {
            try encodeContainer.encode(defaultAction, forKey: .defaultAction)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateListenerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceIdentifier = serviceIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners"
    }
}

public struct CreateListenerInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The action for the default rule. Each listener has a default rule. Each rule consists of a priority, one or more actions, and one or more conditions. The default rule is the rule that's used if no other rules match. Each rule must include exactly one of the following types of actions: forward or fixed-response, and it must be the last action to be performed.
    /// This member is required.
    public var defaultAction: VPCLatticeClientTypes.RuleAction?
    /// The name of the listener. A listener name must be unique within a service. The valid characters are a-z, 0-9, and hyphens (-). You can't use a hyphen as the first or last character, or immediately after another hyphen.
    /// This member is required.
    public var name: Swift.String?
    /// The listener port. You can specify a value from 1 to 65535. For HTTP, the default is 80. For HTTPS, the default is 443.
    public var port: Swift.Int?
    /// The listener protocol HTTP or HTTPS.
    /// This member is required.
    public var `protocol`: VPCLatticeClientTypes.ListenerProtocol?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?
    /// The tags for the listener.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        defaultAction: VPCLatticeClientTypes.RuleAction? = nil,
        name: Swift.String? = nil,
        port: Swift.Int? = nil,
        `protocol`: VPCLatticeClientTypes.ListenerProtocol? = nil,
        serviceIdentifier: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.defaultAction = defaultAction
        self.name = name
        self.port = port
        self.`protocol` = `protocol`
        self.serviceIdentifier = serviceIdentifier
        self.tags = tags
    }
}

struct CreateListenerInputBody: Swift.Equatable {
    let name: Swift.String?
    let `protocol`: VPCLatticeClientTypes.ListenerProtocol?
    let port: Swift.Int?
    let defaultAction: VPCLatticeClientTypes.RuleAction?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateListenerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case defaultAction
        case name
        case port
        case `protocol` = "protocol"
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ListenerProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let defaultActionDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleAction.self, forKey: .defaultAction)
        defaultAction = defaultActionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateListenerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateListenerOutputBody = try responseDecoder.decode(responseBody: data)
            self.`protocol` = output.`protocol`
            self.arn = output.arn
            self.defaultAction = output.defaultAction
            self.id = output.id
            self.name = output.name
            self.port = output.port
            self.serviceArn = output.serviceArn
            self.serviceId = output.serviceId
        } else {
            self.arn = nil
            self.defaultAction = nil
            self.id = nil
            self.name = nil
            self.port = nil
            self.`protocol` = nil
            self.serviceArn = nil
            self.serviceId = nil
        }
    }
}

public struct CreateListenerOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the listener.
    public var arn: Swift.String?
    /// The action for the default rule.
    public var defaultAction: VPCLatticeClientTypes.RuleAction?
    /// The ID of the listener.
    public var id: Swift.String?
    /// The name of the listener.
    public var name: Swift.String?
    /// The port number of the listener.
    public var port: Swift.Int?
    /// The protocol of the listener.
    public var `protocol`: VPCLatticeClientTypes.ListenerProtocol?
    /// The Amazon Resource Name (ARN) of the service.
    public var serviceArn: Swift.String?
    /// The ID of the service.
    public var serviceId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        defaultAction: VPCLatticeClientTypes.RuleAction? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        port: Swift.Int? = nil,
        `protocol`: VPCLatticeClientTypes.ListenerProtocol? = nil,
        serviceArn: Swift.String? = nil,
        serviceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.defaultAction = defaultAction
        self.id = id
        self.name = name
        self.port = port
        self.`protocol` = `protocol`
        self.serviceArn = serviceArn
        self.serviceId = serviceId
    }
}

struct CreateListenerOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let `protocol`: VPCLatticeClientTypes.ListenerProtocol?
    let port: Swift.Int?
    let serviceArn: Swift.String?
    let serviceId: Swift.String?
    let defaultAction: VPCLatticeClientTypes.RuleAction?
}

extension CreateListenerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case defaultAction
        case id
        case name
        case port
        case `protocol` = "protocol"
        case serviceArn
        case serviceId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ListenerProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let defaultActionDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleAction.self, forKey: .defaultAction)
        defaultAction = defaultActionDecoded
    }
}

enum CreateListenerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case clientToken
        case match
        case name
        case priority
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let match = self.match {
            try encodeContainer.encode(match, forKey: .match)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceIdentifier = serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = listenerIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())/rules"
    }
}

public struct CreateRuleInput: Swift.Equatable {
    /// The action for the default rule.
    /// This member is required.
    public var action: VPCLatticeClientTypes.RuleAction?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The rule match.
    /// This member is required.
    public var match: VPCLatticeClientTypes.RuleMatch?
    /// The name of the rule. The name must be unique within the listener. The valid characters are a-z, 0-9, and hyphens (-). You can't use a hyphen as the first or last character, or immediately after another hyphen.
    /// This member is required.
    public var name: Swift.String?
    /// The priority assigned to the rule. Each rule for a specific listener must have a unique priority. The lower the priority number the higher the priority.
    /// This member is required.
    public var priority: Swift.Int?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?
    /// The tags for the rule.
    public var tags: [Swift.String:Swift.String]?

    public init(
        action: VPCLatticeClientTypes.RuleAction? = nil,
        clientToken: Swift.String? = nil,
        listenerIdentifier: Swift.String? = nil,
        match: VPCLatticeClientTypes.RuleMatch? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil,
        serviceIdentifier: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.action = action
        self.clientToken = clientToken
        self.listenerIdentifier = listenerIdentifier
        self.match = match
        self.name = name
        self.priority = priority
        self.serviceIdentifier = serviceIdentifier
        self.tags = tags
    }
}

struct CreateRuleInputBody: Swift.Equatable {
    let name: Swift.String?
    let match: VPCLatticeClientTypes.RuleMatch?
    let priority: Swift.Int?
    let action: VPCLatticeClientTypes.RuleAction?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case clientToken
        case match
        case name
        case priority
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let matchDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleMatch.self, forKey: .match)
        match = matchDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let actionDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleAction.self, forKey: .action)
        action = actionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.action = output.action
            self.arn = output.arn
            self.id = output.id
            self.match = output.match
            self.name = output.name
            self.priority = output.priority
        } else {
            self.action = nil
            self.arn = nil
            self.id = nil
            self.match = nil
            self.name = nil
            self.priority = nil
        }
    }
}

public struct CreateRuleOutput: Swift.Equatable {
    /// The rule action. Each rule must include exactly one of the following types of actions: forward or fixed-response, and it must be the last action to be performed.
    public var action: VPCLatticeClientTypes.RuleAction?
    /// The Amazon Resource Name (ARN) of the rule.
    public var arn: Swift.String?
    /// The ID of the rule.
    public var id: Swift.String?
    /// The rule match. The RuleMatch must be an HttpMatch. This means that the rule should be an exact match on HTTP constraints which are made up of the HTTP method, path, and header.
    public var match: VPCLatticeClientTypes.RuleMatch?
    /// The name of the rule.
    public var name: Swift.String?
    /// The priority assigned to the rule. The lower the priority number the higher the priority.
    public var priority: Swift.Int?

    public init(
        action: VPCLatticeClientTypes.RuleAction? = nil,
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        match: VPCLatticeClientTypes.RuleMatch? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil
    )
    {
        self.action = action
        self.arn = arn
        self.id = id
        self.match = match
        self.name = name
        self.priority = priority
    }
}

struct CreateRuleOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let match: VPCLatticeClientTypes.RuleMatch?
    let priority: Swift.Int?
    let action: VPCLatticeClientTypes.RuleAction?
}

extension CreateRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case arn
        case id
        case match
        case name
        case priority
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let matchDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleMatch.self, forKey: .match)
        match = matchDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let actionDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleAction.self, forKey: .action)
        action = actionDecoded
    }
}

enum CreateRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateServiceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType
        case certificateArn
        case clientToken
        case customDomainName
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authType = self.authType {
            try encodeContainer.encode(authType.rawValue, forKey: .authType)
        }
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let customDomainName = self.customDomainName {
            try encodeContainer.encode(customDomainName, forKey: .customDomainName)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/services"
    }
}

public struct CreateServiceInput: Swift.Equatable {
    /// The type of IAM policy.
    ///
    /// * NONE: The resource does not use an IAM policy. This is the default.
    ///
    /// * AWS_IAM: The resource uses an IAM policy. When this type is used, auth is enabled and an auth policy is required.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The Amazon Resource Name (ARN) of the certificate.
    public var certificateArn: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The custom domain name of the service.
    public var customDomainName: Swift.String?
    /// The name of the service. The name must be unique within the account. The valid characters are a-z, 0-9, and hyphens (-). You can't use a hyphen as the first or last character, or immediately after another hyphen.
    /// This member is required.
    public var name: Swift.String?
    /// The tags for the service.
    public var tags: [Swift.String:Swift.String]?

    public init(
        authType: VPCLatticeClientTypes.AuthType? = nil,
        certificateArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        customDomainName: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.authType = authType
        self.certificateArn = certificateArn
        self.clientToken = clientToken
        self.customDomainName = customDomainName
        self.name = name
        self.tags = tags
    }
}

struct CreateServiceInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let customDomainName: Swift.String?
    let certificateArn: Swift.String?
    let authType: VPCLatticeClientTypes.AuthType?
}

extension CreateServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType
        case certificateArn
        case clientToken
        case customDomainName
        case name
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let customDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomainName)
        customDomainName = customDomainNameDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.AuthType.self, forKey: .authType)
        authType = authTypeDecoded
    }
}

extension CreateServiceNetworkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType
        case clientToken
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authType = self.authType {
            try encodeContainer.encode(authType.rawValue, forKey: .authType)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateServiceNetworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/servicenetworks"
    }
}

public struct CreateServiceNetworkInput: Swift.Equatable {
    /// The type of IAM policy.
    ///
    /// * NONE: The resource does not use an IAM policy. This is the default.
    ///
    /// * AWS_IAM: The resource uses an IAM policy. When this type is used, auth is enabled and an auth policy is required.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The name of the service network. The name must be unique to the account. The valid characters are a-z, 0-9, and hyphens (-). You can't use a hyphen as the first or last character, or immediately after another hyphen.
    /// This member is required.
    public var name: Swift.String?
    /// The tags for the service network.
    public var tags: [Swift.String:Swift.String]?

    public init(
        authType: VPCLatticeClientTypes.AuthType? = nil,
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.authType = authType
        self.clientToken = clientToken
        self.name = name
        self.tags = tags
    }
}

struct CreateServiceNetworkInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let name: Swift.String?
    let authType: VPCLatticeClientTypes.AuthType?
    let tags: [Swift.String:Swift.String]?
}

extension CreateServiceNetworkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType
        case clientToken
        case name
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.AuthType.self, forKey: .authType)
        authType = authTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateServiceNetworkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateServiceNetworkOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.authType = output.authType
            self.id = output.id
            self.name = output.name
        } else {
            self.arn = nil
            self.authType = nil
            self.id = nil
            self.name = nil
        }
    }
}

public struct CreateServiceNetworkOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the service network.
    public var arn: Swift.String?
    /// The type of IAM policy.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The ID of the service network.
    public var id: Swift.String?
    /// The name of the service network.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        authType: VPCLatticeClientTypes.AuthType? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.authType = authType
        self.id = id
        self.name = name
    }
}

struct CreateServiceNetworkOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let authType: VPCLatticeClientTypes.AuthType?
}

extension CreateServiceNetworkOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case authType
        case id
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.AuthType.self, forKey: .authType)
        authType = authTypeDecoded
    }
}

enum CreateServiceNetworkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateServiceNetworkServiceAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case serviceIdentifier
        case serviceNetworkIdentifier
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let serviceIdentifier = self.serviceIdentifier {
            try encodeContainer.encode(serviceIdentifier, forKey: .serviceIdentifier)
        }
        if let serviceNetworkIdentifier = self.serviceNetworkIdentifier {
            try encodeContainer.encode(serviceNetworkIdentifier, forKey: .serviceNetworkIdentifier)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateServiceNetworkServiceAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/servicenetworkserviceassociations"
    }
}

public struct CreateServiceNetworkServiceAssociationInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service network. You must use the ARN if the resources specified in the operation are in different accounts.
    /// This member is required.
    public var serviceNetworkIdentifier: Swift.String?
    /// The tags for the association.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil,
        serviceNetworkIdentifier: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.serviceIdentifier = serviceIdentifier
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
        self.tags = tags
    }
}

struct CreateServiceNetworkServiceAssociationInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let serviceIdentifier: Swift.String?
    let serviceNetworkIdentifier: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateServiceNetworkServiceAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case serviceIdentifier
        case serviceNetworkIdentifier
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let serviceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceIdentifier)
        serviceIdentifier = serviceIdentifierDecoded
        let serviceNetworkIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceNetworkIdentifier)
        serviceNetworkIdentifier = serviceNetworkIdentifierDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateServiceNetworkServiceAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateServiceNetworkServiceAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdBy = output.createdBy
            self.customDomainName = output.customDomainName
            self.dnsEntry = output.dnsEntry
            self.id = output.id
            self.status = output.status
        } else {
            self.arn = nil
            self.createdBy = nil
            self.customDomainName = nil
            self.dnsEntry = nil
            self.id = nil
            self.status = nil
        }
    }
}

public struct CreateServiceNetworkServiceAssociationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The account that created the association.
    public var createdBy: Swift.String?
    /// The custom domain name of the service.
    public var customDomainName: Swift.String?
    /// The DNS name of the service.
    public var dnsEntry: VPCLatticeClientTypes.DnsEntry?
    /// The ID of the association.
    public var id: Swift.String?
    /// The operation's status.
    public var status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus?

    public init(
        arn: Swift.String? = nil,
        createdBy: Swift.String? = nil,
        customDomainName: Swift.String? = nil,
        dnsEntry: VPCLatticeClientTypes.DnsEntry? = nil,
        id: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus? = nil
    )
    {
        self.arn = arn
        self.createdBy = createdBy
        self.customDomainName = customDomainName
        self.dnsEntry = dnsEntry
        self.id = id
        self.status = status
    }
}

struct CreateServiceNetworkServiceAssociationOutputBody: Swift.Equatable {
    let id: Swift.String?
    let status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus?
    let arn: Swift.String?
    let createdBy: Swift.String?
    let customDomainName: Swift.String?
    let dnsEntry: VPCLatticeClientTypes.DnsEntry?
}

extension CreateServiceNetworkServiceAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdBy
        case customDomainName
        case dnsEntry
        case id
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let customDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomainName)
        customDomainName = customDomainNameDecoded
        let dnsEntryDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.DnsEntry.self, forKey: .dnsEntry)
        dnsEntry = dnsEntryDecoded
    }
}

enum CreateServiceNetworkServiceAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateServiceNetworkVpcAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case securityGroupIds
        case serviceNetworkIdentifier
        case tags
        case vpcIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let serviceNetworkIdentifier = self.serviceNetworkIdentifier {
            try encodeContainer.encode(serviceNetworkIdentifier, forKey: .serviceNetworkIdentifier)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vpcIdentifier = self.vpcIdentifier {
            try encodeContainer.encode(vpcIdentifier, forKey: .vpcIdentifier)
        }
    }
}

extension CreateServiceNetworkVpcAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/servicenetworkvpcassociations"
    }
}

public struct CreateServiceNetworkVpcAssociationInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The IDs of the security groups. Security groups aren't added by default. You can add a security group to apply network level controls to control which resources in a VPC are allowed to access the service network and its services. For more information, see [Control traffic to resources using security groups](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html) in the Amazon VPC User Guide.
    public var securityGroupIds: [Swift.String]?
    /// The ID or Amazon Resource Name (ARN) of the service network. You must use the ARN when the resources specified in the operation are in different accounts.
    /// This member is required.
    public var serviceNetworkIdentifier: Swift.String?
    /// The tags for the association.
    public var tags: [Swift.String:Swift.String]?
    /// The ID of the VPC.
    /// This member is required.
    public var vpcIdentifier: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        serviceNetworkIdentifier: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcIdentifier: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.securityGroupIds = securityGroupIds
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
        self.tags = tags
        self.vpcIdentifier = vpcIdentifier
    }
}

struct CreateServiceNetworkVpcAssociationInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let serviceNetworkIdentifier: Swift.String?
    let vpcIdentifier: Swift.String?
    let securityGroupIds: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateServiceNetworkVpcAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case securityGroupIds
        case serviceNetworkIdentifier
        case tags
        case vpcIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let serviceNetworkIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceNetworkIdentifier)
        serviceNetworkIdentifier = serviceNetworkIdentifierDecoded
        let vpcIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcIdentifier)
        vpcIdentifier = vpcIdentifierDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateServiceNetworkVpcAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateServiceNetworkVpcAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdBy = output.createdBy
            self.id = output.id
            self.securityGroupIds = output.securityGroupIds
            self.status = output.status
        } else {
            self.arn = nil
            self.createdBy = nil
            self.id = nil
            self.securityGroupIds = nil
            self.status = nil
        }
    }
}

public struct CreateServiceNetworkVpcAssociationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The account that created the association.
    public var createdBy: Swift.String?
    /// The ID of the association.
    public var id: Swift.String?
    /// The IDs of the security groups.
    public var securityGroupIds: [Swift.String]?
    /// The operation's status.
    public var status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus?

    public init(
        arn: Swift.String? = nil,
        createdBy: Swift.String? = nil,
        id: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus? = nil
    )
    {
        self.arn = arn
        self.createdBy = createdBy
        self.id = id
        self.securityGroupIds = securityGroupIds
        self.status = status
    }
}

struct CreateServiceNetworkVpcAssociationOutputBody: Swift.Equatable {
    let id: Swift.String?
    let status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus?
    let arn: Swift.String?
    let createdBy: Swift.String?
    let securityGroupIds: [Swift.String]?
}

extension CreateServiceNetworkVpcAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdBy
        case id
        case securityGroupIds
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

enum CreateServiceNetworkVpcAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateServiceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateServiceOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.authType = output.authType
            self.certificateArn = output.certificateArn
            self.customDomainName = output.customDomainName
            self.dnsEntry = output.dnsEntry
            self.id = output.id
            self.name = output.name
            self.status = output.status
        } else {
            self.arn = nil
            self.authType = nil
            self.certificateArn = nil
            self.customDomainName = nil
            self.dnsEntry = nil
            self.id = nil
            self.name = nil
            self.status = nil
        }
    }
}

public struct CreateServiceOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the service.
    public var arn: Swift.String?
    /// The type of IAM policy.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The Amazon Resource Name (ARN) of the certificate.
    public var certificateArn: Swift.String?
    /// The custom domain name of the service.
    public var customDomainName: Swift.String?
    /// The public DNS name of the service.
    public var dnsEntry: VPCLatticeClientTypes.DnsEntry?
    /// The ID of the service.
    public var id: Swift.String?
    /// The name of the service.
    public var name: Swift.String?
    /// The status. If the status is CREATE_FAILED, you will have to delete and recreate the service.
    public var status: VPCLatticeClientTypes.ServiceStatus?

    public init(
        arn: Swift.String? = nil,
        authType: VPCLatticeClientTypes.AuthType? = nil,
        certificateArn: Swift.String? = nil,
        customDomainName: Swift.String? = nil,
        dnsEntry: VPCLatticeClientTypes.DnsEntry? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceStatus? = nil
    )
    {
        self.arn = arn
        self.authType = authType
        self.certificateArn = certificateArn
        self.customDomainName = customDomainName
        self.dnsEntry = dnsEntry
        self.id = id
        self.name = name
        self.status = status
    }
}

struct CreateServiceOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let customDomainName: Swift.String?
    let certificateArn: Swift.String?
    let status: VPCLatticeClientTypes.ServiceStatus?
    let authType: VPCLatticeClientTypes.AuthType?
    let dnsEntry: VPCLatticeClientTypes.DnsEntry?
}

extension CreateServiceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case authType
        case certificateArn
        case customDomainName
        case dnsEntry
        case id
        case name
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let customDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomainName)
        customDomainName = customDomainNameDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ServiceStatus.self, forKey: .status)
        status = statusDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.AuthType.self, forKey: .authType)
        authType = authTypeDecoded
        let dnsEntryDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.DnsEntry.self, forKey: .dnsEntry)
        dnsEntry = dnsEntryDecoded
    }
}

enum CreateServiceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateTargetGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case config
        case name
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let config = self.config {
            try encodeContainer.encode(config, forKey: .config)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateTargetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/targetgroups"
    }
}

public struct CreateTargetGroupInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The target group configuration. If type is set to LAMBDA, this parameter doesn't apply.
    public var config: VPCLatticeClientTypes.TargetGroupConfig?
    /// The name of the target group. The name must be unique within the account. The valid characters are a-z, 0-9, and hyphens (-). You can't use a hyphen as the first or last character, or immediately after another hyphen.
    /// This member is required.
    public var name: Swift.String?
    /// The tags for the target group.
    public var tags: [Swift.String:Swift.String]?
    /// The type of target group.
    /// This member is required.
    public var type: VPCLatticeClientTypes.TargetGroupType?

    public init(
        clientToken: Swift.String? = nil,
        config: VPCLatticeClientTypes.TargetGroupConfig? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: VPCLatticeClientTypes.TargetGroupType? = nil
    )
    {
        self.clientToken = clientToken
        self.config = config
        self.name = name
        self.tags = tags
        self.type = type
    }
}

struct CreateTargetGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let type: VPCLatticeClientTypes.TargetGroupType?
    let config: VPCLatticeClientTypes.TargetGroupConfig?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateTargetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case config
        case name
        case tags
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetGroupType.self, forKey: .type)
        type = typeDecoded
        let configDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetGroupConfig.self, forKey: .config)
        config = configDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateTargetGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateTargetGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.config = output.config
            self.id = output.id
            self.name = output.name
            self.status = output.status
            self.type = output.type
        } else {
            self.arn = nil
            self.config = nil
            self.id = nil
            self.name = nil
            self.status = nil
            self.type = nil
        }
    }
}

public struct CreateTargetGroupOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the target group.
    public var arn: Swift.String?
    /// The target group configuration. If type is set to LAMBDA, this parameter doesn't apply.
    public var config: VPCLatticeClientTypes.TargetGroupConfig?
    /// The ID of the target group.
    public var id: Swift.String?
    /// The name of the target group.
    public var name: Swift.String?
    /// The operation's status. You can retry the operation if the status is CREATE_FAILED. However, if you retry it while the status is CREATE_IN_PROGRESS, there is no change in the status.
    public var status: VPCLatticeClientTypes.TargetGroupStatus?
    /// The type of target group.
    public var type: VPCLatticeClientTypes.TargetGroupType?

    public init(
        arn: Swift.String? = nil,
        config: VPCLatticeClientTypes.TargetGroupConfig? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: VPCLatticeClientTypes.TargetGroupStatus? = nil,
        type: VPCLatticeClientTypes.TargetGroupType? = nil
    )
    {
        self.arn = arn
        self.config = config
        self.id = id
        self.name = name
        self.status = status
        self.type = type
    }
}

struct CreateTargetGroupOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let type: VPCLatticeClientTypes.TargetGroupType?
    let config: VPCLatticeClientTypes.TargetGroupConfig?
    let status: VPCLatticeClientTypes.TargetGroupStatus?
}

extension CreateTargetGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case config
        case id
        case name
        case status
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetGroupType.self, forKey: .type)
        type = typeDecoded
        let configDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetGroupConfig.self, forKey: .config)
        config = configDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetGroupStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum CreateTargetGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAccessLogSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accessLogSubscriptionIdentifier = accessLogSubscriptionIdentifier else {
            return nil
        }
        return "/accesslogsubscriptions/\(accessLogSubscriptionIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteAccessLogSubscriptionInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the access log subscription.
    /// This member is required.
    public var accessLogSubscriptionIdentifier: Swift.String?

    public init(
        accessLogSubscriptionIdentifier: Swift.String? = nil
    )
    {
        self.accessLogSubscriptionIdentifier = accessLogSubscriptionIdentifier
    }
}

struct DeleteAccessLogSubscriptionInputBody: Swift.Equatable {
}

extension DeleteAccessLogSubscriptionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAccessLogSubscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAccessLogSubscriptionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccessLogSubscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAuthPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceIdentifier = resourceIdentifier else {
            return nil
        }
        return "/authpolicy/\(resourceIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteAuthPolicyInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceIdentifier: Swift.String?

    public init(
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
    }
}

struct DeleteAuthPolicyInputBody: Swift.Equatable {
}

extension DeleteAuthPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAuthPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAuthPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAuthPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteListenerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceIdentifier = serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = listenerIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteListenerInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        listenerIdentifier: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.listenerIdentifier = listenerIdentifier
        self.serviceIdentifier = serviceIdentifier
    }
}

struct DeleteListenerInputBody: Swift.Equatable {
}

extension DeleteListenerInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteListenerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteListenerOutput: Swift.Equatable {

    public init() { }
}

enum DeleteListenerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/resourcepolicy/\(resourceArn.urlPercentEncoding())"
    }
}

public struct DeleteResourcePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct DeleteResourcePolicyInputBody: Swift.Equatable {
}

extension DeleteResourcePolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteResourcePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteResourcePolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteResourcePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceIdentifier = serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = listenerIdentifier else {
            return nil
        }
        guard let ruleIdentifier = ruleIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())/rules/\(ruleIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteRuleInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the rule.
    /// This member is required.
    public var ruleIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        listenerIdentifier: Swift.String? = nil,
        ruleIdentifier: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.listenerIdentifier = listenerIdentifier
        self.ruleIdentifier = ruleIdentifier
        self.serviceIdentifier = serviceIdentifier
    }
}

struct DeleteRuleInputBody: Swift.Equatable {
}

extension DeleteRuleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRuleOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceIdentifier = serviceIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteServiceInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.serviceIdentifier = serviceIdentifier
    }
}

struct DeleteServiceInputBody: Swift.Equatable {
}

extension DeleteServiceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteServiceNetworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceNetworkIdentifier = serviceNetworkIdentifier else {
            return nil
        }
        return "/servicenetworks/\(serviceNetworkIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteServiceNetworkInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) or ID of the service network.
    /// This member is required.
    public var serviceNetworkIdentifier: Swift.String?

    public init(
        serviceNetworkIdentifier: Swift.String? = nil
    )
    {
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
    }
}

struct DeleteServiceNetworkInputBody: Swift.Equatable {
}

extension DeleteServiceNetworkInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteServiceNetworkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteServiceNetworkOutput: Swift.Equatable {

    public init() { }
}

enum DeleteServiceNetworkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteServiceNetworkServiceAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceNetworkServiceAssociationIdentifier = serviceNetworkServiceAssociationIdentifier else {
            return nil
        }
        return "/servicenetworkserviceassociations/\(serviceNetworkServiceAssociationIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteServiceNetworkServiceAssociationInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the association.
    /// This member is required.
    public var serviceNetworkServiceAssociationIdentifier: Swift.String?

    public init(
        serviceNetworkServiceAssociationIdentifier: Swift.String? = nil
    )
    {
        self.serviceNetworkServiceAssociationIdentifier = serviceNetworkServiceAssociationIdentifier
    }
}

struct DeleteServiceNetworkServiceAssociationInputBody: Swift.Equatable {
}

extension DeleteServiceNetworkServiceAssociationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteServiceNetworkServiceAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteServiceNetworkServiceAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.status = output.status
        } else {
            self.arn = nil
            self.id = nil
            self.status = nil
        }
    }
}

public struct DeleteServiceNetworkServiceAssociationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The ID of the association.
    public var id: Swift.String?
    /// The operation's status. You can retry the operation if the status is DELETE_FAILED. However, if you retry it when the status is DELETE_IN_PROGRESS, there is no change in the status.
    public var status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.status = status
    }
}

struct DeleteServiceNetworkServiceAssociationOutputBody: Swift.Equatable {
    let id: Swift.String?
    let status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus?
    let arn: Swift.String?
}

extension DeleteServiceNetworkServiceAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum DeleteServiceNetworkServiceAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteServiceNetworkVpcAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceNetworkVpcAssociationIdentifier = serviceNetworkVpcAssociationIdentifier else {
            return nil
        }
        return "/servicenetworkvpcassociations/\(serviceNetworkVpcAssociationIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteServiceNetworkVpcAssociationInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the association.
    /// This member is required.
    public var serviceNetworkVpcAssociationIdentifier: Swift.String?

    public init(
        serviceNetworkVpcAssociationIdentifier: Swift.String? = nil
    )
    {
        self.serviceNetworkVpcAssociationIdentifier = serviceNetworkVpcAssociationIdentifier
    }
}

struct DeleteServiceNetworkVpcAssociationInputBody: Swift.Equatable {
}

extension DeleteServiceNetworkVpcAssociationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteServiceNetworkVpcAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteServiceNetworkVpcAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.status = output.status
        } else {
            self.arn = nil
            self.id = nil
            self.status = nil
        }
    }
}

public struct DeleteServiceNetworkVpcAssociationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The ID of the association.
    public var id: Swift.String?
    /// The status. You can retry the operation if the status is DELETE_FAILED. However, if you retry it when the status is DELETE_IN_PROGRESS, there is no change in the status.
    public var status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.status = status
    }
}

struct DeleteServiceNetworkVpcAssociationOutputBody: Swift.Equatable {
    let id: Swift.String?
    let status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus?
    let arn: Swift.String?
}

extension DeleteServiceNetworkVpcAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum DeleteServiceNetworkVpcAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteServiceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteServiceOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.name = output.name
            self.status = output.status
        } else {
            self.arn = nil
            self.id = nil
            self.name = nil
            self.status = nil
        }
    }
}

public struct DeleteServiceOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the service.
    public var arn: Swift.String?
    /// The ID of the service.
    public var id: Swift.String?
    /// The name of the service.
    public var name: Swift.String?
    /// The status. You can retry the operation if the status is DELETE_FAILED. However, if you retry it while the status is DELETE_IN_PROGRESS, the status doesn't change.
    public var status: VPCLatticeClientTypes.ServiceStatus?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceStatus? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.name = name
        self.status = status
    }
}

struct DeleteServiceOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let status: VPCLatticeClientTypes.ServiceStatus?
}

extension DeleteServiceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case name
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ServiceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum DeleteServiceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteTargetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let targetGroupIdentifier = targetGroupIdentifier else {
            return nil
        }
        return "/targetgroups/\(targetGroupIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteTargetGroupInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the target group.
    /// This member is required.
    public var targetGroupIdentifier: Swift.String?

    public init(
        targetGroupIdentifier: Swift.String? = nil
    )
    {
        self.targetGroupIdentifier = targetGroupIdentifier
    }
}

struct DeleteTargetGroupInputBody: Swift.Equatable {
}

extension DeleteTargetGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTargetGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteTargetGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.status = output.status
        } else {
            self.arn = nil
            self.id = nil
            self.status = nil
        }
    }
}

public struct DeleteTargetGroupOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the target group.
    public var arn: Swift.String?
    /// The ID of the target group.
    public var id: Swift.String?
    /// The status. You can retry the operation if the status is DELETE_FAILED. However, if you retry it while the status is DELETE_IN_PROGRESS, the status doesn't change.
    public var status: VPCLatticeClientTypes.TargetGroupStatus?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        status: VPCLatticeClientTypes.TargetGroupStatus? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.status = status
    }
}

struct DeleteTargetGroupOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let status: VPCLatticeClientTypes.TargetGroupStatus?
}

extension DeleteTargetGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetGroupStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum DeleteTargetGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeregisterTargetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for target0 in targets {
                try targetsContainer.encode(target0)
            }
        }
    }
}

extension DeregisterTargetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let targetGroupIdentifier = targetGroupIdentifier else {
            return nil
        }
        return "/targetgroups/\(targetGroupIdentifier.urlPercentEncoding())/deregistertargets"
    }
}

public struct DeregisterTargetsInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the target group.
    /// This member is required.
    public var targetGroupIdentifier: Swift.String?
    /// The targets to deregister.
    /// This member is required.
    public var targets: [VPCLatticeClientTypes.Target]?

    public init(
        targetGroupIdentifier: Swift.String? = nil,
        targets: [VPCLatticeClientTypes.Target]? = nil
    )
    {
        self.targetGroupIdentifier = targetGroupIdentifier
        self.targets = targets
    }
}

struct DeregisterTargetsInputBody: Swift.Equatable {
    let targets: [VPCLatticeClientTypes.Target]?
}

extension DeregisterTargetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targets
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetsContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[VPCLatticeClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [VPCLatticeClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
    }
}

extension DeregisterTargetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeregisterTargetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.successful = output.successful
            self.unsuccessful = output.unsuccessful
        } else {
            self.successful = nil
            self.unsuccessful = nil
        }
    }
}

public struct DeregisterTargetsOutput: Swift.Equatable {
    /// The targets that were successfully deregistered.
    public var successful: [VPCLatticeClientTypes.Target]?
    /// The targets that the operation couldn't deregister.
    public var unsuccessful: [VPCLatticeClientTypes.TargetFailure]?

    public init(
        successful: [VPCLatticeClientTypes.Target]? = nil,
        unsuccessful: [VPCLatticeClientTypes.TargetFailure]? = nil
    )
    {
        self.successful = successful
        self.unsuccessful = unsuccessful
    }
}

struct DeregisterTargetsOutputBody: Swift.Equatable {
    let successful: [VPCLatticeClientTypes.Target]?
    let unsuccessful: [VPCLatticeClientTypes.TargetFailure]?
}

extension DeregisterTargetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case successful
        case unsuccessful
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.Target?].self, forKey: .successful)
        var successfulDecoded0:[VPCLatticeClientTypes.Target]? = nil
        if let successfulContainer = successfulContainer {
            successfulDecoded0 = [VPCLatticeClientTypes.Target]()
            for structure0 in successfulContainer {
                if let structure0 = structure0 {
                    successfulDecoded0?.append(structure0)
                }
            }
        }
        successful = successfulDecoded0
        let unsuccessfulContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.TargetFailure?].self, forKey: .unsuccessful)
        var unsuccessfulDecoded0:[VPCLatticeClientTypes.TargetFailure]? = nil
        if let unsuccessfulContainer = unsuccessfulContainer {
            unsuccessfulDecoded0 = [VPCLatticeClientTypes.TargetFailure]()
            for structure0 in unsuccessfulContainer {
                if let structure0 = structure0 {
                    unsuccessfulDecoded0?.append(structure0)
                }
            }
        }
        unsuccessful = unsuccessfulDecoded0
    }
}

enum DeregisterTargetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension VPCLatticeClientTypes.DnsEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName
        case hostedZoneId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let hostedZoneId = self.hostedZoneId {
            try encodeContainer.encode(hostedZoneId, forKey: .hostedZoneId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let hostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostedZoneId)
        hostedZoneId = hostedZoneIdDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Describes the DNS information of a service.
    public struct DnsEntry: Swift.Equatable {
        /// The domain name of the service.
        public var domainName: Swift.String?
        /// The ID of the hosted zone.
        public var hostedZoneId: Swift.String?

        public init(
            domainName: Swift.String? = nil,
            hostedZoneId: Swift.String? = nil
        )
        {
            self.domainName = domainName
            self.hostedZoneId = hostedZoneId
        }
    }

}

extension VPCLatticeClientTypes.FixedResponseAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statusCode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode, forKey: .statusCode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Information about an action that returns a custom HTTP response.
    public struct FixedResponseAction: Swift.Equatable {
        /// The HTTP response code.
        /// This member is required.
        public var statusCode: Swift.Int?

        public init(
            statusCode: Swift.Int? = nil
        )
        {
            self.statusCode = statusCode
        }
    }

}

extension VPCLatticeClientTypes.ForwardAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetGroups
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetGroups = targetGroups {
            var targetGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetGroups)
            for weightedtargetgroup0 in targetGroups {
                try targetGroupsContainer.encode(weightedtargetgroup0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetGroupsContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.WeightedTargetGroup?].self, forKey: .targetGroups)
        var targetGroupsDecoded0:[VPCLatticeClientTypes.WeightedTargetGroup]? = nil
        if let targetGroupsContainer = targetGroupsContainer {
            targetGroupsDecoded0 = [VPCLatticeClientTypes.WeightedTargetGroup]()
            for structure0 in targetGroupsContainer {
                if let structure0 = structure0 {
                    targetGroupsDecoded0?.append(structure0)
                }
            }
        }
        targetGroups = targetGroupsDecoded0
    }
}

extension VPCLatticeClientTypes {
    /// Describes a forward action. You can use forward actions to route requests to one or more target groups.
    public struct ForwardAction: Swift.Equatable {
        /// The target groups. Traffic matching the rule is forwarded to the specified target groups. With forward actions, you can assign a weight that controls the prioritization and selection of each target group. This means that requests are distributed to individual target groups based on their weights. For example, if two target groups have the same weight, each target group receives half of the traffic. The default value is 1. This means that if only one target group is provided, there is no need to set the weight; 100% of traffic will go to that target group.
        /// This member is required.
        public var targetGroups: [VPCLatticeClientTypes.WeightedTargetGroup]?

        public init(
            targetGroups: [VPCLatticeClientTypes.WeightedTargetGroup]? = nil
        )
        {
            self.targetGroups = targetGroups
        }
    }

}

extension GetAccessLogSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accessLogSubscriptionIdentifier = accessLogSubscriptionIdentifier else {
            return nil
        }
        return "/accesslogsubscriptions/\(accessLogSubscriptionIdentifier.urlPercentEncoding())"
    }
}

public struct GetAccessLogSubscriptionInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the access log subscription.
    /// This member is required.
    public var accessLogSubscriptionIdentifier: Swift.String?

    public init(
        accessLogSubscriptionIdentifier: Swift.String? = nil
    )
    {
        self.accessLogSubscriptionIdentifier = accessLogSubscriptionIdentifier
    }
}

struct GetAccessLogSubscriptionInputBody: Swift.Equatable {
}

extension GetAccessLogSubscriptionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAccessLogSubscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccessLogSubscriptionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.destinationArn = output.destinationArn
            self.id = output.id
            self.lastUpdatedAt = output.lastUpdatedAt
            self.resourceArn = output.resourceArn
            self.resourceId = output.resourceId
        } else {
            self.arn = nil
            self.createdAt = nil
            self.destinationArn = nil
            self.id = nil
            self.lastUpdatedAt = nil
            self.resourceArn = nil
            self.resourceId = nil
        }
    }
}

public struct GetAccessLogSubscriptionOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the access log subscription.
    /// This member is required.
    public var arn: Swift.String?
    /// The date and time that the access log subscription was created, specified in ISO-8601 format.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the access log destination.
    /// This member is required.
    public var destinationArn: Swift.String?
    /// The ID of the access log subscription.
    /// This member is required.
    public var id: Swift.String?
    /// The date and time that the access log subscription was last updated, specified in ISO-8601 format.
    /// This member is required.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the service network or service.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The ID of the service network or service.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        destinationArn: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        resourceArn: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.destinationArn = destinationArn
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.resourceArn = resourceArn
        self.resourceId = resourceId
    }
}

struct GetAccessLogSubscriptionOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let resourceId: Swift.String?
    let resourceArn: Swift.String?
    let destinationArn: Swift.String?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
}

extension GetAccessLogSubscriptionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case destinationArn
        case id
        case lastUpdatedAt
        case resourceArn
        case resourceId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let destinationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationArn)
        destinationArn = destinationArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

enum GetAccessLogSubscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAuthPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceIdentifier = resourceIdentifier else {
            return nil
        }
        return "/authpolicy/\(resourceIdentifier.urlPercentEncoding())"
    }
}

public struct GetAuthPolicyInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the service network or service.
    /// This member is required.
    public var resourceIdentifier: Swift.String?

    public init(
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
    }
}

struct GetAuthPolicyInputBody: Swift.Equatable {
}

extension GetAuthPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAuthPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAuthPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.lastUpdatedAt = output.lastUpdatedAt
            self.policy = output.policy
            self.state = output.state
        } else {
            self.createdAt = nil
            self.lastUpdatedAt = nil
            self.policy = nil
            self.state = nil
        }
    }
}

public struct GetAuthPolicyOutput: Swift.Equatable {
    /// The date and time that the auth policy was created, specified in ISO-8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The date and time that the auth policy was last updated, specified in ISO-8601 format.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The auth policy.
    public var policy: Swift.String?
    /// The state of the auth policy. The auth policy is only active when the auth type is set to Amazon Web Services_IAM. If you provide a policy, then authentication and authorization decisions are made based on this policy and the client's IAM policy. If the auth type is NONE, then any auth policy you provide will remain inactive. For more information, see [Create a service network](https://docs.aws.amazon.com/vpc-lattice/latest/ug/service-networks.html#create-service-network) in the Amazon VPC Lattice User Guide.
    public var state: VPCLatticeClientTypes.AuthPolicyState?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        policy: Swift.String? = nil,
        state: VPCLatticeClientTypes.AuthPolicyState? = nil
    )
    {
        self.createdAt = createdAt
        self.lastUpdatedAt = lastUpdatedAt
        self.policy = policy
        self.state = state
    }
}

struct GetAuthPolicyOutputBody: Swift.Equatable {
    let policy: Swift.String?
    let state: VPCLatticeClientTypes.AuthPolicyState?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
}

extension GetAuthPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case lastUpdatedAt
        case policy
        case state
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let stateDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.AuthPolicyState.self, forKey: .state)
        state = stateDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

enum GetAuthPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetListenerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceIdentifier = serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = listenerIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())"
    }
}

public struct GetListenerInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        listenerIdentifier: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.listenerIdentifier = listenerIdentifier
        self.serviceIdentifier = serviceIdentifier
    }
}

struct GetListenerInputBody: Swift.Equatable {
}

extension GetListenerInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetListenerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetListenerOutputBody = try responseDecoder.decode(responseBody: data)
            self.`protocol` = output.`protocol`
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.defaultAction = output.defaultAction
            self.id = output.id
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.port = output.port
            self.serviceArn = output.serviceArn
            self.serviceId = output.serviceId
        } else {
            self.arn = nil
            self.createdAt = nil
            self.defaultAction = nil
            self.id = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.port = nil
            self.`protocol` = nil
            self.serviceArn = nil
            self.serviceId = nil
        }
    }
}

public struct GetListenerOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the listener.
    public var arn: Swift.String?
    /// The date and time that the listener was created, specified in ISO-8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The actions for the default listener rule.
    public var defaultAction: VPCLatticeClientTypes.RuleAction?
    /// The ID of the listener.
    public var id: Swift.String?
    /// The date and time that the listener was last updated, specified in ISO-8601 format.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the listener.
    public var name: Swift.String?
    /// The listener port.
    public var port: Swift.Int?
    /// The listener protocol.
    public var `protocol`: VPCLatticeClientTypes.ListenerProtocol?
    /// The Amazon Resource Name (ARN) of the service.
    public var serviceArn: Swift.String?
    /// The ID of the service.
    public var serviceId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        defaultAction: VPCLatticeClientTypes.RuleAction? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        port: Swift.Int? = nil,
        `protocol`: VPCLatticeClientTypes.ListenerProtocol? = nil,
        serviceArn: Swift.String? = nil,
        serviceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.defaultAction = defaultAction
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.port = port
        self.`protocol` = `protocol`
        self.serviceArn = serviceArn
        self.serviceId = serviceId
    }
}

struct GetListenerOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let `protocol`: VPCLatticeClientTypes.ListenerProtocol?
    let port: Swift.Int?
    let serviceArn: Swift.String?
    let serviceId: Swift.String?
    let defaultAction: VPCLatticeClientTypes.RuleAction?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
}

extension GetListenerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case defaultAction
        case id
        case lastUpdatedAt
        case name
        case port
        case `protocol` = "protocol"
        case serviceArn
        case serviceId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ListenerProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let defaultActionDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleAction.self, forKey: .defaultAction)
        defaultAction = defaultActionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

enum GetListenerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/resourcepolicy/\(resourceArn.urlPercentEncoding())"
    }
}

public struct GetResourcePolicyInput: Swift.Equatable {
    /// An IAM policy.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct GetResourcePolicyInputBody: Swift.Equatable {
}

extension GetResourcePolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetResourcePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetResourcePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetResourcePolicyOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the service network or service.
    public var policy: Swift.String?

    public init(
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

struct GetResourcePolicyOutputBody: Swift.Equatable {
    let policy: Swift.String?
}

extension GetResourcePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum GetResourcePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceIdentifier = serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = listenerIdentifier else {
            return nil
        }
        guard let ruleIdentifier = ruleIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())/rules/\(ruleIdentifier.urlPercentEncoding())"
    }
}

public struct GetRuleInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the listener rule.
    /// This member is required.
    public var ruleIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        listenerIdentifier: Swift.String? = nil,
        ruleIdentifier: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.listenerIdentifier = listenerIdentifier
        self.ruleIdentifier = ruleIdentifier
        self.serviceIdentifier = serviceIdentifier
    }
}

struct GetRuleInputBody: Swift.Equatable {
}

extension GetRuleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.action = output.action
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.id = output.id
            self.isDefault = output.isDefault
            self.lastUpdatedAt = output.lastUpdatedAt
            self.match = output.match
            self.name = output.name
            self.priority = output.priority
        } else {
            self.action = nil
            self.arn = nil
            self.createdAt = nil
            self.id = nil
            self.isDefault = nil
            self.lastUpdatedAt = nil
            self.match = nil
            self.name = nil
            self.priority = nil
        }
    }
}

public struct GetRuleOutput: Swift.Equatable {
    /// The action for the default rule.
    public var action: VPCLatticeClientTypes.RuleAction?
    /// The Amazon Resource Name (ARN) of the listener.
    public var arn: Swift.String?
    /// The date and time that the listener rule was created, specified in ISO-8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The ID of the listener.
    public var id: Swift.String?
    /// Indicates whether this is the default rule.
    public var isDefault: Swift.Bool?
    /// The date and time that the listener rule was last updated, specified in ISO-8601 format.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The rule match.
    public var match: VPCLatticeClientTypes.RuleMatch?
    /// The name of the listener.
    public var name: Swift.String?
    /// The priority level for the specified rule.
    public var priority: Swift.Int?

    public init(
        action: VPCLatticeClientTypes.RuleAction? = nil,
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        isDefault: Swift.Bool? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        match: VPCLatticeClientTypes.RuleMatch? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil
    )
    {
        self.action = action
        self.arn = arn
        self.createdAt = createdAt
        self.id = id
        self.isDefault = isDefault
        self.lastUpdatedAt = lastUpdatedAt
        self.match = match
        self.name = name
        self.priority = priority
    }
}

struct GetRuleOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let isDefault: Swift.Bool?
    let match: VPCLatticeClientTypes.RuleMatch?
    let priority: Swift.Int?
    let action: VPCLatticeClientTypes.RuleAction?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
}

extension GetRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case arn
        case createdAt
        case id
        case isDefault
        case lastUpdatedAt
        case match
        case name
        case priority
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let isDefaultDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDefault)
        isDefault = isDefaultDecoded
        let matchDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleMatch.self, forKey: .match)
        match = matchDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let actionDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleAction.self, forKey: .action)
        action = actionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

enum GetRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceIdentifier = serviceIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())"
    }
}

public struct GetServiceInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.serviceIdentifier = serviceIdentifier
    }
}

struct GetServiceInputBody: Swift.Equatable {
}

extension GetServiceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetServiceNetworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceNetworkIdentifier = serviceNetworkIdentifier else {
            return nil
        }
        return "/servicenetworks/\(serviceNetworkIdentifier.urlPercentEncoding())"
    }
}

public struct GetServiceNetworkInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the service network.
    /// This member is required.
    public var serviceNetworkIdentifier: Swift.String?

    public init(
        serviceNetworkIdentifier: Swift.String? = nil
    )
    {
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
    }
}

struct GetServiceNetworkInputBody: Swift.Equatable {
}

extension GetServiceNetworkInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetServiceNetworkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetServiceNetworkOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.authType = output.authType
            self.createdAt = output.createdAt
            self.id = output.id
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.numberOfAssociatedServices = output.numberOfAssociatedServices
            self.numberOfAssociatedVPCs = output.numberOfAssociatedVPCs
        } else {
            self.arn = nil
            self.authType = nil
            self.createdAt = nil
            self.id = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.numberOfAssociatedServices = nil
            self.numberOfAssociatedVPCs = nil
        }
    }
}

public struct GetServiceNetworkOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the service network.
    public var arn: Swift.String?
    /// The type of IAM policy.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The date and time that the service network was created, specified in ISO-8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The ID of the service network.
    public var id: Swift.String?
    /// The date and time of the last update, specified in ISO-8601 format.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the service network.
    public var name: Swift.String?
    /// The number of services associated with the service network.
    public var numberOfAssociatedServices: Swift.Int?
    /// The number of VPCs associated with the service network.
    public var numberOfAssociatedVPCs: Swift.Int?

    public init(
        arn: Swift.String? = nil,
        authType: VPCLatticeClientTypes.AuthType? = nil,
        createdAt: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        numberOfAssociatedServices: Swift.Int? = nil,
        numberOfAssociatedVPCs: Swift.Int? = nil
    )
    {
        self.arn = arn
        self.authType = authType
        self.createdAt = createdAt
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.numberOfAssociatedServices = numberOfAssociatedServices
        self.numberOfAssociatedVPCs = numberOfAssociatedVPCs
    }
}

struct GetServiceNetworkOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
    let arn: Swift.String?
    let authType: VPCLatticeClientTypes.AuthType?
    let numberOfAssociatedVPCs: Swift.Int?
    let numberOfAssociatedServices: Swift.Int?
}

extension GetServiceNetworkOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case authType
        case createdAt
        case id
        case lastUpdatedAt
        case name
        case numberOfAssociatedServices
        case numberOfAssociatedVPCs
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.AuthType.self, forKey: .authType)
        authType = authTypeDecoded
        let numberOfAssociatedVPCsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfAssociatedVPCs)
        numberOfAssociatedVPCs = numberOfAssociatedVPCsDecoded
        let numberOfAssociatedServicesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfAssociatedServices)
        numberOfAssociatedServices = numberOfAssociatedServicesDecoded
    }
}

enum GetServiceNetworkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetServiceNetworkServiceAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceNetworkServiceAssociationIdentifier = serviceNetworkServiceAssociationIdentifier else {
            return nil
        }
        return "/servicenetworkserviceassociations/\(serviceNetworkServiceAssociationIdentifier.urlPercentEncoding())"
    }
}

public struct GetServiceNetworkServiceAssociationInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the association.
    /// This member is required.
    public var serviceNetworkServiceAssociationIdentifier: Swift.String?

    public init(
        serviceNetworkServiceAssociationIdentifier: Swift.String? = nil
    )
    {
        self.serviceNetworkServiceAssociationIdentifier = serviceNetworkServiceAssociationIdentifier
    }
}

struct GetServiceNetworkServiceAssociationInputBody: Swift.Equatable {
}

extension GetServiceNetworkServiceAssociationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetServiceNetworkServiceAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetServiceNetworkServiceAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.customDomainName = output.customDomainName
            self.dnsEntry = output.dnsEntry
            self.failureCode = output.failureCode
            self.failureMessage = output.failureMessage
            self.id = output.id
            self.serviceArn = output.serviceArn
            self.serviceId = output.serviceId
            self.serviceName = output.serviceName
            self.serviceNetworkArn = output.serviceNetworkArn
            self.serviceNetworkId = output.serviceNetworkId
            self.serviceNetworkName = output.serviceNetworkName
            self.status = output.status
        } else {
            self.arn = nil
            self.createdAt = nil
            self.createdBy = nil
            self.customDomainName = nil
            self.dnsEntry = nil
            self.failureCode = nil
            self.failureMessage = nil
            self.id = nil
            self.serviceArn = nil
            self.serviceId = nil
            self.serviceName = nil
            self.serviceNetworkArn = nil
            self.serviceNetworkId = nil
            self.serviceNetworkName = nil
            self.status = nil
        }
    }
}

public struct GetServiceNetworkServiceAssociationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The date and time that the association was created, specified in ISO-8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The account that created the association.
    public var createdBy: Swift.String?
    /// The custom domain name of the service.
    public var customDomainName: Swift.String?
    /// The DNS name of the service.
    public var dnsEntry: VPCLatticeClientTypes.DnsEntry?
    /// The failure code.
    public var failureCode: Swift.String?
    /// The failure message.
    public var failureMessage: Swift.String?
    /// The ID of the service network and service association.
    public var id: Swift.String?
    /// The Amazon Resource Name (ARN) of the service.
    public var serviceArn: Swift.String?
    /// The ID of the service.
    public var serviceId: Swift.String?
    /// The name of the service.
    public var serviceName: Swift.String?
    /// The Amazon Resource Name (ARN) of the service network.
    public var serviceNetworkArn: Swift.String?
    /// The ID of the service network.
    public var serviceNetworkId: Swift.String?
    /// The name of the service network.
    public var serviceNetworkName: Swift.String?
    /// The status of the association.
    public var status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus?

    public init(
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        customDomainName: Swift.String? = nil,
        dnsEntry: VPCLatticeClientTypes.DnsEntry? = nil,
        failureCode: Swift.String? = nil,
        failureMessage: Swift.String? = nil,
        id: Swift.String? = nil,
        serviceArn: Swift.String? = nil,
        serviceId: Swift.String? = nil,
        serviceName: Swift.String? = nil,
        serviceNetworkArn: Swift.String? = nil,
        serviceNetworkId: Swift.String? = nil,
        serviceNetworkName: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.customDomainName = customDomainName
        self.dnsEntry = dnsEntry
        self.failureCode = failureCode
        self.failureMessage = failureMessage
        self.id = id
        self.serviceArn = serviceArn
        self.serviceId = serviceId
        self.serviceName = serviceName
        self.serviceNetworkArn = serviceNetworkArn
        self.serviceNetworkId = serviceNetworkId
        self.serviceNetworkName = serviceNetworkName
        self.status = status
    }
}

struct GetServiceNetworkServiceAssociationOutputBody: Swift.Equatable {
    let id: Swift.String?
    let status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus?
    let arn: Swift.String?
    let createdBy: Swift.String?
    let createdAt: ClientRuntime.Date?
    let serviceId: Swift.String?
    let serviceName: Swift.String?
    let serviceArn: Swift.String?
    let serviceNetworkId: Swift.String?
    let serviceNetworkName: Swift.String?
    let serviceNetworkArn: Swift.String?
    let dnsEntry: VPCLatticeClientTypes.DnsEntry?
    let customDomainName: Swift.String?
    let failureMessage: Swift.String?
    let failureCode: Swift.String?
}

extension GetServiceNetworkServiceAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case createdBy
        case customDomainName
        case dnsEntry
        case failureCode
        case failureMessage
        case id
        case serviceArn
        case serviceId
        case serviceName
        case serviceNetworkArn
        case serviceNetworkId
        case serviceNetworkName
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let serviceNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceNetworkId)
        serviceNetworkId = serviceNetworkIdDecoded
        let serviceNetworkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceNetworkName)
        serviceNetworkName = serviceNetworkNameDecoded
        let serviceNetworkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceNetworkArn)
        serviceNetworkArn = serviceNetworkArnDecoded
        let dnsEntryDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.DnsEntry.self, forKey: .dnsEntry)
        dnsEntry = dnsEntryDecoded
        let customDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomainName)
        customDomainName = customDomainNameDecoded
        let failureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
    }
}

enum GetServiceNetworkServiceAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetServiceNetworkVpcAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceNetworkVpcAssociationIdentifier = serviceNetworkVpcAssociationIdentifier else {
            return nil
        }
        return "/servicenetworkvpcassociations/\(serviceNetworkVpcAssociationIdentifier.urlPercentEncoding())"
    }
}

public struct GetServiceNetworkVpcAssociationInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the association.
    /// This member is required.
    public var serviceNetworkVpcAssociationIdentifier: Swift.String?

    public init(
        serviceNetworkVpcAssociationIdentifier: Swift.String? = nil
    )
    {
        self.serviceNetworkVpcAssociationIdentifier = serviceNetworkVpcAssociationIdentifier
    }
}

struct GetServiceNetworkVpcAssociationInputBody: Swift.Equatable {
}

extension GetServiceNetworkVpcAssociationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetServiceNetworkVpcAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetServiceNetworkVpcAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.failureCode = output.failureCode
            self.failureMessage = output.failureMessage
            self.id = output.id
            self.lastUpdatedAt = output.lastUpdatedAt
            self.securityGroupIds = output.securityGroupIds
            self.serviceNetworkArn = output.serviceNetworkArn
            self.serviceNetworkId = output.serviceNetworkId
            self.serviceNetworkName = output.serviceNetworkName
            self.status = output.status
            self.vpcId = output.vpcId
        } else {
            self.arn = nil
            self.createdAt = nil
            self.createdBy = nil
            self.failureCode = nil
            self.failureMessage = nil
            self.id = nil
            self.lastUpdatedAt = nil
            self.securityGroupIds = nil
            self.serviceNetworkArn = nil
            self.serviceNetworkId = nil
            self.serviceNetworkName = nil
            self.status = nil
            self.vpcId = nil
        }
    }
}

public struct GetServiceNetworkVpcAssociationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The date and time that the association was created, specified in ISO-8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The account that created the association.
    public var createdBy: Swift.String?
    /// The failure code.
    public var failureCode: Swift.String?
    /// The failure message.
    public var failureMessage: Swift.String?
    /// The ID of the specified association between the service network and the VPC.
    public var id: Swift.String?
    /// The date and time that the association was last updated, specified in ISO-8601 format.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The IDs of the security groups.
    public var securityGroupIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the service network.
    public var serviceNetworkArn: Swift.String?
    /// The ID of the service network.
    public var serviceNetworkId: Swift.String?
    /// The name of the service network.
    public var serviceNetworkName: Swift.String?
    /// The status of the association.
    public var status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus?
    /// The ID of the VPC.
    public var vpcId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        failureCode: Swift.String? = nil,
        failureMessage: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        securityGroupIds: [Swift.String]? = nil,
        serviceNetworkArn: Swift.String? = nil,
        serviceNetworkId: Swift.String? = nil,
        serviceNetworkName: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.failureCode = failureCode
        self.failureMessage = failureMessage
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.securityGroupIds = securityGroupIds
        self.serviceNetworkArn = serviceNetworkArn
        self.serviceNetworkId = serviceNetworkId
        self.serviceNetworkName = serviceNetworkName
        self.status = status
        self.vpcId = vpcId
    }
}

struct GetServiceNetworkVpcAssociationOutputBody: Swift.Equatable {
    let id: Swift.String?
    let status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus?
    let arn: Swift.String?
    let createdBy: Swift.String?
    let createdAt: ClientRuntime.Date?
    let serviceNetworkId: Swift.String?
    let serviceNetworkName: Swift.String?
    let serviceNetworkArn: Swift.String?
    let vpcId: Swift.String?
    let securityGroupIds: [Swift.String]?
    let failureMessage: Swift.String?
    let failureCode: Swift.String?
    let lastUpdatedAt: ClientRuntime.Date?
}

extension GetServiceNetworkVpcAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case createdBy
        case failureCode
        case failureMessage
        case id
        case lastUpdatedAt
        case securityGroupIds
        case serviceNetworkArn
        case serviceNetworkId
        case serviceNetworkName
        case status
        case vpcId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let serviceNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceNetworkId)
        serviceNetworkId = serviceNetworkIdDecoded
        let serviceNetworkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceNetworkName)
        serviceNetworkName = serviceNetworkNameDecoded
        let serviceNetworkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceNetworkArn)
        serviceNetworkArn = serviceNetworkArnDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let failureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

enum GetServiceNetworkVpcAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetServiceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetServiceOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.authType = output.authType
            self.certificateArn = output.certificateArn
            self.createdAt = output.createdAt
            self.customDomainName = output.customDomainName
            self.dnsEntry = output.dnsEntry
            self.failureCode = output.failureCode
            self.failureMessage = output.failureMessage
            self.id = output.id
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.status = output.status
        } else {
            self.arn = nil
            self.authType = nil
            self.certificateArn = nil
            self.createdAt = nil
            self.customDomainName = nil
            self.dnsEntry = nil
            self.failureCode = nil
            self.failureMessage = nil
            self.id = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.status = nil
        }
    }
}

public struct GetServiceOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the service.
    public var arn: Swift.String?
    /// The type of IAM policy.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The Amazon Resource Name (ARN) of the certificate.
    public var certificateArn: Swift.String?
    /// The date and time that the service was created, specified in ISO-8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The custom domain name of the service.
    public var customDomainName: Swift.String?
    /// The DNS name of the service.
    public var dnsEntry: VPCLatticeClientTypes.DnsEntry?
    /// The failure code.
    public var failureCode: Swift.String?
    /// The failure message.
    public var failureMessage: Swift.String?
    /// The ID of the service.
    public var id: Swift.String?
    /// The date and time that the service was last updated, specified in ISO-8601 format.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the service.
    public var name: Swift.String?
    /// The status of the service.
    public var status: VPCLatticeClientTypes.ServiceStatus?

    public init(
        arn: Swift.String? = nil,
        authType: VPCLatticeClientTypes.AuthType? = nil,
        certificateArn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        customDomainName: Swift.String? = nil,
        dnsEntry: VPCLatticeClientTypes.DnsEntry? = nil,
        failureCode: Swift.String? = nil,
        failureMessage: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceStatus? = nil
    )
    {
        self.arn = arn
        self.authType = authType
        self.certificateArn = certificateArn
        self.createdAt = createdAt
        self.customDomainName = customDomainName
        self.dnsEntry = dnsEntry
        self.failureCode = failureCode
        self.failureMessage = failureMessage
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.status = status
    }
}

struct GetServiceOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
    let dnsEntry: VPCLatticeClientTypes.DnsEntry?
    let customDomainName: Swift.String?
    let certificateArn: Swift.String?
    let status: VPCLatticeClientTypes.ServiceStatus?
    let authType: VPCLatticeClientTypes.AuthType?
    let failureCode: Swift.String?
    let failureMessage: Swift.String?
}

extension GetServiceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case authType
        case certificateArn
        case createdAt
        case customDomainName
        case dnsEntry
        case failureCode
        case failureMessage
        case id
        case lastUpdatedAt
        case name
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let dnsEntryDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.DnsEntry.self, forKey: .dnsEntry)
        dnsEntry = dnsEntryDecoded
        let customDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomainName)
        customDomainName = customDomainNameDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ServiceStatus.self, forKey: .status)
        status = statusDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.AuthType.self, forKey: .authType)
        authType = authTypeDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
    }
}

enum GetServiceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTargetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let targetGroupIdentifier = targetGroupIdentifier else {
            return nil
        }
        return "/targetgroups/\(targetGroupIdentifier.urlPercentEncoding())"
    }
}

public struct GetTargetGroupInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the target group.
    /// This member is required.
    public var targetGroupIdentifier: Swift.String?

    public init(
        targetGroupIdentifier: Swift.String? = nil
    )
    {
        self.targetGroupIdentifier = targetGroupIdentifier
    }
}

struct GetTargetGroupInputBody: Swift.Equatable {
}

extension GetTargetGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetTargetGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTargetGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.config = output.config
            self.createdAt = output.createdAt
            self.failureCode = output.failureCode
            self.failureMessage = output.failureMessage
            self.id = output.id
            self.lastUpdatedAt = output.lastUpdatedAt
            self.name = output.name
            self.serviceArns = output.serviceArns
            self.status = output.status
            self.type = output.type
        } else {
            self.arn = nil
            self.config = nil
            self.createdAt = nil
            self.failureCode = nil
            self.failureMessage = nil
            self.id = nil
            self.lastUpdatedAt = nil
            self.name = nil
            self.serviceArns = nil
            self.status = nil
            self.type = nil
        }
    }
}

public struct GetTargetGroupOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the target group.
    public var arn: Swift.String?
    /// The target group configuration.
    public var config: VPCLatticeClientTypes.TargetGroupConfig?
    /// The date and time that the target group was created, specified in ISO-8601 format.
    public var createdAt: ClientRuntime.Date?
    /// The failure code.
    public var failureCode: Swift.String?
    /// The failure message.
    public var failureMessage: Swift.String?
    /// The ID of the target group.
    public var id: Swift.String?
    /// The date and time that the target group was last updated, specified in ISO-8601 format.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The name of the target group.
    public var name: Swift.String?
    /// The Amazon Resource Names (ARNs) of the service.
    public var serviceArns: [Swift.String]?
    /// The status.
    public var status: VPCLatticeClientTypes.TargetGroupStatus?
    /// The target group type.
    public var type: VPCLatticeClientTypes.TargetGroupType?

    public init(
        arn: Swift.String? = nil,
        config: VPCLatticeClientTypes.TargetGroupConfig? = nil,
        createdAt: ClientRuntime.Date? = nil,
        failureCode: Swift.String? = nil,
        failureMessage: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        serviceArns: [Swift.String]? = nil,
        status: VPCLatticeClientTypes.TargetGroupStatus? = nil,
        type: VPCLatticeClientTypes.TargetGroupType? = nil
    )
    {
        self.arn = arn
        self.config = config
        self.createdAt = createdAt
        self.failureCode = failureCode
        self.failureMessage = failureMessage
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.serviceArns = serviceArns
        self.status = status
        self.type = type
    }
}

struct GetTargetGroupOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let type: VPCLatticeClientTypes.TargetGroupType?
    let config: VPCLatticeClientTypes.TargetGroupConfig?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
    let status: VPCLatticeClientTypes.TargetGroupStatus?
    let serviceArns: [Swift.String]?
    let failureMessage: Swift.String?
    let failureCode: Swift.String?
}

extension GetTargetGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case config
        case createdAt
        case failureCode
        case failureMessage
        case id
        case lastUpdatedAt
        case name
        case serviceArns
        case status
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetGroupType.self, forKey: .type)
        type = typeDecoded
        let configDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetGroupConfig.self, forKey: .config)
        config = configDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetGroupStatus.self, forKey: .status)
        status = statusDecoded
        let serviceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .serviceArns)
        var serviceArnsDecoded0:[Swift.String]? = nil
        if let serviceArnsContainer = serviceArnsContainer {
            serviceArnsDecoded0 = [Swift.String]()
            for string0 in serviceArnsContainer {
                if let string0 = string0 {
                    serviceArnsDecoded0?.append(string0)
                }
            }
        }
        serviceArns = serviceArnsDecoded0
        let failureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
    }
}

enum GetTargetGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension VPCLatticeClientTypes.HeaderMatch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case caseSensitive
        case match
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let caseSensitive = self.caseSensitive {
            try encodeContainer.encode(caseSensitive, forKey: .caseSensitive)
        }
        if let match = self.match {
            try encodeContainer.encode(match, forKey: .match)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let matchDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.HeaderMatchType.self, forKey: .match)
        match = matchDecoded
        let caseSensitiveDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .caseSensitive)
        caseSensitive = caseSensitiveDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Describes the constraints for a header match. Matches incoming requests with rule based on request header value before applying rule action.
    public struct HeaderMatch: Swift.Equatable {
        /// Indicates whether the match is case sensitive. Defaults to false.
        public var caseSensitive: Swift.Bool?
        /// The header match type.
        /// This member is required.
        public var match: VPCLatticeClientTypes.HeaderMatchType?
        /// The name of the header.
        /// This member is required.
        public var name: Swift.String?

        public init(
            caseSensitive: Swift.Bool? = nil,
            match: VPCLatticeClientTypes.HeaderMatchType? = nil,
            name: Swift.String? = nil
        )
        {
            self.caseSensitive = caseSensitive
            self.match = match
            self.name = name
        }
    }

}

extension VPCLatticeClientTypes.HeaderMatchType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contains
        case exact
        case `prefix` = "prefix"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .contains(contains):
                try container.encode(contains, forKey: .contains)
            case let .exact(exact):
                try container.encode(exact, forKey: .exact)
            case let .`prefix`(`prefix`):
                try container.encode(`prefix`, forKey: .`prefix`)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let exactDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .exact)
        if let exact = exactDecoded {
            self = .exact(exact)
            return
        }
        let prefixDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .prefix)
        if let `prefix` = prefixDecoded {
            self = .`prefix`(`prefix`)
            return
        }
        let containsDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .contains)
        if let contains = containsDecoded {
            self = .contains(contains)
            return
        }
        self = .sdkUnknown("")
    }
}

extension VPCLatticeClientTypes {
    /// Describes a header match type. Only one can be provided.
    public enum HeaderMatchType: Swift.Equatable {
        /// Specifies an exact type match.
        case exact(Swift.String)
        /// Specifies a prefix type match. Matches the value with the prefix.
        case `prefix`(Swift.String)
        /// Specifies a contains type match.
        case contains(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension VPCLatticeClientTypes.HealthCheckConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
        case healthCheckIntervalSeconds
        case healthCheckTimeoutSeconds
        case healthyThresholdCount
        case matcher
        case path
        case port
        case `protocol` = "protocol"
        case protocolVersion
        case unhealthyThresholdCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let healthCheckIntervalSeconds = self.healthCheckIntervalSeconds {
            try encodeContainer.encode(healthCheckIntervalSeconds, forKey: .healthCheckIntervalSeconds)
        }
        if let healthCheckTimeoutSeconds = self.healthCheckTimeoutSeconds {
            try encodeContainer.encode(healthCheckTimeoutSeconds, forKey: .healthCheckTimeoutSeconds)
        }
        if let healthyThresholdCount = self.healthyThresholdCount {
            try encodeContainer.encode(healthyThresholdCount, forKey: .healthyThresholdCount)
        }
        if let matcher = self.matcher {
            try encodeContainer.encode(matcher, forKey: .matcher)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let protocolVersion = self.protocolVersion {
            try encodeContainer.encode(protocolVersion.rawValue, forKey: .protocolVersion)
        }
        if let unhealthyThresholdCount = self.unhealthyThresholdCount {
            try encodeContainer.encode(unhealthyThresholdCount, forKey: .unhealthyThresholdCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetGroupProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let protocolVersionDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.HealthCheckProtocolVersion.self, forKey: .protocolVersion)
        protocolVersion = protocolVersionDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let healthCheckIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthCheckIntervalSeconds)
        healthCheckIntervalSeconds = healthCheckIntervalSecondsDecoded
        let healthCheckTimeoutSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthCheckTimeoutSeconds)
        healthCheckTimeoutSeconds = healthCheckTimeoutSecondsDecoded
        let healthyThresholdCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthyThresholdCount)
        healthyThresholdCount = healthyThresholdCountDecoded
        let unhealthyThresholdCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unhealthyThresholdCount)
        unhealthyThresholdCount = unhealthyThresholdCountDecoded
        let matcherDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.Matcher.self, forKey: .matcher)
        matcher = matcherDecoded
    }
}

extension VPCLatticeClientTypes {
    /// The health check configuration of a target group. Health check configurations aren't used for LAMBDA and ALB target groups.
    public struct HealthCheckConfig: Swift.Equatable {
        /// Indicates whether health checking is enabled.
        public var enabled: Swift.Bool?
        /// The approximate amount of time, in seconds, between health checks of an individual target. The range is 5300 seconds. The default is 30 seconds.
        public var healthCheckIntervalSeconds: Swift.Int?
        /// The amount of time, in seconds, to wait before reporting a target as unhealthy. The range is 1120 seconds. The default is 5 seconds.
        public var healthCheckTimeoutSeconds: Swift.Int?
        /// The number of consecutive successful health checks required before considering an unhealthy target healthy. The range is 210. The default is 5.
        public var healthyThresholdCount: Swift.Int?
        /// The codes to use when checking for a successful response from a target. These are called Success codes in the console.
        public var matcher: VPCLatticeClientTypes.Matcher?
        /// The destination for health checks on the targets. If the protocol version is HTTP/1.1 or HTTP/2, specify a valid URI (for example, /path?query). The default path is /. Health checks are not supported if the protocol version is gRPC, however, you can choose HTTP/1.1 or HTTP/2 and specify a valid URI.
        public var path: Swift.String?
        /// The port used when performing health checks on targets. The default setting is the port that a target receives traffic on.
        public var port: Swift.Int?
        /// The protocol used when performing health checks on targets. The possible protocols are HTTP and HTTPS. The default is HTTP.
        public var `protocol`: VPCLatticeClientTypes.TargetGroupProtocol?
        /// The protocol version used when performing health checks on targets. The possible protocol versions are HTTP1 and HTTP2.
        public var protocolVersion: VPCLatticeClientTypes.HealthCheckProtocolVersion?
        /// The number of consecutive failed health checks required before considering a target unhealthy. The range is 210. The default is 2.
        public var unhealthyThresholdCount: Swift.Int?

        public init(
            enabled: Swift.Bool? = nil,
            healthCheckIntervalSeconds: Swift.Int? = nil,
            healthCheckTimeoutSeconds: Swift.Int? = nil,
            healthyThresholdCount: Swift.Int? = nil,
            matcher: VPCLatticeClientTypes.Matcher? = nil,
            path: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: VPCLatticeClientTypes.TargetGroupProtocol? = nil,
            protocolVersion: VPCLatticeClientTypes.HealthCheckProtocolVersion? = nil,
            unhealthyThresholdCount: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.healthCheckIntervalSeconds = healthCheckIntervalSeconds
            self.healthCheckTimeoutSeconds = healthCheckTimeoutSeconds
            self.healthyThresholdCount = healthyThresholdCount
            self.matcher = matcher
            self.path = path
            self.port = port
            self.`protocol` = `protocol`
            self.protocolVersion = protocolVersion
            self.unhealthyThresholdCount = unhealthyThresholdCount
        }
    }

}

extension VPCLatticeClientTypes {
    public enum HealthCheckProtocolVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Indicates use of HTTP/1.1 to send requests to target
        case http1
        /// Indicates use of HTTP/2 to send requests to target
        case http2
        case sdkUnknown(Swift.String)

        public static var allCases: [HealthCheckProtocolVersion] {
            return [
                .http1,
                .http2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .http1: return "HTTP1"
            case .http2: return "HTTP2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HealthCheckProtocolVersion(rawValue: rawValue) ?? HealthCheckProtocolVersion.sdkUnknown(rawValue)
        }
    }
}

extension VPCLatticeClientTypes.HttpMatch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headerMatches
        case method
        case pathMatch
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let headerMatches = headerMatches {
            var headerMatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .headerMatches)
            for headermatch0 in headerMatches {
                try headerMatchesContainer.encode(headermatch0)
            }
        }
        if let method = self.method {
            try encodeContainer.encode(method, forKey: .method)
        }
        if let pathMatch = self.pathMatch {
            try encodeContainer.encode(pathMatch, forKey: .pathMatch)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let methodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .method)
        method = methodDecoded
        let pathMatchDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.PathMatch.self, forKey: .pathMatch)
        pathMatch = pathMatchDecoded
        let headerMatchesContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.HeaderMatch?].self, forKey: .headerMatches)
        var headerMatchesDecoded0:[VPCLatticeClientTypes.HeaderMatch]? = nil
        if let headerMatchesContainer = headerMatchesContainer {
            headerMatchesDecoded0 = [VPCLatticeClientTypes.HeaderMatch]()
            for structure0 in headerMatchesContainer {
                if let structure0 = structure0 {
                    headerMatchesDecoded0?.append(structure0)
                }
            }
        }
        headerMatches = headerMatchesDecoded0
    }
}

extension VPCLatticeClientTypes {
    /// Describes criteria that can be applied to incoming requests.
    public struct HttpMatch: Swift.Equatable {
        /// The header matches. Matches incoming requests with rule based on request header value before applying rule action.
        public var headerMatches: [VPCLatticeClientTypes.HeaderMatch]?
        /// The HTTP method type.
        public var method: Swift.String?
        /// The path match.
        public var pathMatch: VPCLatticeClientTypes.PathMatch?

        public init(
            headerMatches: [VPCLatticeClientTypes.HeaderMatch]? = nil,
            method: Swift.String? = nil,
            pathMatch: VPCLatticeClientTypes.PathMatch? = nil
        )
        {
            self.headerMatches = headerMatches
            self.method = method
            self.pathMatch = pathMatch
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An unexpected error occurred while processing the request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The number of seconds to wait before retrying.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VPCLatticeClientTypes {
    public enum IpAddressType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Indicates IPv4 address type
        case ipv4
        /// Indicates IPv6 address type
        case ipv6
        case sdkUnknown(Swift.String)

        public static var allCases: [IpAddressType] {
            return [
                .ipv4,
                .ipv6,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ipv4: return "IPV4"
            case .ipv6: return "IPV6"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IpAddressType(rawValue: rawValue) ?? IpAddressType.sdkUnknown(rawValue)
        }
    }
}

extension VPCLatticeClientTypes {
    public enum LambdaEventStructureVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// This is the default lambda event structure version
        case v1
        /// Indicates use of lambda event structure version 2
        case v2
        case sdkUnknown(Swift.String)

        public static var allCases: [LambdaEventStructureVersion] {
            return [
                .v1,
                .v2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .v1: return "V1"
            case .v2: return "V2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LambdaEventStructureVersion(rawValue: rawValue) ?? LambdaEventStructureVersion.sdkUnknown(rawValue)
        }
    }
}

extension ListAccessLogSubscriptionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceIdentifier = resourceIdentifier else {
                let message = "Creating a URL Query Item failed. resourceIdentifier is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceIdentifierQueryItem = ClientRuntime.URLQueryItem(name: "resourceIdentifier".urlPercentEncoding(), value: Swift.String(resourceIdentifier).urlPercentEncoding())
            items.append(resourceIdentifierQueryItem)
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListAccessLogSubscriptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/accesslogsubscriptions"
    }
}

public struct ListAccessLogSubscriptionsInput: Swift.Equatable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service network or service.
    /// This member is required.
    public var resourceIdentifier: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceIdentifier = resourceIdentifier
    }
}

struct ListAccessLogSubscriptionsInputBody: Swift.Equatable {
}

extension ListAccessLogSubscriptionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAccessLogSubscriptionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAccessLogSubscriptionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccessLogSubscriptionsOutput: Swift.Equatable {
    /// The access log subscriptions.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.AccessLogSubscriptionSummary]?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.AccessLogSubscriptionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListAccessLogSubscriptionsOutputBody: Swift.Equatable {
    let items: [VPCLatticeClientTypes.AccessLogSubscriptionSummary]?
    let nextToken: Swift.String?
}

extension ListAccessLogSubscriptionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.AccessLogSubscriptionSummary?].self, forKey: .items)
        var itemsDecoded0:[VPCLatticeClientTypes.AccessLogSubscriptionSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [VPCLatticeClientTypes.AccessLogSubscriptionSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAccessLogSubscriptionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListListenersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListListenersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceIdentifier = serviceIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners"
    }
}

public struct ListListenersInput: Swift.Equatable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceIdentifier = serviceIdentifier
    }
}

struct ListListenersInputBody: Swift.Equatable {
}

extension ListListenersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListListenersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListListenersOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListListenersOutput: Swift.Equatable {
    /// Information about the listeners.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.ListenerSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.ListenerSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListListenersOutputBody: Swift.Equatable {
    let items: [VPCLatticeClientTypes.ListenerSummary]?
    let nextToken: Swift.String?
}

extension ListListenersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.ListenerSummary?].self, forKey: .items)
        var itemsDecoded0:[VPCLatticeClientTypes.ListenerSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [VPCLatticeClientTypes.ListenerSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListListenersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRulesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceIdentifier = serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = listenerIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())/rules"
    }
}

public struct ListRulesInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        listenerIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.listenerIdentifier = listenerIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceIdentifier = serviceIdentifier
    }
}

struct ListRulesInputBody: Swift.Equatable {
}

extension ListRulesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListRulesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRulesOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListRulesOutput: Swift.Equatable {
    /// Information about the rules.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.RuleSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.RuleSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListRulesOutputBody: Swift.Equatable {
    let items: [VPCLatticeClientTypes.RuleSummary]?
    let nextToken: Swift.String?
}

extension ListRulesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.RuleSummary?].self, forKey: .items)
        var itemsDecoded0:[VPCLatticeClientTypes.RuleSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [VPCLatticeClientTypes.RuleSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRulesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListServiceNetworkServiceAssociationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let serviceNetworkIdentifier = serviceNetworkIdentifier {
                let serviceNetworkIdentifierQueryItem = ClientRuntime.URLQueryItem(name: "serviceNetworkIdentifier".urlPercentEncoding(), value: Swift.String(serviceNetworkIdentifier).urlPercentEncoding())
                items.append(serviceNetworkIdentifierQueryItem)
            }
            if let serviceIdentifier = serviceIdentifier {
                let serviceIdentifierQueryItem = ClientRuntime.URLQueryItem(name: "serviceIdentifier".urlPercentEncoding(), value: Swift.String(serviceIdentifier).urlPercentEncoding())
                items.append(serviceIdentifierQueryItem)
            }
            return items
        }
    }
}

extension ListServiceNetworkServiceAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/servicenetworkserviceassociations"
    }
}

public struct ListServiceNetworkServiceAssociationsInput: Swift.Equatable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    public var serviceIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service network.
    public var serviceNetworkIdentifier: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil,
        serviceNetworkIdentifier: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceIdentifier = serviceIdentifier
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
    }
}

struct ListServiceNetworkServiceAssociationsInputBody: Swift.Equatable {
}

extension ListServiceNetworkServiceAssociationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListServiceNetworkServiceAssociationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListServiceNetworkServiceAssociationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListServiceNetworkServiceAssociationsOutput: Swift.Equatable {
    /// Information about the associations.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.ServiceNetworkServiceAssociationSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.ServiceNetworkServiceAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListServiceNetworkServiceAssociationsOutputBody: Swift.Equatable {
    let items: [VPCLatticeClientTypes.ServiceNetworkServiceAssociationSummary]?
    let nextToken: Swift.String?
}

extension ListServiceNetworkServiceAssociationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.ServiceNetworkServiceAssociationSummary?].self, forKey: .items)
        var itemsDecoded0:[VPCLatticeClientTypes.ServiceNetworkServiceAssociationSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [VPCLatticeClientTypes.ServiceNetworkServiceAssociationSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListServiceNetworkServiceAssociationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListServiceNetworkVpcAssociationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let serviceNetworkIdentifier = serviceNetworkIdentifier {
                let serviceNetworkIdentifierQueryItem = ClientRuntime.URLQueryItem(name: "serviceNetworkIdentifier".urlPercentEncoding(), value: Swift.String(serviceNetworkIdentifier).urlPercentEncoding())
                items.append(serviceNetworkIdentifierQueryItem)
            }
            if let vpcIdentifier = vpcIdentifier {
                let vpcIdentifierQueryItem = ClientRuntime.URLQueryItem(name: "vpcIdentifier".urlPercentEncoding(), value: Swift.String(vpcIdentifier).urlPercentEncoding())
                items.append(vpcIdentifierQueryItem)
            }
            return items
        }
    }
}

extension ListServiceNetworkVpcAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/servicenetworkvpcassociations"
    }
}

public struct ListServiceNetworkVpcAssociationsInput: Swift.Equatable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service network.
    public var serviceNetworkIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the VPC.
    public var vpcIdentifier: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceNetworkIdentifier: Swift.String? = nil,
        vpcIdentifier: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
        self.vpcIdentifier = vpcIdentifier
    }
}

struct ListServiceNetworkVpcAssociationsInputBody: Swift.Equatable {
}

extension ListServiceNetworkVpcAssociationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListServiceNetworkVpcAssociationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListServiceNetworkVpcAssociationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListServiceNetworkVpcAssociationsOutput: Swift.Equatable {
    /// Information about the associations.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.ServiceNetworkVpcAssociationSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.ServiceNetworkVpcAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListServiceNetworkVpcAssociationsOutputBody: Swift.Equatable {
    let items: [VPCLatticeClientTypes.ServiceNetworkVpcAssociationSummary]?
    let nextToken: Swift.String?
}

extension ListServiceNetworkVpcAssociationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.ServiceNetworkVpcAssociationSummary?].self, forKey: .items)
        var itemsDecoded0:[VPCLatticeClientTypes.ServiceNetworkVpcAssociationSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [VPCLatticeClientTypes.ServiceNetworkVpcAssociationSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListServiceNetworkVpcAssociationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListServiceNetworksInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListServiceNetworksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/servicenetworks"
    }
}

public struct ListServiceNetworksInput: Swift.Equatable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListServiceNetworksInputBody: Swift.Equatable {
}

extension ListServiceNetworksInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListServiceNetworksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListServiceNetworksOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListServiceNetworksOutput: Swift.Equatable {
    /// Information about the service networks.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.ServiceNetworkSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.ServiceNetworkSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListServiceNetworksOutputBody: Swift.Equatable {
    let items: [VPCLatticeClientTypes.ServiceNetworkSummary]?
    let nextToken: Swift.String?
}

extension ListServiceNetworksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.ServiceNetworkSummary?].self, forKey: .items)
        var itemsDecoded0:[VPCLatticeClientTypes.ServiceNetworkSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [VPCLatticeClientTypes.ServiceNetworkSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListServiceNetworksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListServicesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListServicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/services"
    }
}

public struct ListServicesInput: Swift.Equatable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListServicesInputBody: Swift.Equatable {
}

extension ListServicesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListServicesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListServicesOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListServicesOutput: Swift.Equatable {
    /// The services.
    public var items: [VPCLatticeClientTypes.ServiceSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.ServiceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListServicesOutputBody: Swift.Equatable {
    let items: [VPCLatticeClientTypes.ServiceSummary]?
    let nextToken: Swift.String?
}

extension ListServicesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.ServiceSummary?].self, forKey: .items)
        var itemsDecoded0:[VPCLatticeClientTypes.ServiceSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [VPCLatticeClientTypes.ServiceSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListServicesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tags.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTargetGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let vpcIdentifier = vpcIdentifier {
                let vpcIdentifierQueryItem = ClientRuntime.URLQueryItem(name: "vpcIdentifier".urlPercentEncoding(), value: Swift.String(vpcIdentifier).urlPercentEncoding())
                items.append(vpcIdentifierQueryItem)
            }
            if let targetGroupType = targetGroupType {
                let targetGroupTypeQueryItem = ClientRuntime.URLQueryItem(name: "targetGroupType".urlPercentEncoding(), value: Swift.String(targetGroupType.rawValue).urlPercentEncoding())
                items.append(targetGroupTypeQueryItem)
            }
            return items
        }
    }
}

extension ListTargetGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/targetgroups"
    }
}

public struct ListTargetGroupsInput: Swift.Equatable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The target group type.
    public var targetGroupType: VPCLatticeClientTypes.TargetGroupType?
    /// The ID or Amazon Resource Name (ARN) of the service.
    public var vpcIdentifier: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        targetGroupType: VPCLatticeClientTypes.TargetGroupType? = nil,
        vpcIdentifier: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.targetGroupType = targetGroupType
        self.vpcIdentifier = vpcIdentifier
    }
}

struct ListTargetGroupsInputBody: Swift.Equatable {
}

extension ListTargetGroupsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTargetGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTargetGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListTargetGroupsOutput: Swift.Equatable {
    /// Information about the target groups.
    public var items: [VPCLatticeClientTypes.TargetGroupSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.TargetGroupSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListTargetGroupsOutputBody: Swift.Equatable {
    let items: [VPCLatticeClientTypes.TargetGroupSummary]?
    let nextToken: Swift.String?
}

extension ListTargetGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.TargetGroupSummary?].self, forKey: .items)
        var itemsDecoded0:[VPCLatticeClientTypes.TargetGroupSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [VPCLatticeClientTypes.TargetGroupSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTargetGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTargetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for target0 in targets {
                try targetsContainer.encode(target0)
            }
        }
    }
}

extension ListTargetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListTargetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let targetGroupIdentifier = targetGroupIdentifier else {
            return nil
        }
        return "/targetgroups/\(targetGroupIdentifier.urlPercentEncoding())/listtargets"
    }
}

public struct ListTargetsInput: Swift.Equatable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the target group.
    /// This member is required.
    public var targetGroupIdentifier: Swift.String?
    /// The targets to list.
    public var targets: [VPCLatticeClientTypes.Target]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        targetGroupIdentifier: Swift.String? = nil,
        targets: [VPCLatticeClientTypes.Target]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.targetGroupIdentifier = targetGroupIdentifier
        self.targets = targets
    }
}

struct ListTargetsInputBody: Swift.Equatable {
    let targets: [VPCLatticeClientTypes.Target]?
}

extension ListTargetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targets
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetsContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[VPCLatticeClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [VPCLatticeClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
    }
}

extension ListTargetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTargetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListTargetsOutput: Swift.Equatable {
    /// Information about the targets.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.TargetSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.TargetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListTargetsOutputBody: Swift.Equatable {
    let items: [VPCLatticeClientTypes.TargetSummary]?
    let nextToken: Swift.String?
}

extension ListTargetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.TargetSummary?].self, forKey: .items)
        var itemsDecoded0:[VPCLatticeClientTypes.TargetSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [VPCLatticeClientTypes.TargetSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTargetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension VPCLatticeClientTypes {
    public enum ListenerProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Indicates HTTP protocol
        case http
        /// Indicates HTTPS protocol
        case https
        case sdkUnknown(Swift.String)

        public static var allCases: [ListenerProtocol] {
            return [
                .http,
                .https,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case .https: return "HTTPS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ListenerProtocol(rawValue: rawValue) ?? ListenerProtocol.sdkUnknown(rawValue)
        }
    }
}

extension VPCLatticeClientTypes.ListenerSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case id
        case lastUpdatedAt
        case name
        case port
        case `protocol` = "protocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .dateTime, forKey: .lastUpdatedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ListenerProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Summary information about a listener.
    public struct ListenerSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the listener.
        public var arn: Swift.String?
        /// The date and time that the listener was created, specified in ISO-8601 format.
        public var createdAt: ClientRuntime.Date?
        /// The ID of the listener.
        public var id: Swift.String?
        /// The date and time that the listener was last updated, specified in ISO-8601 format.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the listener.
        public var name: Swift.String?
        /// The listener port.
        public var port: Swift.Int?
        /// The listener protocol.
        public var `protocol`: VPCLatticeClientTypes.ListenerProtocol?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: VPCLatticeClientTypes.ListenerProtocol? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.port = port
            self.`protocol` = `protocol`
        }
    }

}

extension VPCLatticeClientTypes.Matcher: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case httpcode = "httpCode"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .httpcode(httpcode):
                try container.encode(httpcode, forKey: .httpcode)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let httpcodeDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .httpcode)
        if let httpcode = httpcodeDecoded {
            self = .httpcode(httpcode)
            return
        }
        self = .sdkUnknown("")
    }
}

extension VPCLatticeClientTypes {
    /// The codes to use when checking for a successful response from a target for health checks.
    public enum Matcher: Swift.Equatable {
        /// The HTTP code to use when checking for a successful response from a target.
        case httpcode(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension VPCLatticeClientTypes.PathMatch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case caseSensitive
        case match
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let caseSensitive = self.caseSensitive {
            try encodeContainer.encode(caseSensitive, forKey: .caseSensitive)
        }
        if let match = self.match {
            try encodeContainer.encode(match, forKey: .match)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let matchDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.PathMatchType.self, forKey: .match)
        match = matchDecoded
        let caseSensitiveDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .caseSensitive)
        caseSensitive = caseSensitiveDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Describes the conditions that can be applied when matching a path for incoming requests.
    public struct PathMatch: Swift.Equatable {
        /// Indicates whether the match is case sensitive. Defaults to false.
        public var caseSensitive: Swift.Bool?
        /// The type of path match.
        /// This member is required.
        public var match: VPCLatticeClientTypes.PathMatchType?

        public init(
            caseSensitive: Swift.Bool? = nil,
            match: VPCLatticeClientTypes.PathMatchType? = nil
        )
        {
            self.caseSensitive = caseSensitive
            self.match = match
        }
    }

}

extension VPCLatticeClientTypes.PathMatchType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exact
        case `prefix` = "prefix"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .exact(exact):
                try container.encode(exact, forKey: .exact)
            case let .`prefix`(`prefix`):
                try container.encode(`prefix`, forKey: .`prefix`)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let exactDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .exact)
        if let exact = exactDecoded {
            self = .exact(exact)
            return
        }
        let prefixDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .prefix)
        if let `prefix` = prefixDecoded {
            self = .`prefix`(`prefix`)
            return
        }
        self = .sdkUnknown("")
    }
}

extension VPCLatticeClientTypes {
    /// Describes a path match type. Each rule can include only one of the following types of paths.
    public enum PathMatchType: Swift.Equatable {
        /// An exact match of the path.
        case exact(Swift.String)
        /// A prefix match of the path.
        case `prefix`(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension PutAuthPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

extension PutAuthPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceIdentifier = resourceIdentifier else {
            return nil
        }
        return "/authpolicy/\(resourceIdentifier.urlPercentEncoding())"
    }
}

public struct PutAuthPolicyInput: Swift.Equatable {
    /// The auth policy.
    /// This member is required.
    public var policy: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service network or service for which the policy is created.
    /// This member is required.
    public var resourceIdentifier: Swift.String?

    public init(
        policy: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.policy = policy
        self.resourceIdentifier = resourceIdentifier
    }
}

struct PutAuthPolicyInputBody: Swift.Equatable {
    let policy: Swift.String?
}

extension PutAuthPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutAuthPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutAuthPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.state = output.state
        } else {
            self.policy = nil
            self.state = nil
        }
    }
}

public struct PutAuthPolicyOutput: Swift.Equatable {
    /// The auth policy.
    public var policy: Swift.String?
    /// The state of the auth policy. The auth policy is only active when the auth type is set to Amazon Web Services_IAM. If you provide a policy, then authentication and authorization decisions are made based on this policy and the client's IAM policy. If the Auth type is NONE, then, any auth policy you provide will remain inactive. For more information, see [Create a service network](https://docs.aws.amazon.com/vpc-lattice/latest/ug/service-networks.html#create-service-network) in the Amazon VPC Lattice User Guide.
    public var state: VPCLatticeClientTypes.AuthPolicyState?

    public init(
        policy: Swift.String? = nil,
        state: VPCLatticeClientTypes.AuthPolicyState? = nil
    )
    {
        self.policy = policy
        self.state = state
    }
}

struct PutAuthPolicyOutputBody: Swift.Equatable {
    let policy: Swift.String?
    let state: VPCLatticeClientTypes.AuthPolicyState?
}

extension PutAuthPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
        case state
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let stateDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.AuthPolicyState.self, forKey: .state)
        state = stateDecoded
    }
}

enum PutAuthPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutResourcePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

extension PutResourcePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/resourcepolicy/\(resourceArn.urlPercentEncoding())"
    }
}

public struct PutResourcePolicyInput: Swift.Equatable {
    /// An IAM policy.
    /// This member is required.
    public var policy: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service network or service for which the policy is created.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        policy: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.policy = policy
        self.resourceArn = resourceArn
    }
}

struct PutResourcePolicyInputBody: Swift.Equatable {
    let policy: Swift.String?
}

extension PutResourcePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutResourcePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutResourcePolicyOutput: Swift.Equatable {

    public init() { }
}

enum PutResourcePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RegisterTargetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for target0 in targets {
                try targetsContainer.encode(target0)
            }
        }
    }
}

extension RegisterTargetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let targetGroupIdentifier = targetGroupIdentifier else {
            return nil
        }
        return "/targetgroups/\(targetGroupIdentifier.urlPercentEncoding())/registertargets"
    }
}

public struct RegisterTargetsInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the target group.
    /// This member is required.
    public var targetGroupIdentifier: Swift.String?
    /// The targets.
    /// This member is required.
    public var targets: [VPCLatticeClientTypes.Target]?

    public init(
        targetGroupIdentifier: Swift.String? = nil,
        targets: [VPCLatticeClientTypes.Target]? = nil
    )
    {
        self.targetGroupIdentifier = targetGroupIdentifier
        self.targets = targets
    }
}

struct RegisterTargetsInputBody: Swift.Equatable {
    let targets: [VPCLatticeClientTypes.Target]?
}

extension RegisterTargetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targets
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetsContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[VPCLatticeClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [VPCLatticeClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
    }
}

extension RegisterTargetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RegisterTargetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.successful = output.successful
            self.unsuccessful = output.unsuccessful
        } else {
            self.successful = nil
            self.unsuccessful = nil
        }
    }
}

public struct RegisterTargetsOutput: Swift.Equatable {
    /// The targets that were successfully registered.
    public var successful: [VPCLatticeClientTypes.Target]?
    /// The targets that were not registered.
    public var unsuccessful: [VPCLatticeClientTypes.TargetFailure]?

    public init(
        successful: [VPCLatticeClientTypes.Target]? = nil,
        unsuccessful: [VPCLatticeClientTypes.TargetFailure]? = nil
    )
    {
        self.successful = successful
        self.unsuccessful = unsuccessful
    }
}

struct RegisterTargetsOutputBody: Swift.Equatable {
    let successful: [VPCLatticeClientTypes.Target]?
    let unsuccessful: [VPCLatticeClientTypes.TargetFailure]?
}

extension RegisterTargetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case successful
        case unsuccessful
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.Target?].self, forKey: .successful)
        var successfulDecoded0:[VPCLatticeClientTypes.Target]? = nil
        if let successfulContainer = successfulContainer {
            successfulDecoded0 = [VPCLatticeClientTypes.Target]()
            for structure0 in successfulContainer {
                if let structure0 = structure0 {
                    successfulDecoded0?.append(structure0)
                }
            }
        }
        successful = successfulDecoded0
        let unsuccessfulContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.TargetFailure?].self, forKey: .unsuccessful)
        var unsuccessfulDecoded0:[VPCLatticeClientTypes.TargetFailure]? = nil
        if let unsuccessfulContainer = unsuccessfulContainer {
            unsuccessfulDecoded0 = [VPCLatticeClientTypes.TargetFailure]()
            for structure0 in unsuccessfulContainer {
                if let structure0 = structure0 {
                    unsuccessfulDecoded0?.append(structure0)
                }
            }
        }
        unsuccessful = unsuccessfulDecoded0
    }
}

enum RegisterTargetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request references a resource that does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The resource ID.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension VPCLatticeClientTypes.RuleAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fixedresponse = "fixedResponse"
        case forward
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .fixedresponse(fixedresponse):
                try container.encode(fixedresponse, forKey: .fixedresponse)
            case let .forward(forward):
                try container.encode(forward, forKey: .forward)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let forwardDecoded = try values.decodeIfPresent(VPCLatticeClientTypes.ForwardAction.self, forKey: .forward)
        if let forward = forwardDecoded {
            self = .forward(forward)
            return
        }
        let fixedresponseDecoded = try values.decodeIfPresent(VPCLatticeClientTypes.FixedResponseAction.self, forKey: .fixedresponse)
        if let fixedresponse = fixedresponseDecoded {
            self = .fixedresponse(fixedresponse)
            return
        }
        self = .sdkUnknown("")
    }
}

extension VPCLatticeClientTypes {
    /// Describes the action for a rule. Each rule must include exactly one of the following types of actions: forward or fixed-response, and it must be the last action to be performed.
    public enum RuleAction: Swift.Equatable {
        /// The forward action. Traffic that matches the rule is forwarded to the specified target groups.
        case forward(VPCLatticeClientTypes.ForwardAction)
        /// Describes the rule action that returns a custom HTTP response.
        case fixedresponse(VPCLatticeClientTypes.FixedResponseAction)
        case sdkUnknown(Swift.String)
    }

}

extension VPCLatticeClientTypes.RuleMatch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case httpmatch = "httpMatch"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .httpmatch(httpmatch):
                try container.encode(httpmatch, forKey: .httpmatch)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let httpmatchDecoded = try values.decodeIfPresent(VPCLatticeClientTypes.HttpMatch.self, forKey: .httpmatch)
        if let httpmatch = httpmatchDecoded {
            self = .httpmatch(httpmatch)
            return
        }
        self = .sdkUnknown("")
    }
}

extension VPCLatticeClientTypes {
    /// Describes a rule match.
    public enum RuleMatch: Swift.Equatable {
        /// The HTTP criteria that a rule must match.
        case httpmatch(VPCLatticeClientTypes.HttpMatch)
        case sdkUnknown(Swift.String)
    }

}

extension VPCLatticeClientTypes.RuleSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case id
        case isDefault
        case lastUpdatedAt
        case name
        case priority
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let isDefault = self.isDefault {
            try encodeContainer.encode(isDefault, forKey: .isDefault)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .dateTime, forKey: .lastUpdatedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let isDefaultDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDefault)
        isDefault = isDefaultDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Summary information about the listener rule.
    public struct RuleSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the rule.
        public var arn: Swift.String?
        /// The date and time that the listener rule was created, specified in ISO-8601 format.
        public var createdAt: ClientRuntime.Date?
        /// The ID of the rule.
        public var id: Swift.String?
        /// Indicates whether this is the default rule. Listener rules are created when you create a listener. Each listener has a default rule for checking connection requests.
        public var isDefault: Swift.Bool?
        /// The date and time that the listener rule was last updated, specified in ISO-8601 format.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the rule.
        public var name: Swift.String?
        /// The priority of the rule.
        public var priority: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            isDefault: Swift.Bool? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            priority: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.isDefault = isDefault
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.priority = priority
        }
    }

}

extension VPCLatticeClientTypes.RuleUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case match
        case priority
        case ruleIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let match = self.match {
            try encodeContainer.encode(match, forKey: .match)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let ruleIdentifier = self.ruleIdentifier {
            try encodeContainer.encode(ruleIdentifier, forKey: .ruleIdentifier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleIdentifier)
        ruleIdentifier = ruleIdentifierDecoded
        let matchDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleMatch.self, forKey: .match)
        match = matchDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let actionDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleAction.self, forKey: .action)
        action = actionDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Represents an object when updating a rule.
    public struct RuleUpdate: Swift.Equatable {
        /// The rule action.
        public var action: VPCLatticeClientTypes.RuleAction?
        /// The rule match.
        public var match: VPCLatticeClientTypes.RuleMatch?
        /// The rule priority. A listener can't have multiple rules with the same priority.
        public var priority: Swift.Int?
        /// The ID or Amazon Resource Name (ARN) of the rule.
        /// This member is required.
        public var ruleIdentifier: Swift.String?

        public init(
            action: VPCLatticeClientTypes.RuleAction? = nil,
            match: VPCLatticeClientTypes.RuleMatch? = nil,
            priority: Swift.Int? = nil,
            ruleIdentifier: Swift.String? = nil
        )
        {
            self.action = action
            self.match = match
            self.priority = priority
            self.ruleIdentifier = ruleIdentifier
        }
    }

}

extension VPCLatticeClientTypes.RuleUpdateFailure: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureCode
        case failureMessage
        case ruleIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureCode = self.failureCode {
            try encodeContainer.encode(failureCode, forKey: .failureCode)
        }
        if let failureMessage = self.failureMessage {
            try encodeContainer.encode(failureMessage, forKey: .failureMessage)
        }
        if let ruleIdentifier = self.ruleIdentifier {
            try encodeContainer.encode(ruleIdentifier, forKey: .ruleIdentifier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleIdentifier)
        ruleIdentifier = ruleIdentifierDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Describes a rule update that failed.
    public struct RuleUpdateFailure: Swift.Equatable {
        /// The failure code.
        public var failureCode: Swift.String?
        /// The failure message.
        public var failureMessage: Swift.String?
        /// The ID or Amazon Resource Name (ARN) of the rule.
        public var ruleIdentifier: Swift.String?

        public init(
            failureCode: Swift.String? = nil,
            failureMessage: Swift.String? = nil,
            ruleIdentifier: Swift.String? = nil
        )
        {
            self.failureCode = failureCode
            self.failureMessage = failureMessage
            self.ruleIdentifier = ruleIdentifier
        }
    }

}

extension VPCLatticeClientTypes.RuleUpdateSuccess: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case arn
        case id
        case isDefault
        case match
        case name
        case priority
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let isDefault = self.isDefault {
            try encodeContainer.encode(isDefault, forKey: .isDefault)
        }
        if let match = self.match {
            try encodeContainer.encode(match, forKey: .match)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let isDefaultDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDefault)
        isDefault = isDefaultDecoded
        let matchDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleMatch.self, forKey: .match)
        match = matchDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let actionDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleAction.self, forKey: .action)
        action = actionDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Describes a successful rule update.
    public struct RuleUpdateSuccess: Swift.Equatable {
        /// The action for the default rule.
        public var action: VPCLatticeClientTypes.RuleAction?
        /// The Amazon Resource Name (ARN) of the listener.
        public var arn: Swift.String?
        /// The ID of the listener.
        public var id: Swift.String?
        /// Indicates whether this is the default rule.
        public var isDefault: Swift.Bool?
        /// The rule match.
        public var match: VPCLatticeClientTypes.RuleMatch?
        /// The name of the listener.
        public var name: Swift.String?
        /// The rule priority.
        public var priority: Swift.Int?

        public init(
            action: VPCLatticeClientTypes.RuleAction? = nil,
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            isDefault: Swift.Bool? = nil,
            match: VPCLatticeClientTypes.RuleMatch? = nil,
            name: Swift.String? = nil,
            priority: Swift.Int? = nil
        )
        {
            self.action = action
            self.arn = arn
            self.id = id
            self.isDefault = isDefault
            self.match = match
            self.name = name
            self.priority = priority
        }
    }

}

extension VPCLatticeClientTypes {
    public enum ServiceNetworkServiceAssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// ServiceNetwork and Service association is active
        case active
        /// ServiceNetwork and Service association creation failed.
        case createFailed
        /// ServiceNetwork and Service association creation in progress
        case createInProgress
        /// ServiceNetwork and Service association deletion failed
        case deleteFailed
        /// ServiceNetwork and Service association deletion in progress
        case deleteInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceNetworkServiceAssociationStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleteFailed,
                .deleteInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceNetworkServiceAssociationStatus(rawValue: rawValue) ?? ServiceNetworkServiceAssociationStatus.sdkUnknown(rawValue)
        }
    }
}

extension VPCLatticeClientTypes.ServiceNetworkServiceAssociationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case createdBy
        case customDomainName
        case dnsEntry
        case id
        case serviceArn
        case serviceId
        case serviceName
        case serviceNetworkArn
        case serviceNetworkId
        case serviceNetworkName
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let customDomainName = self.customDomainName {
            try encodeContainer.encode(customDomainName, forKey: .customDomainName)
        }
        if let dnsEntry = self.dnsEntry {
            try encodeContainer.encode(dnsEntry, forKey: .dnsEntry)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let serviceArn = self.serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
        if let serviceId = self.serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let serviceNetworkArn = self.serviceNetworkArn {
            try encodeContainer.encode(serviceNetworkArn, forKey: .serviceNetworkArn)
        }
        if let serviceNetworkId = self.serviceNetworkId {
            try encodeContainer.encode(serviceNetworkId, forKey: .serviceNetworkId)
        }
        if let serviceNetworkName = self.serviceNetworkName {
            try encodeContainer.encode(serviceNetworkName, forKey: .serviceNetworkName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let serviceNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceNetworkId)
        serviceNetworkId = serviceNetworkIdDecoded
        let serviceNetworkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceNetworkName)
        serviceNetworkName = serviceNetworkNameDecoded
        let serviceNetworkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceNetworkArn)
        serviceNetworkArn = serviceNetworkArnDecoded
        let dnsEntryDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.DnsEntry.self, forKey: .dnsEntry)
        dnsEntry = dnsEntryDecoded
        let customDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomainName)
        customDomainName = customDomainNameDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Summary information about the association between a service network and a service.
    public struct ServiceNetworkServiceAssociationSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the association.
        public var arn: Swift.String?
        /// The date and time that the association was created, specified in ISO-8601 format.
        public var createdAt: ClientRuntime.Date?
        /// The account that created the association.
        public var createdBy: Swift.String?
        /// The custom domain name of the service.
        public var customDomainName: Swift.String?
        /// DNS information about the service.
        public var dnsEntry: VPCLatticeClientTypes.DnsEntry?
        /// The ID of the association.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of the service.
        public var serviceArn: Swift.String?
        /// The ID of the service.
        public var serviceId: Swift.String?
        /// The name of the service.
        public var serviceName: Swift.String?
        /// The Amazon Resource Name (ARN) of the service network.
        public var serviceNetworkArn: Swift.String?
        /// The ID of the service network.
        public var serviceNetworkId: Swift.String?
        /// The name of the service network.
        public var serviceNetworkName: Swift.String?
        /// The status. If the deletion fails, try to delete again.
        public var status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            customDomainName: Swift.String? = nil,
            dnsEntry: VPCLatticeClientTypes.DnsEntry? = nil,
            id: Swift.String? = nil,
            serviceArn: Swift.String? = nil,
            serviceId: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            serviceNetworkArn: Swift.String? = nil,
            serviceNetworkId: Swift.String? = nil,
            serviceNetworkName: Swift.String? = nil,
            status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.customDomainName = customDomainName
            self.dnsEntry = dnsEntry
            self.id = id
            self.serviceArn = serviceArn
            self.serviceId = serviceId
            self.serviceName = serviceName
            self.serviceNetworkArn = serviceNetworkArn
            self.serviceNetworkId = serviceNetworkId
            self.serviceNetworkName = serviceNetworkName
            self.status = status
        }
    }

}

extension VPCLatticeClientTypes.ServiceNetworkSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case id
        case lastUpdatedAt
        case name
        case numberOfAssociatedServices
        case numberOfAssociatedVPCs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .dateTime, forKey: .lastUpdatedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let numberOfAssociatedServices = self.numberOfAssociatedServices {
            try encodeContainer.encode(numberOfAssociatedServices, forKey: .numberOfAssociatedServices)
        }
        if let numberOfAssociatedVPCs = self.numberOfAssociatedVPCs {
            try encodeContainer.encode(numberOfAssociatedVPCs, forKey: .numberOfAssociatedVPCs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let numberOfAssociatedVPCsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfAssociatedVPCs)
        numberOfAssociatedVPCs = numberOfAssociatedVPCsDecoded
        let numberOfAssociatedServicesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfAssociatedServices)
        numberOfAssociatedServices = numberOfAssociatedServicesDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Summary information about a service network.
    public struct ServiceNetworkSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the service network.
        public var arn: Swift.String?
        /// The date and time that the service network was created, specified in ISO-8601 format.
        public var createdAt: ClientRuntime.Date?
        /// The ID of the service network.
        public var id: Swift.String?
        /// The date and time that the service network was last updated, specified in ISO-8601 format.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the service network.
        public var name: Swift.String?
        /// The number of services associated with the service network.
        public var numberOfAssociatedServices: Swift.Int?
        /// The number of VPCs associated with the service network.
        public var numberOfAssociatedVPCs: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            numberOfAssociatedServices: Swift.Int? = nil,
            numberOfAssociatedVPCs: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.numberOfAssociatedServices = numberOfAssociatedServices
            self.numberOfAssociatedVPCs = numberOfAssociatedVPCs
        }
    }

}

extension VPCLatticeClientTypes {
    public enum ServiceNetworkVpcAssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// ServiceNetwork and Vpc association is active
        case active
        /// ServiceNetwork and Vpc association creation failed.
        case createFailed
        /// ServiceNetwork and Vpc association creation in progress
        case createInProgress
        /// ServiceNetwork and Vpc association deletion failed
        case deleteFailed
        /// ServiceNetwork and Vpc association deletion in progress
        case deleteInProgress
        /// ServiceNetwork and Vpc association update failed
        case updateFailed
        /// ServiceNetwork and Vpc association update in progress
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceNetworkVpcAssociationStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleteFailed,
                .deleteInProgress,
                .updateFailed,
                .updateInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceNetworkVpcAssociationStatus(rawValue: rawValue) ?? ServiceNetworkVpcAssociationStatus.sdkUnknown(rawValue)
        }
    }
}

extension VPCLatticeClientTypes.ServiceNetworkVpcAssociationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case createdBy
        case id
        case lastUpdatedAt
        case serviceNetworkArn
        case serviceNetworkId
        case serviceNetworkName
        case status
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .dateTime, forKey: .lastUpdatedAt)
        }
        if let serviceNetworkArn = self.serviceNetworkArn {
            try encodeContainer.encode(serviceNetworkArn, forKey: .serviceNetworkArn)
        }
        if let serviceNetworkId = self.serviceNetworkId {
            try encodeContainer.encode(serviceNetworkId, forKey: .serviceNetworkId)
        }
        if let serviceNetworkName = self.serviceNetworkName {
            try encodeContainer.encode(serviceNetworkName, forKey: .serviceNetworkName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let serviceNetworkIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceNetworkId)
        serviceNetworkId = serviceNetworkIdDecoded
        let serviceNetworkNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceNetworkName)
        serviceNetworkName = serviceNetworkNameDecoded
        let serviceNetworkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceNetworkArn)
        serviceNetworkArn = serviceNetworkArnDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Summary information about an association between a service network and a VPC.
    public struct ServiceNetworkVpcAssociationSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the association.
        public var arn: Swift.String?
        /// The date and time that the association was created, specified in ISO-8601 format.
        public var createdAt: ClientRuntime.Date?
        /// The account that created the association.
        public var createdBy: Swift.String?
        /// The ID of the association.
        public var id: Swift.String?
        /// The date and time that the association was last updated, specified in ISO-8601 format.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the service network.
        public var serviceNetworkArn: Swift.String?
        /// The ID of the service network.
        public var serviceNetworkId: Swift.String?
        /// The name of the service network.
        public var serviceNetworkName: Swift.String?
        /// The status.
        public var status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus?
        /// The ID of the VPC.
        public var vpcId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            serviceNetworkArn: Swift.String? = nil,
            serviceNetworkId: Swift.String? = nil,
            serviceNetworkName: Swift.String? = nil,
            status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.serviceNetworkArn = serviceNetworkArn
            self.serviceNetworkId = serviceNetworkId
            self.serviceNetworkName = serviceNetworkName
            self.status = status
            self.vpcId = vpcId
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the service quota that was exceeded.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The resource ID.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
        /// The service code.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case resourceId
        case resourceType
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension VPCLatticeClientTypes {
    public enum ServiceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Service is active.
        case active
        /// Service creation failed
        case createFailed
        /// Service creation in progress.
        case createInProgress
        /// Service deletion failed.
        case deleteFailed
        /// Service deletion in progress
        case deleteInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleteFailed,
                .deleteInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceStatus(rawValue: rawValue) ?? ServiceStatus.sdkUnknown(rawValue)
        }
    }
}

extension VPCLatticeClientTypes.ServiceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case customDomainName
        case dnsEntry
        case id
        case lastUpdatedAt
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let customDomainName = self.customDomainName {
            try encodeContainer.encode(customDomainName, forKey: .customDomainName)
        }
        if let dnsEntry = self.dnsEntry {
            try encodeContainer.encode(dnsEntry, forKey: .dnsEntry)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .dateTime, forKey: .lastUpdatedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let dnsEntryDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.DnsEntry.self, forKey: .dnsEntry)
        dnsEntry = dnsEntryDecoded
        let customDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomainName)
        customDomainName = customDomainNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ServiceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Summary information about a service.
    public struct ServiceSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the service.
        public var arn: Swift.String?
        /// The date and time that the service was created, specified in ISO-8601 format.
        public var createdAt: ClientRuntime.Date?
        /// The custom domain name of the service.
        public var customDomainName: Swift.String?
        /// DNS information about the service.
        public var dnsEntry: VPCLatticeClientTypes.DnsEntry?
        /// The ID of the service.
        public var id: Swift.String?
        /// The date and time that the service was last updated. The format is ISO-8601.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the service.
        public var name: Swift.String?
        /// The status.
        public var status: VPCLatticeClientTypes.ServiceStatus?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            customDomainName: Swift.String? = nil,
            dnsEntry: VPCLatticeClientTypes.DnsEntry? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: VPCLatticeClientTypes.ServiceStatus? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.customDomainName = customDomainName
            self.dnsEntry = dnsEntry
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.status = status
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags for the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension VPCLatticeClientTypes.Target: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case port
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Describes a target.
    public struct Target: Swift.Equatable {
        /// The ID of the target. If the target type of the target group is INSTANCE, this is an instance ID. If the target type is IP , this is an IP address. If the target type is LAMBDA, this is the ARN of the Lambda function. If the target type is ALB, this is the ARN of the Application Load Balancer.
        /// This member is required.
        public var id: Swift.String?
        /// The port on which the target is listening. For HTTP, the default is 80. For HTTPS, the default is 443.
        public var port: Swift.Int?

        public init(
            id: Swift.String? = nil,
            port: Swift.Int? = nil
        )
        {
            self.id = id
            self.port = port
        }
    }

}

extension VPCLatticeClientTypes.TargetFailure: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureCode
        case failureMessage
        case id
        case port
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureCode = self.failureCode {
            try encodeContainer.encode(failureCode, forKey: .failureCode)
        }
        if let failureMessage = self.failureMessage {
            try encodeContainer.encode(failureMessage, forKey: .failureMessage)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Describes a target failure.
    public struct TargetFailure: Swift.Equatable {
        /// The failure code.
        public var failureCode: Swift.String?
        /// The failure message.
        public var failureMessage: Swift.String?
        /// The ID of the target. If the target type of the target group is INSTANCE, this is an instance ID. If the target type is IP , this is an IP address. If the target type is LAMBDA, this is the ARN of the Lambda function. If the target type is ALB, this is the ARN of the Application Load Balancer.
        public var id: Swift.String?
        /// The port on which the target is listening. This parameter doesn't apply if the target is a Lambda function.
        public var port: Swift.Int?

        public init(
            failureCode: Swift.String? = nil,
            failureMessage: Swift.String? = nil,
            id: Swift.String? = nil,
            port: Swift.Int? = nil
        )
        {
            self.failureCode = failureCode
            self.failureMessage = failureMessage
            self.id = id
            self.port = port
        }
    }

}

extension VPCLatticeClientTypes.TargetGroupConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthCheck
        case ipAddressType
        case lambdaEventStructureVersion
        case port
        case `protocol` = "protocol"
        case protocolVersion
        case vpcIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let healthCheck = self.healthCheck {
            try encodeContainer.encode(healthCheck, forKey: .healthCheck)
        }
        if let ipAddressType = self.ipAddressType {
            try encodeContainer.encode(ipAddressType.rawValue, forKey: .ipAddressType)
        }
        if let lambdaEventStructureVersion = self.lambdaEventStructureVersion {
            try encodeContainer.encode(lambdaEventStructureVersion.rawValue, forKey: .lambdaEventStructureVersion)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let protocolVersion = self.protocolVersion {
            try encodeContainer.encode(protocolVersion.rawValue, forKey: .protocolVersion)
        }
        if let vpcIdentifier = self.vpcIdentifier {
            try encodeContainer.encode(vpcIdentifier, forKey: .vpcIdentifier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetGroupProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let protocolVersionDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetGroupProtocolVersion.self, forKey: .protocolVersion)
        protocolVersion = protocolVersionDecoded
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let vpcIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcIdentifier)
        vpcIdentifier = vpcIdentifierDecoded
        let healthCheckDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.HealthCheckConfig.self, forKey: .healthCheck)
        healthCheck = healthCheckDecoded
        let lambdaEventStructureVersionDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.LambdaEventStructureVersion.self, forKey: .lambdaEventStructureVersion)
        lambdaEventStructureVersion = lambdaEventStructureVersionDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Describes the configuration of a target group. Lambda functions don't support target group configuration.
    public struct TargetGroupConfig: Swift.Equatable {
        /// The health check configuration.
        public var healthCheck: VPCLatticeClientTypes.HealthCheckConfig?
        /// The type of IP address used for the target group. The possible values are ipv4 and ipv6. This is an optional parameter. If not specified, the IP address type defaults to ipv4.
        public var ipAddressType: VPCLatticeClientTypes.IpAddressType?
        /// Lambda event structure version
        public var lambdaEventStructureVersion: VPCLatticeClientTypes.LambdaEventStructureVersion?
        /// The port on which the targets are listening. For HTTP, the default is 80. For HTTPS, the default is 443
        public var port: Swift.Int?
        /// The protocol to use for routing traffic to the targets. Default is the protocol of a target group.
        public var `protocol`: VPCLatticeClientTypes.TargetGroupProtocol?
        /// The protocol version. Default value is HTTP1.
        public var protocolVersion: VPCLatticeClientTypes.TargetGroupProtocolVersion?
        /// The ID of the VPC.
        public var vpcIdentifier: Swift.String?

        public init(
            healthCheck: VPCLatticeClientTypes.HealthCheckConfig? = nil,
            ipAddressType: VPCLatticeClientTypes.IpAddressType? = nil,
            lambdaEventStructureVersion: VPCLatticeClientTypes.LambdaEventStructureVersion? = nil,
            port: Swift.Int? = nil,
            `protocol`: VPCLatticeClientTypes.TargetGroupProtocol? = nil,
            protocolVersion: VPCLatticeClientTypes.TargetGroupProtocolVersion? = nil,
            vpcIdentifier: Swift.String? = nil
        )
        {
            self.healthCheck = healthCheck
            self.ipAddressType = ipAddressType
            self.lambdaEventStructureVersion = lambdaEventStructureVersion
            self.port = port
            self.`protocol` = `protocol`
            self.protocolVersion = protocolVersion
            self.vpcIdentifier = vpcIdentifier
        }
    }

}

extension VPCLatticeClientTypes {
    public enum TargetGroupProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Indicates HTTP protocol
        case http
        /// Indicates HTTPS protocol
        case https
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetGroupProtocol] {
            return [
                .http,
                .https,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case .https: return "HTTPS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetGroupProtocol(rawValue: rawValue) ?? TargetGroupProtocol.sdkUnknown(rawValue)
        }
    }
}

extension VPCLatticeClientTypes {
    public enum TargetGroupProtocolVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Indicates use of gRPC to send requests to target
        case grpc
        /// Indicates use of HTTP/1.1 to send requests to target
        case http1
        /// Indicates use of HTTP/2 to send requests to target
        case http2
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetGroupProtocolVersion] {
            return [
                .grpc,
                .http1,
                .http2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .grpc: return "GRPC"
            case .http1: return "HTTP1"
            case .http2: return "HTTP2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetGroupProtocolVersion(rawValue: rawValue) ?? TargetGroupProtocolVersion.sdkUnknown(rawValue)
        }
    }
}

extension VPCLatticeClientTypes {
    public enum TargetGroupStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// TargetGroup is active
        case active
        /// TargetGroup creation failed.
        case createFailed
        /// TargetGroup creation in progress
        case createInProgress
        /// TargetGroup deletion failed
        case deleteFailed
        /// TargetGroup deletion in progress
        case deleteInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetGroupStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleteFailed,
                .deleteInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetGroupStatus(rawValue: rawValue) ?? TargetGroupStatus.sdkUnknown(rawValue)
        }
    }
}

extension VPCLatticeClientTypes.TargetGroupSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case id
        case ipAddressType
        case lambdaEventStructureVersion
        case lastUpdatedAt
        case name
        case port
        case `protocol` = "protocol"
        case serviceArns
        case status
        case type
        case vpcIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let ipAddressType = self.ipAddressType {
            try encodeContainer.encode(ipAddressType.rawValue, forKey: .ipAddressType)
        }
        if let lambdaEventStructureVersion = self.lambdaEventStructureVersion {
            try encodeContainer.encode(lambdaEventStructureVersion.rawValue, forKey: .lambdaEventStructureVersion)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .dateTime, forKey: .lastUpdatedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let serviceArns = serviceArns {
            var serviceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serviceArns)
            for servicearn0 in serviceArns {
                try serviceArnsContainer.encode(servicearn0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let vpcIdentifier = self.vpcIdentifier {
            try encodeContainer.encode(vpcIdentifier, forKey: .vpcIdentifier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetGroupType.self, forKey: .type)
        type = typeDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetGroupProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let vpcIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcIdentifier)
        vpcIdentifier = vpcIdentifierDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetGroupStatus.self, forKey: .status)
        status = statusDecoded
        let serviceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .serviceArns)
        var serviceArnsDecoded0:[Swift.String]? = nil
        if let serviceArnsContainer = serviceArnsContainer {
            serviceArnsDecoded0 = [Swift.String]()
            for string0 in serviceArnsContainer {
                if let string0 = string0 {
                    serviceArnsDecoded0?.append(string0)
                }
            }
        }
        serviceArns = serviceArnsDecoded0
        let lambdaEventStructureVersionDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.LambdaEventStructureVersion.self, forKey: .lambdaEventStructureVersion)
        lambdaEventStructureVersion = lambdaEventStructureVersionDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Summary information about a target group.
    public struct TargetGroupSummary: Swift.Equatable {
        /// The ARN (Amazon Resource Name) of the target group.
        public var arn: Swift.String?
        /// The date and time that the target group was created, specified in ISO-8601 format.
        public var createdAt: ClientRuntime.Date?
        /// The ID of the target group.
        public var id: Swift.String?
        /// The type of IP address used for the target group. The possible values are ipv4 and ipv6. This is an optional parameter. If not specified, the IP address type defaults to ipv4.
        public var ipAddressType: VPCLatticeClientTypes.IpAddressType?
        /// Lambda event structure version
        public var lambdaEventStructureVersion: VPCLatticeClientTypes.LambdaEventStructureVersion?
        /// The date and time that the target group was last updated, specified in ISO-8601 format.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The name of the target group.
        public var name: Swift.String?
        /// The port of the target group.
        public var port: Swift.Int?
        /// The protocol of the target group.
        public var `protocol`: VPCLatticeClientTypes.TargetGroupProtocol?
        /// The list of Amazon Resource Names (ARNs) of the service.
        public var serviceArns: [Swift.String]?
        /// The status.
        public var status: VPCLatticeClientTypes.TargetGroupStatus?
        /// The target group type.
        public var type: VPCLatticeClientTypes.TargetGroupType?
        /// The ID of the VPC of the target group.
        public var vpcIdentifier: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            ipAddressType: VPCLatticeClientTypes.IpAddressType? = nil,
            lambdaEventStructureVersion: VPCLatticeClientTypes.LambdaEventStructureVersion? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: VPCLatticeClientTypes.TargetGroupProtocol? = nil,
            serviceArns: [Swift.String]? = nil,
            status: VPCLatticeClientTypes.TargetGroupStatus? = nil,
            type: VPCLatticeClientTypes.TargetGroupType? = nil,
            vpcIdentifier: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.ipAddressType = ipAddressType
            self.lambdaEventStructureVersion = lambdaEventStructureVersion
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.port = port
            self.`protocol` = `protocol`
            self.serviceArns = serviceArns
            self.status = status
            self.type = type
            self.vpcIdentifier = vpcIdentifier
        }
    }

}

extension VPCLatticeClientTypes {
    public enum TargetGroupType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Indicates target in this target group is an ALB
        case alb
        /// Indicates targets in this target group are EC2 instances
        case instance
        /// Indicates targets in this target group are IP
        case ip
        /// Indicates targets in this target group are Lambda
        case lambda
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetGroupType] {
            return [
                .alb,
                .instance,
                .ip,
                .lambda,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alb: return "ALB"
            case .instance: return "INSTANCE"
            case .ip: return "IP"
            case .lambda: return "LAMBDA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetGroupType(rawValue: rawValue) ?? TargetGroupType.sdkUnknown(rawValue)
        }
    }
}

extension VPCLatticeClientTypes {
    public enum TargetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// The target is deregistering and connection draining is in process.
        case draining
        /// The target is healthy.
        case healthy
        /// The initial health check is in progress.
        case initial
        /// Health checks are disabled.
        case unavailable
        /// The target failed the health check.
        case unhealthy
        /// The target group is not used in a listener rule.
        case unused
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetStatus] {
            return [
                .draining,
                .healthy,
                .initial,
                .unavailable,
                .unhealthy,
                .unused,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .draining: return "DRAINING"
            case .healthy: return "HEALTHY"
            case .initial: return "INITIAL"
            case .unavailable: return "UNAVAILABLE"
            case .unhealthy: return "UNHEALTHY"
            case .unused: return "UNUSED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetStatus(rawValue: rawValue) ?? TargetStatus.sdkUnknown(rawValue)
        }
    }
}

extension VPCLatticeClientTypes.TargetSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case port
        case reasonCode
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let reasonCode = self.reasonCode {
            try encodeContainer.encode(reasonCode, forKey: .reasonCode)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetStatus.self, forKey: .status)
        status = statusDecoded
        let reasonCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reasonCode)
        reasonCode = reasonCodeDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Summary information about a target.
    public struct TargetSummary: Swift.Equatable {
        /// The ID of the target. If the target type of the target group is INSTANCE, this is an instance ID. If the target type is IP , this is an IP address. If the target type is LAMBDA, this is the ARN of the Lambda function. If the target type is ALB, this is the ARN of the Application Load Balancer.
        public var id: Swift.String?
        /// The port on which the target is listening.
        public var port: Swift.Int?
        /// The code for why the target status is what it is.
        public var reasonCode: Swift.String?
        /// The status of the target.
        ///
        /// * Draining: The target is being deregistered. No new connections will be sent to this target while current connections are being drained. Default draining time is 5 minutes.
        ///
        /// * Unavailable: Health checks are unavailable for the target group.
        ///
        /// * Healthy: The target is healthy.
        ///
        /// * Unhealthy: The target is unhealthy.
        ///
        /// * Initial: Initial health checks on the target are being performed.
        ///
        /// * Unused: Target group is not used in a service.
        public var status: VPCLatticeClientTypes.TargetStatus?

        public init(
            id: Swift.String? = nil,
            port: Swift.Int? = nil,
            reasonCode: Swift.String? = nil,
            status: VPCLatticeClientTypes.TargetStatus? = nil
        )
        {
            self.id = id
            self.port = port
            self.reasonCode = reasonCode
            self.status = status
        }
    }

}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The limit on the number of requests per second was exceeded.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the service quota that was exceeded.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The number of seconds to wait before retrying.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
        /// The service code.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys of the tags to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAccessLogSubscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationArn = self.destinationArn {
            try encodeContainer.encode(destinationArn, forKey: .destinationArn)
        }
    }
}

extension UpdateAccessLogSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accessLogSubscriptionIdentifier = accessLogSubscriptionIdentifier else {
            return nil
        }
        return "/accesslogsubscriptions/\(accessLogSubscriptionIdentifier.urlPercentEncoding())"
    }
}

public struct UpdateAccessLogSubscriptionInput: Swift.Equatable {
    /// The ID or Amazon Resource Name (ARN) of the access log subscription.
    /// This member is required.
    public var accessLogSubscriptionIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) of the access log destination.
    /// This member is required.
    public var destinationArn: Swift.String?

    public init(
        accessLogSubscriptionIdentifier: Swift.String? = nil,
        destinationArn: Swift.String? = nil
    )
    {
        self.accessLogSubscriptionIdentifier = accessLogSubscriptionIdentifier
        self.destinationArn = destinationArn
    }
}

struct UpdateAccessLogSubscriptionInputBody: Swift.Equatable {
    let destinationArn: Swift.String?
}

extension UpdateAccessLogSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationArn)
        destinationArn = destinationArnDecoded
    }
}

extension UpdateAccessLogSubscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAccessLogSubscriptionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.destinationArn = output.destinationArn
            self.id = output.id
            self.resourceArn = output.resourceArn
            self.resourceId = output.resourceId
        } else {
            self.arn = nil
            self.destinationArn = nil
            self.id = nil
            self.resourceArn = nil
            self.resourceId = nil
        }
    }
}

public struct UpdateAccessLogSubscriptionOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the access log subscription.
    /// This member is required.
    public var arn: Swift.String?
    /// The Amazon Resource Name (ARN) of the access log destination.
    /// This member is required.
    public var destinationArn: Swift.String?
    /// The ID of the access log subscription.
    /// This member is required.
    public var id: Swift.String?
    /// The Amazon Resource Name (ARN) of the access log subscription.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        destinationArn: Swift.String? = nil,
        id: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.destinationArn = destinationArn
        self.id = id
        self.resourceArn = resourceArn
        self.resourceId = resourceId
    }
}

struct UpdateAccessLogSubscriptionOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let resourceId: Swift.String?
    let resourceArn: Swift.String?
    let destinationArn: Swift.String?
}

extension UpdateAccessLogSubscriptionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case destinationArn
        case id
        case resourceArn
        case resourceId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let destinationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationArn)
        destinationArn = destinationArnDecoded
    }
}

enum UpdateAccessLogSubscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateListenerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultAction
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultAction = self.defaultAction {
            try encodeContainer.encode(defaultAction, forKey: .defaultAction)
        }
    }
}

extension UpdateListenerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceIdentifier = serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = listenerIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())"
    }
}

public struct UpdateListenerInput: Swift.Equatable {
    /// The action for the default rule.
    /// This member is required.
    public var defaultAction: VPCLatticeClientTypes.RuleAction?
    /// The ID or Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        defaultAction: VPCLatticeClientTypes.RuleAction? = nil,
        listenerIdentifier: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.defaultAction = defaultAction
        self.listenerIdentifier = listenerIdentifier
        self.serviceIdentifier = serviceIdentifier
    }
}

struct UpdateListenerInputBody: Swift.Equatable {
    let defaultAction: VPCLatticeClientTypes.RuleAction?
}

extension UpdateListenerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultAction
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultActionDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleAction.self, forKey: .defaultAction)
        defaultAction = defaultActionDecoded
    }
}

extension UpdateListenerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateListenerOutputBody = try responseDecoder.decode(responseBody: data)
            self.`protocol` = output.`protocol`
            self.arn = output.arn
            self.defaultAction = output.defaultAction
            self.id = output.id
            self.name = output.name
            self.port = output.port
            self.serviceArn = output.serviceArn
            self.serviceId = output.serviceId
        } else {
            self.arn = nil
            self.defaultAction = nil
            self.id = nil
            self.name = nil
            self.port = nil
            self.`protocol` = nil
            self.serviceArn = nil
            self.serviceId = nil
        }
    }
}

public struct UpdateListenerOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the listener.
    public var arn: Swift.String?
    /// The action for the default rule.
    public var defaultAction: VPCLatticeClientTypes.RuleAction?
    /// The ID of the listener.
    public var id: Swift.String?
    /// The name of the listener.
    public var name: Swift.String?
    /// The listener port.
    public var port: Swift.Int?
    /// The protocol of the listener.
    public var `protocol`: VPCLatticeClientTypes.ListenerProtocol?
    /// The Amazon Resource Name (ARN) of the service.
    public var serviceArn: Swift.String?
    /// The ID of the service.
    public var serviceId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        defaultAction: VPCLatticeClientTypes.RuleAction? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        port: Swift.Int? = nil,
        `protocol`: VPCLatticeClientTypes.ListenerProtocol? = nil,
        serviceArn: Swift.String? = nil,
        serviceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.defaultAction = defaultAction
        self.id = id
        self.name = name
        self.port = port
        self.`protocol` = `protocol`
        self.serviceArn = serviceArn
        self.serviceId = serviceId
    }
}

struct UpdateListenerOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let `protocol`: VPCLatticeClientTypes.ListenerProtocol?
    let port: Swift.Int?
    let serviceArn: Swift.String?
    let serviceId: Swift.String?
    let defaultAction: VPCLatticeClientTypes.RuleAction?
}

extension UpdateListenerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case defaultAction
        case id
        case name
        case port
        case `protocol` = "protocol"
        case serviceArn
        case serviceId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ListenerProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let defaultActionDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleAction.self, forKey: .defaultAction)
        defaultAction = defaultActionDecoded
    }
}

enum UpdateListenerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case match
        case priority
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let match = self.match {
            try encodeContainer.encode(match, forKey: .match)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
    }
}

extension UpdateRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceIdentifier = serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = listenerIdentifier else {
            return nil
        }
        guard let ruleIdentifier = ruleIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())/rules/\(ruleIdentifier.urlPercentEncoding())"
    }
}

public struct UpdateRuleInput: Swift.Equatable {
    /// Information about the action for the specified listener rule.
    public var action: VPCLatticeClientTypes.RuleAction?
    /// The ID or Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The rule match.
    public var match: VPCLatticeClientTypes.RuleMatch?
    /// The rule priority. A listener can't have multiple rules with the same priority.
    public var priority: Swift.Int?
    /// The ID or Amazon Resource Name (ARN) of the rule.
    /// This member is required.
    public var ruleIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        action: VPCLatticeClientTypes.RuleAction? = nil,
        listenerIdentifier: Swift.String? = nil,
        match: VPCLatticeClientTypes.RuleMatch? = nil,
        priority: Swift.Int? = nil,
        ruleIdentifier: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.action = action
        self.listenerIdentifier = listenerIdentifier
        self.match = match
        self.priority = priority
        self.ruleIdentifier = ruleIdentifier
        self.serviceIdentifier = serviceIdentifier
    }
}

struct UpdateRuleInputBody: Swift.Equatable {
    let match: VPCLatticeClientTypes.RuleMatch?
    let priority: Swift.Int?
    let action: VPCLatticeClientTypes.RuleAction?
}

extension UpdateRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case match
        case priority
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let matchDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleMatch.self, forKey: .match)
        match = matchDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let actionDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleAction.self, forKey: .action)
        action = actionDecoded
    }
}

extension UpdateRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.action = output.action
            self.arn = output.arn
            self.id = output.id
            self.isDefault = output.isDefault
            self.match = output.match
            self.name = output.name
            self.priority = output.priority
        } else {
            self.action = nil
            self.arn = nil
            self.id = nil
            self.isDefault = nil
            self.match = nil
            self.name = nil
            self.priority = nil
        }
    }
}

public struct UpdateRuleOutput: Swift.Equatable {
    /// Information about the action for the specified listener rule.
    public var action: VPCLatticeClientTypes.RuleAction?
    /// The Amazon Resource Name (ARN) of the listener.
    public var arn: Swift.String?
    /// The ID of the listener.
    public var id: Swift.String?
    /// Indicates whether this is the default rule.
    public var isDefault: Swift.Bool?
    /// The rule match.
    public var match: VPCLatticeClientTypes.RuleMatch?
    /// The name of the listener.
    public var name: Swift.String?
    /// The rule priority.
    public var priority: Swift.Int?

    public init(
        action: VPCLatticeClientTypes.RuleAction? = nil,
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        isDefault: Swift.Bool? = nil,
        match: VPCLatticeClientTypes.RuleMatch? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil
    )
    {
        self.action = action
        self.arn = arn
        self.id = id
        self.isDefault = isDefault
        self.match = match
        self.name = name
        self.priority = priority
    }
}

struct UpdateRuleOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let isDefault: Swift.Bool?
    let match: VPCLatticeClientTypes.RuleMatch?
    let priority: Swift.Int?
    let action: VPCLatticeClientTypes.RuleAction?
}

extension UpdateRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case arn
        case id
        case isDefault
        case match
        case name
        case priority
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let isDefaultDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDefault)
        isDefault = isDefaultDecoded
        let matchDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleMatch.self, forKey: .match)
        match = matchDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let actionDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.RuleAction.self, forKey: .action)
        action = actionDecoded
    }
}

enum UpdateRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateServiceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType
        case certificateArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authType = self.authType {
            try encodeContainer.encode(authType.rawValue, forKey: .authType)
        }
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
    }
}

extension UpdateServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceIdentifier = serviceIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())"
    }
}

public struct UpdateServiceInput: Swift.Equatable {
    /// The type of IAM policy.
    ///
    /// * NONE: The resource does not use an IAM policy. This is the default.
    ///
    /// * AWS_IAM: The resource uses an IAM policy. When this type is used, auth is enabled and an auth policy is required.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The Amazon Resource Name (ARN) of the certificate.
    public var certificateArn: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        authType: VPCLatticeClientTypes.AuthType? = nil,
        certificateArn: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.authType = authType
        self.certificateArn = certificateArn
        self.serviceIdentifier = serviceIdentifier
    }
}

struct UpdateServiceInputBody: Swift.Equatable {
    let certificateArn: Swift.String?
    let authType: VPCLatticeClientTypes.AuthType?
}

extension UpdateServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType
        case certificateArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.AuthType.self, forKey: .authType)
        authType = authTypeDecoded
    }
}

extension UpdateServiceNetworkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authType = self.authType {
            try encodeContainer.encode(authType.rawValue, forKey: .authType)
        }
    }
}

extension UpdateServiceNetworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceNetworkIdentifier = serviceNetworkIdentifier else {
            return nil
        }
        return "/servicenetworks/\(serviceNetworkIdentifier.urlPercentEncoding())"
    }
}

public struct UpdateServiceNetworkInput: Swift.Equatable {
    /// The type of IAM policy.
    ///
    /// * NONE: The resource does not use an IAM policy. This is the default.
    ///
    /// * AWS_IAM: The resource uses an IAM policy. When this type is used, auth is enabled and an auth policy is required.
    /// This member is required.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The ID or Amazon Resource Name (ARN) of the service network.
    /// This member is required.
    public var serviceNetworkIdentifier: Swift.String?

    public init(
        authType: VPCLatticeClientTypes.AuthType? = nil,
        serviceNetworkIdentifier: Swift.String? = nil
    )
    {
        self.authType = authType
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
    }
}

struct UpdateServiceNetworkInputBody: Swift.Equatable {
    let authType: VPCLatticeClientTypes.AuthType?
}

extension UpdateServiceNetworkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authTypeDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.AuthType.self, forKey: .authType)
        authType = authTypeDecoded
    }
}

extension UpdateServiceNetworkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateServiceNetworkOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.authType = output.authType
            self.id = output.id
            self.name = output.name
        } else {
            self.arn = nil
            self.authType = nil
            self.id = nil
            self.name = nil
        }
    }
}

public struct UpdateServiceNetworkOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the service network.
    public var arn: Swift.String?
    /// The type of IAM policy.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The ID of the service network.
    public var id: Swift.String?
    /// The name of the service network.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        authType: VPCLatticeClientTypes.AuthType? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.authType = authType
        self.id = id
        self.name = name
    }
}

struct UpdateServiceNetworkOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let authType: VPCLatticeClientTypes.AuthType?
}

extension UpdateServiceNetworkOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case authType
        case id
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.AuthType.self, forKey: .authType)
        authType = authTypeDecoded
    }
}

enum UpdateServiceNetworkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateServiceNetworkVpcAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupid0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupid0)
            }
        }
    }
}

extension UpdateServiceNetworkVpcAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serviceNetworkVpcAssociationIdentifier = serviceNetworkVpcAssociationIdentifier else {
            return nil
        }
        return "/servicenetworkvpcassociations/\(serviceNetworkVpcAssociationIdentifier.urlPercentEncoding())"
    }
}

public struct UpdateServiceNetworkVpcAssociationInput: Swift.Equatable {
    /// The IDs of the security groups. Once you add a security group, it cannot be removed.
    /// This member is required.
    public var securityGroupIds: [Swift.String]?
    /// The ID or Amazon Resource Name (ARN) of the association.
    /// This member is required.
    public var serviceNetworkVpcAssociationIdentifier: Swift.String?

    public init(
        securityGroupIds: [Swift.String]? = nil,
        serviceNetworkVpcAssociationIdentifier: Swift.String? = nil
    )
    {
        self.securityGroupIds = securityGroupIds
        self.serviceNetworkVpcAssociationIdentifier = serviceNetworkVpcAssociationIdentifier
    }
}

struct UpdateServiceNetworkVpcAssociationInputBody: Swift.Equatable {
    let securityGroupIds: [Swift.String]?
}

extension UpdateServiceNetworkVpcAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension UpdateServiceNetworkVpcAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateServiceNetworkVpcAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdBy = output.createdBy
            self.id = output.id
            self.securityGroupIds = output.securityGroupIds
            self.status = output.status
        } else {
            self.arn = nil
            self.createdBy = nil
            self.id = nil
            self.securityGroupIds = nil
            self.status = nil
        }
    }
}

public struct UpdateServiceNetworkVpcAssociationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The account that created the association.
    public var createdBy: Swift.String?
    /// The ID of the association.
    public var id: Swift.String?
    /// The IDs of the security groups.
    public var securityGroupIds: [Swift.String]?
    /// The status. You can retry the operation if the status is DELETE_FAILED. However, if you retry it while the status is DELETE_IN_PROGRESS, there is no change in the status.
    public var status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus?

    public init(
        arn: Swift.String? = nil,
        createdBy: Swift.String? = nil,
        id: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus? = nil
    )
    {
        self.arn = arn
        self.createdBy = createdBy
        self.id = id
        self.securityGroupIds = securityGroupIds
        self.status = status
    }
}

struct UpdateServiceNetworkVpcAssociationOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus?
    let createdBy: Swift.String?
    let securityGroupIds: [Swift.String]?
}

extension UpdateServiceNetworkVpcAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdBy
        case id
        case securityGroupIds
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

enum UpdateServiceNetworkVpcAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateServiceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateServiceOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.authType = output.authType
            self.certificateArn = output.certificateArn
            self.customDomainName = output.customDomainName
            self.id = output.id
            self.name = output.name
        } else {
            self.arn = nil
            self.authType = nil
            self.certificateArn = nil
            self.customDomainName = nil
            self.id = nil
            self.name = nil
        }
    }
}

public struct UpdateServiceOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the service.
    public var arn: Swift.String?
    /// The type of IAM policy.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The Amazon Resource Name (ARN) of the certificate.
    public var certificateArn: Swift.String?
    /// The custom domain name of the service.
    public var customDomainName: Swift.String?
    /// The ID of the service.
    public var id: Swift.String?
    /// The name of the service.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        authType: VPCLatticeClientTypes.AuthType? = nil,
        certificateArn: Swift.String? = nil,
        customDomainName: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.authType = authType
        self.certificateArn = certificateArn
        self.customDomainName = customDomainName
        self.id = id
        self.name = name
    }
}

struct UpdateServiceOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let customDomainName: Swift.String?
    let certificateArn: Swift.String?
    let authType: VPCLatticeClientTypes.AuthType?
}

extension UpdateServiceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case authType
        case certificateArn
        case customDomainName
        case id
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let customDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomainName)
        customDomainName = customDomainNameDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.AuthType.self, forKey: .authType)
        authType = authTypeDecoded
    }
}

enum UpdateServiceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateTargetGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthCheck
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let healthCheck = self.healthCheck {
            try encodeContainer.encode(healthCheck, forKey: .healthCheck)
        }
    }
}

extension UpdateTargetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let targetGroupIdentifier = targetGroupIdentifier else {
            return nil
        }
        return "/targetgroups/\(targetGroupIdentifier.urlPercentEncoding())"
    }
}

public struct UpdateTargetGroupInput: Swift.Equatable {
    /// The health check configuration.
    /// This member is required.
    public var healthCheck: VPCLatticeClientTypes.HealthCheckConfig?
    /// The ID or Amazon Resource Name (ARN) of the target group.
    /// This member is required.
    public var targetGroupIdentifier: Swift.String?

    public init(
        healthCheck: VPCLatticeClientTypes.HealthCheckConfig? = nil,
        targetGroupIdentifier: Swift.String? = nil
    )
    {
        self.healthCheck = healthCheck
        self.targetGroupIdentifier = targetGroupIdentifier
    }
}

struct UpdateTargetGroupInputBody: Swift.Equatable {
    let healthCheck: VPCLatticeClientTypes.HealthCheckConfig?
}

extension UpdateTargetGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthCheck
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let healthCheckDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.HealthCheckConfig.self, forKey: .healthCheck)
        healthCheck = healthCheckDecoded
    }
}

extension UpdateTargetGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateTargetGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.config = output.config
            self.id = output.id
            self.name = output.name
            self.status = output.status
            self.type = output.type
        } else {
            self.arn = nil
            self.config = nil
            self.id = nil
            self.name = nil
            self.status = nil
            self.type = nil
        }
    }
}

public struct UpdateTargetGroupOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the target group.
    public var arn: Swift.String?
    /// The target group configuration.
    public var config: VPCLatticeClientTypes.TargetGroupConfig?
    /// The ID of the target group.
    public var id: Swift.String?
    /// The name of the target group.
    public var name: Swift.String?
    /// The status.
    public var status: VPCLatticeClientTypes.TargetGroupStatus?
    /// The target group type.
    public var type: VPCLatticeClientTypes.TargetGroupType?

    public init(
        arn: Swift.String? = nil,
        config: VPCLatticeClientTypes.TargetGroupConfig? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: VPCLatticeClientTypes.TargetGroupStatus? = nil,
        type: VPCLatticeClientTypes.TargetGroupType? = nil
    )
    {
        self.arn = arn
        self.config = config
        self.id = id
        self.name = name
        self.status = status
        self.type = type
    }
}

struct UpdateTargetGroupOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let type: VPCLatticeClientTypes.TargetGroupType?
    let config: VPCLatticeClientTypes.TargetGroupConfig?
    let status: VPCLatticeClientTypes.TargetGroupStatus?
}

extension UpdateTargetGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case config
        case id
        case name
        case status
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetGroupType.self, forKey: .type)
        type = typeDecoded
        let configDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetGroupConfig.self, forKey: .config)
        config = configDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.TargetGroupStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum UpdateTargetGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fieldList = output.fieldList
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.fieldList = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input does not satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The fields that failed validation.
        public internal(set) var fieldList: [VPCLatticeClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason.
        /// This member is required.
        public internal(set) var reason: VPCLatticeClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [VPCLatticeClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: VPCLatticeClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: VPCLatticeClientTypes.ValidationExceptionReason?
    let fieldList: [VPCLatticeClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(VPCLatticeClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([VPCLatticeClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[VPCLatticeClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [VPCLatticeClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension VPCLatticeClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Describes a validation failure.
    public struct ValidationExceptionField: Swift.Equatable {
        /// Additional details about why the validation failed.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the validation exception.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension VPCLatticeClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension VPCLatticeClientTypes.WeightedTargetGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetGroupIdentifier
        case weight
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetGroupIdentifier = self.targetGroupIdentifier {
            try encodeContainer.encode(targetGroupIdentifier, forKey: .targetGroupIdentifier)
        }
        if let weight = self.weight {
            try encodeContainer.encode(weight, forKey: .weight)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetGroupIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetGroupIdentifier)
        targetGroupIdentifier = targetGroupIdentifierDecoded
        let weightDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .weight)
        weight = weightDecoded
    }
}

extension VPCLatticeClientTypes {
    /// Describes the weight of a target group.
    public struct WeightedTargetGroup: Swift.Equatable {
        /// The ID or Amazon Resource Name (ARN) of the target group.
        /// This member is required.
        public var targetGroupIdentifier: Swift.String?
        /// Only required if you specify multiple target groups for a forward action. The "weight" determines how requests are distributed to the target group. For example, if you specify two target groups, each with a weight of 10, each target group receives half the requests. If you specify two target groups, one with a weight of 10 and the other with a weight of 20, the target group with a weight of 20 receives twice as many requests as the other target group. If there's only one target group specified, then the default value is 100.
        public var weight: Swift.Int?

        public init(
            targetGroupIdentifier: Swift.String? = nil,
            weight: Swift.Int? = nil
        )
        {
            self.targetGroupIdentifier = targetGroupIdentifier
            self.weight = weight
        }
    }

}
