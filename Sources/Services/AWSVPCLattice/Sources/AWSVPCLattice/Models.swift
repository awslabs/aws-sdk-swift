//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// The user does not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request conflicts with the current state of the resource. Updating or deleting a resource can cause an inconsistent state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The resource ID.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// An unexpected error occurred while processing the request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The number of seconds to wait before retrying.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    ) {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// The request references a resource that does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The resource ID.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The limit on the number of requests per second was exceeded.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the service quota that was exceeded.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The number of seconds to wait before retrying.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
        /// The service code.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

extension VPCLatticeClientTypes {

    /// Describes a validation failure.
    public struct ValidationExceptionField: Swift.Sendable {
        /// Additional information about why the validation failed.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the validation exception.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        ) {
            self.message = message
            self.name = name
        }
    }
}

extension VPCLatticeClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The input does not satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// The fields that failed validation.
        public internal(set) var fieldList: [VPCLatticeClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason.
        /// This member is required.
        public internal(set) var reason: VPCLatticeClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [VPCLatticeClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: VPCLatticeClientTypes.ValidationExceptionReason? = nil
    ) {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension VPCLatticeClientTypes {

    public enum ServiceNetworkLogType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Indicates logs for Lattice resource configurations.
        case resource
        /// Indicates logs for Lattice services.
        case service
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceNetworkLogType] {
            return [
                .resource,
                .service
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .resource: return "RESOURCE"
            case .service: return "SERVICE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateAccessLogSubscriptionInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the destination. The supported destination types are CloudWatch Log groups, Kinesis Data Firehose delivery streams, and Amazon S3 buckets.
    /// This member is required.
    public var destinationArn: Swift.String?
    /// The ID or ARN of the service network or service.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The type of log that monitors your Amazon VPC Lattice service networks.
    public var serviceNetworkLogType: VPCLatticeClientTypes.ServiceNetworkLogType?
    /// The tags for the access log subscription.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        destinationArn: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil,
        serviceNetworkLogType: VPCLatticeClientTypes.ServiceNetworkLogType? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.clientToken = clientToken
        self.destinationArn = destinationArn
        self.resourceIdentifier = resourceIdentifier
        self.serviceNetworkLogType = serviceNetworkLogType
        self.tags = tags
    }
}

public struct CreateAccessLogSubscriptionOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the access log subscription.
    /// This member is required.
    public var arn: Swift.String?
    /// The Amazon Resource Name (ARN) of the log destination.
    /// This member is required.
    public var destinationArn: Swift.String?
    /// The ID of the access log subscription.
    /// This member is required.
    public var id: Swift.String?
    /// The Amazon Resource Name (ARN) of the service network or service.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The ID of the service network or service.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The type of log that monitors your Amazon VPC Lattice service networks.
    public var serviceNetworkLogType: VPCLatticeClientTypes.ServiceNetworkLogType?

    public init(
        arn: Swift.String? = nil,
        destinationArn: Swift.String? = nil,
        id: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        serviceNetworkLogType: VPCLatticeClientTypes.ServiceNetworkLogType? = nil
    ) {
        self.arn = arn
        self.destinationArn = destinationArn
        self.id = id
        self.resourceArn = resourceArn
        self.resourceId = resourceId
        self.serviceNetworkLogType = serviceNetworkLogType
    }
}

public struct DeleteAccessLogSubscriptionInput: Swift.Sendable {
    /// The ID or ARN of the access log subscription.
    /// This member is required.
    public var accessLogSubscriptionIdentifier: Swift.String?

    public init(
        accessLogSubscriptionIdentifier: Swift.String? = nil
    ) {
        self.accessLogSubscriptionIdentifier = accessLogSubscriptionIdentifier
    }
}

public struct DeleteAccessLogSubscriptionOutput: Swift.Sendable {

    public init() { }
}

public struct GetAccessLogSubscriptionInput: Swift.Sendable {
    /// The ID or ARN of the access log subscription.
    /// This member is required.
    public var accessLogSubscriptionIdentifier: Swift.String?

    public init(
        accessLogSubscriptionIdentifier: Swift.String? = nil
    ) {
        self.accessLogSubscriptionIdentifier = accessLogSubscriptionIdentifier
    }
}

public struct GetAccessLogSubscriptionOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the access log subscription.
    /// This member is required.
    public var arn: Swift.String?
    /// The date and time that the access log subscription was created, in ISO-8601 format.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the access log destination.
    /// This member is required.
    public var destinationArn: Swift.String?
    /// The ID of the access log subscription.
    /// This member is required.
    public var id: Swift.String?
    /// The date and time that the access log subscription was last updated, in ISO-8601 format.
    /// This member is required.
    public var lastUpdatedAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the service network or service.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The ID of the service network or service.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The log type for the service network.
    public var serviceNetworkLogType: VPCLatticeClientTypes.ServiceNetworkLogType?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        destinationArn: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        resourceArn: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        serviceNetworkLogType: VPCLatticeClientTypes.ServiceNetworkLogType? = nil
    ) {
        self.arn = arn
        self.createdAt = createdAt
        self.destinationArn = destinationArn
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.resourceArn = resourceArn
        self.resourceId = resourceId
        self.serviceNetworkLogType = serviceNetworkLogType
    }
}

public struct ListAccessLogSubscriptionsInput: Swift.Sendable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID or ARN of the service network or service.
    /// This member is required.
    public var resourceIdentifier: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceIdentifier = resourceIdentifier
    }
}

extension VPCLatticeClientTypes {

    /// Summary information about an access log subscription.
    public struct AccessLogSubscriptionSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the access log subscription
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the access log subscription was created, in ISO-8601 format.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the destination.
        /// This member is required.
        public var destinationArn: Swift.String?
        /// The ID of the access log subscription.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time that the access log subscription was last updated, in ISO-8601 format.
        /// This member is required.
        public var lastUpdatedAt: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the service or service network.
        /// This member is required.
        public var resourceArn: Swift.String?
        /// The ID of the service or service network.
        /// This member is required.
        public var resourceId: Swift.String?
        /// Log type of the service network.
        public var serviceNetworkLogType: VPCLatticeClientTypes.ServiceNetworkLogType?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            destinationArn: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            resourceArn: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            serviceNetworkLogType: VPCLatticeClientTypes.ServiceNetworkLogType? = nil
        ) {
            self.arn = arn
            self.createdAt = createdAt
            self.destinationArn = destinationArn
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.serviceNetworkLogType = serviceNetworkLogType
        }
    }
}

public struct ListAccessLogSubscriptionsOutput: Swift.Sendable {
    /// Information about the access log subscriptions.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.AccessLogSubscriptionSummary]?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.AccessLogSubscriptionSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct UpdateAccessLogSubscriptionInput: Swift.Sendable {
    /// The ID or ARN of the access log subscription.
    /// This member is required.
    public var accessLogSubscriptionIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) of the access log destination.
    /// This member is required.
    public var destinationArn: Swift.String?

    public init(
        accessLogSubscriptionIdentifier: Swift.String? = nil,
        destinationArn: Swift.String? = nil
    ) {
        self.accessLogSubscriptionIdentifier = accessLogSubscriptionIdentifier
        self.destinationArn = destinationArn
    }
}

public struct UpdateAccessLogSubscriptionOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the access log subscription.
    /// This member is required.
    public var arn: Swift.String?
    /// The Amazon Resource Name (ARN) of the access log destination.
    /// This member is required.
    public var destinationArn: Swift.String?
    /// The ID of the access log subscription.
    /// This member is required.
    public var id: Swift.String?
    /// The Amazon Resource Name (ARN) of the access log subscription.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        destinationArn: Swift.String? = nil,
        id: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceId: Swift.String? = nil
    ) {
        self.arn = arn
        self.destinationArn = destinationArn
        self.id = id
        self.resourceArn = resourceArn
        self.resourceId = resourceId
    }
}

extension VPCLatticeClientTypes {

    /// The Amazon Resource Name (ARN) of the resource.
    public struct ArnResource: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the resource.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        ) {
            self.arn = arn
        }
    }
}

extension VPCLatticeClientTypes {

    public enum AuthPolicyState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthPolicyState] {
            return [
                .active,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .inactive: return "Inactive"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VPCLatticeClientTypes {

    public enum AuthType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsIam
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthType] {
            return [
                .awsIam,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsIam: return "AWS_IAM"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VPCLatticeClientTypes {

    /// Describes an action that returns a custom HTTP response.
    public struct FixedResponseAction: Swift.Sendable {
        /// The HTTP response code.
        /// This member is required.
        public var statusCode: Swift.Int?

        public init(
            statusCode: Swift.Int? = nil
        ) {
            self.statusCode = statusCode
        }
    }
}

extension VPCLatticeClientTypes {

    /// Describes the weight of a target group.
    public struct WeightedTargetGroup: Swift.Sendable {
        /// The ID or ARN of the target group.
        /// This member is required.
        public var targetGroupIdentifier: Swift.String?
        /// Only required if you specify multiple target groups for a forward action. The weight determines how requests are distributed to the target group. For example, if you specify two target groups, each with a weight of 10, each target group receives half the requests. If you specify two target groups, one with a weight of 10 and the other with a weight of 20, the target group with a weight of 20 receives twice as many requests as the other target group. If there's only one target group specified, then the default value is 100.
        public var weight: Swift.Int?

        public init(
            targetGroupIdentifier: Swift.String? = nil,
            weight: Swift.Int? = nil
        ) {
            self.targetGroupIdentifier = targetGroupIdentifier
            self.weight = weight
        }
    }
}

extension VPCLatticeClientTypes {

    /// Describes a forward action. You can use forward actions to route requests to one or more target groups.
    public struct ForwardAction: Swift.Sendable {
        /// The target groups. Traffic matching the rule is forwarded to the specified target groups. With forward actions, you can assign a weight that controls the prioritization and selection of each target group. This means that requests are distributed to individual target groups based on their weights. For example, if two target groups have the same weight, each target group receives half of the traffic. The default value is 1. This means that if only one target group is provided, there is no need to set the weight; 100% of the traffic goes to that target group.
        /// This member is required.
        public var targetGroups: [VPCLatticeClientTypes.WeightedTargetGroup]?

        public init(
            targetGroups: [VPCLatticeClientTypes.WeightedTargetGroup]? = nil
        ) {
            self.targetGroups = targetGroups
        }
    }
}

extension VPCLatticeClientTypes {

    /// Describes the action for a rule.
    public enum RuleAction: Swift.Sendable {
        /// The forward action. Traffic that matches the rule is forwarded to the specified target groups.
        case forward(VPCLatticeClientTypes.ForwardAction)
        /// The fixed response action. The rule returns a custom HTTP response.
        case fixedresponse(VPCLatticeClientTypes.FixedResponseAction)
        case sdkUnknown(Swift.String)
    }
}

extension VPCLatticeClientTypes {

    /// Describes a header match type.
    public enum HeaderMatchType: Swift.Sendable {
        /// An exact type match.
        case exact(Swift.String)
        /// A prefix type match. Matches the value with the prefix.
        case `prefix`(Swift.String)
        /// A contains type match.
        case contains(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension VPCLatticeClientTypes {

    /// Describes the constraints for a header match. Matches incoming requests with rule based on request header value before applying rule action.
    public struct HeaderMatch: Swift.Sendable {
        /// Indicates whether the match is case sensitive.
        public var caseSensitive: Swift.Bool?
        /// The header match type.
        /// This member is required.
        public var match: VPCLatticeClientTypes.HeaderMatchType?
        /// The name of the header.
        /// This member is required.
        public var name: Swift.String?

        public init(
            caseSensitive: Swift.Bool? = nil,
            match: VPCLatticeClientTypes.HeaderMatchType? = nil,
            name: Swift.String? = nil
        ) {
            self.caseSensitive = caseSensitive
            self.match = match
            self.name = name
        }
    }
}

extension VPCLatticeClientTypes {

    /// Describes a path match type. Each rule can include only one of the following types of paths.
    public enum PathMatchType: Swift.Sendable {
        /// An exact match of the path.
        case exact(Swift.String)
        /// A prefix match of the path.
        case `prefix`(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension VPCLatticeClientTypes {

    /// Describes the conditions that can be applied when matching a path for incoming requests.
    public struct PathMatch: Swift.Sendable {
        /// Indicates whether the match is case sensitive.
        public var caseSensitive: Swift.Bool?
        /// The type of path match.
        /// This member is required.
        public var match: VPCLatticeClientTypes.PathMatchType?

        public init(
            caseSensitive: Swift.Bool? = nil,
            match: VPCLatticeClientTypes.PathMatchType? = nil
        ) {
            self.caseSensitive = caseSensitive
            self.match = match
        }
    }
}

extension VPCLatticeClientTypes {

    /// Describes criteria that can be applied to incoming requests.
    public struct HttpMatch: Swift.Sendable {
        /// The header matches. Matches incoming requests with rule based on request header value before applying rule action.
        public var headerMatches: [VPCLatticeClientTypes.HeaderMatch]?
        /// The HTTP method type.
        public var method: Swift.String?
        /// The path match.
        public var pathMatch: VPCLatticeClientTypes.PathMatch?

        public init(
            headerMatches: [VPCLatticeClientTypes.HeaderMatch]? = nil,
            method: Swift.String? = nil,
            pathMatch: VPCLatticeClientTypes.PathMatch? = nil
        ) {
            self.headerMatches = headerMatches
            self.method = method
            self.pathMatch = pathMatch
        }
    }
}

extension VPCLatticeClientTypes {

    /// Describes a rule match.
    public enum RuleMatch: Swift.Sendable {
        /// The HTTP criteria that a rule must match.
        case httpmatch(VPCLatticeClientTypes.HttpMatch)
        case sdkUnknown(Swift.String)
    }
}

extension VPCLatticeClientTypes {

    /// Describes a rule update.
    public struct RuleUpdate: Swift.Sendable {
        /// The rule action.
        public var action: VPCLatticeClientTypes.RuleAction?
        /// The rule match.
        public var match: VPCLatticeClientTypes.RuleMatch?
        /// The rule priority. A listener can't have multiple rules with the same priority.
        public var priority: Swift.Int?
        /// The ID or ARN of the rule.
        /// This member is required.
        public var ruleIdentifier: Swift.String?

        public init(
            action: VPCLatticeClientTypes.RuleAction? = nil,
            match: VPCLatticeClientTypes.RuleMatch? = nil,
            priority: Swift.Int? = nil,
            ruleIdentifier: Swift.String? = nil
        ) {
            self.action = action
            self.match = match
            self.priority = priority
            self.ruleIdentifier = ruleIdentifier
        }
    }
}

public struct BatchUpdateRuleInput: Swift.Sendable {
    /// The ID or ARN of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The rules for the specified listener.
    /// This member is required.
    public var rules: [VPCLatticeClientTypes.RuleUpdate]?
    /// The ID or ARN of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        listenerIdentifier: Swift.String? = nil,
        rules: [VPCLatticeClientTypes.RuleUpdate]? = nil,
        serviceIdentifier: Swift.String? = nil
    ) {
        self.listenerIdentifier = listenerIdentifier
        self.rules = rules
        self.serviceIdentifier = serviceIdentifier
    }
}

extension VPCLatticeClientTypes {

    /// Describes a successful rule update.
    public struct RuleUpdateSuccess: Swift.Sendable {
        /// The action for the rule.
        public var action: VPCLatticeClientTypes.RuleAction?
        /// The Amazon Resource Name (ARN) of the listener.
        public var arn: Swift.String?
        /// The ID of the listener.
        public var id: Swift.String?
        /// Indicates whether this is the default rule.
        public var isDefault: Swift.Bool?
        /// The rule match.
        public var match: VPCLatticeClientTypes.RuleMatch?
        /// The name of the listener.
        public var name: Swift.String?
        /// The rule priority.
        public var priority: Swift.Int?

        public init(
            action: VPCLatticeClientTypes.RuleAction? = nil,
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            isDefault: Swift.Bool? = nil,
            match: VPCLatticeClientTypes.RuleMatch? = nil,
            name: Swift.String? = nil,
            priority: Swift.Int? = nil
        ) {
            self.action = action
            self.arn = arn
            self.id = id
            self.isDefault = isDefault
            self.match = match
            self.name = name
            self.priority = priority
        }
    }
}

extension VPCLatticeClientTypes {

    /// Describes a rule update that failed.
    public struct RuleUpdateFailure: Swift.Sendable {
        /// The failure code.
        public var failureCode: Swift.String?
        /// The failure message.
        public var failureMessage: Swift.String?
        /// The ID or ARN of the rule.
        public var ruleIdentifier: Swift.String?

        public init(
            failureCode: Swift.String? = nil,
            failureMessage: Swift.String? = nil,
            ruleIdentifier: Swift.String? = nil
        ) {
            self.failureCode = failureCode
            self.failureMessage = failureMessage
            self.ruleIdentifier = ruleIdentifier
        }
    }
}

public struct BatchUpdateRuleOutput: Swift.Sendable {
    /// The rules that were successfully updated.
    public var successful: [VPCLatticeClientTypes.RuleUpdateSuccess]?
    /// The rules that the operation couldn't update.
    public var unsuccessful: [VPCLatticeClientTypes.RuleUpdateFailure]?

    public init(
        successful: [VPCLatticeClientTypes.RuleUpdateSuccess]? = nil,
        unsuccessful: [VPCLatticeClientTypes.RuleUpdateFailure]? = nil
    ) {
        self.successful = successful
        self.unsuccessful = unsuccessful
    }
}

/// The request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the service quota that was exceeded.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The resource ID.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
        /// The service code.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

extension VPCLatticeClientTypes {

    public enum ListenerProtocol: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Indicates HTTP protocol
        case http
        /// Indicates HTTPS protocol
        case https
        /// Indicates TLS_PASSTHROUGH protocol
        case tlsPassthrough
        case sdkUnknown(Swift.String)

        public static var allCases: [ListenerProtocol] {
            return [
                .http,
                .https,
                .tlsPassthrough
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case .https: return "HTTPS"
            case .tlsPassthrough: return "TLS_PASSTHROUGH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateListenerInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The action for the default rule. Each listener has a default rule. The default rule is used if no other rules match.
    /// This member is required.
    public var defaultAction: VPCLatticeClientTypes.RuleAction?
    /// The name of the listener. A listener name must be unique within a service. The valid characters are a-z, 0-9, and hyphens (-). You can't use a hyphen as the first or last character, or immediately after another hyphen.
    /// This member is required.
    public var name: Swift.String?
    /// The listener port. You can specify a value from 1 to 65535. For HTTP, the default is 80. For HTTPS, the default is 443.
    public var port: Swift.Int?
    /// The listener protocol.
    /// This member is required.
    public var `protocol`: VPCLatticeClientTypes.ListenerProtocol?
    /// The ID or ARN of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?
    /// The tags for the listener.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        defaultAction: VPCLatticeClientTypes.RuleAction? = nil,
        name: Swift.String? = nil,
        port: Swift.Int? = nil,
        `protocol`: VPCLatticeClientTypes.ListenerProtocol? = nil,
        serviceIdentifier: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.clientToken = clientToken
        self.defaultAction = defaultAction
        self.name = name
        self.port = port
        self.`protocol` = `protocol`
        self.serviceIdentifier = serviceIdentifier
        self.tags = tags
    }
}

public struct CreateListenerOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the listener.
    public var arn: Swift.String?
    /// The action for the default rule.
    public var defaultAction: VPCLatticeClientTypes.RuleAction?
    /// The ID of the listener.
    public var id: Swift.String?
    /// The name of the listener.
    public var name: Swift.String?
    /// The port number of the listener.
    public var port: Swift.Int?
    /// The protocol of the listener.
    public var `protocol`: VPCLatticeClientTypes.ListenerProtocol?
    /// The Amazon Resource Name (ARN) of the service.
    public var serviceArn: Swift.String?
    /// The ID of the service.
    public var serviceId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        defaultAction: VPCLatticeClientTypes.RuleAction? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        port: Swift.Int? = nil,
        `protocol`: VPCLatticeClientTypes.ListenerProtocol? = nil,
        serviceArn: Swift.String? = nil,
        serviceId: Swift.String? = nil
    ) {
        self.arn = arn
        self.defaultAction = defaultAction
        self.id = id
        self.name = name
        self.port = port
        self.`protocol` = `protocol`
        self.serviceArn = serviceArn
        self.serviceId = serviceId
    }
}

extension VPCLatticeClientTypes {

    public enum ProtocolType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Resource Configuration protocol type TCP
        case tcp
        case sdkUnknown(Swift.String)

        public static var allCases: [ProtocolType] {
            return [
                .tcp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .tcp: return "TCP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VPCLatticeClientTypes {

    public enum ResourceConfigurationIpAddressType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Dualstack ip address type for dns type resource configs
        case dualstack
        /// Ipv4 ip address type for dns type resource configs
        case ipv4
        /// IPv6 ip address type for dns type resource configs
        case ipv6
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceConfigurationIpAddressType] {
            return [
                .dualstack,
                .ipv4,
                .ipv6
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dualstack: return "DUALSTACK"
            case .ipv4: return "IPV4"
            case .ipv6: return "IPV6"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VPCLatticeClientTypes {

    /// The DNS name of the resource.
    public struct DnsResource: Swift.Sendable {
        /// The domain name of the resource.
        public var domainName: Swift.String?
        /// The type of IP address.
        public var ipAddressType: VPCLatticeClientTypes.ResourceConfigurationIpAddressType?

        public init(
            domainName: Swift.String? = nil,
            ipAddressType: VPCLatticeClientTypes.ResourceConfigurationIpAddressType? = nil
        ) {
            self.domainName = domainName
            self.ipAddressType = ipAddressType
        }
    }
}

extension VPCLatticeClientTypes {

    /// Describes an IP resource.
    public struct IpResource: Swift.Sendable {
        /// The IP address of the IP resource.
        public var ipAddress: Swift.String?

        public init(
            ipAddress: Swift.String? = nil
        ) {
            self.ipAddress = ipAddress
        }
    }
}

extension VPCLatticeClientTypes {

    /// Describes a resource configuration.
    public enum ResourceConfigurationDefinition: Swift.Sendable {
        /// The DNS name of the resource.
        case dnsresource(VPCLatticeClientTypes.DnsResource)
        /// The IP resource.
        case ipresource(VPCLatticeClientTypes.IpResource)
        /// The Amazon Resource Name (ARN) of the resource.
        case arnresource(VPCLatticeClientTypes.ArnResource)
        case sdkUnknown(Swift.String)
    }
}

extension VPCLatticeClientTypes {

    public enum ResourceConfigurationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Resource Configuration of type ARN
        case arn
        /// Resource Configuration of type CHILD
        case child
        /// Resource Configuration of type GROUP
        case group
        /// Resource Configuration of type SINGLE
        case single
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceConfigurationType] {
            return [
                .arn,
                .child,
                .group,
                .single
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .arn: return "ARN"
            case .child: return "CHILD"
            case .group: return "GROUP"
            case .single: return "SINGLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateResourceConfigurationInput: Swift.Sendable {
    /// (SINGLE, GROUP, ARN) Specifies whether the resource configuration can be associated with a sharable service network. The default is false.
    public var allowAssociationToShareableServiceNetwork: Swift.Bool?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The name of the resource configuration. The name must be unique within the account. The valid characters are a-z, 0-9, and hyphens (-). You can't use a hyphen as the first or last character, or immediately after another hyphen.
    /// This member is required.
    public var name: Swift.String?
    /// (SINGLE, GROUP, CHILD) The TCP port ranges that a consumer can use to access a resource configuration (for example: 1-65535). You can separate port ranges using commas (for example: 1,2,22-30).
    public var portRanges: [Swift.String]?
    /// (SINGLE, GROUP) The protocol accepted by the resource configuration.
    public var `protocol`: VPCLatticeClientTypes.ProtocolType?
    /// (SINGLE, CHILD, ARN) The resource configuration.
    public var resourceConfigurationDefinition: VPCLatticeClientTypes.ResourceConfigurationDefinition?
    /// (CHILD) The ID or ARN of the parent resource configuration (type is GROUP). This is used to associate a child resource configuration with a group resource configuration.
    public var resourceConfigurationGroupIdentifier: Swift.String?
    /// (SINGLE, GROUP, ARN) The ID or ARN of the resource gateway used to connect to the resource configuration. For a child resource configuration, this value is inherited from the parent resource configuration.
    public var resourceGatewayIdentifier: Swift.String?
    /// The tags for the resource configuration.
    public var tags: [Swift.String: Swift.String]?
    /// The type of resource configuration.
    ///
    /// * SINGLE - A single resource.
    ///
    /// * GROUP - A group of resources. You must create a group resource configuration before you create a child resource configuration.
    ///
    /// * CHILD - A single resource that is part of a group resource configuration.
    ///
    /// * ARN - An Amazon Web Services resource.
    /// This member is required.
    public var type: VPCLatticeClientTypes.ResourceConfigurationType?

    public init(
        allowAssociationToShareableServiceNetwork: Swift.Bool? = nil,
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        portRanges: [Swift.String]? = nil,
        `protocol`: VPCLatticeClientTypes.ProtocolType? = nil,
        resourceConfigurationDefinition: VPCLatticeClientTypes.ResourceConfigurationDefinition? = nil,
        resourceConfigurationGroupIdentifier: Swift.String? = nil,
        resourceGatewayIdentifier: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        type: VPCLatticeClientTypes.ResourceConfigurationType? = nil
    ) {
        self.allowAssociationToShareableServiceNetwork = allowAssociationToShareableServiceNetwork
        self.clientToken = clientToken
        self.name = name
        self.portRanges = portRanges
        self.`protocol` = `protocol`
        self.resourceConfigurationDefinition = resourceConfigurationDefinition
        self.resourceConfigurationGroupIdentifier = resourceConfigurationGroupIdentifier
        self.resourceGatewayIdentifier = resourceGatewayIdentifier
        self.tags = tags
        self.type = type
    }
}

extension VPCLatticeClientTypes {

    public enum ResourceConfigurationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Resource Configuration is active.
        case active
        /// Resource Configuration creation failed
        case createFailed
        /// Resource Configuration creation in progress.
        case createInProgress
        /// Resource Configuration deletion failed.
        case deleteFailed
        /// Resource Configuration deletion in progress
        case deleteInProgress
        /// Resource Configuration update failed
        case updateFailed
        /// Resource Configuration update in progress.
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceConfigurationStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleteFailed,
                .deleteInProgress,
                .updateFailed,
                .updateInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateResourceConfigurationOutput: Swift.Sendable {
    /// Specifies whether the resource configuration can be associated with a sharable service network.
    public var allowAssociationToShareableServiceNetwork: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the resource configuration.
    public var arn: Swift.String?
    /// The date and time that the resource configuration was created, in ISO-8601 format.
    public var createdAt: Foundation.Date?
    /// The reason that the request failed.
    public var failureReason: Swift.String?
    /// The ID of the resource configuration.
    public var id: Swift.String?
    /// The name of the resource configuration.
    public var name: Swift.String?
    /// The port range.
    public var portRanges: [Swift.String]?
    /// The protocol.
    public var `protocol`: VPCLatticeClientTypes.ProtocolType?
    /// The resource configuration.
    public var resourceConfigurationDefinition: VPCLatticeClientTypes.ResourceConfigurationDefinition?
    /// The ID of the parent resource configuration (type is GROUP).
    public var resourceConfigurationGroupId: Swift.String?
    /// The ID of the resource gateway associated with the resource configuration.
    public var resourceGatewayId: Swift.String?
    /// The current status of the resource configuration.
    public var status: VPCLatticeClientTypes.ResourceConfigurationStatus?
    /// The type of resource configuration.
    public var type: VPCLatticeClientTypes.ResourceConfigurationType?

    public init(
        allowAssociationToShareableServiceNetwork: Swift.Bool? = nil,
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        failureReason: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        portRanges: [Swift.String]? = nil,
        `protocol`: VPCLatticeClientTypes.ProtocolType? = nil,
        resourceConfigurationDefinition: VPCLatticeClientTypes.ResourceConfigurationDefinition? = nil,
        resourceConfigurationGroupId: Swift.String? = nil,
        resourceGatewayId: Swift.String? = nil,
        status: VPCLatticeClientTypes.ResourceConfigurationStatus? = nil,
        type: VPCLatticeClientTypes.ResourceConfigurationType? = nil
    ) {
        self.allowAssociationToShareableServiceNetwork = allowAssociationToShareableServiceNetwork
        self.arn = arn
        self.createdAt = createdAt
        self.failureReason = failureReason
        self.id = id
        self.name = name
        self.portRanges = portRanges
        self.`protocol` = `protocol`
        self.resourceConfigurationDefinition = resourceConfigurationDefinition
        self.resourceConfigurationGroupId = resourceConfigurationGroupId
        self.resourceGatewayId = resourceGatewayId
        self.status = status
        self.type = type
    }
}

extension VPCLatticeClientTypes {

    public enum ResourceGatewayIpAddressType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Dualstack ip address type for resource gateway
        case dualstack
        /// Ipv4 ip address type for resource gateway
        case ipv4
        /// IPv6 ip address type for resource gateway
        case ipv6
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceGatewayIpAddressType] {
            return [
                .dualstack,
                .ipv4,
                .ipv6
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dualstack: return "DUALSTACK"
            case .ipv4: return "IPV4"
            case .ipv6: return "IPV6"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateResourceGatewayInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The type of IP address used by the resource gateway.
    public var ipAddressType: VPCLatticeClientTypes.ResourceGatewayIpAddressType?
    /// The name of the resource gateway.
    /// This member is required.
    public var name: Swift.String?
    /// The IDs of the security groups to apply to the resource gateway. The security groups must be in the same VPC.
    public var securityGroupIds: [Swift.String]?
    /// The IDs of the VPC subnets in which to create the resource gateway.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// The tags for the resource gateway.
    public var tags: [Swift.String: Swift.String]?
    /// The ID of the VPC for the resource gateway.
    /// This member is required.
    public var vpcIdentifier: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        ipAddressType: VPCLatticeClientTypes.ResourceGatewayIpAddressType? = nil,
        name: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        vpcIdentifier: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.ipAddressType = ipAddressType
        self.name = name
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.tags = tags
        self.vpcIdentifier = vpcIdentifier
    }
}

extension VPCLatticeClientTypes {

    public enum ResourceGatewayStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Resource Gateway is active.
        case active
        /// Resource Gateway creation failed
        case createFailed
        /// Resource Gateway creation in progress.
        case createInProgress
        /// Resource Gateway deletion failed.
        case deleteFailed
        /// Resource Gateway deletion in progress
        case deleteInProgress
        /// Reosurce Gateway update failed
        case updateFailed
        /// Resource Gateway update in progress.
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceGatewayStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleteFailed,
                .deleteInProgress,
                .updateFailed,
                .updateInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateResourceGatewayOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource gateway.
    public var arn: Swift.String?
    /// The ID of the resource gateway.
    public var id: Swift.String?
    /// The type of IP address for the resource gateway.
    public var ipAddressType: VPCLatticeClientTypes.ResourceGatewayIpAddressType?
    /// The name of the resource gateway.
    public var name: Swift.String?
    /// The IDs of the security groups for the resource gateway.
    public var securityGroupIds: [Swift.String]?
    /// The status of the resource gateway.
    public var status: VPCLatticeClientTypes.ResourceGatewayStatus?
    /// The IDs of the resource gateway subnets.
    public var subnetIds: [Swift.String]?
    /// The ID of the VPC.
    public var vpcIdentifier: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        ipAddressType: VPCLatticeClientTypes.ResourceGatewayIpAddressType? = nil,
        name: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        status: VPCLatticeClientTypes.ResourceGatewayStatus? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcIdentifier: Swift.String? = nil
    ) {
        self.arn = arn
        self.id = id
        self.ipAddressType = ipAddressType
        self.name = name
        self.securityGroupIds = securityGroupIds
        self.status = status
        self.subnetIds = subnetIds
        self.vpcIdentifier = vpcIdentifier
    }
}

public struct CreateRuleInput: Swift.Sendable {
    /// The action for the default rule.
    /// This member is required.
    public var action: VPCLatticeClientTypes.RuleAction?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The ID or ARN of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The rule match.
    /// This member is required.
    public var match: VPCLatticeClientTypes.RuleMatch?
    /// The name of the rule. The name must be unique within the listener. The valid characters are a-z, 0-9, and hyphens (-). You can't use a hyphen as the first or last character, or immediately after another hyphen.
    /// This member is required.
    public var name: Swift.String?
    /// The priority assigned to the rule. Each rule for a specific listener must have a unique priority. The lower the priority number the higher the priority.
    /// This member is required.
    public var priority: Swift.Int?
    /// The ID or ARN of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?
    /// The tags for the rule.
    public var tags: [Swift.String: Swift.String]?

    public init(
        action: VPCLatticeClientTypes.RuleAction? = nil,
        clientToken: Swift.String? = nil,
        listenerIdentifier: Swift.String? = nil,
        match: VPCLatticeClientTypes.RuleMatch? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil,
        serviceIdentifier: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.action = action
        self.clientToken = clientToken
        self.listenerIdentifier = listenerIdentifier
        self.match = match
        self.name = name
        self.priority = priority
        self.serviceIdentifier = serviceIdentifier
        self.tags = tags
    }
}

public struct CreateRuleOutput: Swift.Sendable {
    /// The rule action.
    public var action: VPCLatticeClientTypes.RuleAction?
    /// The Amazon Resource Name (ARN) of the rule.
    public var arn: Swift.String?
    /// The ID of the rule.
    public var id: Swift.String?
    /// The rule match. The RuleMatch must be an HttpMatch. This means that the rule should be an exact match on HTTP constraints which are made up of the HTTP method, path, and header.
    public var match: VPCLatticeClientTypes.RuleMatch?
    /// The name of the rule.
    public var name: Swift.String?
    /// The priority assigned to the rule. The lower the priority number the higher the priority.
    public var priority: Swift.Int?

    public init(
        action: VPCLatticeClientTypes.RuleAction? = nil,
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        match: VPCLatticeClientTypes.RuleMatch? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil
    ) {
        self.action = action
        self.arn = arn
        self.id = id
        self.match = match
        self.name = name
        self.priority = priority
    }
}

public struct CreateServiceInput: Swift.Sendable {
    /// The type of IAM policy.
    ///
    /// * NONE: The resource does not use an IAM policy. This is the default.
    ///
    /// * AWS_IAM: The resource uses an IAM policy. When this type is used, auth is enabled and an auth policy is required.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The Amazon Resource Name (ARN) of the certificate.
    public var certificateArn: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The custom domain name of the service.
    public var customDomainName: Swift.String?
    /// The name of the service. The name must be unique within the account. The valid characters are a-z, 0-9, and hyphens (-). You can't use a hyphen as the first or last character, or immediately after another hyphen.
    /// This member is required.
    public var name: Swift.String?
    /// The tags for the service.
    public var tags: [Swift.String: Swift.String]?

    public init(
        authType: VPCLatticeClientTypes.AuthType? = nil,
        certificateArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        customDomainName: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.authType = authType
        self.certificateArn = certificateArn
        self.clientToken = clientToken
        self.customDomainName = customDomainName
        self.name = name
        self.tags = tags
    }
}

extension VPCLatticeClientTypes {

    /// Describes the DNS information of a service.
    public struct DnsEntry: Swift.Sendable {
        /// The domain name of the service.
        public var domainName: Swift.String?
        /// The ID of the hosted zone.
        public var hostedZoneId: Swift.String?

        public init(
            domainName: Swift.String? = nil,
            hostedZoneId: Swift.String? = nil
        ) {
            self.domainName = domainName
            self.hostedZoneId = hostedZoneId
        }
    }
}

extension VPCLatticeClientTypes {

    public enum ServiceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Service is active.
        case active
        /// Service creation failed
        case createFailed
        /// Service creation in progress.
        case createInProgress
        /// Service deletion failed.
        case deleteFailed
        /// Service deletion in progress
        case deleteInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleteFailed,
                .deleteInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateServiceOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the service.
    public var arn: Swift.String?
    /// The type of IAM policy.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The Amazon Resource Name (ARN) of the certificate.
    public var certificateArn: Swift.String?
    /// The custom domain name of the service.
    public var customDomainName: Swift.String?
    /// The public DNS name of the service.
    public var dnsEntry: VPCLatticeClientTypes.DnsEntry?
    /// The ID of the service.
    public var id: Swift.String?
    /// The name of the service.
    public var name: Swift.String?
    /// The status. If the status is CREATE_FAILED, you must delete and recreate the service.
    public var status: VPCLatticeClientTypes.ServiceStatus?

    public init(
        arn: Swift.String? = nil,
        authType: VPCLatticeClientTypes.AuthType? = nil,
        certificateArn: Swift.String? = nil,
        customDomainName: Swift.String? = nil,
        dnsEntry: VPCLatticeClientTypes.DnsEntry? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceStatus? = nil
    ) {
        self.arn = arn
        self.authType = authType
        self.certificateArn = certificateArn
        self.customDomainName = customDomainName
        self.dnsEntry = dnsEntry
        self.id = id
        self.name = name
        self.status = status
    }
}

extension VPCLatticeClientTypes {

    /// Specifies if the service network should be enabled for sharing.
    public struct SharingConfig: Swift.Sendable {
        /// Specifies if the service network is enabled for sharing.
        public var enabled: Swift.Bool?

        public init(
            enabled: Swift.Bool? = nil
        ) {
            self.enabled = enabled
        }
    }
}

public struct CreateServiceNetworkInput: Swift.Sendable {
    /// The type of IAM policy.
    ///
    /// * NONE: The resource does not use an IAM policy. This is the default.
    ///
    /// * AWS_IAM: The resource uses an IAM policy. When this type is used, auth is enabled and an auth policy is required.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The name of the service network. The name must be unique to the account. The valid characters are a-z, 0-9, and hyphens (-). You can't use a hyphen as the first or last character, or immediately after another hyphen.
    /// This member is required.
    public var name: Swift.String?
    /// Specify if the service network should be enabled for sharing.
    public var sharingConfig: VPCLatticeClientTypes.SharingConfig?
    /// The tags for the service network.
    public var tags: [Swift.String: Swift.String]?

    public init(
        authType: VPCLatticeClientTypes.AuthType? = nil,
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        sharingConfig: VPCLatticeClientTypes.SharingConfig? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.authType = authType
        self.clientToken = clientToken
        self.name = name
        self.sharingConfig = sharingConfig
        self.tags = tags
    }
}

public struct CreateServiceNetworkOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the service network.
    public var arn: Swift.String?
    /// The type of IAM policy.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The ID of the service network.
    public var id: Swift.String?
    /// The name of the service network.
    public var name: Swift.String?
    /// Specifies if the service network is enabled for sharing.
    public var sharingConfig: VPCLatticeClientTypes.SharingConfig?

    public init(
        arn: Swift.String? = nil,
        authType: VPCLatticeClientTypes.AuthType? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        sharingConfig: VPCLatticeClientTypes.SharingConfig? = nil
    ) {
        self.arn = arn
        self.authType = authType
        self.id = id
        self.name = name
        self.sharingConfig = sharingConfig
    }
}

public struct CreateServiceNetworkResourceAssociationInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The ID of the resource configuration to associate with the service network.
    /// This member is required.
    public var resourceConfigurationIdentifier: Swift.String?
    /// The ID of the service network to associate with the resource configuration.
    /// This member is required.
    public var serviceNetworkIdentifier: Swift.String?
    /// The tags for the association.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        resourceConfigurationIdentifier: Swift.String? = nil,
        serviceNetworkIdentifier: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.clientToken = clientToken
        self.resourceConfigurationIdentifier = resourceConfigurationIdentifier
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
        self.tags = tags
    }
}

extension VPCLatticeClientTypes {

    public enum ServiceNetworkResourceAssociationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// ServiceNetwork and Service association is active
        case active
        /// ServiceNetwork and Service association creation failed.
        case createFailed
        /// ServiceNetwork and Service association creation in progress
        case createInProgress
        /// ServiceNetwork and Service association deletion failed
        case deleteFailed
        /// ServiceNetwork and Service association deletion in progress
        case deleteInProgress
        /// ServiceNetwork and Service association is partial
        case partial
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceNetworkResourceAssociationStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleteFailed,
                .deleteInProgress,
                .partial
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .partial: return "PARTIAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateServiceNetworkResourceAssociationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The ID of the account that created the association.
    public var createdBy: Swift.String?
    /// The ID of the association.
    public var id: Swift.String?
    /// The status of the association.
    public var status: VPCLatticeClientTypes.ServiceNetworkResourceAssociationStatus?

    public init(
        arn: Swift.String? = nil,
        createdBy: Swift.String? = nil,
        id: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkResourceAssociationStatus? = nil
    ) {
        self.arn = arn
        self.createdBy = createdBy
        self.id = id
        self.status = status
    }
}

public struct CreateServiceNetworkServiceAssociationInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The ID or ARN of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?
    /// The ID or ARN of the service network. You must use an ARN if the resources are in different accounts.
    /// This member is required.
    public var serviceNetworkIdentifier: Swift.String?
    /// The tags for the association.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil,
        serviceNetworkIdentifier: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.clientToken = clientToken
        self.serviceIdentifier = serviceIdentifier
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
        self.tags = tags
    }
}

extension VPCLatticeClientTypes {

    public enum ServiceNetworkServiceAssociationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// ServiceNetwork and Service association is active
        case active
        /// ServiceNetwork and Service association creation failed.
        case createFailed
        /// ServiceNetwork and Service association creation in progress
        case createInProgress
        /// ServiceNetwork and Service association deletion failed
        case deleteFailed
        /// ServiceNetwork and Service association deletion in progress
        case deleteInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceNetworkServiceAssociationStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleteFailed,
                .deleteInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateServiceNetworkServiceAssociationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The account that created the association.
    public var createdBy: Swift.String?
    /// The custom domain name of the service.
    public var customDomainName: Swift.String?
    /// The DNS name of the service.
    public var dnsEntry: VPCLatticeClientTypes.DnsEntry?
    /// The ID of the association.
    public var id: Swift.String?
    /// The association status.
    public var status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus?

    public init(
        arn: Swift.String? = nil,
        createdBy: Swift.String? = nil,
        customDomainName: Swift.String? = nil,
        dnsEntry: VPCLatticeClientTypes.DnsEntry? = nil,
        id: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus? = nil
    ) {
        self.arn = arn
        self.createdBy = createdBy
        self.customDomainName = customDomainName
        self.dnsEntry = dnsEntry
        self.id = id
        self.status = status
    }
}

public struct CreateServiceNetworkVpcAssociationInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The IDs of the security groups. Security groups aren't added by default. You can add a security group to apply network level controls to control which resources in a VPC are allowed to access the service network and its services. For more information, see [Control traffic to resources using security groups](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html) in the Amazon VPC User Guide.
    public var securityGroupIds: [Swift.String]?
    /// The ID or ARN of the service network. You must use an ARN if the resources are in different accounts.
    /// This member is required.
    public var serviceNetworkIdentifier: Swift.String?
    /// The tags for the association.
    public var tags: [Swift.String: Swift.String]?
    /// The ID of the VPC.
    /// This member is required.
    public var vpcIdentifier: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        serviceNetworkIdentifier: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        vpcIdentifier: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.securityGroupIds = securityGroupIds
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
        self.tags = tags
        self.vpcIdentifier = vpcIdentifier
    }
}

extension VPCLatticeClientTypes {

    public enum ServiceNetworkVpcAssociationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// ServiceNetwork and Vpc association is active
        case active
        /// ServiceNetwork and Vpc association creation failed.
        case createFailed
        /// ServiceNetwork and Vpc association creation in progress
        case createInProgress
        /// ServiceNetwork and Vpc association deletion failed
        case deleteFailed
        /// ServiceNetwork and Vpc association deletion in progress
        case deleteInProgress
        /// ServiceNetwork and Vpc association update failed
        case updateFailed
        /// ServiceNetwork and Vpc association update in progress
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceNetworkVpcAssociationStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleteFailed,
                .deleteInProgress,
                .updateFailed,
                .updateInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateServiceNetworkVpcAssociationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The account that created the association.
    public var createdBy: Swift.String?
    /// The ID of the association.
    public var id: Swift.String?
    /// The IDs of the security groups.
    public var securityGroupIds: [Swift.String]?
    /// The association status.
    public var status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus?

    public init(
        arn: Swift.String? = nil,
        createdBy: Swift.String? = nil,
        id: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus? = nil
    ) {
        self.arn = arn
        self.createdBy = createdBy
        self.id = id
        self.securityGroupIds = securityGroupIds
        self.status = status
    }
}

extension VPCLatticeClientTypes {

    /// Describes the codes to use when checking for a successful response from a target for health checks.
    public enum Matcher: Swift.Sendable {
        /// The HTTP code to use when checking for a successful response from a target.
        case httpcode(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension VPCLatticeClientTypes {

    public enum TargetGroupProtocol: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Indicates HTTP protocol
        case http
        /// Indicates HTTPS protocol
        case https
        /// Indicates TCP protocol
        case tcp
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetGroupProtocol] {
            return [
                .http,
                .https,
                .tcp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case .https: return "HTTPS"
            case .tcp: return "TCP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VPCLatticeClientTypes {

    public enum HealthCheckProtocolVersion: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Indicates use of HTTP/1.1 to send requests to target
        case http1
        /// Indicates use of HTTP/2 to send requests to target
        case http2
        case sdkUnknown(Swift.String)

        public static var allCases: [HealthCheckProtocolVersion] {
            return [
                .http1,
                .http2
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .http1: return "HTTP1"
            case .http2: return "HTTP2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VPCLatticeClientTypes {

    /// Describes the health check configuration of a target group. Health check configurations aren't used for target groups of type LAMBDA or ALB.
    public struct HealthCheckConfig: Swift.Sendable {
        /// Indicates whether health checking is enabled.
        public var enabled: Swift.Bool?
        /// The approximate amount of time, in seconds, between health checks of an individual target. The range is 5–300 seconds. The default is 30 seconds.
        public var healthCheckIntervalSeconds: Swift.Int?
        /// The amount of time, in seconds, to wait before reporting a target as unhealthy. The range is 1–120 seconds. The default is 5 seconds.
        public var healthCheckTimeoutSeconds: Swift.Int?
        /// The number of consecutive successful health checks required before considering an unhealthy target healthy. The range is 2–10. The default is 5.
        public var healthyThresholdCount: Swift.Int?
        /// The codes to use when checking for a successful response from a target.
        public var matcher: VPCLatticeClientTypes.Matcher?
        /// The destination for health checks on the targets. If the protocol version is HTTP/1.1 or HTTP/2, specify a valid URI (for example, /path?query). The default path is /. Health checks are not supported if the protocol version is gRPC, however, you can choose HTTP/1.1 or HTTP/2 and specify a valid URI.
        public var path: Swift.String?
        /// The port used when performing health checks on targets. The default setting is the port that a target receives traffic on.
        public var port: Swift.Int?
        /// The protocol used when performing health checks on targets. The possible protocols are HTTP and HTTPS. The default is HTTP.
        public var `protocol`: VPCLatticeClientTypes.TargetGroupProtocol?
        /// The protocol version used when performing health checks on targets. The possible protocol versions are HTTP1 and HTTP2.
        public var protocolVersion: VPCLatticeClientTypes.HealthCheckProtocolVersion?
        /// The number of consecutive failed health checks required before considering a target unhealthy. The range is 2–10. The default is 2.
        public var unhealthyThresholdCount: Swift.Int?

        public init(
            enabled: Swift.Bool? = nil,
            healthCheckIntervalSeconds: Swift.Int? = nil,
            healthCheckTimeoutSeconds: Swift.Int? = nil,
            healthyThresholdCount: Swift.Int? = nil,
            matcher: VPCLatticeClientTypes.Matcher? = nil,
            path: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: VPCLatticeClientTypes.TargetGroupProtocol? = nil,
            protocolVersion: VPCLatticeClientTypes.HealthCheckProtocolVersion? = nil,
            unhealthyThresholdCount: Swift.Int? = nil
        ) {
            self.enabled = enabled
            self.healthCheckIntervalSeconds = healthCheckIntervalSeconds
            self.healthCheckTimeoutSeconds = healthCheckTimeoutSeconds
            self.healthyThresholdCount = healthyThresholdCount
            self.matcher = matcher
            self.path = path
            self.port = port
            self.`protocol` = `protocol`
            self.protocolVersion = protocolVersion
            self.unhealthyThresholdCount = unhealthyThresholdCount
        }
    }
}

extension VPCLatticeClientTypes {

    public enum IpAddressType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Indicates IPv4 address type
        case ipv4
        /// Indicates IPv6 address type
        case ipv6
        case sdkUnknown(Swift.String)

        public static var allCases: [IpAddressType] {
            return [
                .ipv4,
                .ipv6
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ipv4: return "IPV4"
            case .ipv6: return "IPV6"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VPCLatticeClientTypes {

    public enum LambdaEventStructureVersion: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// This is the default lambda event structure version
        case v1
        /// Indicates use of lambda event structure version 2
        case v2
        case sdkUnknown(Swift.String)

        public static var allCases: [LambdaEventStructureVersion] {
            return [
                .v1,
                .v2
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .v1: return "V1"
            case .v2: return "V2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VPCLatticeClientTypes {

    public enum TargetGroupProtocolVersion: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Indicates use of gRPC to send requests to target
        case grpc
        /// Indicates use of HTTP/1.1 to send requests to target
        case http1
        /// Indicates use of HTTP/2 to send requests to target
        case http2
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetGroupProtocolVersion] {
            return [
                .grpc,
                .http1,
                .http2
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .grpc: return "GRPC"
            case .http1: return "HTTP1"
            case .http2: return "HTTP2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VPCLatticeClientTypes {

    /// Describes the configuration of a target group. For more information, see [Target groups](https://docs.aws.amazon.com/vpc-lattice/latest/ug/target-groups.html) in the Amazon VPC Lattice User Guide.
    public struct TargetGroupConfig: Swift.Sendable {
        /// The health check configuration. Not supported if the target group type is LAMBDA or ALB.
        public var healthCheck: VPCLatticeClientTypes.HealthCheckConfig?
        /// The type of IP address used for the target group. Supported only if the target group type is IP. The default is IPV4.
        public var ipAddressType: VPCLatticeClientTypes.IpAddressType?
        /// The version of the event structure that your Lambda function receives. Supported only if the target group type is LAMBDA. The default is V1.
        public var lambdaEventStructureVersion: VPCLatticeClientTypes.LambdaEventStructureVersion?
        /// The port on which the targets are listening. For HTTP, the default is 80. For HTTPS, the default is 443. Not supported if the target group type is LAMBDA.
        public var port: Swift.Int?
        /// The protocol to use for routing traffic to the targets. The default is the protocol of the target group. Not supported if the target group type is LAMBDA.
        public var `protocol`: VPCLatticeClientTypes.TargetGroupProtocol?
        /// The protocol version. The default is HTTP1. Not supported if the target group type is LAMBDA.
        public var protocolVersion: VPCLatticeClientTypes.TargetGroupProtocolVersion?
        /// The ID of the VPC. Not supported if the target group type is LAMBDA.
        public var vpcIdentifier: Swift.String?

        public init(
            healthCheck: VPCLatticeClientTypes.HealthCheckConfig? = nil,
            ipAddressType: VPCLatticeClientTypes.IpAddressType? = nil,
            lambdaEventStructureVersion: VPCLatticeClientTypes.LambdaEventStructureVersion? = nil,
            port: Swift.Int? = nil,
            `protocol`: VPCLatticeClientTypes.TargetGroupProtocol? = nil,
            protocolVersion: VPCLatticeClientTypes.TargetGroupProtocolVersion? = nil,
            vpcIdentifier: Swift.String? = nil
        ) {
            self.healthCheck = healthCheck
            self.ipAddressType = ipAddressType
            self.lambdaEventStructureVersion = lambdaEventStructureVersion
            self.port = port
            self.`protocol` = `protocol`
            self.protocolVersion = protocolVersion
            self.vpcIdentifier = vpcIdentifier
        }
    }
}

extension VPCLatticeClientTypes {

    public enum TargetGroupType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Indicates target in this target group is an ALB
        case alb
        /// Indicates targets in this target group are EC2 instances
        case instance
        /// Indicates targets in this target group are IP
        case ip
        /// Indicates targets in this target group are Lambda
        case lambda
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetGroupType] {
            return [
                .alb,
                .instance,
                .ip,
                .lambda
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .alb: return "ALB"
            case .instance: return "INSTANCE"
            case .ip: return "IP"
            case .lambda: return "LAMBDA"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateTargetGroupInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The target group configuration.
    public var config: VPCLatticeClientTypes.TargetGroupConfig?
    /// The name of the target group. The name must be unique within the account. The valid characters are a-z, 0-9, and hyphens (-). You can't use a hyphen as the first or last character, or immediately after another hyphen.
    /// This member is required.
    public var name: Swift.String?
    /// The tags for the target group.
    public var tags: [Swift.String: Swift.String]?
    /// The type of target group.
    /// This member is required.
    public var type: VPCLatticeClientTypes.TargetGroupType?

    public init(
        clientToken: Swift.String? = nil,
        config: VPCLatticeClientTypes.TargetGroupConfig? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        type: VPCLatticeClientTypes.TargetGroupType? = nil
    ) {
        self.clientToken = clientToken
        self.config = config
        self.name = name
        self.tags = tags
        self.type = type
    }
}

extension VPCLatticeClientTypes {

    public enum TargetGroupStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// TargetGroup is active
        case active
        /// TargetGroup creation failed.
        case createFailed
        /// TargetGroup creation in progress
        case createInProgress
        /// TargetGroup deletion failed
        case deleteFailed
        /// TargetGroup deletion in progress
        case deleteInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetGroupStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleteFailed,
                .deleteInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateTargetGroupOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the target group.
    public var arn: Swift.String?
    /// The target group configuration.
    public var config: VPCLatticeClientTypes.TargetGroupConfig?
    /// The ID of the target group.
    public var id: Swift.String?
    /// The name of the target group.
    public var name: Swift.String?
    /// The status. You can retry the operation if the status is CREATE_FAILED. However, if you retry it while the status is CREATE_IN_PROGRESS, there is no change in the status.
    public var status: VPCLatticeClientTypes.TargetGroupStatus?
    /// The type of target group.
    public var type: VPCLatticeClientTypes.TargetGroupType?

    public init(
        arn: Swift.String? = nil,
        config: VPCLatticeClientTypes.TargetGroupConfig? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: VPCLatticeClientTypes.TargetGroupStatus? = nil,
        type: VPCLatticeClientTypes.TargetGroupType? = nil
    ) {
        self.arn = arn
        self.config = config
        self.id = id
        self.name = name
        self.status = status
        self.type = type
    }
}

public struct DeleteAuthPolicyInput: Swift.Sendable {
    /// The ID or ARN of the resource.
    /// This member is required.
    public var resourceIdentifier: Swift.String?

    public init(
        resourceIdentifier: Swift.String? = nil
    ) {
        self.resourceIdentifier = resourceIdentifier
    }
}

public struct DeleteAuthPolicyOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteListenerInput: Swift.Sendable {
    /// The ID or ARN of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The ID or ARN of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        listenerIdentifier: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    ) {
        self.listenerIdentifier = listenerIdentifier
        self.serviceIdentifier = serviceIdentifier
    }
}

public struct DeleteListenerOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteResourceConfigurationInput: Swift.Sendable {
    /// The ID or ARN of the resource configuration.
    /// This member is required.
    public var resourceConfigurationIdentifier: Swift.String?

    public init(
        resourceConfigurationIdentifier: Swift.String? = nil
    ) {
        self.resourceConfigurationIdentifier = resourceConfigurationIdentifier
    }
}

public struct DeleteResourceConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteResourceEndpointAssociationInput: Swift.Sendable {
    /// The ID or ARN of the association.
    /// This member is required.
    public var resourceEndpointAssociationIdentifier: Swift.String?

    public init(
        resourceEndpointAssociationIdentifier: Swift.String? = nil
    ) {
        self.resourceEndpointAssociationIdentifier = resourceEndpointAssociationIdentifier
    }
}

public struct DeleteResourceEndpointAssociationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The ID of the association.
    public var id: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource configuration associated with the VPC endpoint of type resource.
    public var resourceConfigurationArn: Swift.String?
    /// The ID of the resource configuration.
    public var resourceConfigurationId: Swift.String?
    /// The ID of the resource VPC endpoint that is associated with the resource configuration.
    public var vpcEndpointId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        resourceConfigurationArn: Swift.String? = nil,
        resourceConfigurationId: Swift.String? = nil,
        vpcEndpointId: Swift.String? = nil
    ) {
        self.arn = arn
        self.id = id
        self.resourceConfigurationArn = resourceConfigurationArn
        self.resourceConfigurationId = resourceConfigurationId
        self.vpcEndpointId = vpcEndpointId
    }
}

public struct DeleteResourceGatewayInput: Swift.Sendable {
    /// The ID or ARN of the resource gateway.
    /// This member is required.
    public var resourceGatewayIdentifier: Swift.String?

    public init(
        resourceGatewayIdentifier: Swift.String? = nil
    ) {
        self.resourceGatewayIdentifier = resourceGatewayIdentifier
    }
}

public struct DeleteResourceGatewayOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource gateway.
    public var arn: Swift.String?
    /// The ID of the resource gateway.
    public var id: Swift.String?
    /// The name of the resource gateway.
    public var name: Swift.String?
    /// The status of the resource gateway.
    public var status: VPCLatticeClientTypes.ResourceGatewayStatus?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: VPCLatticeClientTypes.ResourceGatewayStatus? = nil
    ) {
        self.arn = arn
        self.id = id
        self.name = name
        self.status = status
    }
}

public struct DeleteResourcePolicyInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    ) {
        self.resourceArn = resourceArn
    }
}

public struct DeleteResourcePolicyOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteRuleInput: Swift.Sendable {
    /// The ID or ARN of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The ID or ARN of the rule.
    /// This member is required.
    public var ruleIdentifier: Swift.String?
    /// The ID or ARN of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        listenerIdentifier: Swift.String? = nil,
        ruleIdentifier: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    ) {
        self.listenerIdentifier = listenerIdentifier
        self.ruleIdentifier = ruleIdentifier
        self.serviceIdentifier = serviceIdentifier
    }
}

public struct DeleteRuleOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteServiceInput: Swift.Sendable {
    /// The ID or ARN of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        serviceIdentifier: Swift.String? = nil
    ) {
        self.serviceIdentifier = serviceIdentifier
    }
}

public struct DeleteServiceOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the service.
    public var arn: Swift.String?
    /// The ID of the service.
    public var id: Swift.String?
    /// The name of the service.
    public var name: Swift.String?
    /// The status. You can retry the operation if the status is DELETE_FAILED. However, if you retry it while the status is DELETE_IN_PROGRESS, the status doesn't change.
    public var status: VPCLatticeClientTypes.ServiceStatus?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceStatus? = nil
    ) {
        self.arn = arn
        self.id = id
        self.name = name
        self.status = status
    }
}

public struct DeleteServiceNetworkInput: Swift.Sendable {
    /// The ID or ARN of the service network.
    /// This member is required.
    public var serviceNetworkIdentifier: Swift.String?

    public init(
        serviceNetworkIdentifier: Swift.String? = nil
    ) {
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
    }
}

public struct DeleteServiceNetworkOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteServiceNetworkResourceAssociationInput: Swift.Sendable {
    /// The ID of the association.
    /// This member is required.
    public var serviceNetworkResourceAssociationIdentifier: Swift.String?

    public init(
        serviceNetworkResourceAssociationIdentifier: Swift.String? = nil
    ) {
        self.serviceNetworkResourceAssociationIdentifier = serviceNetworkResourceAssociationIdentifier
    }
}

public struct DeleteServiceNetworkResourceAssociationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The ID of the association.
    public var id: Swift.String?
    /// The status of the association.
    public var status: VPCLatticeClientTypes.ServiceNetworkResourceAssociationStatus?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkResourceAssociationStatus? = nil
    ) {
        self.arn = arn
        self.id = id
        self.status = status
    }
}

public struct DeleteServiceNetworkServiceAssociationInput: Swift.Sendable {
    /// The ID or ARN of the association.
    /// This member is required.
    public var serviceNetworkServiceAssociationIdentifier: Swift.String?

    public init(
        serviceNetworkServiceAssociationIdentifier: Swift.String? = nil
    ) {
        self.serviceNetworkServiceAssociationIdentifier = serviceNetworkServiceAssociationIdentifier
    }
}

public struct DeleteServiceNetworkServiceAssociationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The ID of the association.
    public var id: Swift.String?
    /// The status. You can retry the operation if the status is DELETE_FAILED. However, if you retry it when the status is DELETE_IN_PROGRESS, there is no change in the status.
    public var status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus? = nil
    ) {
        self.arn = arn
        self.id = id
        self.status = status
    }
}

public struct DeleteServiceNetworkVpcAssociationInput: Swift.Sendable {
    /// The ID or ARN of the association.
    /// This member is required.
    public var serviceNetworkVpcAssociationIdentifier: Swift.String?

    public init(
        serviceNetworkVpcAssociationIdentifier: Swift.String? = nil
    ) {
        self.serviceNetworkVpcAssociationIdentifier = serviceNetworkVpcAssociationIdentifier
    }
}

public struct DeleteServiceNetworkVpcAssociationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The ID of the association.
    public var id: Swift.String?
    /// The status. You can retry the operation if the status is DELETE_FAILED. However, if you retry it while the status is DELETE_IN_PROGRESS, there is no change in the status.
    public var status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus? = nil
    ) {
        self.arn = arn
        self.id = id
        self.status = status
    }
}

public struct DeleteTargetGroupInput: Swift.Sendable {
    /// The ID or ARN of the target group.
    /// This member is required.
    public var targetGroupIdentifier: Swift.String?

    public init(
        targetGroupIdentifier: Swift.String? = nil
    ) {
        self.targetGroupIdentifier = targetGroupIdentifier
    }
}

public struct DeleteTargetGroupOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the target group.
    public var arn: Swift.String?
    /// The ID of the target group.
    public var id: Swift.String?
    /// The status. You can retry the operation if the status is DELETE_FAILED. However, if you retry it while the status is DELETE_IN_PROGRESS, the status doesn't change.
    public var status: VPCLatticeClientTypes.TargetGroupStatus?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        status: VPCLatticeClientTypes.TargetGroupStatus? = nil
    ) {
        self.arn = arn
        self.id = id
        self.status = status
    }
}

extension VPCLatticeClientTypes {

    /// Describes a target.
    public struct Target: Swift.Sendable {
        /// The ID of the target. If the target group type is INSTANCE, this is an instance ID. If the target group type is IP, this is an IP address. If the target group type is LAMBDA, this is the ARN of a Lambda function. If the target group type is ALB, this is the ARN of an Application Load Balancer.
        /// This member is required.
        public var id: Swift.String?
        /// The port on which the target is listening. For HTTP, the default is 80. For HTTPS, the default is 443.
        public var port: Swift.Int?

        public init(
            id: Swift.String? = nil,
            port: Swift.Int? = nil
        ) {
            self.id = id
            self.port = port
        }
    }
}

public struct DeregisterTargetsInput: Swift.Sendable {
    /// The ID or ARN of the target group.
    /// This member is required.
    public var targetGroupIdentifier: Swift.String?
    /// The targets to deregister.
    /// This member is required.
    public var targets: [VPCLatticeClientTypes.Target]?

    public init(
        targetGroupIdentifier: Swift.String? = nil,
        targets: [VPCLatticeClientTypes.Target]? = nil
    ) {
        self.targetGroupIdentifier = targetGroupIdentifier
        self.targets = targets
    }
}

extension VPCLatticeClientTypes {

    /// Describes a target failure.
    public struct TargetFailure: Swift.Sendable {
        /// The failure code.
        public var failureCode: Swift.String?
        /// The failure message.
        public var failureMessage: Swift.String?
        /// The ID of the target. If the target group type is INSTANCE, this is an instance ID. If the target group type is IP, this is an IP address. If the target group type is LAMBDA, this is the ARN of a Lambda function. If the target group type is ALB, this is the ARN of an Application Load Balancer.
        public var id: Swift.String?
        /// The port on which the target is listening. This parameter doesn't apply if the target is a Lambda function.
        public var port: Swift.Int?

        public init(
            failureCode: Swift.String? = nil,
            failureMessage: Swift.String? = nil,
            id: Swift.String? = nil,
            port: Swift.Int? = nil
        ) {
            self.failureCode = failureCode
            self.failureMessage = failureMessage
            self.id = id
            self.port = port
        }
    }
}

public struct DeregisterTargetsOutput: Swift.Sendable {
    /// The targets that were successfully deregistered.
    public var successful: [VPCLatticeClientTypes.Target]?
    /// The targets that the operation couldn't deregister.
    public var unsuccessful: [VPCLatticeClientTypes.TargetFailure]?

    public init(
        successful: [VPCLatticeClientTypes.Target]? = nil,
        unsuccessful: [VPCLatticeClientTypes.TargetFailure]? = nil
    ) {
        self.successful = successful
        self.unsuccessful = unsuccessful
    }
}

public struct GetAuthPolicyInput: Swift.Sendable {
    /// The ID or ARN of the service network or service.
    /// This member is required.
    public var resourceIdentifier: Swift.String?

    public init(
        resourceIdentifier: Swift.String? = nil
    ) {
        self.resourceIdentifier = resourceIdentifier
    }
}

public struct GetAuthPolicyOutput: Swift.Sendable {
    /// The date and time that the auth policy was created, in ISO-8601 format.
    public var createdAt: Foundation.Date?
    /// The date and time that the auth policy was last updated, in ISO-8601 format.
    public var lastUpdatedAt: Foundation.Date?
    /// The auth policy.
    public var policy: Swift.String?
    /// The state of the auth policy. The auth policy is only active when the auth type is set to AWS_IAM. If you provide a policy, then authentication and authorization decisions are made based on this policy and the client's IAM policy. If the auth type is NONE, then any auth policy that you provide remains inactive. For more information, see [Create a service network](https://docs.aws.amazon.com/vpc-lattice/latest/ug/service-networks.html#create-service-network) in the Amazon VPC Lattice User Guide.
    public var state: VPCLatticeClientTypes.AuthPolicyState?

    public init(
        createdAt: Foundation.Date? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        policy: Swift.String? = nil,
        state: VPCLatticeClientTypes.AuthPolicyState? = nil
    ) {
        self.createdAt = createdAt
        self.lastUpdatedAt = lastUpdatedAt
        self.policy = policy
        self.state = state
    }
}

public struct GetListenerInput: Swift.Sendable {
    /// The ID or ARN of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The ID or ARN of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        listenerIdentifier: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    ) {
        self.listenerIdentifier = listenerIdentifier
        self.serviceIdentifier = serviceIdentifier
    }
}

public struct GetListenerOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the listener.
    public var arn: Swift.String?
    /// The date and time that the listener was created, in ISO-8601 format.
    public var createdAt: Foundation.Date?
    /// The actions for the default listener rule.
    public var defaultAction: VPCLatticeClientTypes.RuleAction?
    /// The ID of the listener.
    public var id: Swift.String?
    /// The date and time that the listener was last updated, in ISO-8601 format.
    public var lastUpdatedAt: Foundation.Date?
    /// The name of the listener.
    public var name: Swift.String?
    /// The listener port.
    public var port: Swift.Int?
    /// The listener protocol.
    public var `protocol`: VPCLatticeClientTypes.ListenerProtocol?
    /// The Amazon Resource Name (ARN) of the service.
    public var serviceArn: Swift.String?
    /// The ID of the service.
    public var serviceId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        defaultAction: VPCLatticeClientTypes.RuleAction? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        port: Swift.Int? = nil,
        `protocol`: VPCLatticeClientTypes.ListenerProtocol? = nil,
        serviceArn: Swift.String? = nil,
        serviceId: Swift.String? = nil
    ) {
        self.arn = arn
        self.createdAt = createdAt
        self.defaultAction = defaultAction
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.port = port
        self.`protocol` = `protocol`
        self.serviceArn = serviceArn
        self.serviceId = serviceId
    }
}

public struct GetResourceConfigurationInput: Swift.Sendable {
    /// The ID of the resource configuration.
    /// This member is required.
    public var resourceConfigurationIdentifier: Swift.String?

    public init(
        resourceConfigurationIdentifier: Swift.String? = nil
    ) {
        self.resourceConfigurationIdentifier = resourceConfigurationIdentifier
    }
}

public struct GetResourceConfigurationOutput: Swift.Sendable {
    /// Specifies whether the resource configuration is associated with a sharable service network.
    public var allowAssociationToShareableServiceNetwork: Swift.Bool?
    /// Indicates whether the resource configuration was created and is managed by Amazon.
    public var amazonManaged: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the resource configuration.
    public var arn: Swift.String?
    /// The date and time that the resource configuration was created, in ISO-8601 format.
    public var createdAt: Foundation.Date?
    /// The custom domain name of the resource configuration.
    public var customDomainName: Swift.String?
    /// The reason the create-resource-configuration request failed.
    public var failureReason: Swift.String?
    /// The ID of the resource configuration.
    public var id: Swift.String?
    /// The most recent date and time that the resource configuration was updated, in ISO-8601 format.
    public var lastUpdatedAt: Foundation.Date?
    /// The name of the resource configuration.
    public var name: Swift.String?
    /// The TCP port ranges that a consumer can use to access a resource configuration. You can separate port ranges with a comma. Example: 1-65535 or 1,2,22-30
    public var portRanges: [Swift.String]?
    /// The TCP protocol accepted by the specified resource configuration.
    public var `protocol`: VPCLatticeClientTypes.ProtocolType?
    /// The resource configuration.
    public var resourceConfigurationDefinition: VPCLatticeClientTypes.ResourceConfigurationDefinition?
    /// The ID of the group resource configuration.
    public var resourceConfigurationGroupId: Swift.String?
    /// The ID of the resource gateway used to connect to the resource configuration in a given VPC. You can specify the resource gateway identifier only for resource configurations with type SINGLE, GROUP, or ARN.
    public var resourceGatewayId: Swift.String?
    /// The status of the resource configuration.
    public var status: VPCLatticeClientTypes.ResourceConfigurationStatus?
    /// The type of resource configuration.
    ///
    /// * SINGLE - A single resource.
    ///
    /// * GROUP - A group of resources.
    ///
    /// * CHILD - A single resource that is part of a group resource configuration.
    ///
    /// * ARN - An Amazon Web Services resource.
    public var type: VPCLatticeClientTypes.ResourceConfigurationType?

    public init(
        allowAssociationToShareableServiceNetwork: Swift.Bool? = nil,
        amazonManaged: Swift.Bool? = nil,
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        customDomainName: Swift.String? = nil,
        failureReason: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        portRanges: [Swift.String]? = nil,
        `protocol`: VPCLatticeClientTypes.ProtocolType? = nil,
        resourceConfigurationDefinition: VPCLatticeClientTypes.ResourceConfigurationDefinition? = nil,
        resourceConfigurationGroupId: Swift.String? = nil,
        resourceGatewayId: Swift.String? = nil,
        status: VPCLatticeClientTypes.ResourceConfigurationStatus? = nil,
        type: VPCLatticeClientTypes.ResourceConfigurationType? = nil
    ) {
        self.allowAssociationToShareableServiceNetwork = allowAssociationToShareableServiceNetwork
        self.amazonManaged = amazonManaged
        self.arn = arn
        self.createdAt = createdAt
        self.customDomainName = customDomainName
        self.failureReason = failureReason
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.portRanges = portRanges
        self.`protocol` = `protocol`
        self.resourceConfigurationDefinition = resourceConfigurationDefinition
        self.resourceConfigurationGroupId = resourceConfigurationGroupId
        self.resourceGatewayId = resourceGatewayId
        self.status = status
        self.type = type
    }
}

public struct GetResourceGatewayInput: Swift.Sendable {
    /// The ID of the resource gateway.
    /// This member is required.
    public var resourceGatewayIdentifier: Swift.String?

    public init(
        resourceGatewayIdentifier: Swift.String? = nil
    ) {
        self.resourceGatewayIdentifier = resourceGatewayIdentifier
    }
}

public struct GetResourceGatewayOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource gateway.
    public var arn: Swift.String?
    /// The date and time that the resource gateway was created, in ISO-8601 format.
    public var createdAt: Foundation.Date?
    /// The ID of the resource gateway.
    public var id: Swift.String?
    /// The type of IP address for the resource gateway.
    public var ipAddressType: VPCLatticeClientTypes.ResourceGatewayIpAddressType?
    /// The date and time that the resource gateway was last updated, in ISO-8601 format.
    public var lastUpdatedAt: Foundation.Date?
    /// The name of the resource gateway.
    public var name: Swift.String?
    /// The security group IDs associated with the resource gateway.
    public var securityGroupIds: [Swift.String]?
    /// The status for the resource gateway.
    public var status: VPCLatticeClientTypes.ResourceGatewayStatus?
    /// The IDs of the VPC subnets for resource gateway.
    public var subnetIds: [Swift.String]?
    /// The ID of the VPC for the resource gateway.
    public var vpcId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        id: Swift.String? = nil,
        ipAddressType: VPCLatticeClientTypes.ResourceGatewayIpAddressType? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        status: VPCLatticeClientTypes.ResourceGatewayStatus? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcId: Swift.String? = nil
    ) {
        self.arn = arn
        self.createdAt = createdAt
        self.id = id
        self.ipAddressType = ipAddressType
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.securityGroupIds = securityGroupIds
        self.status = status
        self.subnetIds = subnetIds
        self.vpcId = vpcId
    }
}

public struct GetResourcePolicyInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the service network or service.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    ) {
        self.resourceArn = resourceArn
    }
}

public struct GetResourcePolicyOutput: Swift.Sendable {
    /// An IAM policy.
    public var policy: Swift.String?

    public init(
        policy: Swift.String? = nil
    ) {
        self.policy = policy
    }
}

public struct GetRuleInput: Swift.Sendable {
    /// The ID or ARN of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The ID or ARN of the listener rule.
    /// This member is required.
    public var ruleIdentifier: Swift.String?
    /// The ID or ARN of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        listenerIdentifier: Swift.String? = nil,
        ruleIdentifier: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    ) {
        self.listenerIdentifier = listenerIdentifier
        self.ruleIdentifier = ruleIdentifier
        self.serviceIdentifier = serviceIdentifier
    }
}

public struct GetRuleOutput: Swift.Sendable {
    /// The action for the default rule.
    public var action: VPCLatticeClientTypes.RuleAction?
    /// The Amazon Resource Name (ARN) of the listener.
    public var arn: Swift.String?
    /// The date and time that the listener rule was created, in ISO-8601 format.
    public var createdAt: Foundation.Date?
    /// The ID of the listener.
    public var id: Swift.String?
    /// Indicates whether this is the default rule.
    public var isDefault: Swift.Bool?
    /// The date and time that the listener rule was last updated, in ISO-8601 format.
    public var lastUpdatedAt: Foundation.Date?
    /// The rule match.
    public var match: VPCLatticeClientTypes.RuleMatch?
    /// The name of the listener.
    public var name: Swift.String?
    /// The priority level for the specified rule.
    public var priority: Swift.Int?

    public init(
        action: VPCLatticeClientTypes.RuleAction? = nil,
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        id: Swift.String? = nil,
        isDefault: Swift.Bool? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        match: VPCLatticeClientTypes.RuleMatch? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil
    ) {
        self.action = action
        self.arn = arn
        self.createdAt = createdAt
        self.id = id
        self.isDefault = isDefault
        self.lastUpdatedAt = lastUpdatedAt
        self.match = match
        self.name = name
        self.priority = priority
    }
}

public struct GetServiceInput: Swift.Sendable {
    /// The ID or ARN of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        serviceIdentifier: Swift.String? = nil
    ) {
        self.serviceIdentifier = serviceIdentifier
    }
}

public struct GetServiceOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the service.
    public var arn: Swift.String?
    /// The type of IAM policy.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The Amazon Resource Name (ARN) of the certificate.
    public var certificateArn: Swift.String?
    /// The date and time that the service was created, in ISO-8601 format.
    public var createdAt: Foundation.Date?
    /// The custom domain name of the service.
    public var customDomainName: Swift.String?
    /// The DNS name of the service.
    public var dnsEntry: VPCLatticeClientTypes.DnsEntry?
    /// The failure code.
    public var failureCode: Swift.String?
    /// The failure message.
    public var failureMessage: Swift.String?
    /// The ID of the service.
    public var id: Swift.String?
    /// The date and time that the service was last updated, in ISO-8601 format.
    public var lastUpdatedAt: Foundation.Date?
    /// The name of the service.
    public var name: Swift.String?
    /// The status of the service.
    public var status: VPCLatticeClientTypes.ServiceStatus?

    public init(
        arn: Swift.String? = nil,
        authType: VPCLatticeClientTypes.AuthType? = nil,
        certificateArn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        customDomainName: Swift.String? = nil,
        dnsEntry: VPCLatticeClientTypes.DnsEntry? = nil,
        failureCode: Swift.String? = nil,
        failureMessage: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceStatus? = nil
    ) {
        self.arn = arn
        self.authType = authType
        self.certificateArn = certificateArn
        self.createdAt = createdAt
        self.customDomainName = customDomainName
        self.dnsEntry = dnsEntry
        self.failureCode = failureCode
        self.failureMessage = failureMessage
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.status = status
    }
}

public struct GetServiceNetworkInput: Swift.Sendable {
    /// The ID or ARN of the service network.
    /// This member is required.
    public var serviceNetworkIdentifier: Swift.String?

    public init(
        serviceNetworkIdentifier: Swift.String? = nil
    ) {
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
    }
}

public struct GetServiceNetworkOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the service network.
    public var arn: Swift.String?
    /// The type of IAM policy.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The date and time that the service network was created, in ISO-8601 format.
    public var createdAt: Foundation.Date?
    /// The ID of the service network.
    public var id: Swift.String?
    /// The date and time of the last update, in ISO-8601 format.
    public var lastUpdatedAt: Foundation.Date?
    /// The name of the service network.
    public var name: Swift.String?
    /// The number of services associated with the service network.
    public var numberOfAssociatedServices: Swift.Int?
    /// The number of VPCs associated with the service network.
    public var numberOfAssociatedVPCs: Swift.Int?
    /// Specifies if the service network is enabled for sharing.
    public var sharingConfig: VPCLatticeClientTypes.SharingConfig?

    public init(
        arn: Swift.String? = nil,
        authType: VPCLatticeClientTypes.AuthType? = nil,
        createdAt: Foundation.Date? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        numberOfAssociatedServices: Swift.Int? = nil,
        numberOfAssociatedVPCs: Swift.Int? = nil,
        sharingConfig: VPCLatticeClientTypes.SharingConfig? = nil
    ) {
        self.arn = arn
        self.authType = authType
        self.createdAt = createdAt
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.numberOfAssociatedServices = numberOfAssociatedServices
        self.numberOfAssociatedVPCs = numberOfAssociatedVPCs
        self.sharingConfig = sharingConfig
    }
}

public struct GetServiceNetworkResourceAssociationInput: Swift.Sendable {
    /// The ID of the association.
    /// This member is required.
    public var serviceNetworkResourceAssociationIdentifier: Swift.String?

    public init(
        serviceNetworkResourceAssociationIdentifier: Swift.String? = nil
    ) {
        self.serviceNetworkResourceAssociationIdentifier = serviceNetworkResourceAssociationIdentifier
    }
}

public struct GetServiceNetworkResourceAssociationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The date and time that the association was created, in ISO-8601 format.
    public var createdAt: Foundation.Date?
    /// The account that created the association.
    public var createdBy: Swift.String?
    /// The DNS entry for the service.
    public var dnsEntry: VPCLatticeClientTypes.DnsEntry?
    /// The failure code.
    public var failureCode: Swift.String?
    /// The reason the association request failed.
    public var failureReason: Swift.String?
    /// The ID of the association.
    public var id: Swift.String?
    /// Indicates whether the association is managed by Amazon.
    public var isManagedAssociation: Swift.Bool?
    /// The most recent date and time that the association was updated, in ISO-8601 format.
    public var lastUpdatedAt: Foundation.Date?
    /// The private DNS entry for the service.
    public var privateDnsEntry: VPCLatticeClientTypes.DnsEntry?
    /// The Amazon Resource Name (ARN) of the association.
    public var resourceConfigurationArn: Swift.String?
    /// The ID of the resource configuration that is associated with the service network.
    public var resourceConfigurationId: Swift.String?
    /// The name of the resource configuration that is associated with the service network.
    public var resourceConfigurationName: Swift.String?
    /// The Amazon Resource Name (ARN) of the service network that is associated with the resource configuration.
    public var serviceNetworkArn: Swift.String?
    /// The ID of the service network that is associated with the resource configuration.
    public var serviceNetworkId: Swift.String?
    /// The name of the service network that is associated with the resource configuration.
    public var serviceNetworkName: Swift.String?
    /// The status of the association.
    public var status: VPCLatticeClientTypes.ServiceNetworkResourceAssociationStatus?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        dnsEntry: VPCLatticeClientTypes.DnsEntry? = nil,
        failureCode: Swift.String? = nil,
        failureReason: Swift.String? = nil,
        id: Swift.String? = nil,
        isManagedAssociation: Swift.Bool? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        privateDnsEntry: VPCLatticeClientTypes.DnsEntry? = nil,
        resourceConfigurationArn: Swift.String? = nil,
        resourceConfigurationId: Swift.String? = nil,
        resourceConfigurationName: Swift.String? = nil,
        serviceNetworkArn: Swift.String? = nil,
        serviceNetworkId: Swift.String? = nil,
        serviceNetworkName: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkResourceAssociationStatus? = nil
    ) {
        self.arn = arn
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.dnsEntry = dnsEntry
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.id = id
        self.isManagedAssociation = isManagedAssociation
        self.lastUpdatedAt = lastUpdatedAt
        self.privateDnsEntry = privateDnsEntry
        self.resourceConfigurationArn = resourceConfigurationArn
        self.resourceConfigurationId = resourceConfigurationId
        self.resourceConfigurationName = resourceConfigurationName
        self.serviceNetworkArn = serviceNetworkArn
        self.serviceNetworkId = serviceNetworkId
        self.serviceNetworkName = serviceNetworkName
        self.status = status
    }
}

public struct GetServiceNetworkServiceAssociationInput: Swift.Sendable {
    /// The ID or ARN of the association.
    /// This member is required.
    public var serviceNetworkServiceAssociationIdentifier: Swift.String?

    public init(
        serviceNetworkServiceAssociationIdentifier: Swift.String? = nil
    ) {
        self.serviceNetworkServiceAssociationIdentifier = serviceNetworkServiceAssociationIdentifier
    }
}

public struct GetServiceNetworkServiceAssociationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The date and time that the association was created, in ISO-8601 format.
    public var createdAt: Foundation.Date?
    /// The account that created the association.
    public var createdBy: Swift.String?
    /// The custom domain name of the service.
    public var customDomainName: Swift.String?
    /// The DNS name of the service.
    public var dnsEntry: VPCLatticeClientTypes.DnsEntry?
    /// The failure code.
    public var failureCode: Swift.String?
    /// The failure message.
    public var failureMessage: Swift.String?
    /// The ID of the service network and service association.
    public var id: Swift.String?
    /// The Amazon Resource Name (ARN) of the service.
    public var serviceArn: Swift.String?
    /// The ID of the service.
    public var serviceId: Swift.String?
    /// The name of the service.
    public var serviceName: Swift.String?
    /// The Amazon Resource Name (ARN) of the service network.
    public var serviceNetworkArn: Swift.String?
    /// The ID of the service network.
    public var serviceNetworkId: Swift.String?
    /// The name of the service network.
    public var serviceNetworkName: Swift.String?
    /// The status of the association.
    public var status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        customDomainName: Swift.String? = nil,
        dnsEntry: VPCLatticeClientTypes.DnsEntry? = nil,
        failureCode: Swift.String? = nil,
        failureMessage: Swift.String? = nil,
        id: Swift.String? = nil,
        serviceArn: Swift.String? = nil,
        serviceId: Swift.String? = nil,
        serviceName: Swift.String? = nil,
        serviceNetworkArn: Swift.String? = nil,
        serviceNetworkId: Swift.String? = nil,
        serviceNetworkName: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus? = nil
    ) {
        self.arn = arn
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.customDomainName = customDomainName
        self.dnsEntry = dnsEntry
        self.failureCode = failureCode
        self.failureMessage = failureMessage
        self.id = id
        self.serviceArn = serviceArn
        self.serviceId = serviceId
        self.serviceName = serviceName
        self.serviceNetworkArn = serviceNetworkArn
        self.serviceNetworkId = serviceNetworkId
        self.serviceNetworkName = serviceNetworkName
        self.status = status
    }
}

public struct GetServiceNetworkVpcAssociationInput: Swift.Sendable {
    /// The ID or ARN of the association.
    /// This member is required.
    public var serviceNetworkVpcAssociationIdentifier: Swift.String?

    public init(
        serviceNetworkVpcAssociationIdentifier: Swift.String? = nil
    ) {
        self.serviceNetworkVpcAssociationIdentifier = serviceNetworkVpcAssociationIdentifier
    }
}

public struct GetServiceNetworkVpcAssociationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The date and time that the association was created, in ISO-8601 format.
    public var createdAt: Foundation.Date?
    /// The account that created the association.
    public var createdBy: Swift.String?
    /// The failure code.
    public var failureCode: Swift.String?
    /// The failure message.
    public var failureMessage: Swift.String?
    /// The ID of the association.
    public var id: Swift.String?
    /// The date and time that the association was last updated, in ISO-8601 format.
    public var lastUpdatedAt: Foundation.Date?
    /// The IDs of the security groups.
    public var securityGroupIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the service network.
    public var serviceNetworkArn: Swift.String?
    /// The ID of the service network.
    public var serviceNetworkId: Swift.String?
    /// The name of the service network.
    public var serviceNetworkName: Swift.String?
    /// The status of the association.
    public var status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus?
    /// The ID of the VPC.
    public var vpcId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        failureCode: Swift.String? = nil,
        failureMessage: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        securityGroupIds: [Swift.String]? = nil,
        serviceNetworkArn: Swift.String? = nil,
        serviceNetworkId: Swift.String? = nil,
        serviceNetworkName: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus? = nil,
        vpcId: Swift.String? = nil
    ) {
        self.arn = arn
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.failureCode = failureCode
        self.failureMessage = failureMessage
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.securityGroupIds = securityGroupIds
        self.serviceNetworkArn = serviceNetworkArn
        self.serviceNetworkId = serviceNetworkId
        self.serviceNetworkName = serviceNetworkName
        self.status = status
        self.vpcId = vpcId
    }
}

public struct GetTargetGroupInput: Swift.Sendable {
    /// The ID or ARN of the target group.
    /// This member is required.
    public var targetGroupIdentifier: Swift.String?

    public init(
        targetGroupIdentifier: Swift.String? = nil
    ) {
        self.targetGroupIdentifier = targetGroupIdentifier
    }
}

public struct GetTargetGroupOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the target group.
    public var arn: Swift.String?
    /// The target group configuration.
    public var config: VPCLatticeClientTypes.TargetGroupConfig?
    /// The date and time that the target group was created, in ISO-8601 format.
    public var createdAt: Foundation.Date?
    /// The failure code.
    public var failureCode: Swift.String?
    /// The failure message.
    public var failureMessage: Swift.String?
    /// The ID of the target group.
    public var id: Swift.String?
    /// The date and time that the target group was last updated, in ISO-8601 format.
    public var lastUpdatedAt: Foundation.Date?
    /// The name of the target group.
    public var name: Swift.String?
    /// The Amazon Resource Names (ARNs) of the service.
    public var serviceArns: [Swift.String]?
    /// The status.
    public var status: VPCLatticeClientTypes.TargetGroupStatus?
    /// The target group type.
    public var type: VPCLatticeClientTypes.TargetGroupType?

    public init(
        arn: Swift.String? = nil,
        config: VPCLatticeClientTypes.TargetGroupConfig? = nil,
        createdAt: Foundation.Date? = nil,
        failureCode: Swift.String? = nil,
        failureMessage: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        serviceArns: [Swift.String]? = nil,
        status: VPCLatticeClientTypes.TargetGroupStatus? = nil,
        type: VPCLatticeClientTypes.TargetGroupType? = nil
    ) {
        self.arn = arn
        self.config = config
        self.createdAt = createdAt
        self.failureCode = failureCode
        self.failureMessage = failureMessage
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.serviceArns = serviceArns
        self.status = status
        self.type = type
    }
}

public struct ListListenersInput: Swift.Sendable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID or ARN of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceIdentifier = serviceIdentifier
    }
}

extension VPCLatticeClientTypes {

    /// Summary information about a listener.
    public struct ListenerSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the listener.
        public var arn: Swift.String?
        /// The date and time that the listener was created, in ISO-8601 format.
        public var createdAt: Foundation.Date?
        /// The ID of the listener.
        public var id: Swift.String?
        /// The date and time that the listener was last updated, in ISO-8601 format.
        public var lastUpdatedAt: Foundation.Date?
        /// The name of the listener.
        public var name: Swift.String?
        /// The listener port.
        public var port: Swift.Int?
        /// The listener protocol.
        public var `protocol`: VPCLatticeClientTypes.ListenerProtocol?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: VPCLatticeClientTypes.ListenerProtocol? = nil
        ) {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.port = port
            self.`protocol` = `protocol`
        }
    }
}

public struct ListListenersOutput: Swift.Sendable {
    /// Information about the listeners.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.ListenerSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.ListenerSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct UpdateListenerInput: Swift.Sendable {
    /// The action for the default rule.
    /// This member is required.
    public var defaultAction: VPCLatticeClientTypes.RuleAction?
    /// The ID or ARN of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The ID or ARN of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        defaultAction: VPCLatticeClientTypes.RuleAction? = nil,
        listenerIdentifier: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    ) {
        self.defaultAction = defaultAction
        self.listenerIdentifier = listenerIdentifier
        self.serviceIdentifier = serviceIdentifier
    }
}

public struct UpdateListenerOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the listener.
    public var arn: Swift.String?
    /// The action for the default rule.
    public var defaultAction: VPCLatticeClientTypes.RuleAction?
    /// The ID of the listener.
    public var id: Swift.String?
    /// The name of the listener.
    public var name: Swift.String?
    /// The listener port.
    public var port: Swift.Int?
    /// The protocol of the listener.
    public var `protocol`: VPCLatticeClientTypes.ListenerProtocol?
    /// The Amazon Resource Name (ARN) of the service.
    public var serviceArn: Swift.String?
    /// The ID of the service.
    public var serviceId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        defaultAction: VPCLatticeClientTypes.RuleAction? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        port: Swift.Int? = nil,
        `protocol`: VPCLatticeClientTypes.ListenerProtocol? = nil,
        serviceArn: Swift.String? = nil,
        serviceId: Swift.String? = nil
    ) {
        self.arn = arn
        self.defaultAction = defaultAction
        self.id = id
        self.name = name
        self.port = port
        self.`protocol` = `protocol`
        self.serviceArn = serviceArn
        self.serviceId = serviceId
    }
}

public struct ListResourceConfigurationsInput: Swift.Sendable {
    /// The maximum page size.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the group resource configuration.
    public var resourceConfigurationGroupIdentifier: Swift.String?
    /// The ID of the resource gateway for the resource configuration.
    public var resourceGatewayIdentifier: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceConfigurationGroupIdentifier: Swift.String? = nil,
        resourceGatewayIdentifier: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceConfigurationGroupIdentifier = resourceConfigurationGroupIdentifier
        self.resourceGatewayIdentifier = resourceGatewayIdentifier
    }
}

extension VPCLatticeClientTypes {

    /// Summary information about a resource configuration.
    public struct ResourceConfigurationSummary: Swift.Sendable {
        /// Indicates whether the resource configuration was created and is managed by Amazon.
        public var amazonManaged: Swift.Bool?
        /// The Amazon Resource Name (ARN) of the resource configuration.
        public var arn: Swift.String?
        /// The date and time that the resource configuration was created, in ISO-8601 format.
        public var createdAt: Foundation.Date?
        /// The ID of the resource configuration.
        public var id: Swift.String?
        /// The most recent date and time that the resource configuration was updated, in ISO-8601 format.
        public var lastUpdatedAt: Foundation.Date?
        /// The name of the resource configuration.
        public var name: Swift.String?
        /// The ID of the group resource configuration.
        public var resourceConfigurationGroupId: Swift.String?
        /// The ID of the resource gateway.
        public var resourceGatewayId: Swift.String?
        /// The status of the resource configuration.
        public var status: VPCLatticeClientTypes.ResourceConfigurationStatus?
        /// The type of resource configuration.
        ///
        /// * SINGLE - A single resource.
        ///
        /// * GROUP - A group of resources.
        ///
        /// * CHILD - A single resource that is part of a group resource configuration.
        ///
        /// * ARN - An Amazon Web Services resource.
        public var type: VPCLatticeClientTypes.ResourceConfigurationType?

        public init(
            amazonManaged: Swift.Bool? = nil,
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            resourceConfigurationGroupId: Swift.String? = nil,
            resourceGatewayId: Swift.String? = nil,
            status: VPCLatticeClientTypes.ResourceConfigurationStatus? = nil,
            type: VPCLatticeClientTypes.ResourceConfigurationType? = nil
        ) {
            self.amazonManaged = amazonManaged
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.resourceConfigurationGroupId = resourceConfigurationGroupId
            self.resourceGatewayId = resourceGatewayId
            self.status = status
            self.type = type
        }
    }
}

public struct ListResourceConfigurationsOutput: Swift.Sendable {
    /// Information about the resource configurations.
    public var items: [VPCLatticeClientTypes.ResourceConfigurationSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.ResourceConfigurationSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListResourceEndpointAssociationsInput: Swift.Sendable {
    /// The maximum page size.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID for the resource configuration associated with the VPC endpoint.
    /// This member is required.
    public var resourceConfigurationIdentifier: Swift.String?
    /// The ID of the association.
    public var resourceEndpointAssociationIdentifier: Swift.String?
    /// The ID of the VPC endpoint in the association.
    public var vpcEndpointId: Swift.String?
    /// The owner of the VPC endpoint in the association.
    public var vpcEndpointOwner: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceConfigurationIdentifier: Swift.String? = nil,
        resourceEndpointAssociationIdentifier: Swift.String? = nil,
        vpcEndpointId: Swift.String? = nil,
        vpcEndpointOwner: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceConfigurationIdentifier = resourceConfigurationIdentifier
        self.resourceEndpointAssociationIdentifier = resourceEndpointAssociationIdentifier
        self.vpcEndpointId = vpcEndpointId
        self.vpcEndpointOwner = vpcEndpointOwner
    }
}

extension VPCLatticeClientTypes {

    /// Summary information about a VPC endpoint association.
    public struct ResourceEndpointAssociationSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the VPC endpoint association.
        public var arn: Swift.String?
        /// The date and time that the VPC endpoint association was created, in ISO-8601 format.
        public var createdAt: Foundation.Date?
        /// The account that created the association.
        public var createdBy: Swift.String?
        /// The ID of the VPC endpoint association.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of the resource configuration.
        public var resourceConfigurationArn: Swift.String?
        /// The ID of the resource configuration.
        public var resourceConfigurationId: Swift.String?
        /// The name of the resource configuration.
        public var resourceConfigurationName: Swift.String?
        /// The ID of the VPC endpoint.
        public var vpcEndpointId: Swift.String?
        /// The owner of the VPC endpoint.
        public var vpcEndpointOwner: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            id: Swift.String? = nil,
            resourceConfigurationArn: Swift.String? = nil,
            resourceConfigurationId: Swift.String? = nil,
            resourceConfigurationName: Swift.String? = nil,
            vpcEndpointId: Swift.String? = nil,
            vpcEndpointOwner: Swift.String? = nil
        ) {
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.id = id
            self.resourceConfigurationArn = resourceConfigurationArn
            self.resourceConfigurationId = resourceConfigurationId
            self.resourceConfigurationName = resourceConfigurationName
            self.vpcEndpointId = vpcEndpointId
            self.vpcEndpointOwner = vpcEndpointOwner
        }
    }
}

public struct ListResourceEndpointAssociationsOutput: Swift.Sendable {
    /// Information about the VPC endpoint associations.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.ResourceEndpointAssociationSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.ResourceEndpointAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListResourceGatewaysInput: Swift.Sendable {
    /// The maximum page size.
    public var maxResults: Swift.Int?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension VPCLatticeClientTypes {

    /// Summary information about a resource gateway.
    public struct ResourceGatewaySummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the resource gateway.
        public var arn: Swift.String?
        /// The date and time that the VPC endpoint association was created, in ISO-8601 format.
        public var createdAt: Foundation.Date?
        /// The ID of the resource gateway.
        public var id: Swift.String?
        /// The type of IP address used by the resource gateway.
        public var ipAddressType: VPCLatticeClientTypes.ResourceGatewayIpAddressType?
        /// The most recent date and time that the resource gateway was updated, in ISO-8601 format.
        public var lastUpdatedAt: Foundation.Date?
        /// The name of the resource gateway.
        public var name: Swift.String?
        /// The IDs of the security groups applied to the resource gateway.
        public var securityGroupIds: [Swift.String]?
        /// The name of the resource gateway.
        public var status: VPCLatticeClientTypes.ResourceGatewayStatus?
        /// The IDs of the VPC subnets for the resource gateway.
        public var subnetIds: [Swift.String]?
        /// The ID of the VPC for the resource gateway.
        public var vpcIdentifier: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            id: Swift.String? = nil,
            ipAddressType: VPCLatticeClientTypes.ResourceGatewayIpAddressType? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            status: VPCLatticeClientTypes.ResourceGatewayStatus? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcIdentifier: Swift.String? = nil
        ) {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.ipAddressType = ipAddressType
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.securityGroupIds = securityGroupIds
            self.status = status
            self.subnetIds = subnetIds
            self.vpcIdentifier = vpcIdentifier
        }
    }
}

public struct ListResourceGatewaysOutput: Swift.Sendable {
    /// Information about the resource gateways.
    public var items: [VPCLatticeClientTypes.ResourceGatewaySummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.ResourceGatewaySummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListRulesInput: Swift.Sendable {
    /// The ID or ARN of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID or ARN of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        listenerIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    ) {
        self.listenerIdentifier = listenerIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceIdentifier = serviceIdentifier
    }
}

extension VPCLatticeClientTypes {

    /// Summary information about a listener rule.
    public struct RuleSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the rule.
        public var arn: Swift.String?
        /// The date and time that the listener rule was created, in ISO-8601 format.
        public var createdAt: Foundation.Date?
        /// The ID of the rule.
        public var id: Swift.String?
        /// Indicates whether this is the default listener rule.
        public var isDefault: Swift.Bool?
        /// The date and time that the listener rule was last updated, in ISO-8601 format.
        public var lastUpdatedAt: Foundation.Date?
        /// The name of the rule.
        public var name: Swift.String?
        /// The priority of the rule.
        public var priority: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            id: Swift.String? = nil,
            isDefault: Swift.Bool? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            priority: Swift.Int? = nil
        ) {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.isDefault = isDefault
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.priority = priority
        }
    }
}

public struct ListRulesOutput: Swift.Sendable {
    /// Information about the rules.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.RuleSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.RuleSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListServiceNetworkResourceAssociationsInput: Swift.Sendable {
    /// The maximum page size.
    public var maxResults: Swift.Int?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the resource configurationk.
    public var resourceConfigurationIdentifier: Swift.String?
    /// The ID of the service network.
    public var serviceNetworkIdentifier: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceConfigurationIdentifier: Swift.String? = nil,
        serviceNetworkIdentifier: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceConfigurationIdentifier = resourceConfigurationIdentifier
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
    }
}

extension VPCLatticeClientTypes {

    /// Summary information about an association between a service network and a resource configuration.
    public struct ServiceNetworkResourceAssociationSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the association.
        public var arn: Swift.String?
        /// The date and time that the association was created, in ISO-8601 format.
        public var createdAt: Foundation.Date?
        /// The account that created the association.
        public var createdBy: Swift.String?
        /// The DNS entry for the service.
        public var dnsEntry: VPCLatticeClientTypes.DnsEntry?
        /// The failure code.
        public var failureCode: Swift.String?
        /// The ID of the association between the service network and resource configuration.
        public var id: Swift.String?
        /// Specifies whether the association is managed by Amazon.
        public var isManagedAssociation: Swift.Bool?
        /// The private DNS entry for the service.
        public var privateDnsEntry: VPCLatticeClientTypes.DnsEntry?
        /// The Amazon Resource Name (ARN) of the association.
        public var resourceConfigurationArn: Swift.String?
        /// The ID of the resource configuration associated with the service network.
        public var resourceConfigurationId: Swift.String?
        /// The name of the resource configuration associated with the service network.
        public var resourceConfigurationName: Swift.String?
        /// The Amazon Resource Name (ARN) of the service network associated with the resource configuration.
        public var serviceNetworkArn: Swift.String?
        /// The ID of the service network associated with the resource configuration.
        public var serviceNetworkId: Swift.String?
        /// The name of the service network associated with the resource configuration.
        public var serviceNetworkName: Swift.String?
        /// The status of the service network associated with the resource configuration.
        public var status: VPCLatticeClientTypes.ServiceNetworkResourceAssociationStatus?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            dnsEntry: VPCLatticeClientTypes.DnsEntry? = nil,
            failureCode: Swift.String? = nil,
            id: Swift.String? = nil,
            isManagedAssociation: Swift.Bool? = nil,
            privateDnsEntry: VPCLatticeClientTypes.DnsEntry? = nil,
            resourceConfigurationArn: Swift.String? = nil,
            resourceConfigurationId: Swift.String? = nil,
            resourceConfigurationName: Swift.String? = nil,
            serviceNetworkArn: Swift.String? = nil,
            serviceNetworkId: Swift.String? = nil,
            serviceNetworkName: Swift.String? = nil,
            status: VPCLatticeClientTypes.ServiceNetworkResourceAssociationStatus? = nil
        ) {
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.dnsEntry = dnsEntry
            self.failureCode = failureCode
            self.id = id
            self.isManagedAssociation = isManagedAssociation
            self.privateDnsEntry = privateDnsEntry
            self.resourceConfigurationArn = resourceConfigurationArn
            self.resourceConfigurationId = resourceConfigurationId
            self.resourceConfigurationName = resourceConfigurationName
            self.serviceNetworkArn = serviceNetworkArn
            self.serviceNetworkId = serviceNetworkId
            self.serviceNetworkName = serviceNetworkName
            self.status = status
        }
    }
}

public struct ListServiceNetworkResourceAssociationsOutput: Swift.Sendable {
    /// Information about the associations.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.ServiceNetworkResourceAssociationSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.ServiceNetworkResourceAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListServiceNetworksInput: Swift.Sendable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension VPCLatticeClientTypes {

    /// Summary information about a service network.
    public struct ServiceNetworkSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the service network.
        public var arn: Swift.String?
        /// The date and time that the service network was created, in ISO-8601 format.
        public var createdAt: Foundation.Date?
        /// The ID of the service network.
        public var id: Swift.String?
        /// The date and time that the service network was last updated, in ISO-8601 format.
        public var lastUpdatedAt: Foundation.Date?
        /// The name of the service network.
        public var name: Swift.String?
        /// The number of resource configurations associated with a service network.
        public var numberOfAssociatedResourceConfigurations: Swift.Int?
        /// The number of services associated with the service network.
        public var numberOfAssociatedServices: Swift.Int?
        /// The number of VPCs associated with the service network.
        public var numberOfAssociatedVPCs: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            numberOfAssociatedResourceConfigurations: Swift.Int? = nil,
            numberOfAssociatedServices: Swift.Int? = nil,
            numberOfAssociatedVPCs: Swift.Int? = nil
        ) {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.numberOfAssociatedResourceConfigurations = numberOfAssociatedResourceConfigurations
            self.numberOfAssociatedServices = numberOfAssociatedServices
            self.numberOfAssociatedVPCs = numberOfAssociatedVPCs
        }
    }
}

public struct ListServiceNetworksOutput: Swift.Sendable {
    /// Information about the service networks.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.ServiceNetworkSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.ServiceNetworkSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListServiceNetworkServiceAssociationsInput: Swift.Sendable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID or ARN of the service.
    public var serviceIdentifier: Swift.String?
    /// The ID or ARN of the service network.
    public var serviceNetworkIdentifier: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil,
        serviceNetworkIdentifier: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceIdentifier = serviceIdentifier
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
    }
}

extension VPCLatticeClientTypes {

    /// Summary information about an association between a service network and a service.
    public struct ServiceNetworkServiceAssociationSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the association.
        public var arn: Swift.String?
        /// The date and time that the association was created, in ISO-8601 format.
        public var createdAt: Foundation.Date?
        /// The account that created the association.
        public var createdBy: Swift.String?
        /// The custom domain name of the service.
        public var customDomainName: Swift.String?
        /// The DNS information.
        public var dnsEntry: VPCLatticeClientTypes.DnsEntry?
        /// The ID of the association.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of the service.
        public var serviceArn: Swift.String?
        /// The ID of the service.
        public var serviceId: Swift.String?
        /// The name of the service.
        public var serviceName: Swift.String?
        /// The Amazon Resource Name (ARN) of the service network.
        public var serviceNetworkArn: Swift.String?
        /// The ID of the service network.
        public var serviceNetworkId: Swift.String?
        /// The name of the service network.
        public var serviceNetworkName: Swift.String?
        /// The status. If the deletion fails, try to delete again.
        public var status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            customDomainName: Swift.String? = nil,
            dnsEntry: VPCLatticeClientTypes.DnsEntry? = nil,
            id: Swift.String? = nil,
            serviceArn: Swift.String? = nil,
            serviceId: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            serviceNetworkArn: Swift.String? = nil,
            serviceNetworkId: Swift.String? = nil,
            serviceNetworkName: Swift.String? = nil,
            status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus? = nil
        ) {
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.customDomainName = customDomainName
            self.dnsEntry = dnsEntry
            self.id = id
            self.serviceArn = serviceArn
            self.serviceId = serviceId
            self.serviceName = serviceName
            self.serviceNetworkArn = serviceNetworkArn
            self.serviceNetworkId = serviceNetworkId
            self.serviceNetworkName = serviceNetworkName
            self.status = status
        }
    }
}

public struct ListServiceNetworkServiceAssociationsOutput: Swift.Sendable {
    /// Information about the associations.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.ServiceNetworkServiceAssociationSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.ServiceNetworkServiceAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListServiceNetworkVpcAssociationsInput: Swift.Sendable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID or ARN of the service network.
    public var serviceNetworkIdentifier: Swift.String?
    /// The ID or ARN of the VPC.
    public var vpcIdentifier: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceNetworkIdentifier: Swift.String? = nil,
        vpcIdentifier: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
        self.vpcIdentifier = vpcIdentifier
    }
}

extension VPCLatticeClientTypes {

    /// Summary information about an association between a service network and a VPC.
    public struct ServiceNetworkVpcAssociationSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the association.
        public var arn: Swift.String?
        /// The date and time that the association was created, in ISO-8601 format.
        public var createdAt: Foundation.Date?
        /// The account that created the association.
        public var createdBy: Swift.String?
        /// The ID of the association.
        public var id: Swift.String?
        /// The date and time that the association was last updated, in ISO-8601 format.
        public var lastUpdatedAt: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the service network.
        public var serviceNetworkArn: Swift.String?
        /// The ID of the service network.
        public var serviceNetworkId: Swift.String?
        /// The name of the service network.
        public var serviceNetworkName: Swift.String?
        /// The status.
        public var status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus?
        /// The ID of the VPC.
        public var vpcId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            serviceNetworkArn: Swift.String? = nil,
            serviceNetworkId: Swift.String? = nil,
            serviceNetworkName: Swift.String? = nil,
            status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus? = nil,
            vpcId: Swift.String? = nil
        ) {
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.serviceNetworkArn = serviceNetworkArn
            self.serviceNetworkId = serviceNetworkId
            self.serviceNetworkName = serviceNetworkName
            self.status = status
            self.vpcId = vpcId
        }
    }
}

public struct ListServiceNetworkVpcAssociationsOutput: Swift.Sendable {
    /// Information about the associations.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.ServiceNetworkVpcAssociationSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.ServiceNetworkVpcAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListServiceNetworkVpcEndpointAssociationsInput: Swift.Sendable {
    /// The maximum page size.
    public var maxResults: Swift.Int?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the service network associated with the VPC endpoint.
    /// This member is required.
    public var serviceNetworkIdentifier: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceNetworkIdentifier: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
    }
}

extension VPCLatticeClientTypes {

    /// Describes the association between a service network and a VPC endpoint.
    public struct ServiceNetworkEndpointAssociation: Swift.Sendable {
        /// The date and time that the association was created, in ISO-8601 format.
        public var createdAt: Foundation.Date?
        /// The ID of the association.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of the service network.
        public var serviceNetworkArn: Swift.String?
        /// The state of the association.
        public var state: Swift.String?
        /// The ID of the VPC endpoint associated with the service network.
        public var vpcEndpointId: Swift.String?
        /// The owner of the VPC endpoint associated with the service network.
        public var vpcEndpointOwnerId: Swift.String?
        /// The ID of the VPC for the association.
        public var vpcId: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            id: Swift.String? = nil,
            serviceNetworkArn: Swift.String? = nil,
            state: Swift.String? = nil,
            vpcEndpointId: Swift.String? = nil,
            vpcEndpointOwnerId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        ) {
            self.createdAt = createdAt
            self.id = id
            self.serviceNetworkArn = serviceNetworkArn
            self.state = state
            self.vpcEndpointId = vpcEndpointId
            self.vpcEndpointOwnerId = vpcEndpointOwnerId
            self.vpcId = vpcId
        }
    }
}

public struct ListServiceNetworkVpcEndpointAssociationsOutput: Swift.Sendable {
    /// Information about the association between the VPC endpoint and service network.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.ServiceNetworkEndpointAssociation]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.ServiceNetworkEndpointAssociation]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListServicesInput: Swift.Sendable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension VPCLatticeClientTypes {

    /// Summary information about a service.
    public struct ServiceSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the service.
        public var arn: Swift.String?
        /// The date and time that the service was created, in ISO-8601 format.
        public var createdAt: Foundation.Date?
        /// The custom domain name of the service.
        public var customDomainName: Swift.String?
        /// The DNS information.
        public var dnsEntry: VPCLatticeClientTypes.DnsEntry?
        /// The ID of the service.
        public var id: Swift.String?
        /// The date and time that the service was last updated, in ISO-8601 format.
        public var lastUpdatedAt: Foundation.Date?
        /// The name of the service.
        public var name: Swift.String?
        /// The status.
        public var status: VPCLatticeClientTypes.ServiceStatus?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            customDomainName: Swift.String? = nil,
            dnsEntry: VPCLatticeClientTypes.DnsEntry? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            status: VPCLatticeClientTypes.ServiceStatus? = nil
        ) {
            self.arn = arn
            self.createdAt = createdAt
            self.customDomainName = customDomainName
            self.dnsEntry = dnsEntry
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.status = status
        }
    }
}

public struct ListServicesOutput: Swift.Sendable {
    /// Information about the services.
    public var items: [VPCLatticeClientTypes.ServiceSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.ServiceSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    ) {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// Information about the tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.tags = tags
    }
}

public struct ListTargetGroupsInput: Swift.Sendable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The target group type.
    public var targetGroupType: VPCLatticeClientTypes.TargetGroupType?
    /// The ID or ARN of the VPC.
    public var vpcIdentifier: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        targetGroupType: VPCLatticeClientTypes.TargetGroupType? = nil,
        vpcIdentifier: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.targetGroupType = targetGroupType
        self.vpcIdentifier = vpcIdentifier
    }
}

extension VPCLatticeClientTypes {

    /// Summary information about a target group. For more information, see [Target groups](https://docs.aws.amazon.com/vpc-lattice/latest/ug/target-groups.html) in the Amazon VPC Lattice User Guide.
    public struct TargetGroupSummary: Swift.Sendable {
        /// The ARN (Amazon Resource Name) of the target group.
        public var arn: Swift.String?
        /// The date and time that the target group was created, in ISO-8601 format.
        public var createdAt: Foundation.Date?
        /// The ID of the target group.
        public var id: Swift.String?
        /// The type of IP address used for the target group. The possible values are IPV4 and IPV6. This is an optional parameter. If not specified, the default is IPV4.
        public var ipAddressType: VPCLatticeClientTypes.IpAddressType?
        /// The version of the event structure that your Lambda function receives. Supported only if the target group type is LAMBDA.
        public var lambdaEventStructureVersion: VPCLatticeClientTypes.LambdaEventStructureVersion?
        /// The date and time that the target group was last updated, in ISO-8601 format.
        public var lastUpdatedAt: Foundation.Date?
        /// The name of the target group.
        public var name: Swift.String?
        /// The port of the target group.
        public var port: Swift.Int?
        /// The protocol of the target group.
        public var `protocol`: VPCLatticeClientTypes.TargetGroupProtocol?
        /// The Amazon Resource Names (ARNs) of the service.
        public var serviceArns: [Swift.String]?
        /// The status.
        public var status: VPCLatticeClientTypes.TargetGroupStatus?
        /// The target group type.
        public var type: VPCLatticeClientTypes.TargetGroupType?
        /// The ID of the VPC of the target group.
        public var vpcIdentifier: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            id: Swift.String? = nil,
            ipAddressType: VPCLatticeClientTypes.IpAddressType? = nil,
            lambdaEventStructureVersion: VPCLatticeClientTypes.LambdaEventStructureVersion? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: VPCLatticeClientTypes.TargetGroupProtocol? = nil,
            serviceArns: [Swift.String]? = nil,
            status: VPCLatticeClientTypes.TargetGroupStatus? = nil,
            type: VPCLatticeClientTypes.TargetGroupType? = nil,
            vpcIdentifier: Swift.String? = nil
        ) {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.ipAddressType = ipAddressType
            self.lambdaEventStructureVersion = lambdaEventStructureVersion
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.port = port
            self.`protocol` = `protocol`
            self.serviceArns = serviceArns
            self.status = status
            self.type = type
            self.vpcIdentifier = vpcIdentifier
        }
    }
}

public struct ListTargetGroupsOutput: Swift.Sendable {
    /// Information about the target groups.
    public var items: [VPCLatticeClientTypes.TargetGroupSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.TargetGroupSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListTargetsInput: Swift.Sendable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID or ARN of the target group.
    /// This member is required.
    public var targetGroupIdentifier: Swift.String?
    /// The targets.
    public var targets: [VPCLatticeClientTypes.Target]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        targetGroupIdentifier: Swift.String? = nil,
        targets: [VPCLatticeClientTypes.Target]? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.targetGroupIdentifier = targetGroupIdentifier
        self.targets = targets
    }
}

extension VPCLatticeClientTypes {

    public enum TargetStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// The target is deregistering and connection draining is in process.
        case draining
        /// The target is healthy.
        case healthy
        /// The initial health check is in progress.
        case initial
        /// Health checks are disabled.
        case unavailable
        /// The target failed the health check.
        case unhealthy
        /// The target group is not used in a listener rule.
        case unused
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetStatus] {
            return [
                .draining,
                .healthy,
                .initial,
                .unavailable,
                .unhealthy,
                .unused
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .draining: return "DRAINING"
            case .healthy: return "HEALTHY"
            case .initial: return "INITIAL"
            case .unavailable: return "UNAVAILABLE"
            case .unhealthy: return "UNHEALTHY"
            case .unused: return "UNUSED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VPCLatticeClientTypes {

    /// Summary information about a target.
    public struct TargetSummary: Swift.Sendable {
        /// The ID of the target. If the target group type is INSTANCE, this is an instance ID. If the target group type is IP, this is an IP address. If the target group type is LAMBDA, this is the ARN of a Lambda function. If the target type is ALB, this is the ARN of an Application Load Balancer.
        public var id: Swift.String?
        /// The port on which the target is listening.
        public var port: Swift.Int?
        /// The code for why the target status is what it is.
        public var reasonCode: Swift.String?
        /// The status of the target.
        ///
        /// * DRAINING: The target is being deregistered. No new connections are sent to this target while current connections are being drained. The default draining time is 5 minutes.
        ///
        /// * UNAVAILABLE: Health checks are unavailable for the target group.
        ///
        /// * HEALTHY: The target is healthy.
        ///
        /// * UNHEALTHY: The target is unhealthy.
        ///
        /// * INITIAL: Initial health checks on the target are being performed.
        ///
        /// * UNUSED: Target group is not used in a service.
        public var status: VPCLatticeClientTypes.TargetStatus?

        public init(
            id: Swift.String? = nil,
            port: Swift.Int? = nil,
            reasonCode: Swift.String? = nil,
            status: VPCLatticeClientTypes.TargetStatus? = nil
        ) {
            self.id = id
            self.port = port
            self.reasonCode = reasonCode
            self.status = status
        }
    }
}

public struct ListTargetsOutput: Swift.Sendable {
    /// Information about the targets.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.TargetSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.TargetSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct PutAuthPolicyInput: Swift.Sendable {
    /// The auth policy. The policy string in JSON must not contain newlines or blank lines.
    /// This member is required.
    public var policy: Swift.String?
    /// The ID or ARN of the service network or service for which the policy is created.
    /// This member is required.
    public var resourceIdentifier: Swift.String?

    public init(
        policy: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil
    ) {
        self.policy = policy
        self.resourceIdentifier = resourceIdentifier
    }
}

public struct PutAuthPolicyOutput: Swift.Sendable {
    /// The auth policy. The policy string in JSON must not contain newlines or blank lines.
    public var policy: Swift.String?
    /// The state of the auth policy. The auth policy is only active when the auth type is set to AWS_IAM. If you provide a policy, then authentication and authorization decisions are made based on this policy and the client's IAM policy. If the Auth type is NONE, then, any auth policy that you provide remains inactive. For more information, see [Create a service network](https://docs.aws.amazon.com/vpc-lattice/latest/ug/service-networks.html#create-service-network) in the Amazon VPC Lattice User Guide.
    public var state: VPCLatticeClientTypes.AuthPolicyState?

    public init(
        policy: Swift.String? = nil,
        state: VPCLatticeClientTypes.AuthPolicyState? = nil
    ) {
        self.policy = policy
        self.state = state
    }
}

public struct PutResourcePolicyInput: Swift.Sendable {
    /// An IAM policy. The policy string in JSON must not contain newlines or blank lines.
    /// This member is required.
    public var policy: Swift.String?
    /// The ID or ARN of the service network or service for which the policy is created.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        policy: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    ) {
        self.policy = policy
        self.resourceArn = resourceArn
    }
}

public struct PutResourcePolicyOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateResourceConfigurationInput: Swift.Sendable {
    /// Indicates whether to add the resource configuration to service networks that are shared with other accounts.
    public var allowAssociationToShareableServiceNetwork: Swift.Bool?
    /// The TCP port ranges that a consumer can use to access a resource configuration. You can separate port ranges with a comma. Example: 1-65535 or 1,2,22-30
    public var portRanges: [Swift.String]?
    /// The resource configuration.
    public var resourceConfigurationDefinition: VPCLatticeClientTypes.ResourceConfigurationDefinition?
    /// The ID of the resource configuration.
    /// This member is required.
    public var resourceConfigurationIdentifier: Swift.String?

    public init(
        allowAssociationToShareableServiceNetwork: Swift.Bool? = nil,
        portRanges: [Swift.String]? = nil,
        resourceConfigurationDefinition: VPCLatticeClientTypes.ResourceConfigurationDefinition? = nil,
        resourceConfigurationIdentifier: Swift.String? = nil
    ) {
        self.allowAssociationToShareableServiceNetwork = allowAssociationToShareableServiceNetwork
        self.portRanges = portRanges
        self.resourceConfigurationDefinition = resourceConfigurationDefinition
        self.resourceConfigurationIdentifier = resourceConfigurationIdentifier
    }
}

public struct UpdateResourceConfigurationOutput: Swift.Sendable {
    /// Indicates whether to add the resource configuration to service networks that are shared with other accounts.
    public var allowAssociationToShareableServiceNetwork: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the resource configuration.
    public var arn: Swift.String?
    /// The ID of the resource configuration.
    public var id: Swift.String?
    /// The name of the resource configuration.
    public var name: Swift.String?
    /// The TCP port ranges that a consumer can use to access a resource configuration. You can separate port ranges with a comma. Example: 1-65535 or 1,2,22-30
    public var portRanges: [Swift.String]?
    /// The TCP protocol accepted by the specified resource configuration.
    public var `protocol`: VPCLatticeClientTypes.ProtocolType?
    /// The resource configuration.
    public var resourceConfigurationDefinition: VPCLatticeClientTypes.ResourceConfigurationDefinition?
    /// The ID of the group resource configuration.
    public var resourceConfigurationGroupId: Swift.String?
    /// The ID of the resource gateway associated with the resource configuration.
    public var resourceGatewayId: Swift.String?
    /// The status of the resource configuration.
    public var status: VPCLatticeClientTypes.ResourceConfigurationStatus?
    /// The type of resource configuration.
    ///
    /// * SINGLE - A single resource.
    ///
    /// * GROUP - A group of resources.
    ///
    /// * CHILD - A single resource that is part of a group resource configuration.
    ///
    /// * ARN - An Amazon Web Services resource.
    public var type: VPCLatticeClientTypes.ResourceConfigurationType?

    public init(
        allowAssociationToShareableServiceNetwork: Swift.Bool? = nil,
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        portRanges: [Swift.String]? = nil,
        `protocol`: VPCLatticeClientTypes.ProtocolType? = nil,
        resourceConfigurationDefinition: VPCLatticeClientTypes.ResourceConfigurationDefinition? = nil,
        resourceConfigurationGroupId: Swift.String? = nil,
        resourceGatewayId: Swift.String? = nil,
        status: VPCLatticeClientTypes.ResourceConfigurationStatus? = nil,
        type: VPCLatticeClientTypes.ResourceConfigurationType? = nil
    ) {
        self.allowAssociationToShareableServiceNetwork = allowAssociationToShareableServiceNetwork
        self.arn = arn
        self.id = id
        self.name = name
        self.portRanges = portRanges
        self.`protocol` = `protocol`
        self.resourceConfigurationDefinition = resourceConfigurationDefinition
        self.resourceConfigurationGroupId = resourceConfigurationGroupId
        self.resourceGatewayId = resourceGatewayId
        self.status = status
        self.type = type
    }
}

public struct UpdateResourceGatewayInput: Swift.Sendable {
    /// The ID or ARN of the resource gateway.
    /// This member is required.
    public var resourceGatewayIdentifier: Swift.String?
    /// The IDs of the security groups associated with the resource gateway.
    public var securityGroupIds: [Swift.String]?

    public init(
        resourceGatewayIdentifier: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil
    ) {
        self.resourceGatewayIdentifier = resourceGatewayIdentifier
        self.securityGroupIds = securityGroupIds
    }
}

public struct UpdateResourceGatewayOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource gateway.
    public var arn: Swift.String?
    /// The ID of the resource gateway.
    public var id: Swift.String?
    /// The type of IP address used by the resource gateway.
    public var ipAddressType: VPCLatticeClientTypes.IpAddressType?
    /// The name of the resource gateway.
    public var name: Swift.String?
    /// The IDs of the security groups associated with the resource gateway.
    public var securityGroupIds: [Swift.String]?
    /// The status of the resource gateway.
    public var status: VPCLatticeClientTypes.ResourceGatewayStatus?
    /// The IDs of the VPC subnets for the resource gateway.
    public var subnetIds: [Swift.String]?
    /// The ID of the VPC for the resource gateway.
    public var vpcId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        ipAddressType: VPCLatticeClientTypes.IpAddressType? = nil,
        name: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        status: VPCLatticeClientTypes.ResourceGatewayStatus? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcId: Swift.String? = nil
    ) {
        self.arn = arn
        self.id = id
        self.ipAddressType = ipAddressType
        self.name = name
        self.securityGroupIds = securityGroupIds
        self.status = status
        self.subnetIds = subnetIds
        self.vpcId = vpcId
    }
}

public struct UpdateRuleInput: Swift.Sendable {
    /// Information about the action for the specified listener rule.
    public var action: VPCLatticeClientTypes.RuleAction?
    /// The ID or ARN of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The rule match.
    public var match: VPCLatticeClientTypes.RuleMatch?
    /// The rule priority. A listener can't have multiple rules with the same priority.
    public var priority: Swift.Int?
    /// The ID or ARN of the rule.
    /// This member is required.
    public var ruleIdentifier: Swift.String?
    /// The ID or ARN of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        action: VPCLatticeClientTypes.RuleAction? = nil,
        listenerIdentifier: Swift.String? = nil,
        match: VPCLatticeClientTypes.RuleMatch? = nil,
        priority: Swift.Int? = nil,
        ruleIdentifier: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    ) {
        self.action = action
        self.listenerIdentifier = listenerIdentifier
        self.match = match
        self.priority = priority
        self.ruleIdentifier = ruleIdentifier
        self.serviceIdentifier = serviceIdentifier
    }
}

public struct UpdateRuleOutput: Swift.Sendable {
    /// Information about the action for the specified listener rule.
    public var action: VPCLatticeClientTypes.RuleAction?
    /// The Amazon Resource Name (ARN) of the listener.
    public var arn: Swift.String?
    /// The ID of the listener.
    public var id: Swift.String?
    /// Indicates whether this is the default rule.
    public var isDefault: Swift.Bool?
    /// The rule match.
    public var match: VPCLatticeClientTypes.RuleMatch?
    /// The name of the listener.
    public var name: Swift.String?
    /// The rule priority.
    public var priority: Swift.Int?

    public init(
        action: VPCLatticeClientTypes.RuleAction? = nil,
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        isDefault: Swift.Bool? = nil,
        match: VPCLatticeClientTypes.RuleMatch? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil
    ) {
        self.action = action
        self.arn = arn
        self.id = id
        self.isDefault = isDefault
        self.match = match
        self.name = name
        self.priority = priority
    }
}

public struct UpdateServiceInput: Swift.Sendable {
    /// The type of IAM policy.
    ///
    /// * NONE: The resource does not use an IAM policy. This is the default.
    ///
    /// * AWS_IAM: The resource uses an IAM policy. When this type is used, auth is enabled and an auth policy is required.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The Amazon Resource Name (ARN) of the certificate.
    public var certificateArn: Swift.String?
    /// The ID or ARN of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        authType: VPCLatticeClientTypes.AuthType? = nil,
        certificateArn: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    ) {
        self.authType = authType
        self.certificateArn = certificateArn
        self.serviceIdentifier = serviceIdentifier
    }
}

public struct UpdateServiceOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the service.
    public var arn: Swift.String?
    /// The type of IAM policy.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The Amazon Resource Name (ARN) of the certificate.
    public var certificateArn: Swift.String?
    /// The custom domain name of the service.
    public var customDomainName: Swift.String?
    /// The ID of the service.
    public var id: Swift.String?
    /// The name of the service.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        authType: VPCLatticeClientTypes.AuthType? = nil,
        certificateArn: Swift.String? = nil,
        customDomainName: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    ) {
        self.arn = arn
        self.authType = authType
        self.certificateArn = certificateArn
        self.customDomainName = customDomainName
        self.id = id
        self.name = name
    }
}

public struct UpdateServiceNetworkInput: Swift.Sendable {
    /// The type of IAM policy.
    ///
    /// * NONE: The resource does not use an IAM policy. This is the default.
    ///
    /// * AWS_IAM: The resource uses an IAM policy. When this type is used, auth is enabled and an auth policy is required.
    /// This member is required.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The ID or ARN of the service network.
    /// This member is required.
    public var serviceNetworkIdentifier: Swift.String?

    public init(
        authType: VPCLatticeClientTypes.AuthType? = nil,
        serviceNetworkIdentifier: Swift.String? = nil
    ) {
        self.authType = authType
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
    }
}

public struct UpdateServiceNetworkOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the service network.
    public var arn: Swift.String?
    /// The type of IAM policy.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The ID of the service network.
    public var id: Swift.String?
    /// The name of the service network.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        authType: VPCLatticeClientTypes.AuthType? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    ) {
        self.arn = arn
        self.authType = authType
        self.id = id
        self.name = name
    }
}

public struct UpdateServiceNetworkVpcAssociationInput: Swift.Sendable {
    /// The IDs of the security groups.
    /// This member is required.
    public var securityGroupIds: [Swift.String]?
    /// The ID or ARN of the association.
    /// This member is required.
    public var serviceNetworkVpcAssociationIdentifier: Swift.String?

    public init(
        securityGroupIds: [Swift.String]? = nil,
        serviceNetworkVpcAssociationIdentifier: Swift.String? = nil
    ) {
        self.securityGroupIds = securityGroupIds
        self.serviceNetworkVpcAssociationIdentifier = serviceNetworkVpcAssociationIdentifier
    }
}

public struct UpdateServiceNetworkVpcAssociationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The account that created the association.
    public var createdBy: Swift.String?
    /// The ID of the association.
    public var id: Swift.String?
    /// The IDs of the security groups.
    public var securityGroupIds: [Swift.String]?
    /// The status. You can retry the operation if the status is DELETE_FAILED. However, if you retry it while the status is DELETE_IN_PROGRESS, there is no change in the status.
    public var status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus?

    public init(
        arn: Swift.String? = nil,
        createdBy: Swift.String? = nil,
        id: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus? = nil
    ) {
        self.arn = arn
        self.createdBy = createdBy
        self.id = id
        self.securityGroupIds = securityGroupIds
        self.status = status
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags for the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct RegisterTargetsInput: Swift.Sendable {
    /// The ID or ARN of the target group.
    /// This member is required.
    public var targetGroupIdentifier: Swift.String?
    /// The targets.
    /// This member is required.
    public var targets: [VPCLatticeClientTypes.Target]?

    public init(
        targetGroupIdentifier: Swift.String? = nil,
        targets: [VPCLatticeClientTypes.Target]? = nil
    ) {
        self.targetGroupIdentifier = targetGroupIdentifier
        self.targets = targets
    }
}

public struct RegisterTargetsOutput: Swift.Sendable {
    /// The targets that were successfully registered.
    public var successful: [VPCLatticeClientTypes.Target]?
    /// The targets that were not registered.
    public var unsuccessful: [VPCLatticeClientTypes.TargetFailure]?

    public init(
        successful: [VPCLatticeClientTypes.Target]? = nil,
        unsuccessful: [VPCLatticeClientTypes.TargetFailure]? = nil
    ) {
        self.successful = successful
        self.unsuccessful = unsuccessful
    }
}

public struct UpdateTargetGroupInput: Swift.Sendable {
    /// The health check configuration.
    /// This member is required.
    public var healthCheck: VPCLatticeClientTypes.HealthCheckConfig?
    /// The ID or ARN of the target group.
    /// This member is required.
    public var targetGroupIdentifier: Swift.String?

    public init(
        healthCheck: VPCLatticeClientTypes.HealthCheckConfig? = nil,
        targetGroupIdentifier: Swift.String? = nil
    ) {
        self.healthCheck = healthCheck
        self.targetGroupIdentifier = targetGroupIdentifier
    }
}

public struct UpdateTargetGroupOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the target group.
    public var arn: Swift.String?
    /// The target group configuration.
    public var config: VPCLatticeClientTypes.TargetGroupConfig?
    /// The ID of the target group.
    public var id: Swift.String?
    /// The name of the target group.
    public var name: Swift.String?
    /// The status.
    public var status: VPCLatticeClientTypes.TargetGroupStatus?
    /// The target group type.
    public var type: VPCLatticeClientTypes.TargetGroupType?

    public init(
        arn: Swift.String? = nil,
        config: VPCLatticeClientTypes.TargetGroupConfig? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: VPCLatticeClientTypes.TargetGroupStatus? = nil,
        type: VPCLatticeClientTypes.TargetGroupType? = nil
    ) {
        self.arn = arn
        self.config = config
        self.id = id
        self.name = name
        self.status = status
        self.type = type
    }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys of the tags to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension BatchUpdateRuleInput {

    static func urlPathProvider(_ value: BatchUpdateRuleInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = value.listenerIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())/rules"
    }
}

extension CreateAccessLogSubscriptionInput {

    static func urlPathProvider(_ value: CreateAccessLogSubscriptionInput) -> Swift.String? {
        return "/accesslogsubscriptions"
    }
}

extension CreateListenerInput {

    static func urlPathProvider(_ value: CreateListenerInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners"
    }
}

extension CreateResourceConfigurationInput {

    static func urlPathProvider(_ value: CreateResourceConfigurationInput) -> Swift.String? {
        return "/resourceconfigurations"
    }
}

extension CreateResourceGatewayInput {

    static func urlPathProvider(_ value: CreateResourceGatewayInput) -> Swift.String? {
        return "/resourcegateways"
    }
}

extension CreateRuleInput {

    static func urlPathProvider(_ value: CreateRuleInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = value.listenerIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())/rules"
    }
}

extension CreateServiceInput {

    static func urlPathProvider(_ value: CreateServiceInput) -> Swift.String? {
        return "/services"
    }
}

extension CreateServiceNetworkInput {

    static func urlPathProvider(_ value: CreateServiceNetworkInput) -> Swift.String? {
        return "/servicenetworks"
    }
}

extension CreateServiceNetworkResourceAssociationInput {

    static func urlPathProvider(_ value: CreateServiceNetworkResourceAssociationInput) -> Swift.String? {
        return "/servicenetworkresourceassociations"
    }
}

extension CreateServiceNetworkServiceAssociationInput {

    static func urlPathProvider(_ value: CreateServiceNetworkServiceAssociationInput) -> Swift.String? {
        return "/servicenetworkserviceassociations"
    }
}

extension CreateServiceNetworkVpcAssociationInput {

    static func urlPathProvider(_ value: CreateServiceNetworkVpcAssociationInput) -> Swift.String? {
        return "/servicenetworkvpcassociations"
    }
}

extension CreateTargetGroupInput {

    static func urlPathProvider(_ value: CreateTargetGroupInput) -> Swift.String? {
        return "/targetgroups"
    }
}

extension DeleteAccessLogSubscriptionInput {

    static func urlPathProvider(_ value: DeleteAccessLogSubscriptionInput) -> Swift.String? {
        guard let accessLogSubscriptionIdentifier = value.accessLogSubscriptionIdentifier else {
            return nil
        }
        return "/accesslogsubscriptions/\(accessLogSubscriptionIdentifier.urlPercentEncoding())"
    }
}

extension DeleteAuthPolicyInput {

    static func urlPathProvider(_ value: DeleteAuthPolicyInput) -> Swift.String? {
        guard let resourceIdentifier = value.resourceIdentifier else {
            return nil
        }
        return "/authpolicy/\(resourceIdentifier.urlPercentEncoding())"
    }
}

extension DeleteListenerInput {

    static func urlPathProvider(_ value: DeleteListenerInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = value.listenerIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())"
    }
}

extension DeleteResourceConfigurationInput {

    static func urlPathProvider(_ value: DeleteResourceConfigurationInput) -> Swift.String? {
        guard let resourceConfigurationIdentifier = value.resourceConfigurationIdentifier else {
            return nil
        }
        return "/resourceconfigurations/\(resourceConfigurationIdentifier.urlPercentEncoding())"
    }
}

extension DeleteResourceEndpointAssociationInput {

    static func urlPathProvider(_ value: DeleteResourceEndpointAssociationInput) -> Swift.String? {
        guard let resourceEndpointAssociationIdentifier = value.resourceEndpointAssociationIdentifier else {
            return nil
        }
        return "/resourceendpointassociations/\(resourceEndpointAssociationIdentifier.urlPercentEncoding())"
    }
}

extension DeleteResourceGatewayInput {

    static func urlPathProvider(_ value: DeleteResourceGatewayInput) -> Swift.String? {
        guard let resourceGatewayIdentifier = value.resourceGatewayIdentifier else {
            return nil
        }
        return "/resourcegateways/\(resourceGatewayIdentifier.urlPercentEncoding())"
    }
}

extension DeleteResourcePolicyInput {

    static func urlPathProvider(_ value: DeleteResourcePolicyInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/resourcepolicy/\(resourceArn.urlPercentEncoding())"
    }
}

extension DeleteRuleInput {

    static func urlPathProvider(_ value: DeleteRuleInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = value.listenerIdentifier else {
            return nil
        }
        guard let ruleIdentifier = value.ruleIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())/rules/\(ruleIdentifier.urlPercentEncoding())"
    }
}

extension DeleteServiceInput {

    static func urlPathProvider(_ value: DeleteServiceInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())"
    }
}

extension DeleteServiceNetworkInput {

    static func urlPathProvider(_ value: DeleteServiceNetworkInput) -> Swift.String? {
        guard let serviceNetworkIdentifier = value.serviceNetworkIdentifier else {
            return nil
        }
        return "/servicenetworks/\(serviceNetworkIdentifier.urlPercentEncoding())"
    }
}

extension DeleteServiceNetworkResourceAssociationInput {

    static func urlPathProvider(_ value: DeleteServiceNetworkResourceAssociationInput) -> Swift.String? {
        guard let serviceNetworkResourceAssociationIdentifier = value.serviceNetworkResourceAssociationIdentifier else {
            return nil
        }
        return "/servicenetworkresourceassociations/\(serviceNetworkResourceAssociationIdentifier.urlPercentEncoding())"
    }
}

extension DeleteServiceNetworkServiceAssociationInput {

    static func urlPathProvider(_ value: DeleteServiceNetworkServiceAssociationInput) -> Swift.String? {
        guard let serviceNetworkServiceAssociationIdentifier = value.serviceNetworkServiceAssociationIdentifier else {
            return nil
        }
        return "/servicenetworkserviceassociations/\(serviceNetworkServiceAssociationIdentifier.urlPercentEncoding())"
    }
}

extension DeleteServiceNetworkVpcAssociationInput {

    static func urlPathProvider(_ value: DeleteServiceNetworkVpcAssociationInput) -> Swift.String? {
        guard let serviceNetworkVpcAssociationIdentifier = value.serviceNetworkVpcAssociationIdentifier else {
            return nil
        }
        return "/servicenetworkvpcassociations/\(serviceNetworkVpcAssociationIdentifier.urlPercentEncoding())"
    }
}

extension DeleteTargetGroupInput {

    static func urlPathProvider(_ value: DeleteTargetGroupInput) -> Swift.String? {
        guard let targetGroupIdentifier = value.targetGroupIdentifier else {
            return nil
        }
        return "/targetgroups/\(targetGroupIdentifier.urlPercentEncoding())"
    }
}

extension DeregisterTargetsInput {

    static func urlPathProvider(_ value: DeregisterTargetsInput) -> Swift.String? {
        guard let targetGroupIdentifier = value.targetGroupIdentifier else {
            return nil
        }
        return "/targetgroups/\(targetGroupIdentifier.urlPercentEncoding())/deregistertargets"
    }
}

extension GetAccessLogSubscriptionInput {

    static func urlPathProvider(_ value: GetAccessLogSubscriptionInput) -> Swift.String? {
        guard let accessLogSubscriptionIdentifier = value.accessLogSubscriptionIdentifier else {
            return nil
        }
        return "/accesslogsubscriptions/\(accessLogSubscriptionIdentifier.urlPercentEncoding())"
    }
}

extension GetAuthPolicyInput {

    static func urlPathProvider(_ value: GetAuthPolicyInput) -> Swift.String? {
        guard let resourceIdentifier = value.resourceIdentifier else {
            return nil
        }
        return "/authpolicy/\(resourceIdentifier.urlPercentEncoding())"
    }
}

extension GetListenerInput {

    static func urlPathProvider(_ value: GetListenerInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = value.listenerIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())"
    }
}

extension GetResourceConfigurationInput {

    static func urlPathProvider(_ value: GetResourceConfigurationInput) -> Swift.String? {
        guard let resourceConfigurationIdentifier = value.resourceConfigurationIdentifier else {
            return nil
        }
        return "/resourceconfigurations/\(resourceConfigurationIdentifier.urlPercentEncoding())"
    }
}

extension GetResourceGatewayInput {

    static func urlPathProvider(_ value: GetResourceGatewayInput) -> Swift.String? {
        guard let resourceGatewayIdentifier = value.resourceGatewayIdentifier else {
            return nil
        }
        return "/resourcegateways/\(resourceGatewayIdentifier.urlPercentEncoding())"
    }
}

extension GetResourcePolicyInput {

    static func urlPathProvider(_ value: GetResourcePolicyInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/resourcepolicy/\(resourceArn.urlPercentEncoding())"
    }
}

extension GetRuleInput {

    static func urlPathProvider(_ value: GetRuleInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = value.listenerIdentifier else {
            return nil
        }
        guard let ruleIdentifier = value.ruleIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())/rules/\(ruleIdentifier.urlPercentEncoding())"
    }
}

extension GetServiceInput {

    static func urlPathProvider(_ value: GetServiceInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())"
    }
}

extension GetServiceNetworkInput {

    static func urlPathProvider(_ value: GetServiceNetworkInput) -> Swift.String? {
        guard let serviceNetworkIdentifier = value.serviceNetworkIdentifier else {
            return nil
        }
        return "/servicenetworks/\(serviceNetworkIdentifier.urlPercentEncoding())"
    }
}

extension GetServiceNetworkResourceAssociationInput {

    static func urlPathProvider(_ value: GetServiceNetworkResourceAssociationInput) -> Swift.String? {
        guard let serviceNetworkResourceAssociationIdentifier = value.serviceNetworkResourceAssociationIdentifier else {
            return nil
        }
        return "/servicenetworkresourceassociations/\(serviceNetworkResourceAssociationIdentifier.urlPercentEncoding())"
    }
}

extension GetServiceNetworkServiceAssociationInput {

    static func urlPathProvider(_ value: GetServiceNetworkServiceAssociationInput) -> Swift.String? {
        guard let serviceNetworkServiceAssociationIdentifier = value.serviceNetworkServiceAssociationIdentifier else {
            return nil
        }
        return "/servicenetworkserviceassociations/\(serviceNetworkServiceAssociationIdentifier.urlPercentEncoding())"
    }
}

extension GetServiceNetworkVpcAssociationInput {

    static func urlPathProvider(_ value: GetServiceNetworkVpcAssociationInput) -> Swift.String? {
        guard let serviceNetworkVpcAssociationIdentifier = value.serviceNetworkVpcAssociationIdentifier else {
            return nil
        }
        return "/servicenetworkvpcassociations/\(serviceNetworkVpcAssociationIdentifier.urlPercentEncoding())"
    }
}

extension GetTargetGroupInput {

    static func urlPathProvider(_ value: GetTargetGroupInput) -> Swift.String? {
        guard let targetGroupIdentifier = value.targetGroupIdentifier else {
            return nil
        }
        return "/targetgroups/\(targetGroupIdentifier.urlPercentEncoding())"
    }
}

extension ListAccessLogSubscriptionsInput {

    static func urlPathProvider(_ value: ListAccessLogSubscriptionsInput) -> Swift.String? {
        return "/accesslogsubscriptions"
    }
}

extension ListAccessLogSubscriptionsInput {

    static func queryItemProvider(_ value: ListAccessLogSubscriptionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let resourceIdentifier = value.resourceIdentifier else {
            let message = "Creating a URL Query Item failed. resourceIdentifier is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceIdentifierQueryItem = Smithy.URIQueryItem(name: "resourceIdentifier".urlPercentEncoding(), value: Swift.String(resourceIdentifier).urlPercentEncoding())
        items.append(resourceIdentifierQueryItem)
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListListenersInput {

    static func urlPathProvider(_ value: ListListenersInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners"
    }
}

extension ListListenersInput {

    static func queryItemProvider(_ value: ListListenersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListResourceConfigurationsInput {

    static func urlPathProvider(_ value: ListResourceConfigurationsInput) -> Swift.String? {
        return "/resourceconfigurations"
    }
}

extension ListResourceConfigurationsInput {

    static func queryItemProvider(_ value: ListResourceConfigurationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let resourceConfigurationGroupIdentifier = value.resourceConfigurationGroupIdentifier {
            let resourceConfigurationGroupIdentifierQueryItem = Smithy.URIQueryItem(name: "resourceConfigurationGroupIdentifier".urlPercentEncoding(), value: Swift.String(resourceConfigurationGroupIdentifier).urlPercentEncoding())
            items.append(resourceConfigurationGroupIdentifierQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let resourceGatewayIdentifier = value.resourceGatewayIdentifier {
            let resourceGatewayIdentifierQueryItem = Smithy.URIQueryItem(name: "resourceGatewayIdentifier".urlPercentEncoding(), value: Swift.String(resourceGatewayIdentifier).urlPercentEncoding())
            items.append(resourceGatewayIdentifierQueryItem)
        }
        return items
    }
}

extension ListResourceEndpointAssociationsInput {

    static func urlPathProvider(_ value: ListResourceEndpointAssociationsInput) -> Swift.String? {
        return "/resourceendpointassociations"
    }
}

extension ListResourceEndpointAssociationsInput {

    static func queryItemProvider(_ value: ListResourceEndpointAssociationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let vpcEndpointOwner = value.vpcEndpointOwner {
            let vpcEndpointOwnerQueryItem = Smithy.URIQueryItem(name: "vpcEndpointOwner".urlPercentEncoding(), value: Swift.String(vpcEndpointOwner).urlPercentEncoding())
            items.append(vpcEndpointOwnerQueryItem)
        }
        if let resourceEndpointAssociationIdentifier = value.resourceEndpointAssociationIdentifier {
            let resourceEndpointAssociationIdentifierQueryItem = Smithy.URIQueryItem(name: "resourceEndpointAssociationIdentifier".urlPercentEncoding(), value: Swift.String(resourceEndpointAssociationIdentifier).urlPercentEncoding())
            items.append(resourceEndpointAssociationIdentifierQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        guard let resourceConfigurationIdentifier = value.resourceConfigurationIdentifier else {
            let message = "Creating a URL Query Item failed. resourceConfigurationIdentifier is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceConfigurationIdentifierQueryItem = Smithy.URIQueryItem(name: "resourceConfigurationIdentifier".urlPercentEncoding(), value: Swift.String(resourceConfigurationIdentifier).urlPercentEncoding())
        items.append(resourceConfigurationIdentifierQueryItem)
        if let vpcEndpointId = value.vpcEndpointId {
            let vpcEndpointIdQueryItem = Smithy.URIQueryItem(name: "vpcEndpointId".urlPercentEncoding(), value: Swift.String(vpcEndpointId).urlPercentEncoding())
            items.append(vpcEndpointIdQueryItem)
        }
        return items
    }
}

extension ListResourceGatewaysInput {

    static func urlPathProvider(_ value: ListResourceGatewaysInput) -> Swift.String? {
        return "/resourcegateways"
    }
}

extension ListResourceGatewaysInput {

    static func queryItemProvider(_ value: ListResourceGatewaysInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListRulesInput {

    static func urlPathProvider(_ value: ListRulesInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = value.listenerIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())/rules"
    }
}

extension ListRulesInput {

    static func queryItemProvider(_ value: ListRulesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListServiceNetworkResourceAssociationsInput {

    static func urlPathProvider(_ value: ListServiceNetworkResourceAssociationsInput) -> Swift.String? {
        return "/servicenetworkresourceassociations"
    }
}

extension ListServiceNetworkResourceAssociationsInput {

    static func queryItemProvider(_ value: ListServiceNetworkResourceAssociationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let serviceNetworkIdentifier = value.serviceNetworkIdentifier {
            let serviceNetworkIdentifierQueryItem = Smithy.URIQueryItem(name: "serviceNetworkIdentifier".urlPercentEncoding(), value: Swift.String(serviceNetworkIdentifier).urlPercentEncoding())
            items.append(serviceNetworkIdentifierQueryItem)
        }
        if let resourceConfigurationIdentifier = value.resourceConfigurationIdentifier {
            let resourceConfigurationIdentifierQueryItem = Smithy.URIQueryItem(name: "resourceConfigurationIdentifier".urlPercentEncoding(), value: Swift.String(resourceConfigurationIdentifier).urlPercentEncoding())
            items.append(resourceConfigurationIdentifierQueryItem)
        }
        return items
    }
}

extension ListServiceNetworksInput {

    static func urlPathProvider(_ value: ListServiceNetworksInput) -> Swift.String? {
        return "/servicenetworks"
    }
}

extension ListServiceNetworksInput {

    static func queryItemProvider(_ value: ListServiceNetworksInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListServiceNetworkServiceAssociationsInput {

    static func urlPathProvider(_ value: ListServiceNetworkServiceAssociationsInput) -> Swift.String? {
        return "/servicenetworkserviceassociations"
    }
}

extension ListServiceNetworkServiceAssociationsInput {

    static func queryItemProvider(_ value: ListServiceNetworkServiceAssociationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let serviceNetworkIdentifier = value.serviceNetworkIdentifier {
            let serviceNetworkIdentifierQueryItem = Smithy.URIQueryItem(name: "serviceNetworkIdentifier".urlPercentEncoding(), value: Swift.String(serviceNetworkIdentifier).urlPercentEncoding())
            items.append(serviceNetworkIdentifierQueryItem)
        }
        if let serviceIdentifier = value.serviceIdentifier {
            let serviceIdentifierQueryItem = Smithy.URIQueryItem(name: "serviceIdentifier".urlPercentEncoding(), value: Swift.String(serviceIdentifier).urlPercentEncoding())
            items.append(serviceIdentifierQueryItem)
        }
        return items
    }
}

extension ListServiceNetworkVpcAssociationsInput {

    static func urlPathProvider(_ value: ListServiceNetworkVpcAssociationsInput) -> Swift.String? {
        return "/servicenetworkvpcassociations"
    }
}

extension ListServiceNetworkVpcAssociationsInput {

    static func queryItemProvider(_ value: ListServiceNetworkVpcAssociationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let serviceNetworkIdentifier = value.serviceNetworkIdentifier {
            let serviceNetworkIdentifierQueryItem = Smithy.URIQueryItem(name: "serviceNetworkIdentifier".urlPercentEncoding(), value: Swift.String(serviceNetworkIdentifier).urlPercentEncoding())
            items.append(serviceNetworkIdentifierQueryItem)
        }
        if let vpcIdentifier = value.vpcIdentifier {
            let vpcIdentifierQueryItem = Smithy.URIQueryItem(name: "vpcIdentifier".urlPercentEncoding(), value: Swift.String(vpcIdentifier).urlPercentEncoding())
            items.append(vpcIdentifierQueryItem)
        }
        return items
    }
}

extension ListServiceNetworkVpcEndpointAssociationsInput {

    static func urlPathProvider(_ value: ListServiceNetworkVpcEndpointAssociationsInput) -> Swift.String? {
        return "/servicenetworkvpcendpointassociations"
    }
}

extension ListServiceNetworkVpcEndpointAssociationsInput {

    static func queryItemProvider(_ value: ListServiceNetworkVpcEndpointAssociationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        guard let serviceNetworkIdentifier = value.serviceNetworkIdentifier else {
            let message = "Creating a URL Query Item failed. serviceNetworkIdentifier is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let serviceNetworkIdentifierQueryItem = Smithy.URIQueryItem(name: "serviceNetworkIdentifier".urlPercentEncoding(), value: Swift.String(serviceNetworkIdentifier).urlPercentEncoding())
        items.append(serviceNetworkIdentifierQueryItem)
        return items
    }
}

extension ListServicesInput {

    static func urlPathProvider(_ value: ListServicesInput) -> Swift.String? {
        return "/services"
    }
}

extension ListServicesInput {

    static func queryItemProvider(_ value: ListServicesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension ListTargetGroupsInput {

    static func urlPathProvider(_ value: ListTargetGroupsInput) -> Swift.String? {
        return "/targetgroups"
    }
}

extension ListTargetGroupsInput {

    static func queryItemProvider(_ value: ListTargetGroupsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let vpcIdentifier = value.vpcIdentifier {
            let vpcIdentifierQueryItem = Smithy.URIQueryItem(name: "vpcIdentifier".urlPercentEncoding(), value: Swift.String(vpcIdentifier).urlPercentEncoding())
            items.append(vpcIdentifierQueryItem)
        }
        if let targetGroupType = value.targetGroupType {
            let targetGroupTypeQueryItem = Smithy.URIQueryItem(name: "targetGroupType".urlPercentEncoding(), value: Swift.String(targetGroupType.rawValue).urlPercentEncoding())
            items.append(targetGroupTypeQueryItem)
        }
        return items
    }
}

extension ListTargetsInput {

    static func urlPathProvider(_ value: ListTargetsInput) -> Swift.String? {
        guard let targetGroupIdentifier = value.targetGroupIdentifier else {
            return nil
        }
        return "/targetgroups/\(targetGroupIdentifier.urlPercentEncoding())/listtargets"
    }
}

extension ListTargetsInput {

    static func queryItemProvider(_ value: ListTargetsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension PutAuthPolicyInput {

    static func urlPathProvider(_ value: PutAuthPolicyInput) -> Swift.String? {
        guard let resourceIdentifier = value.resourceIdentifier else {
            return nil
        }
        return "/authpolicy/\(resourceIdentifier.urlPercentEncoding())"
    }
}

extension PutResourcePolicyInput {

    static func urlPathProvider(_ value: PutResourcePolicyInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/resourcepolicy/\(resourceArn.urlPercentEncoding())"
    }
}

extension RegisterTargetsInput {

    static func urlPathProvider(_ value: RegisterTargetsInput) -> Swift.String? {
        guard let targetGroupIdentifier = value.targetGroupIdentifier else {
            return nil
        }
        return "/targetgroups/\(targetGroupIdentifier.urlPercentEncoding())/registertargets"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateAccessLogSubscriptionInput {

    static func urlPathProvider(_ value: UpdateAccessLogSubscriptionInput) -> Swift.String? {
        guard let accessLogSubscriptionIdentifier = value.accessLogSubscriptionIdentifier else {
            return nil
        }
        return "/accesslogsubscriptions/\(accessLogSubscriptionIdentifier.urlPercentEncoding())"
    }
}

extension UpdateListenerInput {

    static func urlPathProvider(_ value: UpdateListenerInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = value.listenerIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())"
    }
}

extension UpdateResourceConfigurationInput {

    static func urlPathProvider(_ value: UpdateResourceConfigurationInput) -> Swift.String? {
        guard let resourceConfigurationIdentifier = value.resourceConfigurationIdentifier else {
            return nil
        }
        return "/resourceconfigurations/\(resourceConfigurationIdentifier.urlPercentEncoding())"
    }
}

extension UpdateResourceGatewayInput {

    static func urlPathProvider(_ value: UpdateResourceGatewayInput) -> Swift.String? {
        guard let resourceGatewayIdentifier = value.resourceGatewayIdentifier else {
            return nil
        }
        return "/resourcegateways/\(resourceGatewayIdentifier.urlPercentEncoding())"
    }
}

extension UpdateRuleInput {

    static func urlPathProvider(_ value: UpdateRuleInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = value.listenerIdentifier else {
            return nil
        }
        guard let ruleIdentifier = value.ruleIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())/rules/\(ruleIdentifier.urlPercentEncoding())"
    }
}

extension UpdateServiceInput {

    static func urlPathProvider(_ value: UpdateServiceInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())"
    }
}

extension UpdateServiceNetworkInput {

    static func urlPathProvider(_ value: UpdateServiceNetworkInput) -> Swift.String? {
        guard let serviceNetworkIdentifier = value.serviceNetworkIdentifier else {
            return nil
        }
        return "/servicenetworks/\(serviceNetworkIdentifier.urlPercentEncoding())"
    }
}

extension UpdateServiceNetworkVpcAssociationInput {

    static func urlPathProvider(_ value: UpdateServiceNetworkVpcAssociationInput) -> Swift.String? {
        guard let serviceNetworkVpcAssociationIdentifier = value.serviceNetworkVpcAssociationIdentifier else {
            return nil
        }
        return "/servicenetworkvpcassociations/\(serviceNetworkVpcAssociationIdentifier.urlPercentEncoding())"
    }
}

extension UpdateTargetGroupInput {

    static func urlPathProvider(_ value: UpdateTargetGroupInput) -> Swift.String? {
        guard let targetGroupIdentifier = value.targetGroupIdentifier else {
            return nil
        }
        return "/targetgroups/\(targetGroupIdentifier.urlPercentEncoding())"
    }
}

extension BatchUpdateRuleInput {

    static func write(value: BatchUpdateRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["rules"].writeList(value.rules, memberWritingClosure: VPCLatticeClientTypes.RuleUpdate.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateAccessLogSubscriptionInput {

    static func write(value: CreateAccessLogSubscriptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["destinationArn"].write(value.destinationArn)
        try writer["resourceIdentifier"].write(value.resourceIdentifier)
        try writer["serviceNetworkLogType"].write(value.serviceNetworkLogType)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateListenerInput {

    static func write(value: CreateListenerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["defaultAction"].write(value.defaultAction, with: VPCLatticeClientTypes.RuleAction.write(value:to:))
        try writer["name"].write(value.name)
        try writer["port"].write(value.port)
        try writer["protocol"].write(value.`protocol`)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateResourceConfigurationInput {

    static func write(value: CreateResourceConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allowAssociationToShareableServiceNetwork"].write(value.allowAssociationToShareableServiceNetwork)
        try writer["clientToken"].write(value.clientToken)
        try writer["name"].write(value.name)
        try writer["portRanges"].writeList(value.portRanges, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["protocol"].write(value.`protocol`)
        try writer["resourceConfigurationDefinition"].write(value.resourceConfigurationDefinition, with: VPCLatticeClientTypes.ResourceConfigurationDefinition.write(value:to:))
        try writer["resourceConfigurationGroupIdentifier"].write(value.resourceConfigurationGroupIdentifier)
        try writer["resourceGatewayIdentifier"].write(value.resourceGatewayIdentifier)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["type"].write(value.type)
    }
}

extension CreateResourceGatewayInput {

    static func write(value: CreateResourceGatewayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["ipAddressType"].write(value.ipAddressType)
        try writer["name"].write(value.name)
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["vpcIdentifier"].write(value.vpcIdentifier)
    }
}

extension CreateRuleInput {

    static func write(value: CreateRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action, with: VPCLatticeClientTypes.RuleAction.write(value:to:))
        try writer["clientToken"].write(value.clientToken)
        try writer["match"].write(value.match, with: VPCLatticeClientTypes.RuleMatch.write(value:to:))
        try writer["name"].write(value.name)
        try writer["priority"].write(value.priority)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateServiceInput {

    static func write(value: CreateServiceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authType"].write(value.authType)
        try writer["certificateArn"].write(value.certificateArn)
        try writer["clientToken"].write(value.clientToken)
        try writer["customDomainName"].write(value.customDomainName)
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateServiceNetworkInput {

    static func write(value: CreateServiceNetworkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authType"].write(value.authType)
        try writer["clientToken"].write(value.clientToken)
        try writer["name"].write(value.name)
        try writer["sharingConfig"].write(value.sharingConfig, with: VPCLatticeClientTypes.SharingConfig.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateServiceNetworkResourceAssociationInput {

    static func write(value: CreateServiceNetworkResourceAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["resourceConfigurationIdentifier"].write(value.resourceConfigurationIdentifier)
        try writer["serviceNetworkIdentifier"].write(value.serviceNetworkIdentifier)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateServiceNetworkServiceAssociationInput {

    static func write(value: CreateServiceNetworkServiceAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["serviceIdentifier"].write(value.serviceIdentifier)
        try writer["serviceNetworkIdentifier"].write(value.serviceNetworkIdentifier)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateServiceNetworkVpcAssociationInput {

    static func write(value: CreateServiceNetworkVpcAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["serviceNetworkIdentifier"].write(value.serviceNetworkIdentifier)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["vpcIdentifier"].write(value.vpcIdentifier)
    }
}

extension CreateTargetGroupInput {

    static func write(value: CreateTargetGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["config"].write(value.config, with: VPCLatticeClientTypes.TargetGroupConfig.write(value:to:))
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["type"].write(value.type)
    }
}

extension DeregisterTargetsInput {

    static func write(value: DeregisterTargetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["targets"].writeList(value.targets, memberWritingClosure: VPCLatticeClientTypes.Target.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListTargetsInput {

    static func write(value: ListTargetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["targets"].writeList(value.targets, memberWritingClosure: VPCLatticeClientTypes.Target.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PutAuthPolicyInput {

    static func write(value: PutAuthPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["policy"].write(value.policy)
    }
}

extension PutResourcePolicyInput {

    static func write(value: PutResourcePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["policy"].write(value.policy)
    }
}

extension RegisterTargetsInput {

    static func write(value: RegisterTargetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["targets"].writeList(value.targets, memberWritingClosure: VPCLatticeClientTypes.Target.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateAccessLogSubscriptionInput {

    static func write(value: UpdateAccessLogSubscriptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destinationArn"].write(value.destinationArn)
    }
}

extension UpdateListenerInput {

    static func write(value: UpdateListenerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["defaultAction"].write(value.defaultAction, with: VPCLatticeClientTypes.RuleAction.write(value:to:))
    }
}

extension UpdateResourceConfigurationInput {

    static func write(value: UpdateResourceConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allowAssociationToShareableServiceNetwork"].write(value.allowAssociationToShareableServiceNetwork)
        try writer["portRanges"].writeList(value.portRanges, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["resourceConfigurationDefinition"].write(value.resourceConfigurationDefinition, with: VPCLatticeClientTypes.ResourceConfigurationDefinition.write(value:to:))
    }
}

extension UpdateResourceGatewayInput {

    static func write(value: UpdateResourceGatewayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateRuleInput {

    static func write(value: UpdateRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action, with: VPCLatticeClientTypes.RuleAction.write(value:to:))
        try writer["match"].write(value.match, with: VPCLatticeClientTypes.RuleMatch.write(value:to:))
        try writer["priority"].write(value.priority)
    }
}

extension UpdateServiceInput {

    static func write(value: UpdateServiceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authType"].write(value.authType)
        try writer["certificateArn"].write(value.certificateArn)
    }
}

extension UpdateServiceNetworkInput {

    static func write(value: UpdateServiceNetworkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authType"].write(value.authType)
    }
}

extension UpdateServiceNetworkVpcAssociationInput {

    static func write(value: UpdateServiceNetworkVpcAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateTargetGroupInput {

    static func write(value: UpdateTargetGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["healthCheck"].write(value.healthCheck, with: VPCLatticeClientTypes.HealthCheckConfig.write(value:to:))
    }
}

extension BatchUpdateRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchUpdateRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchUpdateRuleOutput()
        value.successful = try reader["successful"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.RuleUpdateSuccess.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.unsuccessful = try reader["unsuccessful"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.RuleUpdateFailure.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateAccessLogSubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAccessLogSubscriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAccessLogSubscriptionOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.destinationArn = try reader["destinationArn"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.resourceArn = try reader["resourceArn"].readIfPresent() ?? ""
        value.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.serviceNetworkLogType = try reader["serviceNetworkLogType"].readIfPresent()
        return value
    }
}

extension CreateListenerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateListenerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateListenerOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.defaultAction = try reader["defaultAction"].readIfPresent(with: VPCLatticeClientTypes.RuleAction.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.port = try reader["port"].readIfPresent()
        value.`protocol` = try reader["protocol"].readIfPresent()
        value.serviceArn = try reader["serviceArn"].readIfPresent()
        value.serviceId = try reader["serviceId"].readIfPresent()
        return value
    }
}

extension CreateResourceConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateResourceConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateResourceConfigurationOutput()
        value.allowAssociationToShareableServiceNetwork = try reader["allowAssociationToShareableServiceNetwork"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.portRanges = try reader["portRanges"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.`protocol` = try reader["protocol"].readIfPresent()
        value.resourceConfigurationDefinition = try reader["resourceConfigurationDefinition"].readIfPresent(with: VPCLatticeClientTypes.ResourceConfigurationDefinition.read(from:))
        value.resourceConfigurationGroupId = try reader["resourceConfigurationGroupId"].readIfPresent()
        value.resourceGatewayId = try reader["resourceGatewayId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension CreateResourceGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateResourceGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateResourceGatewayOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.ipAddressType = try reader["ipAddressType"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcIdentifier = try reader["vpcIdentifier"].readIfPresent()
        return value
    }
}

extension CreateRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRuleOutput()
        value.action = try reader["action"].readIfPresent(with: VPCLatticeClientTypes.RuleAction.read(from:))
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.match = try reader["match"].readIfPresent(with: VPCLatticeClientTypes.RuleMatch.read(from:))
        value.name = try reader["name"].readIfPresent()
        value.priority = try reader["priority"].readIfPresent()
        return value
    }
}

extension CreateServiceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateServiceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateServiceOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.authType = try reader["authType"].readIfPresent()
        value.certificateArn = try reader["certificateArn"].readIfPresent()
        value.customDomainName = try reader["customDomainName"].readIfPresent()
        value.dnsEntry = try reader["dnsEntry"].readIfPresent(with: VPCLatticeClientTypes.DnsEntry.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension CreateServiceNetworkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateServiceNetworkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateServiceNetworkOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.authType = try reader["authType"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.sharingConfig = try reader["sharingConfig"].readIfPresent(with: VPCLatticeClientTypes.SharingConfig.read(from:))
        return value
    }
}

extension CreateServiceNetworkResourceAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateServiceNetworkResourceAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateServiceNetworkResourceAssociationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension CreateServiceNetworkServiceAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateServiceNetworkServiceAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateServiceNetworkServiceAssociationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.customDomainName = try reader["customDomainName"].readIfPresent()
        value.dnsEntry = try reader["dnsEntry"].readIfPresent(with: VPCLatticeClientTypes.DnsEntry.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension CreateServiceNetworkVpcAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateServiceNetworkVpcAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateServiceNetworkVpcAssociationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension CreateTargetGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTargetGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTargetGroupOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.config = try reader["config"].readIfPresent(with: VPCLatticeClientTypes.TargetGroupConfig.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension DeleteAccessLogSubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAccessLogSubscriptionOutput {
        return DeleteAccessLogSubscriptionOutput()
    }
}

extension DeleteAuthPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAuthPolicyOutput {
        return DeleteAuthPolicyOutput()
    }
}

extension DeleteListenerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteListenerOutput {
        return DeleteListenerOutput()
    }
}

extension DeleteResourceConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteResourceConfigurationOutput {
        return DeleteResourceConfigurationOutput()
    }
}

extension DeleteResourceEndpointAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteResourceEndpointAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteResourceEndpointAssociationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.resourceConfigurationArn = try reader["resourceConfigurationArn"].readIfPresent()
        value.resourceConfigurationId = try reader["resourceConfigurationId"].readIfPresent()
        value.vpcEndpointId = try reader["vpcEndpointId"].readIfPresent()
        return value
    }
}

extension DeleteResourceGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteResourceGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteResourceGatewayOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension DeleteResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteResourcePolicyOutput {
        return DeleteResourcePolicyOutput()
    }
}

extension DeleteRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRuleOutput {
        return DeleteRuleOutput()
    }
}

extension DeleteServiceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteServiceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteServiceOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension DeleteServiceNetworkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteServiceNetworkOutput {
        return DeleteServiceNetworkOutput()
    }
}

extension DeleteServiceNetworkResourceAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteServiceNetworkResourceAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteServiceNetworkResourceAssociationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension DeleteServiceNetworkServiceAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteServiceNetworkServiceAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteServiceNetworkServiceAssociationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension DeleteServiceNetworkVpcAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteServiceNetworkVpcAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteServiceNetworkVpcAssociationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension DeleteTargetGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTargetGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteTargetGroupOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension DeregisterTargetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeregisterTargetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeregisterTargetsOutput()
        value.successful = try reader["successful"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.Target.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.unsuccessful = try reader["unsuccessful"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.TargetFailure.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetAccessLogSubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAccessLogSubscriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAccessLogSubscriptionOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.destinationArn = try reader["destinationArn"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.resourceArn = try reader["resourceArn"].readIfPresent() ?? ""
        value.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.serviceNetworkLogType = try reader["serviceNetworkLogType"].readIfPresent()
        return value
    }
}

extension GetAuthPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAuthPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAuthPolicyOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.policy = try reader["policy"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        return value
    }
}

extension GetListenerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetListenerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetListenerOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.defaultAction = try reader["defaultAction"].readIfPresent(with: VPCLatticeClientTypes.RuleAction.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent()
        value.port = try reader["port"].readIfPresent()
        value.`protocol` = try reader["protocol"].readIfPresent()
        value.serviceArn = try reader["serviceArn"].readIfPresent()
        value.serviceId = try reader["serviceId"].readIfPresent()
        return value
    }
}

extension GetResourceConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourceConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourceConfigurationOutput()
        value.allowAssociationToShareableServiceNetwork = try reader["allowAssociationToShareableServiceNetwork"].readIfPresent()
        value.amazonManaged = try reader["amazonManaged"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.customDomainName = try reader["customDomainName"].readIfPresent()
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent()
        value.portRanges = try reader["portRanges"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.`protocol` = try reader["protocol"].readIfPresent()
        value.resourceConfigurationDefinition = try reader["resourceConfigurationDefinition"].readIfPresent(with: VPCLatticeClientTypes.ResourceConfigurationDefinition.read(from:))
        value.resourceConfigurationGroupId = try reader["resourceConfigurationGroupId"].readIfPresent()
        value.resourceGatewayId = try reader["resourceGatewayId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension GetResourceGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourceGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourceGatewayOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.id = try reader["id"].readIfPresent()
        value.ipAddressType = try reader["ipAddressType"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent()
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcId = try reader["vpcId"].readIfPresent()
        return value
    }
}

extension GetResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourcePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourcePolicyOutput()
        value.policy = try reader["policy"].readIfPresent()
        return value
    }
}

extension GetRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRuleOutput()
        value.action = try reader["action"].readIfPresent(with: VPCLatticeClientTypes.RuleAction.read(from:))
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.id = try reader["id"].readIfPresent()
        value.isDefault = try reader["isDefault"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.match = try reader["match"].readIfPresent(with: VPCLatticeClientTypes.RuleMatch.read(from:))
        value.name = try reader["name"].readIfPresent()
        value.priority = try reader["priority"].readIfPresent()
        return value
    }
}

extension GetServiceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetServiceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetServiceOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.authType = try reader["authType"].readIfPresent()
        value.certificateArn = try reader["certificateArn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.customDomainName = try reader["customDomainName"].readIfPresent()
        value.dnsEntry = try reader["dnsEntry"].readIfPresent(with: VPCLatticeClientTypes.DnsEntry.read(from:))
        value.failureCode = try reader["failureCode"].readIfPresent()
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension GetServiceNetworkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetServiceNetworkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetServiceNetworkOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.authType = try reader["authType"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.id = try reader["id"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent()
        value.numberOfAssociatedServices = try reader["numberOfAssociatedServices"].readIfPresent()
        value.numberOfAssociatedVPCs = try reader["numberOfAssociatedVPCs"].readIfPresent()
        value.sharingConfig = try reader["sharingConfig"].readIfPresent(with: VPCLatticeClientTypes.SharingConfig.read(from:))
        return value
    }
}

extension GetServiceNetworkResourceAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetServiceNetworkResourceAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetServiceNetworkResourceAssociationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.dnsEntry = try reader["dnsEntry"].readIfPresent(with: VPCLatticeClientTypes.DnsEntry.read(from:))
        value.failureCode = try reader["failureCode"].readIfPresent()
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.isManagedAssociation = try reader["isManagedAssociation"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.privateDnsEntry = try reader["privateDnsEntry"].readIfPresent(with: VPCLatticeClientTypes.DnsEntry.read(from:))
        value.resourceConfigurationArn = try reader["resourceConfigurationArn"].readIfPresent()
        value.resourceConfigurationId = try reader["resourceConfigurationId"].readIfPresent()
        value.resourceConfigurationName = try reader["resourceConfigurationName"].readIfPresent()
        value.serviceNetworkArn = try reader["serviceNetworkArn"].readIfPresent()
        value.serviceNetworkId = try reader["serviceNetworkId"].readIfPresent()
        value.serviceNetworkName = try reader["serviceNetworkName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension GetServiceNetworkServiceAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetServiceNetworkServiceAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetServiceNetworkServiceAssociationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.customDomainName = try reader["customDomainName"].readIfPresent()
        value.dnsEntry = try reader["dnsEntry"].readIfPresent(with: VPCLatticeClientTypes.DnsEntry.read(from:))
        value.failureCode = try reader["failureCode"].readIfPresent()
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.serviceArn = try reader["serviceArn"].readIfPresent()
        value.serviceId = try reader["serviceId"].readIfPresent()
        value.serviceName = try reader["serviceName"].readIfPresent()
        value.serviceNetworkArn = try reader["serviceNetworkArn"].readIfPresent()
        value.serviceNetworkId = try reader["serviceNetworkId"].readIfPresent()
        value.serviceNetworkName = try reader["serviceNetworkName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension GetServiceNetworkVpcAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetServiceNetworkVpcAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetServiceNetworkVpcAssociationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.failureCode = try reader["failureCode"].readIfPresent()
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.serviceNetworkArn = try reader["serviceNetworkArn"].readIfPresent()
        value.serviceNetworkId = try reader["serviceNetworkId"].readIfPresent()
        value.serviceNetworkName = try reader["serviceNetworkName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.vpcId = try reader["vpcId"].readIfPresent()
        return value
    }
}

extension GetTargetGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTargetGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTargetGroupOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.config = try reader["config"].readIfPresent(with: VPCLatticeClientTypes.TargetGroupConfig.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.failureCode = try reader["failureCode"].readIfPresent()
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent()
        value.serviceArns = try reader["serviceArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension ListAccessLogSubscriptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAccessLogSubscriptionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAccessLogSubscriptionsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.AccessLogSubscriptionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListListenersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListListenersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListListenersOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.ListenerSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListResourceConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResourceConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResourceConfigurationsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.ResourceConfigurationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListResourceEndpointAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResourceEndpointAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResourceEndpointAssociationsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.ResourceEndpointAssociationSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListResourceGatewaysOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResourceGatewaysOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResourceGatewaysOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.ResourceGatewaySummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListRulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRulesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.RuleSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListServiceNetworkResourceAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListServiceNetworkResourceAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListServiceNetworkResourceAssociationsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.ServiceNetworkResourceAssociationSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListServiceNetworksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListServiceNetworksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListServiceNetworksOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.ServiceNetworkSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListServiceNetworkServiceAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListServiceNetworkServiceAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListServiceNetworkServiceAssociationsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.ServiceNetworkServiceAssociationSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListServiceNetworkVpcAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListServiceNetworkVpcAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListServiceNetworkVpcAssociationsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.ServiceNetworkVpcAssociationSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListServiceNetworkVpcEndpointAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListServiceNetworkVpcEndpointAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListServiceNetworkVpcEndpointAssociationsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.ServiceNetworkEndpointAssociation.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListServicesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListServicesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListServicesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.ServiceSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListTargetGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTargetGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTargetGroupsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.TargetGroupSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTargetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTargetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTargetsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.TargetSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension PutAuthPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutAuthPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutAuthPolicyOutput()
        value.policy = try reader["policy"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        return value
    }
}

extension PutResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutResourcePolicyOutput {
        return PutResourcePolicyOutput()
    }
}

extension RegisterTargetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterTargetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterTargetsOutput()
        value.successful = try reader["successful"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.Target.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.unsuccessful = try reader["unsuccessful"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.TargetFailure.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAccessLogSubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAccessLogSubscriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAccessLogSubscriptionOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.destinationArn = try reader["destinationArn"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.resourceArn = try reader["resourceArn"].readIfPresent() ?? ""
        value.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateListenerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateListenerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateListenerOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.defaultAction = try reader["defaultAction"].readIfPresent(with: VPCLatticeClientTypes.RuleAction.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.port = try reader["port"].readIfPresent()
        value.`protocol` = try reader["protocol"].readIfPresent()
        value.serviceArn = try reader["serviceArn"].readIfPresent()
        value.serviceId = try reader["serviceId"].readIfPresent()
        return value
    }
}

extension UpdateResourceConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateResourceConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateResourceConfigurationOutput()
        value.allowAssociationToShareableServiceNetwork = try reader["allowAssociationToShareableServiceNetwork"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.portRanges = try reader["portRanges"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.`protocol` = try reader["protocol"].readIfPresent()
        value.resourceConfigurationDefinition = try reader["resourceConfigurationDefinition"].readIfPresent(with: VPCLatticeClientTypes.ResourceConfigurationDefinition.read(from:))
        value.resourceConfigurationGroupId = try reader["resourceConfigurationGroupId"].readIfPresent()
        value.resourceGatewayId = try reader["resourceGatewayId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension UpdateResourceGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateResourceGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateResourceGatewayOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.ipAddressType = try reader["ipAddressType"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcId = try reader["vpcId"].readIfPresent()
        return value
    }
}

extension UpdateRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateRuleOutput()
        value.action = try reader["action"].readIfPresent(with: VPCLatticeClientTypes.RuleAction.read(from:))
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.isDefault = try reader["isDefault"].readIfPresent()
        value.match = try reader["match"].readIfPresent(with: VPCLatticeClientTypes.RuleMatch.read(from:))
        value.name = try reader["name"].readIfPresent()
        value.priority = try reader["priority"].readIfPresent()
        return value
    }
}

extension UpdateServiceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateServiceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateServiceOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.authType = try reader["authType"].readIfPresent()
        value.certificateArn = try reader["certificateArn"].readIfPresent()
        value.customDomainName = try reader["customDomainName"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension UpdateServiceNetworkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateServiceNetworkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateServiceNetworkOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.authType = try reader["authType"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension UpdateServiceNetworkVpcAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateServiceNetworkVpcAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateServiceNetworkVpcAssociationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension UpdateTargetGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTargetGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateTargetGroupOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.config = try reader["config"].readIfPresent(with: VPCLatticeClientTypes.TargetGroupConfig.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

enum BatchUpdateRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAccessLogSubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateListenerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateResourceConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateResourceGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateServiceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateServiceNetworkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateServiceNetworkResourceAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateServiceNetworkServiceAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateServiceNetworkVpcAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTargetGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAccessLogSubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAuthPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteListenerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteResourceConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteResourceEndpointAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteResourceGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteServiceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteServiceNetworkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteServiceNetworkResourceAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteServiceNetworkServiceAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteServiceNetworkVpcAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTargetGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeregisterTargetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAccessLogSubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAuthPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetListenerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourceConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourceGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetServiceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetServiceNetworkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetServiceNetworkResourceAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetServiceNetworkServiceAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetServiceNetworkVpcAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTargetGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAccessLogSubscriptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListListenersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResourceConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResourceEndpointAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResourceGatewaysOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListServiceNetworkResourceAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListServiceNetworksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListServiceNetworkServiceAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListServiceNetworkVpcAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListServiceNetworkVpcEndpointAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListServicesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTargetGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTargetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutAuthPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterTargetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAccessLogSubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateListenerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateResourceConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateResourceGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateServiceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateServiceNetworkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateServiceNetworkVpcAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTargetGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension VPCLatticeClientTypes.RuleUpdateSuccess {

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.RuleUpdateSuccess {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.RuleUpdateSuccess()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.isDefault = try reader["isDefault"].readIfPresent()
        value.match = try reader["match"].readIfPresent(with: VPCLatticeClientTypes.RuleMatch.read(from:))
        value.priority = try reader["priority"].readIfPresent()
        value.action = try reader["action"].readIfPresent(with: VPCLatticeClientTypes.RuleAction.read(from:))
        return value
    }
}

extension VPCLatticeClientTypes.RuleAction {

    static func write(value: VPCLatticeClientTypes.RuleAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .fixedresponse(fixedresponse):
                try writer["fixedResponse"].write(fixedresponse, with: VPCLatticeClientTypes.FixedResponseAction.write(value:to:))
            case let .forward(forward):
                try writer["forward"].write(forward, with: VPCLatticeClientTypes.ForwardAction.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.RuleAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "forward":
                return .forward(try reader["forward"].read(with: VPCLatticeClientTypes.ForwardAction.read(from:)))
            case "fixedResponse":
                return .fixedresponse(try reader["fixedResponse"].read(with: VPCLatticeClientTypes.FixedResponseAction.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension VPCLatticeClientTypes.FixedResponseAction {

    static func write(value: VPCLatticeClientTypes.FixedResponseAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["statusCode"].write(value.statusCode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.FixedResponseAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.FixedResponseAction()
        value.statusCode = try reader["statusCode"].readIfPresent() ?? 0
        return value
    }
}

extension VPCLatticeClientTypes.ForwardAction {

    static func write(value: VPCLatticeClientTypes.ForwardAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["targetGroups"].writeList(value.targetGroups, memberWritingClosure: VPCLatticeClientTypes.WeightedTargetGroup.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.ForwardAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.ForwardAction()
        value.targetGroups = try reader["targetGroups"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.WeightedTargetGroup.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension VPCLatticeClientTypes.WeightedTargetGroup {

    static func write(value: VPCLatticeClientTypes.WeightedTargetGroup?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["targetGroupIdentifier"].write(value.targetGroupIdentifier)
        try writer["weight"].write(value.weight)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.WeightedTargetGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.WeightedTargetGroup()
        value.targetGroupIdentifier = try reader["targetGroupIdentifier"].readIfPresent() ?? ""
        value.weight = try reader["weight"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes.RuleMatch {

    static func write(value: VPCLatticeClientTypes.RuleMatch?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .httpmatch(httpmatch):
                try writer["httpMatch"].write(httpmatch, with: VPCLatticeClientTypes.HttpMatch.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.RuleMatch {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "httpMatch":
                return .httpmatch(try reader["httpMatch"].read(with: VPCLatticeClientTypes.HttpMatch.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension VPCLatticeClientTypes.HttpMatch {

    static func write(value: VPCLatticeClientTypes.HttpMatch?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["headerMatches"].writeList(value.headerMatches, memberWritingClosure: VPCLatticeClientTypes.HeaderMatch.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["method"].write(value.method)
        try writer["pathMatch"].write(value.pathMatch, with: VPCLatticeClientTypes.PathMatch.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.HttpMatch {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.HttpMatch()
        value.method = try reader["method"].readIfPresent()
        value.pathMatch = try reader["pathMatch"].readIfPresent(with: VPCLatticeClientTypes.PathMatch.read(from:))
        value.headerMatches = try reader["headerMatches"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.HeaderMatch.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension VPCLatticeClientTypes.HeaderMatch {

    static func write(value: VPCLatticeClientTypes.HeaderMatch?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["caseSensitive"].write(value.caseSensitive)
        try writer["match"].write(value.match, with: VPCLatticeClientTypes.HeaderMatchType.write(value:to:))
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.HeaderMatch {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.HeaderMatch()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.match = try reader["match"].readIfPresent(with: VPCLatticeClientTypes.HeaderMatchType.read(from:))
        value.caseSensitive = try reader["caseSensitive"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes.HeaderMatchType {

    static func write(value: VPCLatticeClientTypes.HeaderMatchType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .contains(contains):
                try writer["contains"].write(contains)
            case let .exact(exact):
                try writer["exact"].write(exact)
            case let .`prefix`(`prefix`):
                try writer["prefix"].write(`prefix`)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.HeaderMatchType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "exact":
                return .exact(try reader["exact"].read())
            case "prefix":
                return .`prefix`(try reader["prefix"].read())
            case "contains":
                return .contains(try reader["contains"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension VPCLatticeClientTypes.PathMatch {

    static func write(value: VPCLatticeClientTypes.PathMatch?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["caseSensitive"].write(value.caseSensitive)
        try writer["match"].write(value.match, with: VPCLatticeClientTypes.PathMatchType.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.PathMatch {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.PathMatch()
        value.match = try reader["match"].readIfPresent(with: VPCLatticeClientTypes.PathMatchType.read(from:))
        value.caseSensitive = try reader["caseSensitive"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes.PathMatchType {

    static func write(value: VPCLatticeClientTypes.PathMatchType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .exact(exact):
                try writer["exact"].write(exact)
            case let .`prefix`(`prefix`):
                try writer["prefix"].write(`prefix`)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.PathMatchType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "exact":
                return .exact(try reader["exact"].read())
            case "prefix":
                return .`prefix`(try reader["prefix"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension VPCLatticeClientTypes.RuleUpdateFailure {

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.RuleUpdateFailure {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.RuleUpdateFailure()
        value.ruleIdentifier = try reader["ruleIdentifier"].readIfPresent()
        value.failureCode = try reader["failureCode"].readIfPresent()
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes.ResourceConfigurationDefinition {

    static func write(value: VPCLatticeClientTypes.ResourceConfigurationDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .arnresource(arnresource):
                try writer["arnResource"].write(arnresource, with: VPCLatticeClientTypes.ArnResource.write(value:to:))
            case let .dnsresource(dnsresource):
                try writer["dnsResource"].write(dnsresource, with: VPCLatticeClientTypes.DnsResource.write(value:to:))
            case let .ipresource(ipresource):
                try writer["ipResource"].write(ipresource, with: VPCLatticeClientTypes.IpResource.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.ResourceConfigurationDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "dnsResource":
                return .dnsresource(try reader["dnsResource"].read(with: VPCLatticeClientTypes.DnsResource.read(from:)))
            case "ipResource":
                return .ipresource(try reader["ipResource"].read(with: VPCLatticeClientTypes.IpResource.read(from:)))
            case "arnResource":
                return .arnresource(try reader["arnResource"].read(with: VPCLatticeClientTypes.ArnResource.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension VPCLatticeClientTypes.ArnResource {

    static func write(value: VPCLatticeClientTypes.ArnResource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.ArnResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.ArnResource()
        value.arn = try reader["arn"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes.IpResource {

    static func write(value: VPCLatticeClientTypes.IpResource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ipAddress"].write(value.ipAddress)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.IpResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.IpResource()
        value.ipAddress = try reader["ipAddress"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes.DnsResource {

    static func write(value: VPCLatticeClientTypes.DnsResource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["domainName"].write(value.domainName)
        try writer["ipAddressType"].write(value.ipAddressType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.DnsResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.DnsResource()
        value.domainName = try reader["domainName"].readIfPresent()
        value.ipAddressType = try reader["ipAddressType"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes.DnsEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.DnsEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.DnsEntry()
        value.domainName = try reader["domainName"].readIfPresent()
        value.hostedZoneId = try reader["hostedZoneId"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes.SharingConfig {

    static func write(value: VPCLatticeClientTypes.SharingConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enabled"].write(value.enabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.SharingConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.SharingConfig()
        value.enabled = try reader["enabled"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes.TargetGroupConfig {

    static func write(value: VPCLatticeClientTypes.TargetGroupConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["healthCheck"].write(value.healthCheck, with: VPCLatticeClientTypes.HealthCheckConfig.write(value:to:))
        try writer["ipAddressType"].write(value.ipAddressType)
        try writer["lambdaEventStructureVersion"].write(value.lambdaEventStructureVersion)
        try writer["port"].write(value.port)
        try writer["protocol"].write(value.`protocol`)
        try writer["protocolVersion"].write(value.protocolVersion)
        try writer["vpcIdentifier"].write(value.vpcIdentifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.TargetGroupConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.TargetGroupConfig()
        value.port = try reader["port"].readIfPresent()
        value.`protocol` = try reader["protocol"].readIfPresent()
        value.protocolVersion = try reader["protocolVersion"].readIfPresent()
        value.ipAddressType = try reader["ipAddressType"].readIfPresent()
        value.vpcIdentifier = try reader["vpcIdentifier"].readIfPresent()
        value.healthCheck = try reader["healthCheck"].readIfPresent(with: VPCLatticeClientTypes.HealthCheckConfig.read(from:))
        value.lambdaEventStructureVersion = try reader["lambdaEventStructureVersion"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes.HealthCheckConfig {

    static func write(value: VPCLatticeClientTypes.HealthCheckConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enabled"].write(value.enabled)
        try writer["healthCheckIntervalSeconds"].write(value.healthCheckIntervalSeconds)
        try writer["healthCheckTimeoutSeconds"].write(value.healthCheckTimeoutSeconds)
        try writer["healthyThresholdCount"].write(value.healthyThresholdCount)
        try writer["matcher"].write(value.matcher, with: VPCLatticeClientTypes.Matcher.write(value:to:))
        try writer["path"].write(value.path)
        try writer["port"].write(value.port)
        try writer["protocol"].write(value.`protocol`)
        try writer["protocolVersion"].write(value.protocolVersion)
        try writer["unhealthyThresholdCount"].write(value.unhealthyThresholdCount)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.HealthCheckConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.HealthCheckConfig()
        value.enabled = try reader["enabled"].readIfPresent()
        value.`protocol` = try reader["protocol"].readIfPresent()
        value.protocolVersion = try reader["protocolVersion"].readIfPresent()
        value.port = try reader["port"].readIfPresent()
        value.path = try reader["path"].readIfPresent()
        value.healthCheckIntervalSeconds = try reader["healthCheckIntervalSeconds"].readIfPresent()
        value.healthCheckTimeoutSeconds = try reader["healthCheckTimeoutSeconds"].readIfPresent()
        value.healthyThresholdCount = try reader["healthyThresholdCount"].readIfPresent()
        value.unhealthyThresholdCount = try reader["unhealthyThresholdCount"].readIfPresent()
        value.matcher = try reader["matcher"].readIfPresent(with: VPCLatticeClientTypes.Matcher.read(from:))
        return value
    }
}

extension VPCLatticeClientTypes.Matcher {

    static func write(value: VPCLatticeClientTypes.Matcher?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .httpcode(httpcode):
                try writer["httpCode"].write(httpcode)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.Matcher {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "httpCode":
                return .httpcode(try reader["httpCode"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension VPCLatticeClientTypes.Target {

    static func write(value: VPCLatticeClientTypes.Target?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
        try writer["port"].write(value.port)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.Target {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.Target()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.port = try reader["port"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes.TargetFailure {

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.TargetFailure {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.TargetFailure()
        value.id = try reader["id"].readIfPresent()
        value.port = try reader["port"].readIfPresent()
        value.failureCode = try reader["failureCode"].readIfPresent()
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes.AccessLogSubscriptionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.AccessLogSubscriptionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.AccessLogSubscriptionSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.resourceArn = try reader["resourceArn"].readIfPresent() ?? ""
        value.destinationArn = try reader["destinationArn"].readIfPresent() ?? ""
        value.serviceNetworkLogType = try reader["serviceNetworkLogType"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension VPCLatticeClientTypes.ListenerSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.ListenerSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.ListenerSummary()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.`protocol` = try reader["protocol"].readIfPresent()
        value.port = try reader["port"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension VPCLatticeClientTypes.ResourceConfigurationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.ResourceConfigurationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.ResourceConfigurationSummary()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.resourceGatewayId = try reader["resourceGatewayId"].readIfPresent()
        value.resourceConfigurationGroupId = try reader["resourceConfigurationGroupId"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.amazonManaged = try reader["amazonManaged"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension VPCLatticeClientTypes.ResourceEndpointAssociationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.ResourceEndpointAssociationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.ResourceEndpointAssociationSummary()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.resourceConfigurationId = try reader["resourceConfigurationId"].readIfPresent()
        value.resourceConfigurationArn = try reader["resourceConfigurationArn"].readIfPresent()
        value.resourceConfigurationName = try reader["resourceConfigurationName"].readIfPresent()
        value.vpcEndpointId = try reader["vpcEndpointId"].readIfPresent()
        value.vpcEndpointOwner = try reader["vpcEndpointOwner"].readIfPresent()
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension VPCLatticeClientTypes.ResourceGatewaySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.ResourceGatewaySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.ResourceGatewaySummary()
        value.name = try reader["name"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.vpcIdentifier = try reader["vpcIdentifier"].readIfPresent()
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.ipAddressType = try reader["ipAddressType"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension VPCLatticeClientTypes.RuleSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.RuleSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.RuleSummary()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.isDefault = try reader["isDefault"].readIfPresent()
        value.priority = try reader["priority"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension VPCLatticeClientTypes.ServiceNetworkResourceAssociationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.ServiceNetworkResourceAssociationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.ServiceNetworkResourceAssociationSummary()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.resourceConfigurationId = try reader["resourceConfigurationId"].readIfPresent()
        value.resourceConfigurationArn = try reader["resourceConfigurationArn"].readIfPresent()
        value.resourceConfigurationName = try reader["resourceConfigurationName"].readIfPresent()
        value.serviceNetworkId = try reader["serviceNetworkId"].readIfPresent()
        value.serviceNetworkArn = try reader["serviceNetworkArn"].readIfPresent()
        value.serviceNetworkName = try reader["serviceNetworkName"].readIfPresent()
        value.dnsEntry = try reader["dnsEntry"].readIfPresent(with: VPCLatticeClientTypes.DnsEntry.read(from:))
        value.privateDnsEntry = try reader["privateDnsEntry"].readIfPresent(with: VPCLatticeClientTypes.DnsEntry.read(from:))
        value.isManagedAssociation = try reader["isManagedAssociation"].readIfPresent()
        value.failureCode = try reader["failureCode"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes.ServiceNetworkSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.ServiceNetworkSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.ServiceNetworkSummary()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.numberOfAssociatedVPCs = try reader["numberOfAssociatedVPCs"].readIfPresent()
        value.numberOfAssociatedServices = try reader["numberOfAssociatedServices"].readIfPresent()
        value.numberOfAssociatedResourceConfigurations = try reader["numberOfAssociatedResourceConfigurations"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes.ServiceNetworkServiceAssociationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.ServiceNetworkServiceAssociationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.ServiceNetworkServiceAssociationSummary()
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.serviceId = try reader["serviceId"].readIfPresent()
        value.serviceName = try reader["serviceName"].readIfPresent()
        value.serviceArn = try reader["serviceArn"].readIfPresent()
        value.serviceNetworkId = try reader["serviceNetworkId"].readIfPresent()
        value.serviceNetworkName = try reader["serviceNetworkName"].readIfPresent()
        value.serviceNetworkArn = try reader["serviceNetworkArn"].readIfPresent()
        value.dnsEntry = try reader["dnsEntry"].readIfPresent(with: VPCLatticeClientTypes.DnsEntry.read(from:))
        value.customDomainName = try reader["customDomainName"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes.ServiceNetworkVpcAssociationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.ServiceNetworkVpcAssociationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.ServiceNetworkVpcAssociationSummary()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.serviceNetworkId = try reader["serviceNetworkId"].readIfPresent()
        value.serviceNetworkName = try reader["serviceNetworkName"].readIfPresent()
        value.serviceNetworkArn = try reader["serviceNetworkArn"].readIfPresent()
        value.vpcId = try reader["vpcId"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension VPCLatticeClientTypes.ServiceNetworkEndpointAssociation {

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.ServiceNetworkEndpointAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.ServiceNetworkEndpointAssociation()
        value.vpcEndpointId = try reader["vpcEndpointId"].readIfPresent()
        value.vpcId = try reader["vpcId"].readIfPresent()
        value.vpcEndpointOwnerId = try reader["vpcEndpointOwnerId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        value.serviceNetworkArn = try reader["serviceNetworkArn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension VPCLatticeClientTypes.ServiceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.ServiceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.ServiceSummary()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.dnsEntry = try reader["dnsEntry"].readIfPresent(with: VPCLatticeClientTypes.DnsEntry.read(from:))
        value.customDomainName = try reader["customDomainName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes.TargetGroupSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.TargetGroupSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.TargetGroupSummary()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.port = try reader["port"].readIfPresent()
        value.`protocol` = try reader["protocol"].readIfPresent()
        value.ipAddressType = try reader["ipAddressType"].readIfPresent()
        value.vpcIdentifier = try reader["vpcIdentifier"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.status = try reader["status"].readIfPresent()
        value.serviceArns = try reader["serviceArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.lambdaEventStructureVersion = try reader["lambdaEventStructureVersion"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes.TargetSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.TargetSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.TargetSummary()
        value.id = try reader["id"].readIfPresent()
        value.port = try reader["port"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.reasonCode = try reader["reasonCode"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension VPCLatticeClientTypes.RuleUpdate {

    static func write(value: VPCLatticeClientTypes.RuleUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action, with: VPCLatticeClientTypes.RuleAction.write(value:to:))
        try writer["match"].write(value.match, with: VPCLatticeClientTypes.RuleMatch.write(value:to:))
        try writer["priority"].write(value.priority)
        try writer["ruleIdentifier"].write(value.ruleIdentifier)
    }
}

public enum VPCLatticeClientTypes {}
