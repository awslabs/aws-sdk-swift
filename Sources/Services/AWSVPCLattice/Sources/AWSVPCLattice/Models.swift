//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// The user does not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request conflicts with the current state of the resource. Updating or deleting a resource can cause an inconsistent state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The resource ID.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// An unexpected error occurred while processing the request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The number of seconds to wait before retrying.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// The request references a resource that does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The resource ID.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The limit on the number of requests per second was exceeded.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the service quota that was exceeded.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The number of seconds to wait before retrying.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
        /// The service code.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

extension VPCLatticeClientTypes {
    /// Describes a validation failure.
    public struct ValidationExceptionField {
        /// Additional information about why the validation failed.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the validation exception.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension VPCLatticeClientTypes {

    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The input does not satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The fields that failed validation.
        public internal(set) var fieldList: [VPCLatticeClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason.
        /// This member is required.
        public internal(set) var reason: VPCLatticeClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [VPCLatticeClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: VPCLatticeClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

public struct CreateAccessLogSubscriptionInput {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the destination. The supported destination types are CloudWatch Log groups, Kinesis Data Firehose delivery streams, and Amazon S3 buckets.
    /// This member is required.
    public var destinationArn: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service network or service.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The tags for the access log subscription.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        destinationArn: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.destinationArn = destinationArn
        self.resourceIdentifier = resourceIdentifier
        self.tags = tags
    }
}

public struct CreateAccessLogSubscriptionOutput {
    /// The Amazon Resource Name (ARN) of the access log subscription.
    /// This member is required.
    public var arn: Swift.String?
    /// The Amazon Resource Name (ARN) of the log destination.
    /// This member is required.
    public var destinationArn: Swift.String?
    /// The ID of the access log subscription.
    /// This member is required.
    public var id: Swift.String?
    /// The Amazon Resource Name (ARN) of the service network or service.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The ID of the service network or service.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        destinationArn: Swift.String? = nil,
        id: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.destinationArn = destinationArn
        self.id = id
        self.resourceArn = resourceArn
        self.resourceId = resourceId
    }
}

public struct DeleteAccessLogSubscriptionInput {
    /// The ID or Amazon Resource Name (ARN) of the access log subscription.
    /// This member is required.
    public var accessLogSubscriptionIdentifier: Swift.String?

    public init(
        accessLogSubscriptionIdentifier: Swift.String? = nil
    )
    {
        self.accessLogSubscriptionIdentifier = accessLogSubscriptionIdentifier
    }
}

public struct DeleteAccessLogSubscriptionOutput {

    public init() { }
}

public struct GetAccessLogSubscriptionInput {
    /// The ID or Amazon Resource Name (ARN) of the access log subscription.
    /// This member is required.
    public var accessLogSubscriptionIdentifier: Swift.String?

    public init(
        accessLogSubscriptionIdentifier: Swift.String? = nil
    )
    {
        self.accessLogSubscriptionIdentifier = accessLogSubscriptionIdentifier
    }
}

public struct GetAccessLogSubscriptionOutput {
    /// The Amazon Resource Name (ARN) of the access log subscription.
    /// This member is required.
    public var arn: Swift.String?
    /// The date and time that the access log subscription was created, specified in ISO-8601 format.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the access log destination.
    /// This member is required.
    public var destinationArn: Swift.String?
    /// The ID of the access log subscription.
    /// This member is required.
    public var id: Swift.String?
    /// The date and time that the access log subscription was last updated, specified in ISO-8601 format.
    /// This member is required.
    public var lastUpdatedAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the service network or service.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The ID of the service network or service.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        destinationArn: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        resourceArn: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.destinationArn = destinationArn
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.resourceArn = resourceArn
        self.resourceId = resourceId
    }
}

public struct ListAccessLogSubscriptionsInput {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service network or service.
    /// This member is required.
    public var resourceIdentifier: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceIdentifier = resourceIdentifier
    }
}

extension VPCLatticeClientTypes {
    /// Summary information about an access log subscription.
    public struct AccessLogSubscriptionSummary {
        /// The Amazon Resource Name (ARN) of the access log subscription
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that the access log subscription was created, specified in ISO-8601 format.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the destination.
        /// This member is required.
        public var destinationArn: Swift.String?
        /// The ID of the access log subscription.
        /// This member is required.
        public var id: Swift.String?
        /// The date and time that the access log subscription was last updated, specified in ISO-8601 format.
        /// This member is required.
        public var lastUpdatedAt: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the service or service network.
        /// This member is required.
        public var resourceArn: Swift.String?
        /// The ID of the service or service network.
        /// This member is required.
        public var resourceId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            destinationArn: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            resourceArn: Swift.String? = nil,
            resourceId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.destinationArn = destinationArn
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.resourceArn = resourceArn
            self.resourceId = resourceId
        }
    }

}

public struct ListAccessLogSubscriptionsOutput {
    /// Information about the access log subscriptions.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.AccessLogSubscriptionSummary]?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.AccessLogSubscriptionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct UpdateAccessLogSubscriptionInput {
    /// The ID or Amazon Resource Name (ARN) of the access log subscription.
    /// This member is required.
    public var accessLogSubscriptionIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) of the access log destination.
    /// This member is required.
    public var destinationArn: Swift.String?

    public init(
        accessLogSubscriptionIdentifier: Swift.String? = nil,
        destinationArn: Swift.String? = nil
    )
    {
        self.accessLogSubscriptionIdentifier = accessLogSubscriptionIdentifier
        self.destinationArn = destinationArn
    }
}

public struct UpdateAccessLogSubscriptionOutput {
    /// The Amazon Resource Name (ARN) of the access log subscription.
    /// This member is required.
    public var arn: Swift.String?
    /// The Amazon Resource Name (ARN) of the access log destination.
    /// This member is required.
    public var destinationArn: Swift.String?
    /// The ID of the access log subscription.
    /// This member is required.
    public var id: Swift.String?
    /// The Amazon Resource Name (ARN) of the access log subscription.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        destinationArn: Swift.String? = nil,
        id: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.destinationArn = destinationArn
        self.id = id
        self.resourceArn = resourceArn
        self.resourceId = resourceId
    }
}

extension VPCLatticeClientTypes {

    public enum AuthPolicyState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthPolicyState] {
            return [
                .active,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .inactive: return "Inactive"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VPCLatticeClientTypes {

    public enum AuthType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsIam
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthType] {
            return [
                .awsIam,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsIam: return "AWS_IAM"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VPCLatticeClientTypes {
    /// Describes an action that returns a custom HTTP response.
    public struct FixedResponseAction {
        /// The HTTP response code.
        /// This member is required.
        public var statusCode: Swift.Int?

        public init(
            statusCode: Swift.Int? = nil
        )
        {
            self.statusCode = statusCode
        }
    }

}

extension VPCLatticeClientTypes {
    /// Describes the weight of a target group.
    public struct WeightedTargetGroup {
        /// The ID or Amazon Resource Name (ARN) of the target group.
        /// This member is required.
        public var targetGroupIdentifier: Swift.String?
        /// Only required if you specify multiple target groups for a forward action. The weight determines how requests are distributed to the target group. For example, if you specify two target groups, each with a weight of 10, each target group receives half the requests. If you specify two target groups, one with a weight of 10 and the other with a weight of 20, the target group with a weight of 20 receives twice as many requests as the other target group. If there's only one target group specified, then the default value is 100.
        public var weight: Swift.Int?

        public init(
            targetGroupIdentifier: Swift.String? = nil,
            weight: Swift.Int? = nil
        )
        {
            self.targetGroupIdentifier = targetGroupIdentifier
            self.weight = weight
        }
    }

}

extension VPCLatticeClientTypes {
    /// Describes a forward action. You can use forward actions to route requests to one or more target groups.
    public struct ForwardAction {
        /// The target groups. Traffic matching the rule is forwarded to the specified target groups. With forward actions, you can assign a weight that controls the prioritization and selection of each target group. This means that requests are distributed to individual target groups based on their weights. For example, if two target groups have the same weight, each target group receives half of the traffic. The default value is 1. This means that if only one target group is provided, there is no need to set the weight; 100% of the traffic goes to that target group.
        /// This member is required.
        public var targetGroups: [VPCLatticeClientTypes.WeightedTargetGroup]?

        public init(
            targetGroups: [VPCLatticeClientTypes.WeightedTargetGroup]? = nil
        )
        {
            self.targetGroups = targetGroups
        }
    }

}

extension VPCLatticeClientTypes {
    /// Describes the action for a rule.
    public enum RuleAction {
        /// The forward action. Traffic that matches the rule is forwarded to the specified target groups.
        case forward(VPCLatticeClientTypes.ForwardAction)
        /// The fixed response action. The rule returns a custom HTTP response.
        case fixedresponse(VPCLatticeClientTypes.FixedResponseAction)
        case sdkUnknown(Swift.String)
    }

}

extension VPCLatticeClientTypes {
    /// Describes a header match type.
    public enum HeaderMatchType {
        /// An exact type match.
        case exact(Swift.String)
        /// A prefix type match. Matches the value with the prefix.
        case `prefix`(Swift.String)
        /// A contains type match.
        case contains(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension VPCLatticeClientTypes {
    /// Describes the constraints for a header match. Matches incoming requests with rule based on request header value before applying rule action.
    public struct HeaderMatch {
        /// Indicates whether the match is case sensitive.
        public var caseSensitive: Swift.Bool?
        /// The header match type.
        /// This member is required.
        public var match: VPCLatticeClientTypes.HeaderMatchType?
        /// The name of the header.
        /// This member is required.
        public var name: Swift.String?

        public init(
            caseSensitive: Swift.Bool? = nil,
            match: VPCLatticeClientTypes.HeaderMatchType? = nil,
            name: Swift.String? = nil
        )
        {
            self.caseSensitive = caseSensitive
            self.match = match
            self.name = name
        }
    }

}

extension VPCLatticeClientTypes {
    /// Describes a path match type. Each rule can include only one of the following types of paths.
    public enum PathMatchType {
        /// An exact match of the path.
        case exact(Swift.String)
        /// A prefix match of the path.
        case `prefix`(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension VPCLatticeClientTypes {
    /// Describes the conditions that can be applied when matching a path for incoming requests.
    public struct PathMatch {
        /// Indicates whether the match is case sensitive.
        public var caseSensitive: Swift.Bool?
        /// The type of path match.
        /// This member is required.
        public var match: VPCLatticeClientTypes.PathMatchType?

        public init(
            caseSensitive: Swift.Bool? = nil,
            match: VPCLatticeClientTypes.PathMatchType? = nil
        )
        {
            self.caseSensitive = caseSensitive
            self.match = match
        }
    }

}

extension VPCLatticeClientTypes {
    /// Describes criteria that can be applied to incoming requests.
    public struct HttpMatch {
        /// The header matches. Matches incoming requests with rule based on request header value before applying rule action.
        public var headerMatches: [VPCLatticeClientTypes.HeaderMatch]?
        /// The HTTP method type.
        public var method: Swift.String?
        /// The path match.
        public var pathMatch: VPCLatticeClientTypes.PathMatch?

        public init(
            headerMatches: [VPCLatticeClientTypes.HeaderMatch]? = nil,
            method: Swift.String? = nil,
            pathMatch: VPCLatticeClientTypes.PathMatch? = nil
        )
        {
            self.headerMatches = headerMatches
            self.method = method
            self.pathMatch = pathMatch
        }
    }

}

extension VPCLatticeClientTypes {
    /// Describes a rule match.
    public enum RuleMatch {
        /// The HTTP criteria that a rule must match.
        case httpmatch(VPCLatticeClientTypes.HttpMatch)
        case sdkUnknown(Swift.String)
    }

}

extension VPCLatticeClientTypes {
    /// Describes a rule update.
    public struct RuleUpdate {
        /// The rule action.
        public var action: VPCLatticeClientTypes.RuleAction?
        /// The rule match.
        public var match: VPCLatticeClientTypes.RuleMatch?
        /// The rule priority. A listener can't have multiple rules with the same priority.
        public var priority: Swift.Int?
        /// The ID or Amazon Resource Name (ARN) of the rule.
        /// This member is required.
        public var ruleIdentifier: Swift.String?

        public init(
            action: VPCLatticeClientTypes.RuleAction? = nil,
            match: VPCLatticeClientTypes.RuleMatch? = nil,
            priority: Swift.Int? = nil,
            ruleIdentifier: Swift.String? = nil
        )
        {
            self.action = action
            self.match = match
            self.priority = priority
            self.ruleIdentifier = ruleIdentifier
        }
    }

}

public struct BatchUpdateRuleInput {
    /// The ID or Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The rules for the specified listener.
    /// This member is required.
    public var rules: [VPCLatticeClientTypes.RuleUpdate]?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        listenerIdentifier: Swift.String? = nil,
        rules: [VPCLatticeClientTypes.RuleUpdate]? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.listenerIdentifier = listenerIdentifier
        self.rules = rules
        self.serviceIdentifier = serviceIdentifier
    }
}

extension VPCLatticeClientTypes {
    /// Describes a successful rule update.
    public struct RuleUpdateSuccess {
        /// The action for the rule.
        public var action: VPCLatticeClientTypes.RuleAction?
        /// The Amazon Resource Name (ARN) of the listener.
        public var arn: Swift.String?
        /// The ID of the listener.
        public var id: Swift.String?
        /// Indicates whether this is the default rule.
        public var isDefault: Swift.Bool?
        /// The rule match.
        public var match: VPCLatticeClientTypes.RuleMatch?
        /// The name of the listener.
        public var name: Swift.String?
        /// The rule priority.
        public var priority: Swift.Int?

        public init(
            action: VPCLatticeClientTypes.RuleAction? = nil,
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            isDefault: Swift.Bool? = nil,
            match: VPCLatticeClientTypes.RuleMatch? = nil,
            name: Swift.String? = nil,
            priority: Swift.Int? = nil
        )
        {
            self.action = action
            self.arn = arn
            self.id = id
            self.isDefault = isDefault
            self.match = match
            self.name = name
            self.priority = priority
        }
    }

}

extension VPCLatticeClientTypes {
    /// Describes a rule update that failed.
    public struct RuleUpdateFailure {
        /// The failure code.
        public var failureCode: Swift.String?
        /// The failure message.
        public var failureMessage: Swift.String?
        /// The ID or Amazon Resource Name (ARN) of the rule.
        public var ruleIdentifier: Swift.String?

        public init(
            failureCode: Swift.String? = nil,
            failureMessage: Swift.String? = nil,
            ruleIdentifier: Swift.String? = nil
        )
        {
            self.failureCode = failureCode
            self.failureMessage = failureMessage
            self.ruleIdentifier = ruleIdentifier
        }
    }

}

public struct BatchUpdateRuleOutput {
    /// The rules that were successfully updated.
    public var successful: [VPCLatticeClientTypes.RuleUpdateSuccess]?
    /// The rules that the operation couldn't update.
    public var unsuccessful: [VPCLatticeClientTypes.RuleUpdateFailure]?

    public init(
        successful: [VPCLatticeClientTypes.RuleUpdateSuccess]? = nil,
        unsuccessful: [VPCLatticeClientTypes.RuleUpdateFailure]? = nil
    )
    {
        self.successful = successful
        self.unsuccessful = unsuccessful
    }
}

/// The request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the service quota that was exceeded.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The resource ID.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
        /// The service code.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

extension VPCLatticeClientTypes {

    public enum ListenerProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Indicates HTTP protocol
        case http
        /// Indicates HTTPS protocol
        case https
        /// Indicates TLS_PASSTHROUGH protocol
        case tlsPassthrough
        case sdkUnknown(Swift.String)

        public static var allCases: [ListenerProtocol] {
            return [
                .http,
                .https,
                .tlsPassthrough
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case .https: return "HTTPS"
            case .tlsPassthrough: return "TLS_PASSTHROUGH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateListenerInput {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The action for the default rule. Each listener has a default rule. The default rule is used if no other rules match.
    /// This member is required.
    public var defaultAction: VPCLatticeClientTypes.RuleAction?
    /// The name of the listener. A listener name must be unique within a service. The valid characters are a-z, 0-9, and hyphens (-). You can't use a hyphen as the first or last character, or immediately after another hyphen.
    /// This member is required.
    public var name: Swift.String?
    /// The listener port. You can specify a value from 1 to 65535. For HTTP, the default is 80. For HTTPS, the default is 443.
    public var port: Swift.Int?
    /// The listener protocol.
    /// This member is required.
    public var `protocol`: VPCLatticeClientTypes.ListenerProtocol?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?
    /// The tags for the listener.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        defaultAction: VPCLatticeClientTypes.RuleAction? = nil,
        name: Swift.String? = nil,
        port: Swift.Int? = nil,
        `protocol`: VPCLatticeClientTypes.ListenerProtocol? = nil,
        serviceIdentifier: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.defaultAction = defaultAction
        self.name = name
        self.port = port
        self.`protocol` = `protocol`
        self.serviceIdentifier = serviceIdentifier
        self.tags = tags
    }
}

public struct CreateListenerOutput {
    /// The Amazon Resource Name (ARN) of the listener.
    public var arn: Swift.String?
    /// The action for the default rule.
    public var defaultAction: VPCLatticeClientTypes.RuleAction?
    /// The ID of the listener.
    public var id: Swift.String?
    /// The name of the listener.
    public var name: Swift.String?
    /// The port number of the listener.
    public var port: Swift.Int?
    /// The protocol of the listener.
    public var `protocol`: VPCLatticeClientTypes.ListenerProtocol?
    /// The Amazon Resource Name (ARN) of the service.
    public var serviceArn: Swift.String?
    /// The ID of the service.
    public var serviceId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        defaultAction: VPCLatticeClientTypes.RuleAction? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        port: Swift.Int? = nil,
        `protocol`: VPCLatticeClientTypes.ListenerProtocol? = nil,
        serviceArn: Swift.String? = nil,
        serviceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.defaultAction = defaultAction
        self.id = id
        self.name = name
        self.port = port
        self.`protocol` = `protocol`
        self.serviceArn = serviceArn
        self.serviceId = serviceId
    }
}

public struct CreateRuleInput {
    /// The action for the default rule.
    /// This member is required.
    public var action: VPCLatticeClientTypes.RuleAction?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The rule match.
    /// This member is required.
    public var match: VPCLatticeClientTypes.RuleMatch?
    /// The name of the rule. The name must be unique within the listener. The valid characters are a-z, 0-9, and hyphens (-). You can't use a hyphen as the first or last character, or immediately after another hyphen.
    /// This member is required.
    public var name: Swift.String?
    /// The priority assigned to the rule. Each rule for a specific listener must have a unique priority. The lower the priority number the higher the priority.
    /// This member is required.
    public var priority: Swift.Int?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?
    /// The tags for the rule.
    public var tags: [Swift.String: Swift.String]?

    public init(
        action: VPCLatticeClientTypes.RuleAction? = nil,
        clientToken: Swift.String? = nil,
        listenerIdentifier: Swift.String? = nil,
        match: VPCLatticeClientTypes.RuleMatch? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil,
        serviceIdentifier: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.action = action
        self.clientToken = clientToken
        self.listenerIdentifier = listenerIdentifier
        self.match = match
        self.name = name
        self.priority = priority
        self.serviceIdentifier = serviceIdentifier
        self.tags = tags
    }
}

public struct CreateRuleOutput {
    /// The rule action.
    public var action: VPCLatticeClientTypes.RuleAction?
    /// The Amazon Resource Name (ARN) of the rule.
    public var arn: Swift.String?
    /// The ID of the rule.
    public var id: Swift.String?
    /// The rule match. The RuleMatch must be an HttpMatch. This means that the rule should be an exact match on HTTP constraints which are made up of the HTTP method, path, and header.
    public var match: VPCLatticeClientTypes.RuleMatch?
    /// The name of the rule.
    public var name: Swift.String?
    /// The priority assigned to the rule. The lower the priority number the higher the priority.
    public var priority: Swift.Int?

    public init(
        action: VPCLatticeClientTypes.RuleAction? = nil,
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        match: VPCLatticeClientTypes.RuleMatch? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil
    )
    {
        self.action = action
        self.arn = arn
        self.id = id
        self.match = match
        self.name = name
        self.priority = priority
    }
}

public struct CreateServiceInput {
    /// The type of IAM policy.
    ///
    /// * NONE: The resource does not use an IAM policy. This is the default.
    ///
    /// * AWS_IAM: The resource uses an IAM policy. When this type is used, auth is enabled and an auth policy is required.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The Amazon Resource Name (ARN) of the certificate.
    public var certificateArn: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The custom domain name of the service.
    public var customDomainName: Swift.String?
    /// The name of the service. The name must be unique within the account. The valid characters are a-z, 0-9, and hyphens (-). You can't use a hyphen as the first or last character, or immediately after another hyphen.
    /// This member is required.
    public var name: Swift.String?
    /// The tags for the service.
    public var tags: [Swift.String: Swift.String]?

    public init(
        authType: VPCLatticeClientTypes.AuthType? = nil,
        certificateArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        customDomainName: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.authType = authType
        self.certificateArn = certificateArn
        self.clientToken = clientToken
        self.customDomainName = customDomainName
        self.name = name
        self.tags = tags
    }
}

extension VPCLatticeClientTypes {
    /// Describes the DNS information of a service.
    public struct DnsEntry {
        /// The domain name of the service.
        public var domainName: Swift.String?
        /// The ID of the hosted zone.
        public var hostedZoneId: Swift.String?

        public init(
            domainName: Swift.String? = nil,
            hostedZoneId: Swift.String? = nil
        )
        {
            self.domainName = domainName
            self.hostedZoneId = hostedZoneId
        }
    }

}

extension VPCLatticeClientTypes {

    public enum ServiceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Service is active.
        case active
        /// Service creation failed
        case createFailed
        /// Service creation in progress.
        case createInProgress
        /// Service deletion failed.
        case deleteFailed
        /// Service deletion in progress
        case deleteInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleteFailed,
                .deleteInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateServiceOutput {
    /// The Amazon Resource Name (ARN) of the service.
    public var arn: Swift.String?
    /// The type of IAM policy.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The Amazon Resource Name (ARN) of the certificate.
    public var certificateArn: Swift.String?
    /// The custom domain name of the service.
    public var customDomainName: Swift.String?
    /// The public DNS name of the service.
    public var dnsEntry: VPCLatticeClientTypes.DnsEntry?
    /// The ID of the service.
    public var id: Swift.String?
    /// The name of the service.
    public var name: Swift.String?
    /// The status. If the status is CREATE_FAILED, you must delete and recreate the service.
    public var status: VPCLatticeClientTypes.ServiceStatus?

    public init(
        arn: Swift.String? = nil,
        authType: VPCLatticeClientTypes.AuthType? = nil,
        certificateArn: Swift.String? = nil,
        customDomainName: Swift.String? = nil,
        dnsEntry: VPCLatticeClientTypes.DnsEntry? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceStatus? = nil
    )
    {
        self.arn = arn
        self.authType = authType
        self.certificateArn = certificateArn
        self.customDomainName = customDomainName
        self.dnsEntry = dnsEntry
        self.id = id
        self.name = name
        self.status = status
    }
}

public struct CreateServiceNetworkInput {
    /// The type of IAM policy.
    ///
    /// * NONE: The resource does not use an IAM policy. This is the default.
    ///
    /// * AWS_IAM: The resource uses an IAM policy. When this type is used, auth is enabled and an auth policy is required.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The name of the service network. The name must be unique to the account. The valid characters are a-z, 0-9, and hyphens (-). You can't use a hyphen as the first or last character, or immediately after another hyphen.
    /// This member is required.
    public var name: Swift.String?
    /// The tags for the service network.
    public var tags: [Swift.String: Swift.String]?

    public init(
        authType: VPCLatticeClientTypes.AuthType? = nil,
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.authType = authType
        self.clientToken = clientToken
        self.name = name
        self.tags = tags
    }
}

public struct CreateServiceNetworkOutput {
    /// The Amazon Resource Name (ARN) of the service network.
    public var arn: Swift.String?
    /// The type of IAM policy.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The ID of the service network.
    public var id: Swift.String?
    /// The name of the service network.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        authType: VPCLatticeClientTypes.AuthType? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.authType = authType
        self.id = id
        self.name = name
    }
}

public struct CreateServiceNetworkServiceAssociationInput {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service network. You must use the ARN if the resources specified in the operation are in different accounts.
    /// This member is required.
    public var serviceNetworkIdentifier: Swift.String?
    /// The tags for the association.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil,
        serviceNetworkIdentifier: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.serviceIdentifier = serviceIdentifier
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
        self.tags = tags
    }
}

extension VPCLatticeClientTypes {

    public enum ServiceNetworkServiceAssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// ServiceNetwork and Service association is active
        case active
        /// ServiceNetwork and Service association creation failed.
        case createFailed
        /// ServiceNetwork and Service association creation in progress
        case createInProgress
        /// ServiceNetwork and Service association deletion failed
        case deleteFailed
        /// ServiceNetwork and Service association deletion in progress
        case deleteInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceNetworkServiceAssociationStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleteFailed,
                .deleteInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateServiceNetworkServiceAssociationOutput {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The account that created the association.
    public var createdBy: Swift.String?
    /// The custom domain name of the service.
    public var customDomainName: Swift.String?
    /// The DNS name of the service.
    public var dnsEntry: VPCLatticeClientTypes.DnsEntry?
    /// The ID of the association.
    public var id: Swift.String?
    /// The association status.
    public var status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus?

    public init(
        arn: Swift.String? = nil,
        createdBy: Swift.String? = nil,
        customDomainName: Swift.String? = nil,
        dnsEntry: VPCLatticeClientTypes.DnsEntry? = nil,
        id: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus? = nil
    )
    {
        self.arn = arn
        self.createdBy = createdBy
        self.customDomainName = customDomainName
        self.dnsEntry = dnsEntry
        self.id = id
        self.status = status
    }
}

public struct CreateServiceNetworkVpcAssociationInput {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The IDs of the security groups. Security groups aren't added by default. You can add a security group to apply network level controls to control which resources in a VPC are allowed to access the service network and its services. For more information, see [Control traffic to resources using security groups](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html) in the Amazon VPC User Guide.
    public var securityGroupIds: [Swift.String]?
    /// The ID or Amazon Resource Name (ARN) of the service network. You must use the ARN when the resources specified in the operation are in different accounts.
    /// This member is required.
    public var serviceNetworkIdentifier: Swift.String?
    /// The tags for the association.
    public var tags: [Swift.String: Swift.String]?
    /// The ID of the VPC.
    /// This member is required.
    public var vpcIdentifier: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        serviceNetworkIdentifier: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        vpcIdentifier: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.securityGroupIds = securityGroupIds
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
        self.tags = tags
        self.vpcIdentifier = vpcIdentifier
    }
}

extension VPCLatticeClientTypes {

    public enum ServiceNetworkVpcAssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// ServiceNetwork and Vpc association is active
        case active
        /// ServiceNetwork and Vpc association creation failed.
        case createFailed
        /// ServiceNetwork and Vpc association creation in progress
        case createInProgress
        /// ServiceNetwork and Vpc association deletion failed
        case deleteFailed
        /// ServiceNetwork and Vpc association deletion in progress
        case deleteInProgress
        /// ServiceNetwork and Vpc association update failed
        case updateFailed
        /// ServiceNetwork and Vpc association update in progress
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceNetworkVpcAssociationStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleteFailed,
                .deleteInProgress,
                .updateFailed,
                .updateInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateServiceNetworkVpcAssociationOutput {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The account that created the association.
    public var createdBy: Swift.String?
    /// The ID of the association.
    public var id: Swift.String?
    /// The IDs of the security groups.
    public var securityGroupIds: [Swift.String]?
    /// The association status.
    public var status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus?

    public init(
        arn: Swift.String? = nil,
        createdBy: Swift.String? = nil,
        id: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus? = nil
    )
    {
        self.arn = arn
        self.createdBy = createdBy
        self.id = id
        self.securityGroupIds = securityGroupIds
        self.status = status
    }
}

extension VPCLatticeClientTypes {
    /// Describes the codes to use when checking for a successful response from a target for health checks.
    public enum Matcher {
        /// The HTTP code to use when checking for a successful response from a target.
        case httpcode(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension VPCLatticeClientTypes {

    public enum TargetGroupProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Indicates HTTP protocol
        case http
        /// Indicates HTTPS protocol
        case https
        /// Indicates TCP protocol
        case tcp
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetGroupProtocol] {
            return [
                .http,
                .https,
                .tcp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case .https: return "HTTPS"
            case .tcp: return "TCP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VPCLatticeClientTypes {

    public enum HealthCheckProtocolVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Indicates use of HTTP/1.1 to send requests to target
        case http1
        /// Indicates use of HTTP/2 to send requests to target
        case http2
        case sdkUnknown(Swift.String)

        public static var allCases: [HealthCheckProtocolVersion] {
            return [
                .http1,
                .http2
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .http1: return "HTTP1"
            case .http2: return "HTTP2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VPCLatticeClientTypes {
    /// Describes the health check configuration of a target group. Health check configurations aren't used for target groups of type LAMBDA or ALB.
    public struct HealthCheckConfig {
        /// Indicates whether health checking is enabled.
        public var enabled: Swift.Bool?
        /// The approximate amount of time, in seconds, between health checks of an individual target. The range is 5–300 seconds. The default is 30 seconds.
        public var healthCheckIntervalSeconds: Swift.Int?
        /// The amount of time, in seconds, to wait before reporting a target as unhealthy. The range is 1–120 seconds. The default is 5 seconds.
        public var healthCheckTimeoutSeconds: Swift.Int?
        /// The number of consecutive successful health checks required before considering an unhealthy target healthy. The range is 2–10. The default is 5.
        public var healthyThresholdCount: Swift.Int?
        /// The codes to use when checking for a successful response from a target.
        public var matcher: VPCLatticeClientTypes.Matcher?
        /// The destination for health checks on the targets. If the protocol version is HTTP/1.1 or HTTP/2, specify a valid URI (for example, /path?query). The default path is /. Health checks are not supported if the protocol version is gRPC, however, you can choose HTTP/1.1 or HTTP/2 and specify a valid URI.
        public var path: Swift.String?
        /// The port used when performing health checks on targets. The default setting is the port that a target receives traffic on.
        public var port: Swift.Int?
        /// The protocol used when performing health checks on targets. The possible protocols are HTTP and HTTPS. The default is HTTP.
        public var `protocol`: VPCLatticeClientTypes.TargetGroupProtocol?
        /// The protocol version used when performing health checks on targets. The possible protocol versions are HTTP1 and HTTP2.
        public var protocolVersion: VPCLatticeClientTypes.HealthCheckProtocolVersion?
        /// The number of consecutive failed health checks required before considering a target unhealthy. The range is 2–10. The default is 2.
        public var unhealthyThresholdCount: Swift.Int?

        public init(
            enabled: Swift.Bool? = nil,
            healthCheckIntervalSeconds: Swift.Int? = nil,
            healthCheckTimeoutSeconds: Swift.Int? = nil,
            healthyThresholdCount: Swift.Int? = nil,
            matcher: VPCLatticeClientTypes.Matcher? = nil,
            path: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: VPCLatticeClientTypes.TargetGroupProtocol? = nil,
            protocolVersion: VPCLatticeClientTypes.HealthCheckProtocolVersion? = nil,
            unhealthyThresholdCount: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.healthCheckIntervalSeconds = healthCheckIntervalSeconds
            self.healthCheckTimeoutSeconds = healthCheckTimeoutSeconds
            self.healthyThresholdCount = healthyThresholdCount
            self.matcher = matcher
            self.path = path
            self.port = port
            self.`protocol` = `protocol`
            self.protocolVersion = protocolVersion
            self.unhealthyThresholdCount = unhealthyThresholdCount
        }
    }

}

extension VPCLatticeClientTypes {

    public enum IpAddressType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Indicates IPv4 address type
        case ipv4
        /// Indicates IPv6 address type
        case ipv6
        case sdkUnknown(Swift.String)

        public static var allCases: [IpAddressType] {
            return [
                .ipv4,
                .ipv6
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ipv4: return "IPV4"
            case .ipv6: return "IPV6"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VPCLatticeClientTypes {

    public enum LambdaEventStructureVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// This is the default lambda event structure version
        case v1
        /// Indicates use of lambda event structure version 2
        case v2
        case sdkUnknown(Swift.String)

        public static var allCases: [LambdaEventStructureVersion] {
            return [
                .v1,
                .v2
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .v1: return "V1"
            case .v2: return "V2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VPCLatticeClientTypes {

    public enum TargetGroupProtocolVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Indicates use of gRPC to send requests to target
        case grpc
        /// Indicates use of HTTP/1.1 to send requests to target
        case http1
        /// Indicates use of HTTP/2 to send requests to target
        case http2
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetGroupProtocolVersion] {
            return [
                .grpc,
                .http1,
                .http2
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .grpc: return "GRPC"
            case .http1: return "HTTP1"
            case .http2: return "HTTP2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VPCLatticeClientTypes {
    /// Describes the configuration of a target group. For more information, see [Target groups](https://docs.aws.amazon.com/vpc-lattice/latest/ug/target-groups.html) in the Amazon VPC Lattice User Guide.
    public struct TargetGroupConfig {
        /// The health check configuration. Not supported if the target group type is LAMBDA or ALB.
        public var healthCheck: VPCLatticeClientTypes.HealthCheckConfig?
        /// The type of IP address used for the target group. Supported only if the target group type is IP. The default is IPV4.
        public var ipAddressType: VPCLatticeClientTypes.IpAddressType?
        /// The version of the event structure that your Lambda function receives. Supported only if the target group type is LAMBDA. The default is V1.
        public var lambdaEventStructureVersion: VPCLatticeClientTypes.LambdaEventStructureVersion?
        /// The port on which the targets are listening. For HTTP, the default is 80. For HTTPS, the default is 443. Not supported if the target group type is LAMBDA.
        public var port: Swift.Int?
        /// The protocol to use for routing traffic to the targets. The default is the protocol of the target group. Not supported if the target group type is LAMBDA.
        public var `protocol`: VPCLatticeClientTypes.TargetGroupProtocol?
        /// The protocol version. The default is HTTP1. Not supported if the target group type is LAMBDA.
        public var protocolVersion: VPCLatticeClientTypes.TargetGroupProtocolVersion?
        /// The ID of the VPC. Not supported if the target group type is LAMBDA.
        public var vpcIdentifier: Swift.String?

        public init(
            healthCheck: VPCLatticeClientTypes.HealthCheckConfig? = nil,
            ipAddressType: VPCLatticeClientTypes.IpAddressType? = nil,
            lambdaEventStructureVersion: VPCLatticeClientTypes.LambdaEventStructureVersion? = nil,
            port: Swift.Int? = nil,
            `protocol`: VPCLatticeClientTypes.TargetGroupProtocol? = nil,
            protocolVersion: VPCLatticeClientTypes.TargetGroupProtocolVersion? = nil,
            vpcIdentifier: Swift.String? = nil
        )
        {
            self.healthCheck = healthCheck
            self.ipAddressType = ipAddressType
            self.lambdaEventStructureVersion = lambdaEventStructureVersion
            self.port = port
            self.`protocol` = `protocol`
            self.protocolVersion = protocolVersion
            self.vpcIdentifier = vpcIdentifier
        }
    }

}

extension VPCLatticeClientTypes {

    public enum TargetGroupType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Indicates target in this target group is an ALB
        case alb
        /// Indicates targets in this target group are EC2 instances
        case instance
        /// Indicates targets in this target group are IP
        case ip
        /// Indicates targets in this target group are Lambda
        case lambda
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetGroupType] {
            return [
                .alb,
                .instance,
                .ip,
                .lambda
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .alb: return "ALB"
            case .instance: return "INSTANCE"
            case .ip: return "IP"
            case .lambda: return "LAMBDA"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateTargetGroupInput {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you retry a request that completed successfully using the same client token and parameters, the retry succeeds without performing any actions. If the parameters aren't identical, the retry fails.
    public var clientToken: Swift.String?
    /// The target group configuration.
    public var config: VPCLatticeClientTypes.TargetGroupConfig?
    /// The name of the target group. The name must be unique within the account. The valid characters are a-z, 0-9, and hyphens (-). You can't use a hyphen as the first or last character, or immediately after another hyphen.
    /// This member is required.
    public var name: Swift.String?
    /// The tags for the target group.
    public var tags: [Swift.String: Swift.String]?
    /// The type of target group.
    /// This member is required.
    public var type: VPCLatticeClientTypes.TargetGroupType?

    public init(
        clientToken: Swift.String? = nil,
        config: VPCLatticeClientTypes.TargetGroupConfig? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        type: VPCLatticeClientTypes.TargetGroupType? = nil
    )
    {
        self.clientToken = clientToken
        self.config = config
        self.name = name
        self.tags = tags
        self.type = type
    }
}

extension VPCLatticeClientTypes {

    public enum TargetGroupStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// TargetGroup is active
        case active
        /// TargetGroup creation failed.
        case createFailed
        /// TargetGroup creation in progress
        case createInProgress
        /// TargetGroup deletion failed
        case deleteFailed
        /// TargetGroup deletion in progress
        case deleteInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetGroupStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .deleteFailed,
                .deleteInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateTargetGroupOutput {
    /// The Amazon Resource Name (ARN) of the target group.
    public var arn: Swift.String?
    /// The target group configuration.
    public var config: VPCLatticeClientTypes.TargetGroupConfig?
    /// The ID of the target group.
    public var id: Swift.String?
    /// The name of the target group.
    public var name: Swift.String?
    /// The status. You can retry the operation if the status is CREATE_FAILED. However, if you retry it while the status is CREATE_IN_PROGRESS, there is no change in the status.
    public var status: VPCLatticeClientTypes.TargetGroupStatus?
    /// The type of target group.
    public var type: VPCLatticeClientTypes.TargetGroupType?

    public init(
        arn: Swift.String? = nil,
        config: VPCLatticeClientTypes.TargetGroupConfig? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: VPCLatticeClientTypes.TargetGroupStatus? = nil,
        type: VPCLatticeClientTypes.TargetGroupType? = nil
    )
    {
        self.arn = arn
        self.config = config
        self.id = id
        self.name = name
        self.status = status
        self.type = type
    }
}

public struct DeleteAuthPolicyInput {
    /// The ID or Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceIdentifier: Swift.String?

    public init(
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
    }
}

public struct DeleteAuthPolicyOutput {

    public init() { }
}

public struct DeleteListenerInput {
    /// The ID or Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        listenerIdentifier: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.listenerIdentifier = listenerIdentifier
        self.serviceIdentifier = serviceIdentifier
    }
}

public struct DeleteListenerOutput {

    public init() { }
}

public struct DeleteResourcePolicyInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct DeleteResourcePolicyOutput {

    public init() { }
}

public struct DeleteRuleInput {
    /// The ID or Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the rule.
    /// This member is required.
    public var ruleIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        listenerIdentifier: Swift.String? = nil,
        ruleIdentifier: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.listenerIdentifier = listenerIdentifier
        self.ruleIdentifier = ruleIdentifier
        self.serviceIdentifier = serviceIdentifier
    }
}

public struct DeleteRuleOutput {

    public init() { }
}

public struct DeleteServiceInput {
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.serviceIdentifier = serviceIdentifier
    }
}

public struct DeleteServiceOutput {
    /// The Amazon Resource Name (ARN) of the service.
    public var arn: Swift.String?
    /// The ID of the service.
    public var id: Swift.String?
    /// The name of the service.
    public var name: Swift.String?
    /// The status. You can retry the operation if the status is DELETE_FAILED. However, if you retry it while the status is DELETE_IN_PROGRESS, the status doesn't change.
    public var status: VPCLatticeClientTypes.ServiceStatus?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceStatus? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.name = name
        self.status = status
    }
}

public struct DeleteServiceNetworkInput {
    /// The Amazon Resource Name (ARN) or ID of the service network.
    /// This member is required.
    public var serviceNetworkIdentifier: Swift.String?

    public init(
        serviceNetworkIdentifier: Swift.String? = nil
    )
    {
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
    }
}

public struct DeleteServiceNetworkOutput {

    public init() { }
}

public struct DeleteServiceNetworkServiceAssociationInput {
    /// The ID or Amazon Resource Name (ARN) of the association.
    /// This member is required.
    public var serviceNetworkServiceAssociationIdentifier: Swift.String?

    public init(
        serviceNetworkServiceAssociationIdentifier: Swift.String? = nil
    )
    {
        self.serviceNetworkServiceAssociationIdentifier = serviceNetworkServiceAssociationIdentifier
    }
}

public struct DeleteServiceNetworkServiceAssociationOutput {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The ID of the association.
    public var id: Swift.String?
    /// The status. You can retry the operation if the status is DELETE_FAILED. However, if you retry it when the status is DELETE_IN_PROGRESS, there is no change in the status.
    public var status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.status = status
    }
}

public struct DeleteServiceNetworkVpcAssociationInput {
    /// The ID or Amazon Resource Name (ARN) of the association.
    /// This member is required.
    public var serviceNetworkVpcAssociationIdentifier: Swift.String?

    public init(
        serviceNetworkVpcAssociationIdentifier: Swift.String? = nil
    )
    {
        self.serviceNetworkVpcAssociationIdentifier = serviceNetworkVpcAssociationIdentifier
    }
}

public struct DeleteServiceNetworkVpcAssociationOutput {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The ID of the association.
    public var id: Swift.String?
    /// The status. You can retry the operation if the status is DELETE_FAILED. However, if you retry it while the status is DELETE_IN_PROGRESS, there is no change in the status.
    public var status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.status = status
    }
}

public struct DeleteTargetGroupInput {
    /// The ID or Amazon Resource Name (ARN) of the target group.
    /// This member is required.
    public var targetGroupIdentifier: Swift.String?

    public init(
        targetGroupIdentifier: Swift.String? = nil
    )
    {
        self.targetGroupIdentifier = targetGroupIdentifier
    }
}

public struct DeleteTargetGroupOutput {
    /// The Amazon Resource Name (ARN) of the target group.
    public var arn: Swift.String?
    /// The ID of the target group.
    public var id: Swift.String?
    /// The status. You can retry the operation if the status is DELETE_FAILED. However, if you retry it while the status is DELETE_IN_PROGRESS, the status doesn't change.
    public var status: VPCLatticeClientTypes.TargetGroupStatus?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        status: VPCLatticeClientTypes.TargetGroupStatus? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.status = status
    }
}

extension VPCLatticeClientTypes {
    /// Describes a target.
    public struct Target {
        /// The ID of the target. If the target group type is INSTANCE, this is an instance ID. If the target group type is IP, this is an IP address. If the target group type is LAMBDA, this is the ARN of a Lambda function. If the target group type is ALB, this is the ARN of an Application Load Balancer.
        /// This member is required.
        public var id: Swift.String?
        /// The port on which the target is listening. For HTTP, the default is 80. For HTTPS, the default is 443.
        public var port: Swift.Int?

        public init(
            id: Swift.String? = nil,
            port: Swift.Int? = nil
        )
        {
            self.id = id
            self.port = port
        }
    }

}

public struct DeregisterTargetsInput {
    /// The ID or Amazon Resource Name (ARN) of the target group.
    /// This member is required.
    public var targetGroupIdentifier: Swift.String?
    /// The targets to deregister.
    /// This member is required.
    public var targets: [VPCLatticeClientTypes.Target]?

    public init(
        targetGroupIdentifier: Swift.String? = nil,
        targets: [VPCLatticeClientTypes.Target]? = nil
    )
    {
        self.targetGroupIdentifier = targetGroupIdentifier
        self.targets = targets
    }
}

extension VPCLatticeClientTypes {
    /// Describes a target failure.
    public struct TargetFailure {
        /// The failure code.
        public var failureCode: Swift.String?
        /// The failure message.
        public var failureMessage: Swift.String?
        /// The ID of the target. If the target group type is INSTANCE, this is an instance ID. If the target group type is IP, this is an IP address. If the target group type is LAMBDA, this is the ARN of a Lambda function. If the target group type is ALB, this is the ARN of an Application Load Balancer.
        public var id: Swift.String?
        /// The port on which the target is listening. This parameter doesn't apply if the target is a Lambda function.
        public var port: Swift.Int?

        public init(
            failureCode: Swift.String? = nil,
            failureMessage: Swift.String? = nil,
            id: Swift.String? = nil,
            port: Swift.Int? = nil
        )
        {
            self.failureCode = failureCode
            self.failureMessage = failureMessage
            self.id = id
            self.port = port
        }
    }

}

public struct DeregisterTargetsOutput {
    /// The targets that were successfully deregistered.
    public var successful: [VPCLatticeClientTypes.Target]?
    /// The targets that the operation couldn't deregister.
    public var unsuccessful: [VPCLatticeClientTypes.TargetFailure]?

    public init(
        successful: [VPCLatticeClientTypes.Target]? = nil,
        unsuccessful: [VPCLatticeClientTypes.TargetFailure]? = nil
    )
    {
        self.successful = successful
        self.unsuccessful = unsuccessful
    }
}

public struct GetAuthPolicyInput {
    /// The ID or Amazon Resource Name (ARN) of the service network or service.
    /// This member is required.
    public var resourceIdentifier: Swift.String?

    public init(
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
    }
}

public struct GetAuthPolicyOutput {
    /// The date and time that the auth policy was created, specified in ISO-8601 format.
    public var createdAt: Foundation.Date?
    /// The date and time that the auth policy was last updated, specified in ISO-8601 format.
    public var lastUpdatedAt: Foundation.Date?
    /// The auth policy.
    public var policy: Swift.String?
    /// The state of the auth policy. The auth policy is only active when the auth type is set to AWS_IAM. If you provide a policy, then authentication and authorization decisions are made based on this policy and the client's IAM policy. If the auth type is NONE, then any auth policy that you provide remains inactive. For more information, see [Create a service network](https://docs.aws.amazon.com/vpc-lattice/latest/ug/service-networks.html#create-service-network) in the Amazon VPC Lattice User Guide.
    public var state: VPCLatticeClientTypes.AuthPolicyState?

    public init(
        createdAt: Foundation.Date? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        policy: Swift.String? = nil,
        state: VPCLatticeClientTypes.AuthPolicyState? = nil
    )
    {
        self.createdAt = createdAt
        self.lastUpdatedAt = lastUpdatedAt
        self.policy = policy
        self.state = state
    }
}

public struct GetListenerInput {
    /// The ID or Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        listenerIdentifier: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.listenerIdentifier = listenerIdentifier
        self.serviceIdentifier = serviceIdentifier
    }
}

public struct GetListenerOutput {
    /// The Amazon Resource Name (ARN) of the listener.
    public var arn: Swift.String?
    /// The date and time that the listener was created, specified in ISO-8601 format.
    public var createdAt: Foundation.Date?
    /// The actions for the default listener rule.
    public var defaultAction: VPCLatticeClientTypes.RuleAction?
    /// The ID of the listener.
    public var id: Swift.String?
    /// The date and time that the listener was last updated, specified in ISO-8601 format.
    public var lastUpdatedAt: Foundation.Date?
    /// The name of the listener.
    public var name: Swift.String?
    /// The listener port.
    public var port: Swift.Int?
    /// The listener protocol.
    public var `protocol`: VPCLatticeClientTypes.ListenerProtocol?
    /// The Amazon Resource Name (ARN) of the service.
    public var serviceArn: Swift.String?
    /// The ID of the service.
    public var serviceId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        defaultAction: VPCLatticeClientTypes.RuleAction? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        port: Swift.Int? = nil,
        `protocol`: VPCLatticeClientTypes.ListenerProtocol? = nil,
        serviceArn: Swift.String? = nil,
        serviceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.defaultAction = defaultAction
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.port = port
        self.`protocol` = `protocol`
        self.serviceArn = serviceArn
        self.serviceId = serviceId
    }
}

public struct GetResourcePolicyInput {
    /// The Amazon Resource Name (ARN) of the service network or service.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct GetResourcePolicyOutput {
    /// An IAM policy.
    public var policy: Swift.String?

    public init(
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

public struct GetRuleInput {
    /// The ID or Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the listener rule.
    /// This member is required.
    public var ruleIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        listenerIdentifier: Swift.String? = nil,
        ruleIdentifier: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.listenerIdentifier = listenerIdentifier
        self.ruleIdentifier = ruleIdentifier
        self.serviceIdentifier = serviceIdentifier
    }
}

public struct GetRuleOutput {
    /// The action for the default rule.
    public var action: VPCLatticeClientTypes.RuleAction?
    /// The Amazon Resource Name (ARN) of the listener.
    public var arn: Swift.String?
    /// The date and time that the listener rule was created, specified in ISO-8601 format.
    public var createdAt: Foundation.Date?
    /// The ID of the listener.
    public var id: Swift.String?
    /// Indicates whether this is the default rule.
    public var isDefault: Swift.Bool?
    /// The date and time that the listener rule was last updated, specified in ISO-8601 format.
    public var lastUpdatedAt: Foundation.Date?
    /// The rule match.
    public var match: VPCLatticeClientTypes.RuleMatch?
    /// The name of the listener.
    public var name: Swift.String?
    /// The priority level for the specified rule.
    public var priority: Swift.Int?

    public init(
        action: VPCLatticeClientTypes.RuleAction? = nil,
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        id: Swift.String? = nil,
        isDefault: Swift.Bool? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        match: VPCLatticeClientTypes.RuleMatch? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil
    )
    {
        self.action = action
        self.arn = arn
        self.createdAt = createdAt
        self.id = id
        self.isDefault = isDefault
        self.lastUpdatedAt = lastUpdatedAt
        self.match = match
        self.name = name
        self.priority = priority
    }
}

public struct GetServiceInput {
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.serviceIdentifier = serviceIdentifier
    }
}

public struct GetServiceOutput {
    /// The Amazon Resource Name (ARN) of the service.
    public var arn: Swift.String?
    /// The type of IAM policy.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The Amazon Resource Name (ARN) of the certificate.
    public var certificateArn: Swift.String?
    /// The date and time that the service was created, specified in ISO-8601 format.
    public var createdAt: Foundation.Date?
    /// The custom domain name of the service.
    public var customDomainName: Swift.String?
    /// The DNS name of the service.
    public var dnsEntry: VPCLatticeClientTypes.DnsEntry?
    /// The failure code.
    public var failureCode: Swift.String?
    /// The failure message.
    public var failureMessage: Swift.String?
    /// The ID of the service.
    public var id: Swift.String?
    /// The date and time that the service was last updated, specified in ISO-8601 format.
    public var lastUpdatedAt: Foundation.Date?
    /// The name of the service.
    public var name: Swift.String?
    /// The status of the service.
    public var status: VPCLatticeClientTypes.ServiceStatus?

    public init(
        arn: Swift.String? = nil,
        authType: VPCLatticeClientTypes.AuthType? = nil,
        certificateArn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        customDomainName: Swift.String? = nil,
        dnsEntry: VPCLatticeClientTypes.DnsEntry? = nil,
        failureCode: Swift.String? = nil,
        failureMessage: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceStatus? = nil
    )
    {
        self.arn = arn
        self.authType = authType
        self.certificateArn = certificateArn
        self.createdAt = createdAt
        self.customDomainName = customDomainName
        self.dnsEntry = dnsEntry
        self.failureCode = failureCode
        self.failureMessage = failureMessage
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.status = status
    }
}

public struct GetServiceNetworkInput {
    /// The ID or Amazon Resource Name (ARN) of the service network.
    /// This member is required.
    public var serviceNetworkIdentifier: Swift.String?

    public init(
        serviceNetworkIdentifier: Swift.String? = nil
    )
    {
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
    }
}

public struct GetServiceNetworkOutput {
    /// The Amazon Resource Name (ARN) of the service network.
    public var arn: Swift.String?
    /// The type of IAM policy.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The date and time that the service network was created, specified in ISO-8601 format.
    public var createdAt: Foundation.Date?
    /// The ID of the service network.
    public var id: Swift.String?
    /// The date and time of the last update, specified in ISO-8601 format.
    public var lastUpdatedAt: Foundation.Date?
    /// The name of the service network.
    public var name: Swift.String?
    /// The number of services associated with the service network.
    public var numberOfAssociatedServices: Swift.Int?
    /// The number of VPCs associated with the service network.
    public var numberOfAssociatedVPCs: Swift.Int?

    public init(
        arn: Swift.String? = nil,
        authType: VPCLatticeClientTypes.AuthType? = nil,
        createdAt: Foundation.Date? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        numberOfAssociatedServices: Swift.Int? = nil,
        numberOfAssociatedVPCs: Swift.Int? = nil
    )
    {
        self.arn = arn
        self.authType = authType
        self.createdAt = createdAt
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.numberOfAssociatedServices = numberOfAssociatedServices
        self.numberOfAssociatedVPCs = numberOfAssociatedVPCs
    }
}

public struct GetServiceNetworkServiceAssociationInput {
    /// The ID or Amazon Resource Name (ARN) of the association.
    /// This member is required.
    public var serviceNetworkServiceAssociationIdentifier: Swift.String?

    public init(
        serviceNetworkServiceAssociationIdentifier: Swift.String? = nil
    )
    {
        self.serviceNetworkServiceAssociationIdentifier = serviceNetworkServiceAssociationIdentifier
    }
}

public struct GetServiceNetworkServiceAssociationOutput {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The date and time that the association was created, specified in ISO-8601 format.
    public var createdAt: Foundation.Date?
    /// The account that created the association.
    public var createdBy: Swift.String?
    /// The custom domain name of the service.
    public var customDomainName: Swift.String?
    /// The DNS name of the service.
    public var dnsEntry: VPCLatticeClientTypes.DnsEntry?
    /// The failure code.
    public var failureCode: Swift.String?
    /// The failure message.
    public var failureMessage: Swift.String?
    /// The ID of the service network and service association.
    public var id: Swift.String?
    /// The Amazon Resource Name (ARN) of the service.
    public var serviceArn: Swift.String?
    /// The ID of the service.
    public var serviceId: Swift.String?
    /// The name of the service.
    public var serviceName: Swift.String?
    /// The Amazon Resource Name (ARN) of the service network.
    public var serviceNetworkArn: Swift.String?
    /// The ID of the service network.
    public var serviceNetworkId: Swift.String?
    /// The name of the service network.
    public var serviceNetworkName: Swift.String?
    /// The status of the association.
    public var status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        customDomainName: Swift.String? = nil,
        dnsEntry: VPCLatticeClientTypes.DnsEntry? = nil,
        failureCode: Swift.String? = nil,
        failureMessage: Swift.String? = nil,
        id: Swift.String? = nil,
        serviceArn: Swift.String? = nil,
        serviceId: Swift.String? = nil,
        serviceName: Swift.String? = nil,
        serviceNetworkArn: Swift.String? = nil,
        serviceNetworkId: Swift.String? = nil,
        serviceNetworkName: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.customDomainName = customDomainName
        self.dnsEntry = dnsEntry
        self.failureCode = failureCode
        self.failureMessage = failureMessage
        self.id = id
        self.serviceArn = serviceArn
        self.serviceId = serviceId
        self.serviceName = serviceName
        self.serviceNetworkArn = serviceNetworkArn
        self.serviceNetworkId = serviceNetworkId
        self.serviceNetworkName = serviceNetworkName
        self.status = status
    }
}

public struct GetServiceNetworkVpcAssociationInput {
    /// The ID or Amazon Resource Name (ARN) of the association.
    /// This member is required.
    public var serviceNetworkVpcAssociationIdentifier: Swift.String?

    public init(
        serviceNetworkVpcAssociationIdentifier: Swift.String? = nil
    )
    {
        self.serviceNetworkVpcAssociationIdentifier = serviceNetworkVpcAssociationIdentifier
    }
}

public struct GetServiceNetworkVpcAssociationOutput {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The date and time that the association was created, specified in ISO-8601 format.
    public var createdAt: Foundation.Date?
    /// The account that created the association.
    public var createdBy: Swift.String?
    /// The failure code.
    public var failureCode: Swift.String?
    /// The failure message.
    public var failureMessage: Swift.String?
    /// The ID of the specified association between the service network and the VPC.
    public var id: Swift.String?
    /// The date and time that the association was last updated, specified in ISO-8601 format.
    public var lastUpdatedAt: Foundation.Date?
    /// The IDs of the security groups.
    public var securityGroupIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the service network.
    public var serviceNetworkArn: Swift.String?
    /// The ID of the service network.
    public var serviceNetworkId: Swift.String?
    /// The name of the service network.
    public var serviceNetworkName: Swift.String?
    /// The status of the association.
    public var status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus?
    /// The ID of the VPC.
    public var vpcId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        failureCode: Swift.String? = nil,
        failureMessage: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        securityGroupIds: [Swift.String]? = nil,
        serviceNetworkArn: Swift.String? = nil,
        serviceNetworkId: Swift.String? = nil,
        serviceNetworkName: Swift.String? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.failureCode = failureCode
        self.failureMessage = failureMessage
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.securityGroupIds = securityGroupIds
        self.serviceNetworkArn = serviceNetworkArn
        self.serviceNetworkId = serviceNetworkId
        self.serviceNetworkName = serviceNetworkName
        self.status = status
        self.vpcId = vpcId
    }
}

public struct GetTargetGroupInput {
    /// The ID or Amazon Resource Name (ARN) of the target group.
    /// This member is required.
    public var targetGroupIdentifier: Swift.String?

    public init(
        targetGroupIdentifier: Swift.String? = nil
    )
    {
        self.targetGroupIdentifier = targetGroupIdentifier
    }
}

public struct GetTargetGroupOutput {
    /// The Amazon Resource Name (ARN) of the target group.
    public var arn: Swift.String?
    /// The target group configuration.
    public var config: VPCLatticeClientTypes.TargetGroupConfig?
    /// The date and time that the target group was created, specified in ISO-8601 format.
    public var createdAt: Foundation.Date?
    /// The failure code.
    public var failureCode: Swift.String?
    /// The failure message.
    public var failureMessage: Swift.String?
    /// The ID of the target group.
    public var id: Swift.String?
    /// The date and time that the target group was last updated, specified in ISO-8601 format.
    public var lastUpdatedAt: Foundation.Date?
    /// The name of the target group.
    public var name: Swift.String?
    /// The Amazon Resource Names (ARNs) of the service.
    public var serviceArns: [Swift.String]?
    /// The status.
    public var status: VPCLatticeClientTypes.TargetGroupStatus?
    /// The target group type.
    public var type: VPCLatticeClientTypes.TargetGroupType?

    public init(
        arn: Swift.String? = nil,
        config: VPCLatticeClientTypes.TargetGroupConfig? = nil,
        createdAt: Foundation.Date? = nil,
        failureCode: Swift.String? = nil,
        failureMessage: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        serviceArns: [Swift.String]? = nil,
        status: VPCLatticeClientTypes.TargetGroupStatus? = nil,
        type: VPCLatticeClientTypes.TargetGroupType? = nil
    )
    {
        self.arn = arn
        self.config = config
        self.createdAt = createdAt
        self.failureCode = failureCode
        self.failureMessage = failureMessage
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
        self.serviceArns = serviceArns
        self.status = status
        self.type = type
    }
}

public struct ListListenersInput {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceIdentifier = serviceIdentifier
    }
}

extension VPCLatticeClientTypes {
    /// Summary information about a listener.
    public struct ListenerSummary {
        /// The Amazon Resource Name (ARN) of the listener.
        public var arn: Swift.String?
        /// The date and time that the listener was created, specified in ISO-8601 format.
        public var createdAt: Foundation.Date?
        /// The ID of the listener.
        public var id: Swift.String?
        /// The date and time that the listener was last updated, specified in ISO-8601 format.
        public var lastUpdatedAt: Foundation.Date?
        /// The name of the listener.
        public var name: Swift.String?
        /// The listener port.
        public var port: Swift.Int?
        /// The listener protocol.
        public var `protocol`: VPCLatticeClientTypes.ListenerProtocol?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: VPCLatticeClientTypes.ListenerProtocol? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.port = port
            self.`protocol` = `protocol`
        }
    }

}

public struct ListListenersOutput {
    /// Information about the listeners.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.ListenerSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.ListenerSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct UpdateListenerInput {
    /// The action for the default rule.
    /// This member is required.
    public var defaultAction: VPCLatticeClientTypes.RuleAction?
    /// The ID or Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        defaultAction: VPCLatticeClientTypes.RuleAction? = nil,
        listenerIdentifier: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.defaultAction = defaultAction
        self.listenerIdentifier = listenerIdentifier
        self.serviceIdentifier = serviceIdentifier
    }
}

public struct UpdateListenerOutput {
    /// The Amazon Resource Name (ARN) of the listener.
    public var arn: Swift.String?
    /// The action for the default rule.
    public var defaultAction: VPCLatticeClientTypes.RuleAction?
    /// The ID of the listener.
    public var id: Swift.String?
    /// The name of the listener.
    public var name: Swift.String?
    /// The listener port.
    public var port: Swift.Int?
    /// The protocol of the listener.
    public var `protocol`: VPCLatticeClientTypes.ListenerProtocol?
    /// The Amazon Resource Name (ARN) of the service.
    public var serviceArn: Swift.String?
    /// The ID of the service.
    public var serviceId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        defaultAction: VPCLatticeClientTypes.RuleAction? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        port: Swift.Int? = nil,
        `protocol`: VPCLatticeClientTypes.ListenerProtocol? = nil,
        serviceArn: Swift.String? = nil,
        serviceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.defaultAction = defaultAction
        self.id = id
        self.name = name
        self.port = port
        self.`protocol` = `protocol`
        self.serviceArn = serviceArn
        self.serviceId = serviceId
    }
}

public struct ListRulesInput {
    /// The ID or Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        listenerIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.listenerIdentifier = listenerIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceIdentifier = serviceIdentifier
    }
}

extension VPCLatticeClientTypes {
    /// Summary information about the listener rule.
    public struct RuleSummary {
        /// The Amazon Resource Name (ARN) of the rule.
        public var arn: Swift.String?
        /// The date and time that the listener rule was created, specified in ISO-8601 format.
        public var createdAt: Foundation.Date?
        /// The ID of the rule.
        public var id: Swift.String?
        /// Indicates whether this is the default listener rule.
        public var isDefault: Swift.Bool?
        /// The date and time that the listener rule was last updated, specified in ISO-8601 format.
        public var lastUpdatedAt: Foundation.Date?
        /// The name of the rule.
        public var name: Swift.String?
        /// The priority of the rule.
        public var priority: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            id: Swift.String? = nil,
            isDefault: Swift.Bool? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            priority: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.isDefault = isDefault
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.priority = priority
        }
    }

}

public struct ListRulesOutput {
    /// Information about the rules.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.RuleSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.RuleSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListServiceNetworksInput {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension VPCLatticeClientTypes {
    /// Summary information about a service network.
    public struct ServiceNetworkSummary {
        /// The Amazon Resource Name (ARN) of the service network.
        public var arn: Swift.String?
        /// The date and time that the service network was created, specified in ISO-8601 format.
        public var createdAt: Foundation.Date?
        /// The ID of the service network.
        public var id: Swift.String?
        /// The date and time that the service network was last updated, specified in ISO-8601 format.
        public var lastUpdatedAt: Foundation.Date?
        /// The name of the service network.
        public var name: Swift.String?
        /// The number of services associated with the service network.
        public var numberOfAssociatedServices: Swift.Int?
        /// The number of VPCs associated with the service network.
        public var numberOfAssociatedVPCs: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            numberOfAssociatedServices: Swift.Int? = nil,
            numberOfAssociatedVPCs: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.numberOfAssociatedServices = numberOfAssociatedServices
            self.numberOfAssociatedVPCs = numberOfAssociatedVPCs
        }
    }

}

public struct ListServiceNetworksOutput {
    /// Information about the service networks.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.ServiceNetworkSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.ServiceNetworkSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListServiceNetworkServiceAssociationsInput {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    public var serviceIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service network.
    public var serviceNetworkIdentifier: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil,
        serviceNetworkIdentifier: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceIdentifier = serviceIdentifier
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
    }
}

extension VPCLatticeClientTypes {
    /// Summary information about the association between a service network and a service.
    public struct ServiceNetworkServiceAssociationSummary {
        /// The Amazon Resource Name (ARN) of the association.
        public var arn: Swift.String?
        /// The date and time that the association was created, specified in ISO-8601 format.
        public var createdAt: Foundation.Date?
        /// The account that created the association.
        public var createdBy: Swift.String?
        /// The custom domain name of the service.
        public var customDomainName: Swift.String?
        /// The DNS information.
        public var dnsEntry: VPCLatticeClientTypes.DnsEntry?
        /// The ID of the association.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of the service.
        public var serviceArn: Swift.String?
        /// The ID of the service.
        public var serviceId: Swift.String?
        /// The name of the service.
        public var serviceName: Swift.String?
        /// The Amazon Resource Name (ARN) of the service network.
        public var serviceNetworkArn: Swift.String?
        /// The ID of the service network.
        public var serviceNetworkId: Swift.String?
        /// The name of the service network.
        public var serviceNetworkName: Swift.String?
        /// The status. If the deletion fails, try to delete again.
        public var status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            customDomainName: Swift.String? = nil,
            dnsEntry: VPCLatticeClientTypes.DnsEntry? = nil,
            id: Swift.String? = nil,
            serviceArn: Swift.String? = nil,
            serviceId: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            serviceNetworkArn: Swift.String? = nil,
            serviceNetworkId: Swift.String? = nil,
            serviceNetworkName: Swift.String? = nil,
            status: VPCLatticeClientTypes.ServiceNetworkServiceAssociationStatus? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.customDomainName = customDomainName
            self.dnsEntry = dnsEntry
            self.id = id
            self.serviceArn = serviceArn
            self.serviceId = serviceId
            self.serviceName = serviceName
            self.serviceNetworkArn = serviceNetworkArn
            self.serviceNetworkId = serviceNetworkId
            self.serviceNetworkName = serviceNetworkName
            self.status = status
        }
    }

}

public struct ListServiceNetworkServiceAssociationsOutput {
    /// Information about the associations.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.ServiceNetworkServiceAssociationSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.ServiceNetworkServiceAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListServiceNetworkVpcAssociationsInput {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service network.
    public var serviceNetworkIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the VPC.
    public var vpcIdentifier: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceNetworkIdentifier: Swift.String? = nil,
        vpcIdentifier: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
        self.vpcIdentifier = vpcIdentifier
    }
}

extension VPCLatticeClientTypes {
    /// Summary information about an association between a service network and a VPC.
    public struct ServiceNetworkVpcAssociationSummary {
        /// The Amazon Resource Name (ARN) of the association.
        public var arn: Swift.String?
        /// The date and time that the association was created, specified in ISO-8601 format.
        public var createdAt: Foundation.Date?
        /// The account that created the association.
        public var createdBy: Swift.String?
        /// The ID of the association.
        public var id: Swift.String?
        /// The date and time that the association was last updated, specified in ISO-8601 format.
        public var lastUpdatedAt: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the service network.
        public var serviceNetworkArn: Swift.String?
        /// The ID of the service network.
        public var serviceNetworkId: Swift.String?
        /// The name of the service network.
        public var serviceNetworkName: Swift.String?
        /// The status.
        public var status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus?
        /// The ID of the VPC.
        public var vpcId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            serviceNetworkArn: Swift.String? = nil,
            serviceNetworkId: Swift.String? = nil,
            serviceNetworkName: Swift.String? = nil,
            status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.serviceNetworkArn = serviceNetworkArn
            self.serviceNetworkId = serviceNetworkId
            self.serviceNetworkName = serviceNetworkName
            self.status = status
            self.vpcId = vpcId
        }
    }

}

public struct ListServiceNetworkVpcAssociationsOutput {
    /// Information about the associations.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.ServiceNetworkVpcAssociationSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.ServiceNetworkVpcAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListServicesInput {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension VPCLatticeClientTypes {
    /// Summary information about a service.
    public struct ServiceSummary {
        /// The Amazon Resource Name (ARN) of the service.
        public var arn: Swift.String?
        /// The date and time that the service was created, specified in ISO-8601 format.
        public var createdAt: Foundation.Date?
        /// The custom domain name of the service.
        public var customDomainName: Swift.String?
        /// The DNS information.
        public var dnsEntry: VPCLatticeClientTypes.DnsEntry?
        /// The ID of the service.
        public var id: Swift.String?
        /// The date and time that the service was last updated. The format is ISO-8601.
        public var lastUpdatedAt: Foundation.Date?
        /// The name of the service.
        public var name: Swift.String?
        /// The status.
        public var status: VPCLatticeClientTypes.ServiceStatus?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            customDomainName: Swift.String? = nil,
            dnsEntry: VPCLatticeClientTypes.DnsEntry? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            status: VPCLatticeClientTypes.ServiceStatus? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.customDomainName = customDomainName
            self.dnsEntry = dnsEntry
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.status = status
        }
    }

}

public struct ListServicesOutput {
    /// Information about the services.
    public var items: [VPCLatticeClientTypes.ServiceSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.ServiceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// Information about the tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct ListTargetGroupsInput {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The target group type.
    public var targetGroupType: VPCLatticeClientTypes.TargetGroupType?
    /// The ID or Amazon Resource Name (ARN) of the VPC.
    public var vpcIdentifier: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        targetGroupType: VPCLatticeClientTypes.TargetGroupType? = nil,
        vpcIdentifier: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.targetGroupType = targetGroupType
        self.vpcIdentifier = vpcIdentifier
    }
}

extension VPCLatticeClientTypes {
    /// Summary information about a target group. For more information, see [Target groups](https://docs.aws.amazon.com/vpc-lattice/latest/ug/target-groups.html) in the Amazon VPC Lattice User Guide.
    public struct TargetGroupSummary {
        /// The ARN (Amazon Resource Name) of the target group.
        public var arn: Swift.String?
        /// The date and time that the target group was created, specified in ISO-8601 format.
        public var createdAt: Foundation.Date?
        /// The ID of the target group.
        public var id: Swift.String?
        /// The type of IP address used for the target group. The possible values are IPV4 and IPV6. This is an optional parameter. If not specified, the default is IPV4.
        public var ipAddressType: VPCLatticeClientTypes.IpAddressType?
        /// The version of the event structure that your Lambda function receives. Supported only if the target group type is LAMBDA.
        public var lambdaEventStructureVersion: VPCLatticeClientTypes.LambdaEventStructureVersion?
        /// The date and time that the target group was last updated, specified in ISO-8601 format.
        public var lastUpdatedAt: Foundation.Date?
        /// The name of the target group.
        public var name: Swift.String?
        /// The port of the target group.
        public var port: Swift.Int?
        /// The protocol of the target group.
        public var `protocol`: VPCLatticeClientTypes.TargetGroupProtocol?
        /// The Amazon Resource Names (ARNs) of the service.
        public var serviceArns: [Swift.String]?
        /// The status.
        public var status: VPCLatticeClientTypes.TargetGroupStatus?
        /// The target group type.
        public var type: VPCLatticeClientTypes.TargetGroupType?
        /// The ID of the VPC of the target group.
        public var vpcIdentifier: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            id: Swift.String? = nil,
            ipAddressType: VPCLatticeClientTypes.IpAddressType? = nil,
            lambdaEventStructureVersion: VPCLatticeClientTypes.LambdaEventStructureVersion? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: VPCLatticeClientTypes.TargetGroupProtocol? = nil,
            serviceArns: [Swift.String]? = nil,
            status: VPCLatticeClientTypes.TargetGroupStatus? = nil,
            type: VPCLatticeClientTypes.TargetGroupType? = nil,
            vpcIdentifier: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.ipAddressType = ipAddressType
            self.lambdaEventStructureVersion = lambdaEventStructureVersion
            self.lastUpdatedAt = lastUpdatedAt
            self.name = name
            self.port = port
            self.`protocol` = `protocol`
            self.serviceArns = serviceArns
            self.status = status
            self.type = type
            self.vpcIdentifier = vpcIdentifier
        }
    }

}

public struct ListTargetGroupsOutput {
    /// Information about the target groups.
    public var items: [VPCLatticeClientTypes.TargetGroupSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.TargetGroupSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListTargetsInput {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// A pagination token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the target group.
    /// This member is required.
    public var targetGroupIdentifier: Swift.String?
    /// The targets.
    public var targets: [VPCLatticeClientTypes.Target]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        targetGroupIdentifier: Swift.String? = nil,
        targets: [VPCLatticeClientTypes.Target]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.targetGroupIdentifier = targetGroupIdentifier
        self.targets = targets
    }
}

extension VPCLatticeClientTypes {

    public enum TargetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// The target is deregistering and connection draining is in process.
        case draining
        /// The target is healthy.
        case healthy
        /// The initial health check is in progress.
        case initial
        /// Health checks are disabled.
        case unavailable
        /// The target failed the health check.
        case unhealthy
        /// The target group is not used in a listener rule.
        case unused
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetStatus] {
            return [
                .draining,
                .healthy,
                .initial,
                .unavailable,
                .unhealthy,
                .unused
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .draining: return "DRAINING"
            case .healthy: return "HEALTHY"
            case .initial: return "INITIAL"
            case .unavailable: return "UNAVAILABLE"
            case .unhealthy: return "UNHEALTHY"
            case .unused: return "UNUSED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VPCLatticeClientTypes {
    /// Summary information about a target.
    public struct TargetSummary {
        /// The ID of the target. If the target group type is INSTANCE, this is an instance ID. If the target group type is IP, this is an IP address. If the target group type is LAMBDA, this is the ARN of a Lambda function. If the target type is ALB, this is the ARN of an Application Load Balancer.
        public var id: Swift.String?
        /// The port on which the target is listening.
        public var port: Swift.Int?
        /// The code for why the target status is what it is.
        public var reasonCode: Swift.String?
        /// The status of the target.
        ///
        /// * DRAINING: The target is being deregistered. No new connections are sent to this target while current connections are being drained. The default draining time is 5 minutes.
        ///
        /// * UNAVAILABLE: Health checks are unavailable for the target group.
        ///
        /// * HEALTHY: The target is healthy.
        ///
        /// * UNHEALTHY: The target is unhealthy.
        ///
        /// * INITIAL: Initial health checks on the target are being performed.
        ///
        /// * UNUSED: Target group is not used in a service.
        public var status: VPCLatticeClientTypes.TargetStatus?

        public init(
            id: Swift.String? = nil,
            port: Swift.Int? = nil,
            reasonCode: Swift.String? = nil,
            status: VPCLatticeClientTypes.TargetStatus? = nil
        )
        {
            self.id = id
            self.port = port
            self.reasonCode = reasonCode
            self.status = status
        }
    }

}

public struct ListTargetsOutput {
    /// Information about the targets.
    /// This member is required.
    public var items: [VPCLatticeClientTypes.TargetSummary]?
    /// If there are additional results, a pagination token for the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [VPCLatticeClientTypes.TargetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct PutAuthPolicyInput {
    /// The auth policy. The policy string in JSON must not contain newlines or blank lines.
    /// This member is required.
    public var policy: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service network or service for which the policy is created.
    /// This member is required.
    public var resourceIdentifier: Swift.String?

    public init(
        policy: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil
    )
    {
        self.policy = policy
        self.resourceIdentifier = resourceIdentifier
    }
}

public struct PutAuthPolicyOutput {
    /// The auth policy. The policy string in JSON must not contain newlines or blank lines.
    public var policy: Swift.String?
    /// The state of the auth policy. The auth policy is only active when the auth type is set to AWS_IAM. If you provide a policy, then authentication and authorization decisions are made based on this policy and the client's IAM policy. If the Auth type is NONE, then, any auth policy that you provide remains inactive. For more information, see [Create a service network](https://docs.aws.amazon.com/vpc-lattice/latest/ug/service-networks.html#create-service-network) in the Amazon VPC Lattice User Guide.
    public var state: VPCLatticeClientTypes.AuthPolicyState?

    public init(
        policy: Swift.String? = nil,
        state: VPCLatticeClientTypes.AuthPolicyState? = nil
    )
    {
        self.policy = policy
        self.state = state
    }
}

public struct PutResourcePolicyInput {
    /// An IAM policy. The policy string in JSON must not contain newlines or blank lines.
    /// This member is required.
    public var policy: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service network or service for which the policy is created.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        policy: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.policy = policy
        self.resourceArn = resourceArn
    }
}

public struct PutResourcePolicyOutput {

    public init() { }
}

public struct UpdateRuleInput {
    /// Information about the action for the specified listener rule.
    public var action: VPCLatticeClientTypes.RuleAction?
    /// The ID or Amazon Resource Name (ARN) of the listener.
    /// This member is required.
    public var listenerIdentifier: Swift.String?
    /// The rule match.
    public var match: VPCLatticeClientTypes.RuleMatch?
    /// The rule priority. A listener can't have multiple rules with the same priority.
    public var priority: Swift.Int?
    /// The ID or Amazon Resource Name (ARN) of the rule.
    /// This member is required.
    public var ruleIdentifier: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        action: VPCLatticeClientTypes.RuleAction? = nil,
        listenerIdentifier: Swift.String? = nil,
        match: VPCLatticeClientTypes.RuleMatch? = nil,
        priority: Swift.Int? = nil,
        ruleIdentifier: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.action = action
        self.listenerIdentifier = listenerIdentifier
        self.match = match
        self.priority = priority
        self.ruleIdentifier = ruleIdentifier
        self.serviceIdentifier = serviceIdentifier
    }
}

public struct UpdateRuleOutput {
    /// Information about the action for the specified listener rule.
    public var action: VPCLatticeClientTypes.RuleAction?
    /// The Amazon Resource Name (ARN) of the listener.
    public var arn: Swift.String?
    /// The ID of the listener.
    public var id: Swift.String?
    /// Indicates whether this is the default rule.
    public var isDefault: Swift.Bool?
    /// The rule match.
    public var match: VPCLatticeClientTypes.RuleMatch?
    /// The name of the listener.
    public var name: Swift.String?
    /// The rule priority.
    public var priority: Swift.Int?

    public init(
        action: VPCLatticeClientTypes.RuleAction? = nil,
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        isDefault: Swift.Bool? = nil,
        match: VPCLatticeClientTypes.RuleMatch? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil
    )
    {
        self.action = action
        self.arn = arn
        self.id = id
        self.isDefault = isDefault
        self.match = match
        self.name = name
        self.priority = priority
    }
}

public struct UpdateServiceInput {
    /// The type of IAM policy.
    ///
    /// * NONE: The resource does not use an IAM policy. This is the default.
    ///
    /// * AWS_IAM: The resource uses an IAM policy. When this type is used, auth is enabled and an auth policy is required.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The Amazon Resource Name (ARN) of the certificate.
    public var certificateArn: Swift.String?
    /// The ID or Amazon Resource Name (ARN) of the service.
    /// This member is required.
    public var serviceIdentifier: Swift.String?

    public init(
        authType: VPCLatticeClientTypes.AuthType? = nil,
        certificateArn: Swift.String? = nil,
        serviceIdentifier: Swift.String? = nil
    )
    {
        self.authType = authType
        self.certificateArn = certificateArn
        self.serviceIdentifier = serviceIdentifier
    }
}

public struct UpdateServiceOutput {
    /// The Amazon Resource Name (ARN) of the service.
    public var arn: Swift.String?
    /// The type of IAM policy.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The Amazon Resource Name (ARN) of the certificate.
    public var certificateArn: Swift.String?
    /// The custom domain name of the service.
    public var customDomainName: Swift.String?
    /// The ID of the service.
    public var id: Swift.String?
    /// The name of the service.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        authType: VPCLatticeClientTypes.AuthType? = nil,
        certificateArn: Swift.String? = nil,
        customDomainName: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.authType = authType
        self.certificateArn = certificateArn
        self.customDomainName = customDomainName
        self.id = id
        self.name = name
    }
}

public struct UpdateServiceNetworkInput {
    /// The type of IAM policy.
    ///
    /// * NONE: The resource does not use an IAM policy. This is the default.
    ///
    /// * AWS_IAM: The resource uses an IAM policy. When this type is used, auth is enabled and an auth policy is required.
    /// This member is required.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The ID or Amazon Resource Name (ARN) of the service network.
    /// This member is required.
    public var serviceNetworkIdentifier: Swift.String?

    public init(
        authType: VPCLatticeClientTypes.AuthType? = nil,
        serviceNetworkIdentifier: Swift.String? = nil
    )
    {
        self.authType = authType
        self.serviceNetworkIdentifier = serviceNetworkIdentifier
    }
}

public struct UpdateServiceNetworkOutput {
    /// The Amazon Resource Name (ARN) of the service network.
    public var arn: Swift.String?
    /// The type of IAM policy.
    public var authType: VPCLatticeClientTypes.AuthType?
    /// The ID of the service network.
    public var id: Swift.String?
    /// The name of the service network.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        authType: VPCLatticeClientTypes.AuthType? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.authType = authType
        self.id = id
        self.name = name
    }
}

public struct UpdateServiceNetworkVpcAssociationInput {
    /// The IDs of the security groups.
    /// This member is required.
    public var securityGroupIds: [Swift.String]?
    /// The ID or Amazon Resource Name (ARN) of the association.
    /// This member is required.
    public var serviceNetworkVpcAssociationIdentifier: Swift.String?

    public init(
        securityGroupIds: [Swift.String]? = nil,
        serviceNetworkVpcAssociationIdentifier: Swift.String? = nil
    )
    {
        self.securityGroupIds = securityGroupIds
        self.serviceNetworkVpcAssociationIdentifier = serviceNetworkVpcAssociationIdentifier
    }
}

public struct UpdateServiceNetworkVpcAssociationOutput {
    /// The Amazon Resource Name (ARN) of the association.
    public var arn: Swift.String?
    /// The account that created the association.
    public var createdBy: Swift.String?
    /// The ID of the association.
    public var id: Swift.String?
    /// The IDs of the security groups.
    public var securityGroupIds: [Swift.String]?
    /// The status. You can retry the operation if the status is DELETE_FAILED. However, if you retry it while the status is DELETE_IN_PROGRESS, there is no change in the status.
    public var status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus?

    public init(
        arn: Swift.String? = nil,
        createdBy: Swift.String? = nil,
        id: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        status: VPCLatticeClientTypes.ServiceNetworkVpcAssociationStatus? = nil
    )
    {
        self.arn = arn
        self.createdBy = createdBy
        self.id = id
        self.securityGroupIds = securityGroupIds
        self.status = status
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags for the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct RegisterTargetsInput {
    /// The ID or Amazon Resource Name (ARN) of the target group.
    /// This member is required.
    public var targetGroupIdentifier: Swift.String?
    /// The targets.
    /// This member is required.
    public var targets: [VPCLatticeClientTypes.Target]?

    public init(
        targetGroupIdentifier: Swift.String? = nil,
        targets: [VPCLatticeClientTypes.Target]? = nil
    )
    {
        self.targetGroupIdentifier = targetGroupIdentifier
        self.targets = targets
    }
}

public struct RegisterTargetsOutput {
    /// The targets that were successfully registered.
    public var successful: [VPCLatticeClientTypes.Target]?
    /// The targets that were not registered.
    public var unsuccessful: [VPCLatticeClientTypes.TargetFailure]?

    public init(
        successful: [VPCLatticeClientTypes.Target]? = nil,
        unsuccessful: [VPCLatticeClientTypes.TargetFailure]? = nil
    )
    {
        self.successful = successful
        self.unsuccessful = unsuccessful
    }
}

public struct UpdateTargetGroupInput {
    /// The health check configuration.
    /// This member is required.
    public var healthCheck: VPCLatticeClientTypes.HealthCheckConfig?
    /// The ID or Amazon Resource Name (ARN) of the target group.
    /// This member is required.
    public var targetGroupIdentifier: Swift.String?

    public init(
        healthCheck: VPCLatticeClientTypes.HealthCheckConfig? = nil,
        targetGroupIdentifier: Swift.String? = nil
    )
    {
        self.healthCheck = healthCheck
        self.targetGroupIdentifier = targetGroupIdentifier
    }
}

public struct UpdateTargetGroupOutput {
    /// The Amazon Resource Name (ARN) of the target group.
    public var arn: Swift.String?
    /// The target group configuration.
    public var config: VPCLatticeClientTypes.TargetGroupConfig?
    /// The ID of the target group.
    public var id: Swift.String?
    /// The name of the target group.
    public var name: Swift.String?
    /// The status.
    public var status: VPCLatticeClientTypes.TargetGroupStatus?
    /// The target group type.
    public var type: VPCLatticeClientTypes.TargetGroupType?

    public init(
        arn: Swift.String? = nil,
        config: VPCLatticeClientTypes.TargetGroupConfig? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: VPCLatticeClientTypes.TargetGroupStatus? = nil,
        type: VPCLatticeClientTypes.TargetGroupType? = nil
    )
    {
        self.arn = arn
        self.config = config
        self.id = id
        self.name = name
        self.status = status
        self.type = type
    }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys of the tags to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

extension BatchUpdateRuleInput {

    static func urlPathProvider(_ value: BatchUpdateRuleInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = value.listenerIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())/rules"
    }
}

extension CreateAccessLogSubscriptionInput {

    static func urlPathProvider(_ value: CreateAccessLogSubscriptionInput) -> Swift.String? {
        return "/accesslogsubscriptions"
    }
}

extension CreateListenerInput {

    static func urlPathProvider(_ value: CreateListenerInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners"
    }
}

extension CreateRuleInput {

    static func urlPathProvider(_ value: CreateRuleInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = value.listenerIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())/rules"
    }
}

extension CreateServiceInput {

    static func urlPathProvider(_ value: CreateServiceInput) -> Swift.String? {
        return "/services"
    }
}

extension CreateServiceNetworkInput {

    static func urlPathProvider(_ value: CreateServiceNetworkInput) -> Swift.String? {
        return "/servicenetworks"
    }
}

extension CreateServiceNetworkServiceAssociationInput {

    static func urlPathProvider(_ value: CreateServiceNetworkServiceAssociationInput) -> Swift.String? {
        return "/servicenetworkserviceassociations"
    }
}

extension CreateServiceNetworkVpcAssociationInput {

    static func urlPathProvider(_ value: CreateServiceNetworkVpcAssociationInput) -> Swift.String? {
        return "/servicenetworkvpcassociations"
    }
}

extension CreateTargetGroupInput {

    static func urlPathProvider(_ value: CreateTargetGroupInput) -> Swift.String? {
        return "/targetgroups"
    }
}

extension DeleteAccessLogSubscriptionInput {

    static func urlPathProvider(_ value: DeleteAccessLogSubscriptionInput) -> Swift.String? {
        guard let accessLogSubscriptionIdentifier = value.accessLogSubscriptionIdentifier else {
            return nil
        }
        return "/accesslogsubscriptions/\(accessLogSubscriptionIdentifier.urlPercentEncoding())"
    }
}

extension DeleteAuthPolicyInput {

    static func urlPathProvider(_ value: DeleteAuthPolicyInput) -> Swift.String? {
        guard let resourceIdentifier = value.resourceIdentifier else {
            return nil
        }
        return "/authpolicy/\(resourceIdentifier.urlPercentEncoding())"
    }
}

extension DeleteListenerInput {

    static func urlPathProvider(_ value: DeleteListenerInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = value.listenerIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())"
    }
}

extension DeleteResourcePolicyInput {

    static func urlPathProvider(_ value: DeleteResourcePolicyInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/resourcepolicy/\(resourceArn.urlPercentEncoding())"
    }
}

extension DeleteRuleInput {

    static func urlPathProvider(_ value: DeleteRuleInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = value.listenerIdentifier else {
            return nil
        }
        guard let ruleIdentifier = value.ruleIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())/rules/\(ruleIdentifier.urlPercentEncoding())"
    }
}

extension DeleteServiceInput {

    static func urlPathProvider(_ value: DeleteServiceInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())"
    }
}

extension DeleteServiceNetworkInput {

    static func urlPathProvider(_ value: DeleteServiceNetworkInput) -> Swift.String? {
        guard let serviceNetworkIdentifier = value.serviceNetworkIdentifier else {
            return nil
        }
        return "/servicenetworks/\(serviceNetworkIdentifier.urlPercentEncoding())"
    }
}

extension DeleteServiceNetworkServiceAssociationInput {

    static func urlPathProvider(_ value: DeleteServiceNetworkServiceAssociationInput) -> Swift.String? {
        guard let serviceNetworkServiceAssociationIdentifier = value.serviceNetworkServiceAssociationIdentifier else {
            return nil
        }
        return "/servicenetworkserviceassociations/\(serviceNetworkServiceAssociationIdentifier.urlPercentEncoding())"
    }
}

extension DeleteServiceNetworkVpcAssociationInput {

    static func urlPathProvider(_ value: DeleteServiceNetworkVpcAssociationInput) -> Swift.String? {
        guard let serviceNetworkVpcAssociationIdentifier = value.serviceNetworkVpcAssociationIdentifier else {
            return nil
        }
        return "/servicenetworkvpcassociations/\(serviceNetworkVpcAssociationIdentifier.urlPercentEncoding())"
    }
}

extension DeleteTargetGroupInput {

    static func urlPathProvider(_ value: DeleteTargetGroupInput) -> Swift.String? {
        guard let targetGroupIdentifier = value.targetGroupIdentifier else {
            return nil
        }
        return "/targetgroups/\(targetGroupIdentifier.urlPercentEncoding())"
    }
}

extension DeregisterTargetsInput {

    static func urlPathProvider(_ value: DeregisterTargetsInput) -> Swift.String? {
        guard let targetGroupIdentifier = value.targetGroupIdentifier else {
            return nil
        }
        return "/targetgroups/\(targetGroupIdentifier.urlPercentEncoding())/deregistertargets"
    }
}

extension GetAccessLogSubscriptionInput {

    static func urlPathProvider(_ value: GetAccessLogSubscriptionInput) -> Swift.String? {
        guard let accessLogSubscriptionIdentifier = value.accessLogSubscriptionIdentifier else {
            return nil
        }
        return "/accesslogsubscriptions/\(accessLogSubscriptionIdentifier.urlPercentEncoding())"
    }
}

extension GetAuthPolicyInput {

    static func urlPathProvider(_ value: GetAuthPolicyInput) -> Swift.String? {
        guard let resourceIdentifier = value.resourceIdentifier else {
            return nil
        }
        return "/authpolicy/\(resourceIdentifier.urlPercentEncoding())"
    }
}

extension GetListenerInput {

    static func urlPathProvider(_ value: GetListenerInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = value.listenerIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())"
    }
}

extension GetResourcePolicyInput {

    static func urlPathProvider(_ value: GetResourcePolicyInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/resourcepolicy/\(resourceArn.urlPercentEncoding())"
    }
}

extension GetRuleInput {

    static func urlPathProvider(_ value: GetRuleInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = value.listenerIdentifier else {
            return nil
        }
        guard let ruleIdentifier = value.ruleIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())/rules/\(ruleIdentifier.urlPercentEncoding())"
    }
}

extension GetServiceInput {

    static func urlPathProvider(_ value: GetServiceInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())"
    }
}

extension GetServiceNetworkInput {

    static func urlPathProvider(_ value: GetServiceNetworkInput) -> Swift.String? {
        guard let serviceNetworkIdentifier = value.serviceNetworkIdentifier else {
            return nil
        }
        return "/servicenetworks/\(serviceNetworkIdentifier.urlPercentEncoding())"
    }
}

extension GetServiceNetworkServiceAssociationInput {

    static func urlPathProvider(_ value: GetServiceNetworkServiceAssociationInput) -> Swift.String? {
        guard let serviceNetworkServiceAssociationIdentifier = value.serviceNetworkServiceAssociationIdentifier else {
            return nil
        }
        return "/servicenetworkserviceassociations/\(serviceNetworkServiceAssociationIdentifier.urlPercentEncoding())"
    }
}

extension GetServiceNetworkVpcAssociationInput {

    static func urlPathProvider(_ value: GetServiceNetworkVpcAssociationInput) -> Swift.String? {
        guard let serviceNetworkVpcAssociationIdentifier = value.serviceNetworkVpcAssociationIdentifier else {
            return nil
        }
        return "/servicenetworkvpcassociations/\(serviceNetworkVpcAssociationIdentifier.urlPercentEncoding())"
    }
}

extension GetTargetGroupInput {

    static func urlPathProvider(_ value: GetTargetGroupInput) -> Swift.String? {
        guard let targetGroupIdentifier = value.targetGroupIdentifier else {
            return nil
        }
        return "/targetgroups/\(targetGroupIdentifier.urlPercentEncoding())"
    }
}

extension ListAccessLogSubscriptionsInput {

    static func urlPathProvider(_ value: ListAccessLogSubscriptionsInput) -> Swift.String? {
        return "/accesslogsubscriptions"
    }
}

extension ListAccessLogSubscriptionsInput {

    static func queryItemProvider(_ value: ListAccessLogSubscriptionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let resourceIdentifier = value.resourceIdentifier else {
            let message = "Creating a URL Query Item failed. resourceIdentifier is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceIdentifierQueryItem = Smithy.URIQueryItem(name: "resourceIdentifier".urlPercentEncoding(), value: Swift.String(resourceIdentifier).urlPercentEncoding())
        items.append(resourceIdentifierQueryItem)
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListListenersInput {

    static func urlPathProvider(_ value: ListListenersInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners"
    }
}

extension ListListenersInput {

    static func queryItemProvider(_ value: ListListenersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListRulesInput {

    static func urlPathProvider(_ value: ListRulesInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = value.listenerIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())/rules"
    }
}

extension ListRulesInput {

    static func queryItemProvider(_ value: ListRulesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListServiceNetworksInput {

    static func urlPathProvider(_ value: ListServiceNetworksInput) -> Swift.String? {
        return "/servicenetworks"
    }
}

extension ListServiceNetworksInput {

    static func queryItemProvider(_ value: ListServiceNetworksInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListServiceNetworkServiceAssociationsInput {

    static func urlPathProvider(_ value: ListServiceNetworkServiceAssociationsInput) -> Swift.String? {
        return "/servicenetworkserviceassociations"
    }
}

extension ListServiceNetworkServiceAssociationsInput {

    static func queryItemProvider(_ value: ListServiceNetworkServiceAssociationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let serviceNetworkIdentifier = value.serviceNetworkIdentifier {
            let serviceNetworkIdentifierQueryItem = Smithy.URIQueryItem(name: "serviceNetworkIdentifier".urlPercentEncoding(), value: Swift.String(serviceNetworkIdentifier).urlPercentEncoding())
            items.append(serviceNetworkIdentifierQueryItem)
        }
        if let serviceIdentifier = value.serviceIdentifier {
            let serviceIdentifierQueryItem = Smithy.URIQueryItem(name: "serviceIdentifier".urlPercentEncoding(), value: Swift.String(serviceIdentifier).urlPercentEncoding())
            items.append(serviceIdentifierQueryItem)
        }
        return items
    }
}

extension ListServiceNetworkVpcAssociationsInput {

    static func urlPathProvider(_ value: ListServiceNetworkVpcAssociationsInput) -> Swift.String? {
        return "/servicenetworkvpcassociations"
    }
}

extension ListServiceNetworkVpcAssociationsInput {

    static func queryItemProvider(_ value: ListServiceNetworkVpcAssociationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let serviceNetworkIdentifier = value.serviceNetworkIdentifier {
            let serviceNetworkIdentifierQueryItem = Smithy.URIQueryItem(name: "serviceNetworkIdentifier".urlPercentEncoding(), value: Swift.String(serviceNetworkIdentifier).urlPercentEncoding())
            items.append(serviceNetworkIdentifierQueryItem)
        }
        if let vpcIdentifier = value.vpcIdentifier {
            let vpcIdentifierQueryItem = Smithy.URIQueryItem(name: "vpcIdentifier".urlPercentEncoding(), value: Swift.String(vpcIdentifier).urlPercentEncoding())
            items.append(vpcIdentifierQueryItem)
        }
        return items
    }
}

extension ListServicesInput {

    static func urlPathProvider(_ value: ListServicesInput) -> Swift.String? {
        return "/services"
    }
}

extension ListServicesInput {

    static func queryItemProvider(_ value: ListServicesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension ListTargetGroupsInput {

    static func urlPathProvider(_ value: ListTargetGroupsInput) -> Swift.String? {
        return "/targetgroups"
    }
}

extension ListTargetGroupsInput {

    static func queryItemProvider(_ value: ListTargetGroupsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let vpcIdentifier = value.vpcIdentifier {
            let vpcIdentifierQueryItem = Smithy.URIQueryItem(name: "vpcIdentifier".urlPercentEncoding(), value: Swift.String(vpcIdentifier).urlPercentEncoding())
            items.append(vpcIdentifierQueryItem)
        }
        if let targetGroupType = value.targetGroupType {
            let targetGroupTypeQueryItem = Smithy.URIQueryItem(name: "targetGroupType".urlPercentEncoding(), value: Swift.String(targetGroupType.rawValue).urlPercentEncoding())
            items.append(targetGroupTypeQueryItem)
        }
        return items
    }
}

extension ListTargetsInput {

    static func urlPathProvider(_ value: ListTargetsInput) -> Swift.String? {
        guard let targetGroupIdentifier = value.targetGroupIdentifier else {
            return nil
        }
        return "/targetgroups/\(targetGroupIdentifier.urlPercentEncoding())/listtargets"
    }
}

extension ListTargetsInput {

    static func queryItemProvider(_ value: ListTargetsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension PutAuthPolicyInput {

    static func urlPathProvider(_ value: PutAuthPolicyInput) -> Swift.String? {
        guard let resourceIdentifier = value.resourceIdentifier else {
            return nil
        }
        return "/authpolicy/\(resourceIdentifier.urlPercentEncoding())"
    }
}

extension PutResourcePolicyInput {

    static func urlPathProvider(_ value: PutResourcePolicyInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/resourcepolicy/\(resourceArn.urlPercentEncoding())"
    }
}

extension RegisterTargetsInput {

    static func urlPathProvider(_ value: RegisterTargetsInput) -> Swift.String? {
        guard let targetGroupIdentifier = value.targetGroupIdentifier else {
            return nil
        }
        return "/targetgroups/\(targetGroupIdentifier.urlPercentEncoding())/registertargets"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateAccessLogSubscriptionInput {

    static func urlPathProvider(_ value: UpdateAccessLogSubscriptionInput) -> Swift.String? {
        guard let accessLogSubscriptionIdentifier = value.accessLogSubscriptionIdentifier else {
            return nil
        }
        return "/accesslogsubscriptions/\(accessLogSubscriptionIdentifier.urlPercentEncoding())"
    }
}

extension UpdateListenerInput {

    static func urlPathProvider(_ value: UpdateListenerInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = value.listenerIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())"
    }
}

extension UpdateRuleInput {

    static func urlPathProvider(_ value: UpdateRuleInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        guard let listenerIdentifier = value.listenerIdentifier else {
            return nil
        }
        guard let ruleIdentifier = value.ruleIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())/listeners/\(listenerIdentifier.urlPercentEncoding())/rules/\(ruleIdentifier.urlPercentEncoding())"
    }
}

extension UpdateServiceInput {

    static func urlPathProvider(_ value: UpdateServiceInput) -> Swift.String? {
        guard let serviceIdentifier = value.serviceIdentifier else {
            return nil
        }
        return "/services/\(serviceIdentifier.urlPercentEncoding())"
    }
}

extension UpdateServiceNetworkInput {

    static func urlPathProvider(_ value: UpdateServiceNetworkInput) -> Swift.String? {
        guard let serviceNetworkIdentifier = value.serviceNetworkIdentifier else {
            return nil
        }
        return "/servicenetworks/\(serviceNetworkIdentifier.urlPercentEncoding())"
    }
}

extension UpdateServiceNetworkVpcAssociationInput {

    static func urlPathProvider(_ value: UpdateServiceNetworkVpcAssociationInput) -> Swift.String? {
        guard let serviceNetworkVpcAssociationIdentifier = value.serviceNetworkVpcAssociationIdentifier else {
            return nil
        }
        return "/servicenetworkvpcassociations/\(serviceNetworkVpcAssociationIdentifier.urlPercentEncoding())"
    }
}

extension UpdateTargetGroupInput {

    static func urlPathProvider(_ value: UpdateTargetGroupInput) -> Swift.String? {
        guard let targetGroupIdentifier = value.targetGroupIdentifier else {
            return nil
        }
        return "/targetgroups/\(targetGroupIdentifier.urlPercentEncoding())"
    }
}

extension BatchUpdateRuleInput {

    static func write(value: BatchUpdateRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["rules"].writeList(value.rules, memberWritingClosure: VPCLatticeClientTypes.RuleUpdate.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateAccessLogSubscriptionInput {

    static func write(value: CreateAccessLogSubscriptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["destinationArn"].write(value.destinationArn)
        try writer["resourceIdentifier"].write(value.resourceIdentifier)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateListenerInput {

    static func write(value: CreateListenerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["defaultAction"].write(value.defaultAction, with: VPCLatticeClientTypes.RuleAction.write(value:to:))
        try writer["name"].write(value.name)
        try writer["port"].write(value.port)
        try writer["protocol"].write(value.`protocol`)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateRuleInput {

    static func write(value: CreateRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action, with: VPCLatticeClientTypes.RuleAction.write(value:to:))
        try writer["clientToken"].write(value.clientToken)
        try writer["match"].write(value.match, with: VPCLatticeClientTypes.RuleMatch.write(value:to:))
        try writer["name"].write(value.name)
        try writer["priority"].write(value.priority)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateServiceInput {

    static func write(value: CreateServiceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authType"].write(value.authType)
        try writer["certificateArn"].write(value.certificateArn)
        try writer["clientToken"].write(value.clientToken)
        try writer["customDomainName"].write(value.customDomainName)
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateServiceNetworkInput {

    static func write(value: CreateServiceNetworkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authType"].write(value.authType)
        try writer["clientToken"].write(value.clientToken)
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateServiceNetworkServiceAssociationInput {

    static func write(value: CreateServiceNetworkServiceAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["serviceIdentifier"].write(value.serviceIdentifier)
        try writer["serviceNetworkIdentifier"].write(value.serviceNetworkIdentifier)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateServiceNetworkVpcAssociationInput {

    static func write(value: CreateServiceNetworkVpcAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["serviceNetworkIdentifier"].write(value.serviceNetworkIdentifier)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["vpcIdentifier"].write(value.vpcIdentifier)
    }
}

extension CreateTargetGroupInput {

    static func write(value: CreateTargetGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["config"].write(value.config, with: VPCLatticeClientTypes.TargetGroupConfig.write(value:to:))
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["type"].write(value.type)
    }
}

extension DeregisterTargetsInput {

    static func write(value: DeregisterTargetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["targets"].writeList(value.targets, memberWritingClosure: VPCLatticeClientTypes.Target.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListTargetsInput {

    static func write(value: ListTargetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["targets"].writeList(value.targets, memberWritingClosure: VPCLatticeClientTypes.Target.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PutAuthPolicyInput {

    static func write(value: PutAuthPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["policy"].write(value.policy)
    }
}

extension PutResourcePolicyInput {

    static func write(value: PutResourcePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["policy"].write(value.policy)
    }
}

extension RegisterTargetsInput {

    static func write(value: RegisterTargetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["targets"].writeList(value.targets, memberWritingClosure: VPCLatticeClientTypes.Target.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateAccessLogSubscriptionInput {

    static func write(value: UpdateAccessLogSubscriptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destinationArn"].write(value.destinationArn)
    }
}

extension UpdateListenerInput {

    static func write(value: UpdateListenerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["defaultAction"].write(value.defaultAction, with: VPCLatticeClientTypes.RuleAction.write(value:to:))
    }
}

extension UpdateRuleInput {

    static func write(value: UpdateRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action, with: VPCLatticeClientTypes.RuleAction.write(value:to:))
        try writer["match"].write(value.match, with: VPCLatticeClientTypes.RuleMatch.write(value:to:))
        try writer["priority"].write(value.priority)
    }
}

extension UpdateServiceInput {

    static func write(value: UpdateServiceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authType"].write(value.authType)
        try writer["certificateArn"].write(value.certificateArn)
    }
}

extension UpdateServiceNetworkInput {

    static func write(value: UpdateServiceNetworkInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authType"].write(value.authType)
    }
}

extension UpdateServiceNetworkVpcAssociationInput {

    static func write(value: UpdateServiceNetworkVpcAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateTargetGroupInput {

    static func write(value: UpdateTargetGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["healthCheck"].write(value.healthCheck, with: VPCLatticeClientTypes.HealthCheckConfig.write(value:to:))
    }
}

extension BatchUpdateRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchUpdateRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchUpdateRuleOutput()
        value.successful = try reader["successful"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.RuleUpdateSuccess.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.unsuccessful = try reader["unsuccessful"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.RuleUpdateFailure.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateAccessLogSubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAccessLogSubscriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAccessLogSubscriptionOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.destinationArn = try reader["destinationArn"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.resourceArn = try reader["resourceArn"].readIfPresent() ?? ""
        value.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateListenerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateListenerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateListenerOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.defaultAction = try reader["defaultAction"].readIfPresent(with: VPCLatticeClientTypes.RuleAction.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.port = try reader["port"].readIfPresent()
        value.`protocol` = try reader["protocol"].readIfPresent()
        value.serviceArn = try reader["serviceArn"].readIfPresent()
        value.serviceId = try reader["serviceId"].readIfPresent()
        return value
    }
}

extension CreateRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRuleOutput()
        value.action = try reader["action"].readIfPresent(with: VPCLatticeClientTypes.RuleAction.read(from:))
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.match = try reader["match"].readIfPresent(with: VPCLatticeClientTypes.RuleMatch.read(from:))
        value.name = try reader["name"].readIfPresent()
        value.priority = try reader["priority"].readIfPresent()
        return value
    }
}

extension CreateServiceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateServiceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateServiceOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.authType = try reader["authType"].readIfPresent()
        value.certificateArn = try reader["certificateArn"].readIfPresent()
        value.customDomainName = try reader["customDomainName"].readIfPresent()
        value.dnsEntry = try reader["dnsEntry"].readIfPresent(with: VPCLatticeClientTypes.DnsEntry.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension CreateServiceNetworkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateServiceNetworkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateServiceNetworkOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.authType = try reader["authType"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension CreateServiceNetworkServiceAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateServiceNetworkServiceAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateServiceNetworkServiceAssociationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.customDomainName = try reader["customDomainName"].readIfPresent()
        value.dnsEntry = try reader["dnsEntry"].readIfPresent(with: VPCLatticeClientTypes.DnsEntry.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension CreateServiceNetworkVpcAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateServiceNetworkVpcAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateServiceNetworkVpcAssociationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension CreateTargetGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTargetGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTargetGroupOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.config = try reader["config"].readIfPresent(with: VPCLatticeClientTypes.TargetGroupConfig.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension DeleteAccessLogSubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAccessLogSubscriptionOutput {
        return DeleteAccessLogSubscriptionOutput()
    }
}

extension DeleteAuthPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAuthPolicyOutput {
        return DeleteAuthPolicyOutput()
    }
}

extension DeleteListenerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteListenerOutput {
        return DeleteListenerOutput()
    }
}

extension DeleteResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteResourcePolicyOutput {
        return DeleteResourcePolicyOutput()
    }
}

extension DeleteRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRuleOutput {
        return DeleteRuleOutput()
    }
}

extension DeleteServiceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteServiceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteServiceOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension DeleteServiceNetworkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteServiceNetworkOutput {
        return DeleteServiceNetworkOutput()
    }
}

extension DeleteServiceNetworkServiceAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteServiceNetworkServiceAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteServiceNetworkServiceAssociationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension DeleteServiceNetworkVpcAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteServiceNetworkVpcAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteServiceNetworkVpcAssociationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension DeleteTargetGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTargetGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteTargetGroupOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension DeregisterTargetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeregisterTargetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeregisterTargetsOutput()
        value.successful = try reader["successful"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.Target.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.unsuccessful = try reader["unsuccessful"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.TargetFailure.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetAccessLogSubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAccessLogSubscriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAccessLogSubscriptionOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.destinationArn = try reader["destinationArn"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.resourceArn = try reader["resourceArn"].readIfPresent() ?? ""
        value.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        return value
    }
}

extension GetAuthPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAuthPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAuthPolicyOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.policy = try reader["policy"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        return value
    }
}

extension GetListenerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetListenerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetListenerOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.defaultAction = try reader["defaultAction"].readIfPresent(with: VPCLatticeClientTypes.RuleAction.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent()
        value.port = try reader["port"].readIfPresent()
        value.`protocol` = try reader["protocol"].readIfPresent()
        value.serviceArn = try reader["serviceArn"].readIfPresent()
        value.serviceId = try reader["serviceId"].readIfPresent()
        return value
    }
}

extension GetResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourcePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourcePolicyOutput()
        value.policy = try reader["policy"].readIfPresent()
        return value
    }
}

extension GetRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRuleOutput()
        value.action = try reader["action"].readIfPresent(with: VPCLatticeClientTypes.RuleAction.read(from:))
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.id = try reader["id"].readIfPresent()
        value.isDefault = try reader["isDefault"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.match = try reader["match"].readIfPresent(with: VPCLatticeClientTypes.RuleMatch.read(from:))
        value.name = try reader["name"].readIfPresent()
        value.priority = try reader["priority"].readIfPresent()
        return value
    }
}

extension GetServiceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetServiceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetServiceOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.authType = try reader["authType"].readIfPresent()
        value.certificateArn = try reader["certificateArn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.customDomainName = try reader["customDomainName"].readIfPresent()
        value.dnsEntry = try reader["dnsEntry"].readIfPresent(with: VPCLatticeClientTypes.DnsEntry.read(from:))
        value.failureCode = try reader["failureCode"].readIfPresent()
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension GetServiceNetworkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetServiceNetworkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetServiceNetworkOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.authType = try reader["authType"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.id = try reader["id"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent()
        value.numberOfAssociatedServices = try reader["numberOfAssociatedServices"].readIfPresent()
        value.numberOfAssociatedVPCs = try reader["numberOfAssociatedVPCs"].readIfPresent()
        return value
    }
}

extension GetServiceNetworkServiceAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetServiceNetworkServiceAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetServiceNetworkServiceAssociationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.customDomainName = try reader["customDomainName"].readIfPresent()
        value.dnsEntry = try reader["dnsEntry"].readIfPresent(with: VPCLatticeClientTypes.DnsEntry.read(from:))
        value.failureCode = try reader["failureCode"].readIfPresent()
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.serviceArn = try reader["serviceArn"].readIfPresent()
        value.serviceId = try reader["serviceId"].readIfPresent()
        value.serviceName = try reader["serviceName"].readIfPresent()
        value.serviceNetworkArn = try reader["serviceNetworkArn"].readIfPresent()
        value.serviceNetworkId = try reader["serviceNetworkId"].readIfPresent()
        value.serviceNetworkName = try reader["serviceNetworkName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension GetServiceNetworkVpcAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetServiceNetworkVpcAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetServiceNetworkVpcAssociationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.failureCode = try reader["failureCode"].readIfPresent()
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.serviceNetworkArn = try reader["serviceNetworkArn"].readIfPresent()
        value.serviceNetworkId = try reader["serviceNetworkId"].readIfPresent()
        value.serviceNetworkName = try reader["serviceNetworkName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.vpcId = try reader["vpcId"].readIfPresent()
        return value
    }
}

extension GetTargetGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTargetGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTargetGroupOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.config = try reader["config"].readIfPresent(with: VPCLatticeClientTypes.TargetGroupConfig.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.failureCode = try reader["failureCode"].readIfPresent()
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent()
        value.serviceArns = try reader["serviceArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension ListAccessLogSubscriptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAccessLogSubscriptionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAccessLogSubscriptionsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.AccessLogSubscriptionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListListenersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListListenersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListListenersOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.ListenerSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListRulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRulesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.RuleSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListServiceNetworksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListServiceNetworksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListServiceNetworksOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.ServiceNetworkSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListServiceNetworkServiceAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListServiceNetworkServiceAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListServiceNetworkServiceAssociationsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.ServiceNetworkServiceAssociationSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListServiceNetworkVpcAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListServiceNetworkVpcAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListServiceNetworkVpcAssociationsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.ServiceNetworkVpcAssociationSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListServicesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListServicesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListServicesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.ServiceSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListTargetGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTargetGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTargetGroupsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.TargetGroupSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTargetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTargetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTargetsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.TargetSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension PutAuthPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutAuthPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutAuthPolicyOutput()
        value.policy = try reader["policy"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        return value
    }
}

extension PutResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutResourcePolicyOutput {
        return PutResourcePolicyOutput()
    }
}

extension RegisterTargetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterTargetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterTargetsOutput()
        value.successful = try reader["successful"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.Target.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.unsuccessful = try reader["unsuccessful"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.TargetFailure.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAccessLogSubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAccessLogSubscriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAccessLogSubscriptionOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.destinationArn = try reader["destinationArn"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.resourceArn = try reader["resourceArn"].readIfPresent() ?? ""
        value.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateListenerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateListenerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateListenerOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.defaultAction = try reader["defaultAction"].readIfPresent(with: VPCLatticeClientTypes.RuleAction.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.port = try reader["port"].readIfPresent()
        value.`protocol` = try reader["protocol"].readIfPresent()
        value.serviceArn = try reader["serviceArn"].readIfPresent()
        value.serviceId = try reader["serviceId"].readIfPresent()
        return value
    }
}

extension UpdateRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateRuleOutput()
        value.action = try reader["action"].readIfPresent(with: VPCLatticeClientTypes.RuleAction.read(from:))
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.isDefault = try reader["isDefault"].readIfPresent()
        value.match = try reader["match"].readIfPresent(with: VPCLatticeClientTypes.RuleMatch.read(from:))
        value.name = try reader["name"].readIfPresent()
        value.priority = try reader["priority"].readIfPresent()
        return value
    }
}

extension UpdateServiceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateServiceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateServiceOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.authType = try reader["authType"].readIfPresent()
        value.certificateArn = try reader["certificateArn"].readIfPresent()
        value.customDomainName = try reader["customDomainName"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension UpdateServiceNetworkOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateServiceNetworkOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateServiceNetworkOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.authType = try reader["authType"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension UpdateServiceNetworkVpcAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateServiceNetworkVpcAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateServiceNetworkVpcAssociationOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension UpdateTargetGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTargetGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateTargetGroupOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.config = try reader["config"].readIfPresent(with: VPCLatticeClientTypes.TargetGroupConfig.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

enum BatchUpdateRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAccessLogSubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateListenerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateServiceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateServiceNetworkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateServiceNetworkServiceAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateServiceNetworkVpcAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTargetGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAccessLogSubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAuthPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteListenerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteServiceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteServiceNetworkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteServiceNetworkServiceAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteServiceNetworkVpcAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTargetGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeregisterTargetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAccessLogSubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAuthPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetListenerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetServiceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetServiceNetworkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetServiceNetworkServiceAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetServiceNetworkVpcAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTargetGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAccessLogSubscriptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListListenersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListServiceNetworksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListServiceNetworkServiceAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListServiceNetworkVpcAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListServicesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTargetGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTargetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutAuthPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterTargetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAccessLogSubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateListenerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateServiceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateServiceNetworkOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateServiceNetworkVpcAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTargetGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension VPCLatticeClientTypes.RuleUpdateSuccess {

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.RuleUpdateSuccess {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.RuleUpdateSuccess()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.isDefault = try reader["isDefault"].readIfPresent()
        value.match = try reader["match"].readIfPresent(with: VPCLatticeClientTypes.RuleMatch.read(from:))
        value.priority = try reader["priority"].readIfPresent()
        value.action = try reader["action"].readIfPresent(with: VPCLatticeClientTypes.RuleAction.read(from:))
        return value
    }
}

extension VPCLatticeClientTypes.RuleAction {

    static func write(value: VPCLatticeClientTypes.RuleAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .fixedresponse(fixedresponse):
                try writer["fixedResponse"].write(fixedresponse, with: VPCLatticeClientTypes.FixedResponseAction.write(value:to:))
            case let .forward(forward):
                try writer["forward"].write(forward, with: VPCLatticeClientTypes.ForwardAction.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.RuleAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "forward":
                return .forward(try reader["forward"].read(with: VPCLatticeClientTypes.ForwardAction.read(from:)))
            case "fixedResponse":
                return .fixedresponse(try reader["fixedResponse"].read(with: VPCLatticeClientTypes.FixedResponseAction.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension VPCLatticeClientTypes.FixedResponseAction {

    static func write(value: VPCLatticeClientTypes.FixedResponseAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["statusCode"].write(value.statusCode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.FixedResponseAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.FixedResponseAction()
        value.statusCode = try reader["statusCode"].readIfPresent() ?? 0
        return value
    }
}

extension VPCLatticeClientTypes.ForwardAction {

    static func write(value: VPCLatticeClientTypes.ForwardAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["targetGroups"].writeList(value.targetGroups, memberWritingClosure: VPCLatticeClientTypes.WeightedTargetGroup.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.ForwardAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.ForwardAction()
        value.targetGroups = try reader["targetGroups"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.WeightedTargetGroup.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension VPCLatticeClientTypes.WeightedTargetGroup {

    static func write(value: VPCLatticeClientTypes.WeightedTargetGroup?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["targetGroupIdentifier"].write(value.targetGroupIdentifier)
        try writer["weight"].write(value.weight)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.WeightedTargetGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.WeightedTargetGroup()
        value.targetGroupIdentifier = try reader["targetGroupIdentifier"].readIfPresent() ?? ""
        value.weight = try reader["weight"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes.RuleMatch {

    static func write(value: VPCLatticeClientTypes.RuleMatch?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .httpmatch(httpmatch):
                try writer["httpMatch"].write(httpmatch, with: VPCLatticeClientTypes.HttpMatch.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.RuleMatch {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "httpMatch":
                return .httpmatch(try reader["httpMatch"].read(with: VPCLatticeClientTypes.HttpMatch.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension VPCLatticeClientTypes.HttpMatch {

    static func write(value: VPCLatticeClientTypes.HttpMatch?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["headerMatches"].writeList(value.headerMatches, memberWritingClosure: VPCLatticeClientTypes.HeaderMatch.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["method"].write(value.method)
        try writer["pathMatch"].write(value.pathMatch, with: VPCLatticeClientTypes.PathMatch.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.HttpMatch {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.HttpMatch()
        value.method = try reader["method"].readIfPresent()
        value.pathMatch = try reader["pathMatch"].readIfPresent(with: VPCLatticeClientTypes.PathMatch.read(from:))
        value.headerMatches = try reader["headerMatches"].readListIfPresent(memberReadingClosure: VPCLatticeClientTypes.HeaderMatch.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension VPCLatticeClientTypes.HeaderMatch {

    static func write(value: VPCLatticeClientTypes.HeaderMatch?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["caseSensitive"].write(value.caseSensitive)
        try writer["match"].write(value.match, with: VPCLatticeClientTypes.HeaderMatchType.write(value:to:))
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.HeaderMatch {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.HeaderMatch()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.match = try reader["match"].readIfPresent(with: VPCLatticeClientTypes.HeaderMatchType.read(from:))
        value.caseSensitive = try reader["caseSensitive"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes.HeaderMatchType {

    static func write(value: VPCLatticeClientTypes.HeaderMatchType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .contains(contains):
                try writer["contains"].write(contains)
            case let .exact(exact):
                try writer["exact"].write(exact)
            case let .`prefix`(`prefix`):
                try writer["prefix"].write(`prefix`)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.HeaderMatchType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "exact":
                return .exact(try reader["exact"].read())
            case "prefix":
                return .`prefix`(try reader["prefix"].read())
            case "contains":
                return .contains(try reader["contains"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension VPCLatticeClientTypes.PathMatch {

    static func write(value: VPCLatticeClientTypes.PathMatch?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["caseSensitive"].write(value.caseSensitive)
        try writer["match"].write(value.match, with: VPCLatticeClientTypes.PathMatchType.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.PathMatch {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.PathMatch()
        value.match = try reader["match"].readIfPresent(with: VPCLatticeClientTypes.PathMatchType.read(from:))
        value.caseSensitive = try reader["caseSensitive"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes.PathMatchType {

    static func write(value: VPCLatticeClientTypes.PathMatchType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .exact(exact):
                try writer["exact"].write(exact)
            case let .`prefix`(`prefix`):
                try writer["prefix"].write(`prefix`)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.PathMatchType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "exact":
                return .exact(try reader["exact"].read())
            case "prefix":
                return .`prefix`(try reader["prefix"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension VPCLatticeClientTypes.RuleUpdateFailure {

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.RuleUpdateFailure {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.RuleUpdateFailure()
        value.ruleIdentifier = try reader["ruleIdentifier"].readIfPresent()
        value.failureCode = try reader["failureCode"].readIfPresent()
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes.DnsEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.DnsEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.DnsEntry()
        value.domainName = try reader["domainName"].readIfPresent()
        value.hostedZoneId = try reader["hostedZoneId"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes.TargetGroupConfig {

    static func write(value: VPCLatticeClientTypes.TargetGroupConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["healthCheck"].write(value.healthCheck, with: VPCLatticeClientTypes.HealthCheckConfig.write(value:to:))
        try writer["ipAddressType"].write(value.ipAddressType)
        try writer["lambdaEventStructureVersion"].write(value.lambdaEventStructureVersion)
        try writer["port"].write(value.port)
        try writer["protocol"].write(value.`protocol`)
        try writer["protocolVersion"].write(value.protocolVersion)
        try writer["vpcIdentifier"].write(value.vpcIdentifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.TargetGroupConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.TargetGroupConfig()
        value.port = try reader["port"].readIfPresent()
        value.`protocol` = try reader["protocol"].readIfPresent()
        value.protocolVersion = try reader["protocolVersion"].readIfPresent()
        value.ipAddressType = try reader["ipAddressType"].readIfPresent()
        value.vpcIdentifier = try reader["vpcIdentifier"].readIfPresent()
        value.healthCheck = try reader["healthCheck"].readIfPresent(with: VPCLatticeClientTypes.HealthCheckConfig.read(from:))
        value.lambdaEventStructureVersion = try reader["lambdaEventStructureVersion"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes.HealthCheckConfig {

    static func write(value: VPCLatticeClientTypes.HealthCheckConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enabled"].write(value.enabled)
        try writer["healthCheckIntervalSeconds"].write(value.healthCheckIntervalSeconds)
        try writer["healthCheckTimeoutSeconds"].write(value.healthCheckTimeoutSeconds)
        try writer["healthyThresholdCount"].write(value.healthyThresholdCount)
        try writer["matcher"].write(value.matcher, with: VPCLatticeClientTypes.Matcher.write(value:to:))
        try writer["path"].write(value.path)
        try writer["port"].write(value.port)
        try writer["protocol"].write(value.`protocol`)
        try writer["protocolVersion"].write(value.protocolVersion)
        try writer["unhealthyThresholdCount"].write(value.unhealthyThresholdCount)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.HealthCheckConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.HealthCheckConfig()
        value.enabled = try reader["enabled"].readIfPresent()
        value.`protocol` = try reader["protocol"].readIfPresent()
        value.protocolVersion = try reader["protocolVersion"].readIfPresent()
        value.port = try reader["port"].readIfPresent()
        value.path = try reader["path"].readIfPresent()
        value.healthCheckIntervalSeconds = try reader["healthCheckIntervalSeconds"].readIfPresent()
        value.healthCheckTimeoutSeconds = try reader["healthCheckTimeoutSeconds"].readIfPresent()
        value.healthyThresholdCount = try reader["healthyThresholdCount"].readIfPresent()
        value.unhealthyThresholdCount = try reader["unhealthyThresholdCount"].readIfPresent()
        value.matcher = try reader["matcher"].readIfPresent(with: VPCLatticeClientTypes.Matcher.read(from:))
        return value
    }
}

extension VPCLatticeClientTypes.Matcher {

    static func write(value: VPCLatticeClientTypes.Matcher?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .httpcode(httpcode):
                try writer["httpCode"].write(httpcode)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.Matcher {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "httpCode":
                return .httpcode(try reader["httpCode"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension VPCLatticeClientTypes.Target {

    static func write(value: VPCLatticeClientTypes.Target?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
        try writer["port"].write(value.port)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.Target {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.Target()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.port = try reader["port"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes.TargetFailure {

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.TargetFailure {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.TargetFailure()
        value.id = try reader["id"].readIfPresent()
        value.port = try reader["port"].readIfPresent()
        value.failureCode = try reader["failureCode"].readIfPresent()
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes.AccessLogSubscriptionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.AccessLogSubscriptionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.AccessLogSubscriptionSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.resourceArn = try reader["resourceArn"].readIfPresent() ?? ""
        value.destinationArn = try reader["destinationArn"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension VPCLatticeClientTypes.ListenerSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.ListenerSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.ListenerSummary()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.`protocol` = try reader["protocol"].readIfPresent()
        value.port = try reader["port"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension VPCLatticeClientTypes.RuleSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.RuleSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.RuleSummary()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.isDefault = try reader["isDefault"].readIfPresent()
        value.priority = try reader["priority"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension VPCLatticeClientTypes.ServiceNetworkSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.ServiceNetworkSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.ServiceNetworkSummary()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.numberOfAssociatedVPCs = try reader["numberOfAssociatedVPCs"].readIfPresent()
        value.numberOfAssociatedServices = try reader["numberOfAssociatedServices"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes.ServiceNetworkServiceAssociationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.ServiceNetworkServiceAssociationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.ServiceNetworkServiceAssociationSummary()
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.serviceId = try reader["serviceId"].readIfPresent()
        value.serviceName = try reader["serviceName"].readIfPresent()
        value.serviceArn = try reader["serviceArn"].readIfPresent()
        value.serviceNetworkId = try reader["serviceNetworkId"].readIfPresent()
        value.serviceNetworkName = try reader["serviceNetworkName"].readIfPresent()
        value.serviceNetworkArn = try reader["serviceNetworkArn"].readIfPresent()
        value.dnsEntry = try reader["dnsEntry"].readIfPresent(with: VPCLatticeClientTypes.DnsEntry.read(from:))
        value.customDomainName = try reader["customDomainName"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes.ServiceNetworkVpcAssociationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.ServiceNetworkVpcAssociationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.ServiceNetworkVpcAssociationSummary()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.serviceNetworkId = try reader["serviceNetworkId"].readIfPresent()
        value.serviceNetworkName = try reader["serviceNetworkName"].readIfPresent()
        value.serviceNetworkArn = try reader["serviceNetworkArn"].readIfPresent()
        value.vpcId = try reader["vpcId"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension VPCLatticeClientTypes.ServiceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.ServiceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.ServiceSummary()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.dnsEntry = try reader["dnsEntry"].readIfPresent(with: VPCLatticeClientTypes.DnsEntry.read(from:))
        value.customDomainName = try reader["customDomainName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes.TargetGroupSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.TargetGroupSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.TargetGroupSummary()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.port = try reader["port"].readIfPresent()
        value.`protocol` = try reader["protocol"].readIfPresent()
        value.ipAddressType = try reader["ipAddressType"].readIfPresent()
        value.vpcIdentifier = try reader["vpcIdentifier"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.status = try reader["status"].readIfPresent()
        value.serviceArns = try reader["serviceArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.lambdaEventStructureVersion = try reader["lambdaEventStructureVersion"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes.TargetSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.TargetSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.TargetSummary()
        value.id = try reader["id"].readIfPresent()
        value.port = try reader["port"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.reasonCode = try reader["reasonCode"].readIfPresent()
        return value
    }
}

extension VPCLatticeClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> VPCLatticeClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VPCLatticeClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension VPCLatticeClientTypes.RuleUpdate {

    static func write(value: VPCLatticeClientTypes.RuleUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action, with: VPCLatticeClientTypes.RuleAction.write(value:to:))
        try writer["match"].write(value.match, with: VPCLatticeClientTypes.RuleMatch.write(value:to:))
        try writer["priority"].write(value.priority)
        try writer["ruleIdentifier"].write(value.ruleIdentifier)
    }
}

public enum VPCLatticeClientTypes {}
