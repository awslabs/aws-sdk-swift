// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension PanoramaClient {
    /// Paginate over `[ListApplicationInstanceDependenciesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListApplicationInstanceDependenciesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListApplicationInstanceDependenciesOutputResponse`
    public func listApplicationInstanceDependenciesPaginated(input: ListApplicationInstanceDependenciesInput) -> ClientRuntime.PaginatorSequence<ListApplicationInstanceDependenciesInput, ListApplicationInstanceDependenciesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListApplicationInstanceDependenciesInput, ListApplicationInstanceDependenciesOutputResponse>(input: input, inputKey: \ListApplicationInstanceDependenciesInput.nextToken, outputKey: \ListApplicationInstanceDependenciesOutputResponse.nextToken, paginationFunction: self.listApplicationInstanceDependencies(input:))
    }
}

extension ListApplicationInstanceDependenciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListApplicationInstanceDependenciesInput {
        return ListApplicationInstanceDependenciesInput(
            applicationInstanceId: self.applicationInstanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension PanoramaClient {
    /// Paginate over `[ListApplicationInstanceNodeInstancesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListApplicationInstanceNodeInstancesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListApplicationInstanceNodeInstancesOutputResponse`
    public func listApplicationInstanceNodeInstancesPaginated(input: ListApplicationInstanceNodeInstancesInput) -> ClientRuntime.PaginatorSequence<ListApplicationInstanceNodeInstancesInput, ListApplicationInstanceNodeInstancesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListApplicationInstanceNodeInstancesInput, ListApplicationInstanceNodeInstancesOutputResponse>(input: input, inputKey: \ListApplicationInstanceNodeInstancesInput.nextToken, outputKey: \ListApplicationInstanceNodeInstancesOutputResponse.nextToken, paginationFunction: self.listApplicationInstanceNodeInstances(input:))
    }
}

extension ListApplicationInstanceNodeInstancesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListApplicationInstanceNodeInstancesInput {
        return ListApplicationInstanceNodeInstancesInput(
            applicationInstanceId: self.applicationInstanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension PanoramaClient {
    /// Paginate over `[ListApplicationInstancesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListApplicationInstancesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListApplicationInstancesOutputResponse`
    public func listApplicationInstancesPaginated(input: ListApplicationInstancesInput) -> ClientRuntime.PaginatorSequence<ListApplicationInstancesInput, ListApplicationInstancesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListApplicationInstancesInput, ListApplicationInstancesOutputResponse>(input: input, inputKey: \ListApplicationInstancesInput.nextToken, outputKey: \ListApplicationInstancesOutputResponse.nextToken, paginationFunction: self.listApplicationInstances(input:))
    }
}

extension ListApplicationInstancesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListApplicationInstancesInput {
        return ListApplicationInstancesInput(
            deviceId: self.deviceId,
            maxResults: self.maxResults,
            nextToken: token,
            statusFilter: self.statusFilter
        )}
}
extension PanoramaClient {
    /// Paginate over `[ListDevicesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDevicesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDevicesOutputResponse`
    public func listDevicesPaginated(input: ListDevicesInput) -> ClientRuntime.PaginatorSequence<ListDevicesInput, ListDevicesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDevicesInput, ListDevicesOutputResponse>(input: input, inputKey: \ListDevicesInput.nextToken, outputKey: \ListDevicesOutputResponse.nextToken, paginationFunction: self.listDevices(input:))
    }
}

extension ListDevicesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDevicesInput {
        return ListDevicesInput(
            deviceAggregatedStatusFilter: self.deviceAggregatedStatusFilter,
            maxResults: self.maxResults,
            nameFilter: self.nameFilter,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}
extension PanoramaClient {
    /// Paginate over `[ListDevicesJobsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDevicesJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDevicesJobsOutputResponse`
    public func listDevicesJobsPaginated(input: ListDevicesJobsInput) -> ClientRuntime.PaginatorSequence<ListDevicesJobsInput, ListDevicesJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDevicesJobsInput, ListDevicesJobsOutputResponse>(input: input, inputKey: \ListDevicesJobsInput.nextToken, outputKey: \ListDevicesJobsOutputResponse.nextToken, paginationFunction: self.listDevicesJobs(input:))
    }
}

extension ListDevicesJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDevicesJobsInput {
        return ListDevicesJobsInput(
            deviceId: self.deviceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension PanoramaClient {
    /// Paginate over `[ListNodeFromTemplateJobsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListNodeFromTemplateJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListNodeFromTemplateJobsOutputResponse`
    public func listNodeFromTemplateJobsPaginated(input: ListNodeFromTemplateJobsInput) -> ClientRuntime.PaginatorSequence<ListNodeFromTemplateJobsInput, ListNodeFromTemplateJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListNodeFromTemplateJobsInput, ListNodeFromTemplateJobsOutputResponse>(input: input, inputKey: \ListNodeFromTemplateJobsInput.nextToken, outputKey: \ListNodeFromTemplateJobsOutputResponse.nextToken, paginationFunction: self.listNodeFromTemplateJobs(input:))
    }
}

extension ListNodeFromTemplateJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListNodeFromTemplateJobsInput {
        return ListNodeFromTemplateJobsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension PanoramaClient {
    /// Paginate over `[ListNodesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListNodesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListNodesOutputResponse`
    public func listNodesPaginated(input: ListNodesInput) -> ClientRuntime.PaginatorSequence<ListNodesInput, ListNodesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListNodesInput, ListNodesOutputResponse>(input: input, inputKey: \ListNodesInput.nextToken, outputKey: \ListNodesOutputResponse.nextToken, paginationFunction: self.listNodes(input:))
    }
}

extension ListNodesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListNodesInput {
        return ListNodesInput(
            category: self.category,
            maxResults: self.maxResults,
            nextToken: token,
            ownerAccount: self.ownerAccount,
            packageName: self.packageName,
            packageVersion: self.packageVersion,
            patchVersion: self.patchVersion
        )}
}
extension PanoramaClient {
    /// Paginate over `[ListPackageImportJobsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPackageImportJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPackageImportJobsOutputResponse`
    public func listPackageImportJobsPaginated(input: ListPackageImportJobsInput) -> ClientRuntime.PaginatorSequence<ListPackageImportJobsInput, ListPackageImportJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListPackageImportJobsInput, ListPackageImportJobsOutputResponse>(input: input, inputKey: \ListPackageImportJobsInput.nextToken, outputKey: \ListPackageImportJobsOutputResponse.nextToken, paginationFunction: self.listPackageImportJobs(input:))
    }
}

extension ListPackageImportJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPackageImportJobsInput {
        return ListPackageImportJobsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension PanoramaClient {
    /// Paginate over `[ListPackagesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPackagesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPackagesOutputResponse`
    public func listPackagesPaginated(input: ListPackagesInput) -> ClientRuntime.PaginatorSequence<ListPackagesInput, ListPackagesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListPackagesInput, ListPackagesOutputResponse>(input: input, inputKey: \ListPackagesInput.nextToken, outputKey: \ListPackagesOutputResponse.nextToken, paginationFunction: self.listPackages(input:))
    }
}

extension ListPackagesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPackagesInput {
        return ListPackagesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
