//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// The requestor does not have permission to access the target action or resource.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension PanoramaClientTypes {

    /// Details about a beta appliance software update.
    public struct AlternateSoftwareMetadata: Swift.Sendable {
        /// The appliance software version.
        public var version: Swift.String?

        public init(
            version: Swift.String? = nil
        )
        {
            self.version = version
        }
    }
}

extension PanoramaClientTypes {

    public enum ApplicationInstanceHealthStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case error
        case notAvailable
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationInstanceHealthStatus] {
            return [
                .error,
                .notAvailable,
                .running
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .notAvailable: return "NOT_AVAILABLE"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PanoramaClientTypes {

    public enum DesiredState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case removed
        case running
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [DesiredState] {
            return [
                .removed,
                .running,
                .stopped
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .removed: return "REMOVED"
            case .running: return "RUNNING"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PanoramaClientTypes {

    public enum DeviceReportedStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case installError
        case installInProgress
        case launched
        case launchError
        case removalFailed
        case removalInProgress
        case running
        case starting
        case stopped
        case stopping
        case stopError
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceReportedStatus] {
            return [
                .installError,
                .installInProgress,
                .launched,
                .launchError,
                .removalFailed,
                .removalInProgress,
                .running,
                .starting,
                .stopped,
                .stopping,
                .stopError
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .installError: return "INSTALL_ERROR"
            case .installInProgress: return "INSTALL_IN_PROGRESS"
            case .launched: return "LAUNCHED"
            case .launchError: return "LAUNCH_ERROR"
            case .removalFailed: return "REMOVAL_FAILED"
            case .removalInProgress: return "REMOVAL_IN_PROGRESS"
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .stopError: return "STOP_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PanoramaClientTypes {

    /// An application instance's state.
    public struct ReportedRuntimeContextState: Swift.Sendable {
        /// The application's desired state.
        /// This member is required.
        public var desiredState: PanoramaClientTypes.DesiredState?
        /// The application's reported status.
        /// This member is required.
        public var deviceReportedStatus: PanoramaClientTypes.DeviceReportedStatus?
        /// When the device reported the application's state.
        /// This member is required.
        public var deviceReportedTime: Foundation.Date?
        /// The device's name.
        /// This member is required.
        public var runtimeContextName: Swift.String?

        public init(
            desiredState: PanoramaClientTypes.DesiredState? = nil,
            deviceReportedStatus: PanoramaClientTypes.DeviceReportedStatus? = nil,
            deviceReportedTime: Foundation.Date? = nil,
            runtimeContextName: Swift.String? = nil
        )
        {
            self.desiredState = desiredState
            self.deviceReportedStatus = deviceReportedStatus
            self.deviceReportedTime = deviceReportedTime
            self.runtimeContextName = runtimeContextName
        }
    }
}

extension PanoramaClientTypes {

    public enum ApplicationInstanceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deploymentError
        case deploymentFailed
        case deploymentInProgress
        case deploymentPending
        case deploymentRequested
        case deploymentSucceeded
        case removalFailed
        case removalInProgress
        case removalPending
        case removalRequested
        case removalSucceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationInstanceStatus] {
            return [
                .deploymentError,
                .deploymentFailed,
                .deploymentInProgress,
                .deploymentPending,
                .deploymentRequested,
                .deploymentSucceeded,
                .removalFailed,
                .removalInProgress,
                .removalPending,
                .removalRequested,
                .removalSucceeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deploymentError: return "DEPLOYMENT_ERROR"
            case .deploymentFailed: return "DEPLOYMENT_FAILED"
            case .deploymentInProgress: return "DEPLOYMENT_IN_PROGRESS"
            case .deploymentPending: return "DEPLOYMENT_PENDING"
            case .deploymentRequested: return "DEPLOYMENT_REQUESTED"
            case .deploymentSucceeded: return "DEPLOYMENT_SUCCEEDED"
            case .removalFailed: return "REMOVAL_FAILED"
            case .removalInProgress: return "REMOVAL_IN_PROGRESS"
            case .removalPending: return "REMOVAL_PENDING"
            case .removalRequested: return "REMOVAL_REQUESTED"
            case .removalSucceeded: return "REMOVAL_SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PanoramaClientTypes {

    /// An application instance on a device.
    public struct ApplicationInstance: Swift.Sendable {
        /// The application instance's ID.
        public var applicationInstanceId: Swift.String?
        /// The application instance's ARN.
        public var arn: Swift.String?
        /// When the application instance was created.
        public var createdTime: Foundation.Date?
        /// The device's ID.
        public var defaultRuntimeContextDevice: Swift.String?
        /// The device's name.
        public var defaultRuntimeContextDeviceName: Swift.String?
        /// The application instance's description.
        public var description: Swift.String?
        /// The application instance's health status.
        public var healthStatus: PanoramaClientTypes.ApplicationInstanceHealthStatus?
        /// The application instance's name.
        public var name: Swift.String?
        /// The application's state.
        public var runtimeContextStates: [PanoramaClientTypes.ReportedRuntimeContextState]?
        /// The application instance's status.
        public var status: PanoramaClientTypes.ApplicationInstanceStatus?
        /// The application instance's status description.
        public var statusDescription: Swift.String?
        /// The application instance's tags.
        public var tags: [Swift.String: Swift.String]?

        public init(
            applicationInstanceId: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            defaultRuntimeContextDevice: Swift.String? = nil,
            defaultRuntimeContextDeviceName: Swift.String? = nil,
            description: Swift.String? = nil,
            healthStatus: PanoramaClientTypes.ApplicationInstanceHealthStatus? = nil,
            name: Swift.String? = nil,
            runtimeContextStates: [PanoramaClientTypes.ReportedRuntimeContextState]? = nil,
            status: PanoramaClientTypes.ApplicationInstanceStatus? = nil,
            statusDescription: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.applicationInstanceId = applicationInstanceId
            self.arn = arn
            self.createdTime = createdTime
            self.defaultRuntimeContextDevice = defaultRuntimeContextDevice
            self.defaultRuntimeContextDeviceName = defaultRuntimeContextDeviceName
            self.description = description
            self.healthStatus = healthStatus
            self.name = name
            self.runtimeContextStates = runtimeContextStates
            self.status = status
            self.statusDescription = statusDescription
            self.tags = tags
        }
    }
}

extension PanoramaClientTypes {

    /// A conflict exception error argument.
    public struct ConflictExceptionErrorArgument: Swift.Sendable {
        /// The error argument's name.
        /// This member is required.
        public var name: Swift.String?
        /// The error argument's value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }
}

/// The target resource is in use.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A list of attributes that led to the exception and their values.
        public internal(set) var errorArguments: [PanoramaClientTypes.ConflictExceptionErrorArgument]? = nil
        /// A unique ID for the error.
        public internal(set) var errorId: Swift.String? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The resource's ID.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource's type.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorArguments: [PanoramaClientTypes.ConflictExceptionErrorArgument]? = nil,
        errorId: Swift.String? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.errorArguments = errorArguments
        self.properties.errorId = errorId
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

extension PanoramaClientTypes {

    public enum ConnectionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dhcp
        case staticIp
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionType] {
            return [
                .dhcp,
                .staticIp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dhcp: return "DHCP"
            case .staticIp: return "STATIC_IP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// An internal error occurred.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The number of seconds a client should wait before retrying the call.
        public internal(set) var retryAfterSeconds: Swift.Int = 0
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// The request would cause a limit to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The name of the limit.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The target resource's ID.
        public internal(set) var resourceId: Swift.String? = nil
        /// The target resource's type.
        public internal(set) var resourceType: Swift.String? = nil
        /// The name of the service.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

extension PanoramaClientTypes {

    /// A validation exception error argument.
    public struct ValidationExceptionErrorArgument: Swift.Sendable {
        /// The argument's name.
        /// This member is required.
        public var name: Swift.String?
        /// The argument's value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }
}

extension PanoramaClientTypes {

    /// A validation exception field.
    public struct ValidationExceptionField: Swift.Sendable {
        /// The field's message.
        /// This member is required.
        public var message: Swift.String?
        /// The field's name.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }
}

extension PanoramaClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The request contains an invalid parameter value.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A list of attributes that led to the exception and their values.
        public internal(set) var errorArguments: [PanoramaClientTypes.ValidationExceptionErrorArgument]? = nil
        /// A unique ID for the error.
        public internal(set) var errorId: Swift.String? = nil
        /// A list of request parameters that failed validation.
        public internal(set) var fields: [PanoramaClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason that validation failed.
        public internal(set) var reason: PanoramaClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorArguments: [PanoramaClientTypes.ValidationExceptionErrorArgument]? = nil,
        errorId: Swift.String? = nil,
        fields: [PanoramaClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: PanoramaClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.errorArguments = errorArguments
        self.properties.errorId = errorId
        self.properties.fields = fields
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension PanoramaClientTypes {

    /// Parameter overrides for an application instance. This is a JSON document that has a single key (PayloadData) where the value is an escaped string representation of the overrides document.
    public enum ManifestOverridesPayload: Swift.Sendable {
        /// The overrides document.
        case payloaddata(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension PanoramaClientTypes {

    /// A application verion's manifest file. This is a JSON document that has a single key (PayloadData) where the value is an escaped string representation of the application manifest (graph.json). This file is located in the graphs folder in your application source.
    public enum ManifestPayload: Swift.Sendable {
        /// The application manifest.
        case payloaddata(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

public struct CreateApplicationInstanceInput: Swift.Sendable {
    /// The ID of an application instance to replace with the new instance.
    public var applicationInstanceIdToReplace: Swift.String?
    /// A device's ID.
    /// This member is required.
    public var defaultRuntimeContextDevice: Swift.String?
    /// A description for the application instance.
    public var description: Swift.String?
    /// Setting overrides for the application manifest.
    public var manifestOverridesPayload: PanoramaClientTypes.ManifestOverridesPayload?
    /// The application's manifest document.
    /// This member is required.
    public var manifestPayload: PanoramaClientTypes.ManifestPayload?
    /// A name for the application instance.
    public var name: Swift.String?
    /// The ARN of a runtime role for the application instance.
    public var runtimeRoleArn: Swift.String?
    /// Tags for the application instance.
    public var tags: [Swift.String: Swift.String]?

    public init(
        applicationInstanceIdToReplace: Swift.String? = nil,
        defaultRuntimeContextDevice: Swift.String? = nil,
        description: Swift.String? = nil,
        manifestOverridesPayload: PanoramaClientTypes.ManifestOverridesPayload? = nil,
        manifestPayload: PanoramaClientTypes.ManifestPayload? = nil,
        name: Swift.String? = nil,
        runtimeRoleArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.applicationInstanceIdToReplace = applicationInstanceIdToReplace
        self.defaultRuntimeContextDevice = defaultRuntimeContextDevice
        self.description = description
        self.manifestOverridesPayload = manifestOverridesPayload
        self.manifestPayload = manifestPayload
        self.name = name
        self.runtimeRoleArn = runtimeRoleArn
        self.tags = tags
    }
}

public struct CreateApplicationInstanceOutput: Swift.Sendable {
    /// The application instance's ID.
    /// This member is required.
    public var applicationInstanceId: Swift.String?

    public init(
        applicationInstanceId: Swift.String? = nil
    )
    {
        self.applicationInstanceId = applicationInstanceId
    }
}

/// The target resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The resource's ID.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource's type.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

extension PanoramaClientTypes {

    /// An over-the-air update (OTA) job configuration.
    public struct OTAJobConfig: Swift.Sendable {
        /// Whether to apply the update if it is a major version change.
        public var allowMajorVersionUpdate: Swift.Bool
        /// The target version of the device software.
        /// This member is required.
        public var imageVersion: Swift.String?

        public init(
            allowMajorVersionUpdate: Swift.Bool = false,
            imageVersion: Swift.String? = nil
        )
        {
            self.allowMajorVersionUpdate = allowMajorVersionUpdate
            self.imageVersion = imageVersion
        }
    }
}

extension PanoramaClientTypes {

    /// A job's configuration.
    public struct DeviceJobConfig: Swift.Sendable {
        /// A configuration for an over-the-air (OTA) upgrade. Required for OTA jobs.
        public var otaJobConfig: PanoramaClientTypes.OTAJobConfig?

        public init(
            otaJobConfig: PanoramaClientTypes.OTAJobConfig? = nil
        )
        {
            self.otaJobConfig = otaJobConfig
        }
    }
}

extension PanoramaClientTypes {

    public enum JobType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ota
        case reboot
        case sdkUnknown(Swift.String)

        public static var allCases: [JobType] {
            return [
                .ota,
                .reboot
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ota: return "OTA"
            case .reboot: return "REBOOT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateJobForDevicesInput: Swift.Sendable {
    /// ID of target device.
    /// This member is required.
    public var deviceIds: [Swift.String]?
    /// Configuration settings for a software update job.
    public var deviceJobConfig: PanoramaClientTypes.DeviceJobConfig?
    /// The type of job to run.
    /// This member is required.
    public var jobType: PanoramaClientTypes.JobType?

    public init(
        deviceIds: [Swift.String]? = nil,
        deviceJobConfig: PanoramaClientTypes.DeviceJobConfig? = nil,
        jobType: PanoramaClientTypes.JobType? = nil
    )
    {
        self.deviceIds = deviceIds
        self.deviceJobConfig = deviceJobConfig
        self.jobType = jobType
    }
}

extension PanoramaClientTypes {

    /// A job for a device.
    public struct Job: Swift.Sendable {
        /// The target device's ID.
        public var deviceId: Swift.String?
        /// The job's ID.
        public var jobId: Swift.String?

        public init(
            deviceId: Swift.String? = nil,
            jobId: Swift.String? = nil
        )
        {
            self.deviceId = deviceId
            self.jobId = jobId
        }
    }
}

public struct CreateJobForDevicesOutput: Swift.Sendable {
    /// A list of jobs.
    /// This member is required.
    public var jobs: [PanoramaClientTypes.Job]?

    public init(
        jobs: [PanoramaClientTypes.Job]? = nil
    )
    {
        self.jobs = jobs
    }
}

extension PanoramaClientTypes {

    public enum JobResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case package
        case sdkUnknown(Swift.String)

        public static var allCases: [JobResourceType] {
            return [
                .package
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .package: return "PACKAGE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PanoramaClientTypes {

    /// Tags for a job.
    public struct JobResourceTags: Swift.Sendable {
        /// The job's type.
        /// This member is required.
        public var resourceType: PanoramaClientTypes.JobResourceType?
        /// The job's tags.
        /// This member is required.
        public var tags: [Swift.String: Swift.String]?

        public init(
            resourceType: PanoramaClientTypes.JobResourceType? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.resourceType = resourceType
            self.tags = tags
        }
    }
}

extension PanoramaClientTypes {

    public enum TemplateType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case rtspCameraStream
        case sdkUnknown(Swift.String)

        public static var allCases: [TemplateType] {
            return [
                .rtspCameraStream
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .rtspCameraStream: return "RTSP_CAMERA_STREAM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateNodeFromTemplateJobInput: Swift.Sendable {
    /// Tags for the job.
    public var jobTags: [PanoramaClientTypes.JobResourceTags]?
    /// A description for the node.
    public var nodeDescription: Swift.String?
    /// A name for the node.
    /// This member is required.
    public var nodeName: Swift.String?
    /// An output package name for the node.
    /// This member is required.
    public var outputPackageName: Swift.String?
    /// An output package version for the node.
    /// This member is required.
    public var outputPackageVersion: Swift.String?
    /// Template parameters for the node.
    /// This member is required.
    public var templateParameters: [Swift.String: Swift.String]?
    /// The type of node.
    /// This member is required.
    public var templateType: PanoramaClientTypes.TemplateType?

    public init(
        jobTags: [PanoramaClientTypes.JobResourceTags]? = nil,
        nodeDescription: Swift.String? = nil,
        nodeName: Swift.String? = nil,
        outputPackageName: Swift.String? = nil,
        outputPackageVersion: Swift.String? = nil,
        templateParameters: [Swift.String: Swift.String]? = nil,
        templateType: PanoramaClientTypes.TemplateType? = nil
    )
    {
        self.jobTags = jobTags
        self.nodeDescription = nodeDescription
        self.nodeName = nodeName
        self.outputPackageName = outputPackageName
        self.outputPackageVersion = outputPackageVersion
        self.templateParameters = templateParameters
        self.templateType = templateType
    }
}

extension CreateNodeFromTemplateJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateNodeFromTemplateJobInput(jobTags: \(Swift.String(describing: jobTags)), nodeDescription: \(Swift.String(describing: nodeDescription)), nodeName: \(Swift.String(describing: nodeName)), outputPackageName: \(Swift.String(describing: outputPackageName)), outputPackageVersion: \(Swift.String(describing: outputPackageVersion)), templateType: \(Swift.String(describing: templateType)), templateParameters: [keys: \(Swift.String(describing: templateParameters?.keys)), values: \"CONTENT_REDACTED\"])"}
}

public struct CreateNodeFromTemplateJobOutput: Swift.Sendable {
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

public struct CreatePackageInput: Swift.Sendable {
    /// A name for the package.
    /// This member is required.
    public var packageName: Swift.String?
    /// Tags for the package.
    public var tags: [Swift.String: Swift.String]?

    public init(
        packageName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.packageName = packageName
        self.tags = tags
    }
}

extension PanoramaClientTypes {

    /// A storage location.
    public struct StorageLocation: Swift.Sendable {
        /// The location's binary prefix.
        /// This member is required.
        public var binaryPrefixLocation: Swift.String?
        /// The location's bucket.
        /// This member is required.
        public var bucket: Swift.String?
        /// The location's generated prefix.
        /// This member is required.
        public var generatedPrefixLocation: Swift.String?
        /// The location's manifest prefix.
        /// This member is required.
        public var manifestPrefixLocation: Swift.String?
        /// The location's repo prefix.
        /// This member is required.
        public var repoPrefixLocation: Swift.String?

        public init(
            binaryPrefixLocation: Swift.String? = nil,
            bucket: Swift.String? = nil,
            generatedPrefixLocation: Swift.String? = nil,
            manifestPrefixLocation: Swift.String? = nil,
            repoPrefixLocation: Swift.String? = nil
        )
        {
            self.binaryPrefixLocation = binaryPrefixLocation
            self.bucket = bucket
            self.generatedPrefixLocation = generatedPrefixLocation
            self.manifestPrefixLocation = manifestPrefixLocation
            self.repoPrefixLocation = repoPrefixLocation
        }
    }
}

public struct CreatePackageOutput: Swift.Sendable {
    /// The package's ARN.
    public var arn: Swift.String?
    /// The package's ID.
    public var packageId: Swift.String?
    /// The package's storage location.
    /// This member is required.
    public var storageLocation: PanoramaClientTypes.StorageLocation?

    public init(
        arn: Swift.String? = nil,
        packageId: Swift.String? = nil,
        storageLocation: PanoramaClientTypes.StorageLocation? = nil
    )
    {
        self.arn = arn
        self.packageId = packageId
        self.storageLocation = storageLocation
    }
}

extension PanoramaClientTypes {

    /// A location in Amazon S3.
    public struct S3Location: Swift.Sendable {
        /// A bucket name.
        /// This member is required.
        public var bucketName: Swift.String?
        /// An object key.
        /// This member is required.
        public var objectKey: Swift.String?
        /// The bucket's Region.
        public var region: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            objectKey: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.objectKey = objectKey
            self.region = region
        }
    }
}

extension PanoramaClientTypes {

    /// A package version input configuration.
    public struct PackageVersionInputConfig: Swift.Sendable {
        /// A location in Amazon S3.
        /// This member is required.
        public var s3Location: PanoramaClientTypes.S3Location?

        public init(
            s3Location: PanoramaClientTypes.S3Location? = nil
        )
        {
            self.s3Location = s3Location
        }
    }
}

extension PanoramaClientTypes {

    /// A configuration for a package import job.
    public struct PackageImportJobInputConfig: Swift.Sendable {
        /// The package version's input configuration.
        public var packageVersionInputConfig: PanoramaClientTypes.PackageVersionInputConfig?

        public init(
            packageVersionInputConfig: PanoramaClientTypes.PackageVersionInputConfig? = nil
        )
        {
            self.packageVersionInputConfig = packageVersionInputConfig
        }
    }
}

extension PanoramaClientTypes {

    public enum PackageImportJobType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case marketplaceNodePackageVersion
        case nodePackageVersion
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageImportJobType] {
            return [
                .marketplaceNodePackageVersion,
                .nodePackageVersion
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .marketplaceNodePackageVersion: return "MARKETPLACE_NODE_PACKAGE_VERSION"
            case .nodePackageVersion: return "NODE_PACKAGE_VERSION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PanoramaClientTypes {

    /// A package version output configuration.
    public struct PackageVersionOutputConfig: Swift.Sendable {
        /// Indicates that the version is recommended for all users.
        public var markLatest: Swift.Bool
        /// The output's package name.
        /// This member is required.
        public var packageName: Swift.String?
        /// The output's package version.
        /// This member is required.
        public var packageVersion: Swift.String?

        public init(
            markLatest: Swift.Bool = false,
            packageName: Swift.String? = nil,
            packageVersion: Swift.String? = nil
        )
        {
            self.markLatest = markLatest
            self.packageName = packageName
            self.packageVersion = packageVersion
        }
    }
}

extension PanoramaClientTypes {

    /// An output configuration for a package import job.
    public struct PackageImportJobOutputConfig: Swift.Sendable {
        /// The package version's output configuration.
        public var packageVersionOutputConfig: PanoramaClientTypes.PackageVersionOutputConfig?

        public init(
            packageVersionOutputConfig: PanoramaClientTypes.PackageVersionOutputConfig? = nil
        )
        {
            self.packageVersionOutputConfig = packageVersionOutputConfig
        }
    }
}

public struct CreatePackageImportJobInput: Swift.Sendable {
    /// A client token for the package import job.
    /// This member is required.
    public var clientToken: Swift.String?
    /// An input config for the package import job.
    /// This member is required.
    public var inputConfig: PanoramaClientTypes.PackageImportJobInputConfig?
    /// Tags for the package import job.
    public var jobTags: [PanoramaClientTypes.JobResourceTags]?
    /// A job type for the package import job.
    /// This member is required.
    public var jobType: PanoramaClientTypes.PackageImportJobType?
    /// An output config for the package import job.
    /// This member is required.
    public var outputConfig: PanoramaClientTypes.PackageImportJobOutputConfig?

    public init(
        clientToken: Swift.String? = nil,
        inputConfig: PanoramaClientTypes.PackageImportJobInputConfig? = nil,
        jobTags: [PanoramaClientTypes.JobResourceTags]? = nil,
        jobType: PanoramaClientTypes.PackageImportJobType? = nil,
        outputConfig: PanoramaClientTypes.PackageImportJobOutputConfig? = nil
    )
    {
        self.clientToken = clientToken
        self.inputConfig = inputConfig
        self.jobTags = jobTags
        self.jobType = jobType
        self.outputConfig = outputConfig
    }
}

public struct CreatePackageImportJobOutput: Swift.Sendable {
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

public struct DeleteDeviceInput: Swift.Sendable {
    /// The device's ID.
    /// This member is required.
    public var deviceId: Swift.String?

    public init(
        deviceId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
    }
}

public struct DeleteDeviceOutput: Swift.Sendable {
    /// The device's ID.
    public var deviceId: Swift.String?

    public init(
        deviceId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
    }
}

public struct DeletePackageInput: Swift.Sendable {
    /// Delete the package even if it has artifacts stored in its access point. Deletes the package's artifacts from Amazon S3.
    public var forceDelete: Swift.Bool
    /// The package's ID.
    /// This member is required.
    public var packageId: Swift.String?

    public init(
        forceDelete: Swift.Bool = false,
        packageId: Swift.String? = nil
    )
    {
        self.forceDelete = forceDelete
        self.packageId = packageId
    }
}

public struct DeletePackageOutput: Swift.Sendable {

    public init() { }
}

public struct DeregisterPackageVersionInput: Swift.Sendable {
    /// An owner account.
    public var ownerAccount: Swift.String?
    /// A package ID.
    /// This member is required.
    public var packageId: Swift.String?
    /// A package version.
    /// This member is required.
    public var packageVersion: Swift.String?
    /// A patch version.
    /// This member is required.
    public var patchVersion: Swift.String?
    /// If the version was marked latest, the new version to maker as latest.
    public var updatedLatestPatchVersion: Swift.String?

    public init(
        ownerAccount: Swift.String? = nil,
        packageId: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        patchVersion: Swift.String? = nil,
        updatedLatestPatchVersion: Swift.String? = nil
    )
    {
        self.ownerAccount = ownerAccount
        self.packageId = packageId
        self.packageVersion = packageVersion
        self.patchVersion = patchVersion
        self.updatedLatestPatchVersion = updatedLatestPatchVersion
    }
}

public struct DeregisterPackageVersionOutput: Swift.Sendable {

    public init() { }
}

public struct DescribeApplicationInstanceInput: Swift.Sendable {
    /// The application instance's ID.
    /// This member is required.
    public var applicationInstanceId: Swift.String?

    public init(
        applicationInstanceId: Swift.String? = nil
    )
    {
        self.applicationInstanceId = applicationInstanceId
    }
}

public struct DescribeApplicationInstanceOutput: Swift.Sendable {
    /// The application instance's ID.
    public var applicationInstanceId: Swift.String?
    /// The ID of the application instance that this instance replaced.
    public var applicationInstanceIdToReplace: Swift.String?
    /// The application instance's ARN.
    public var arn: Swift.String?
    /// When the application instance was created.
    public var createdTime: Foundation.Date?
    /// The device's ID.
    public var defaultRuntimeContextDevice: Swift.String?
    /// The device's bane.
    public var defaultRuntimeContextDeviceName: Swift.String?
    /// The application instance's description.
    public var description: Swift.String?
    /// The application instance's health status.
    public var healthStatus: PanoramaClientTypes.ApplicationInstanceHealthStatus?
    /// The application instance was updated.
    public var lastUpdatedTime: Foundation.Date?
    /// The application instance's name.
    public var name: Swift.String?
    /// The application instance's state.
    public var runtimeContextStates: [PanoramaClientTypes.ReportedRuntimeContextState]?
    /// The application instance's runtime role ARN.
    public var runtimeRoleArn: Swift.String?
    /// The application instance's status.
    public var status: PanoramaClientTypes.ApplicationInstanceStatus?
    /// The application instance's status description.
    public var statusDescription: Swift.String?
    /// The application instance's tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        applicationInstanceId: Swift.String? = nil,
        applicationInstanceIdToReplace: Swift.String? = nil,
        arn: Swift.String? = nil,
        createdTime: Foundation.Date? = nil,
        defaultRuntimeContextDevice: Swift.String? = nil,
        defaultRuntimeContextDeviceName: Swift.String? = nil,
        description: Swift.String? = nil,
        healthStatus: PanoramaClientTypes.ApplicationInstanceHealthStatus? = nil,
        lastUpdatedTime: Foundation.Date? = nil,
        name: Swift.String? = nil,
        runtimeContextStates: [PanoramaClientTypes.ReportedRuntimeContextState]? = nil,
        runtimeRoleArn: Swift.String? = nil,
        status: PanoramaClientTypes.ApplicationInstanceStatus? = nil,
        statusDescription: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.applicationInstanceId = applicationInstanceId
        self.applicationInstanceIdToReplace = applicationInstanceIdToReplace
        self.arn = arn
        self.createdTime = createdTime
        self.defaultRuntimeContextDevice = defaultRuntimeContextDevice
        self.defaultRuntimeContextDeviceName = defaultRuntimeContextDeviceName
        self.description = description
        self.healthStatus = healthStatus
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.runtimeContextStates = runtimeContextStates
        self.runtimeRoleArn = runtimeRoleArn
        self.status = status
        self.statusDescription = statusDescription
        self.tags = tags
    }
}

public struct DescribeApplicationInstanceDetailsInput: Swift.Sendable {
    /// The application instance's ID.
    /// This member is required.
    public var applicationInstanceId: Swift.String?

    public init(
        applicationInstanceId: Swift.String? = nil
    )
    {
        self.applicationInstanceId = applicationInstanceId
    }
}

public struct DescribeApplicationInstanceDetailsOutput: Swift.Sendable {
    /// The application instance's ID.
    public var applicationInstanceId: Swift.String?
    /// The ID of the application instance that this instance replaced.
    public var applicationInstanceIdToReplace: Swift.String?
    /// When the application instance was created.
    public var createdTime: Foundation.Date?
    /// The application instance's default runtime context device.
    public var defaultRuntimeContextDevice: Swift.String?
    /// The application instance's description.
    public var description: Swift.String?
    /// Parameter overrides for the configuration manifest.
    public var manifestOverridesPayload: PanoramaClientTypes.ManifestOverridesPayload?
    /// The application instance's configuration manifest.
    public var manifestPayload: PanoramaClientTypes.ManifestPayload?
    /// The application instance's name.
    public var name: Swift.String?

    public init(
        applicationInstanceId: Swift.String? = nil,
        applicationInstanceIdToReplace: Swift.String? = nil,
        createdTime: Foundation.Date? = nil,
        defaultRuntimeContextDevice: Swift.String? = nil,
        description: Swift.String? = nil,
        manifestOverridesPayload: PanoramaClientTypes.ManifestOverridesPayload? = nil,
        manifestPayload: PanoramaClientTypes.ManifestPayload? = nil,
        name: Swift.String? = nil
    )
    {
        self.applicationInstanceId = applicationInstanceId
        self.applicationInstanceIdToReplace = applicationInstanceIdToReplace
        self.createdTime = createdTime
        self.defaultRuntimeContextDevice = defaultRuntimeContextDevice
        self.description = description
        self.manifestOverridesPayload = manifestOverridesPayload
        self.manifestPayload = manifestPayload
        self.name = name
    }
}

public struct DescribeDeviceInput: Swift.Sendable {
    /// The device's ID.
    /// This member is required.
    public var deviceId: Swift.String?

    public init(
        deviceId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
    }
}

extension PanoramaClientTypes {

    public enum DeviceBrand: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsPanorama
        case lenovo
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceBrand] {
            return [
                .awsPanorama,
                .lenovo
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsPanorama: return "AWS_PANORAMA"
            case .lenovo: return "LENOVO"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PanoramaClientTypes {

    public enum NetworkConnectionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case connected
        case connecting
        case notConnected
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkConnectionStatus] {
            return [
                .connected,
                .connecting,
                .notConnected
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .connected: return "CONNECTED"
            case .connecting: return "CONNECTING"
            case .notConnected: return "NOT_CONNECTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PanoramaClientTypes {

    /// A device's Ethernet status.
    public struct EthernetStatus: Swift.Sendable {
        /// The device's connection status.
        public var connectionStatus: PanoramaClientTypes.NetworkConnectionStatus?
        /// The device's physical address.
        public var hwAddress: Swift.String?
        /// The device's IP address.
        public var ipAddress: Swift.String?

        public init(
            connectionStatus: PanoramaClientTypes.NetworkConnectionStatus? = nil,
            hwAddress: Swift.String? = nil,
            ipAddress: Swift.String? = nil
        )
        {
            self.connectionStatus = connectionStatus
            self.hwAddress = hwAddress
            self.ipAddress = ipAddress
        }
    }
}

extension PanoramaClientTypes {

    /// Details about an NTP server connection.
    public struct NtpStatus: Swift.Sendable {
        /// The connection's status.
        public var connectionStatus: PanoramaClientTypes.NetworkConnectionStatus?
        /// The IP address of the server.
        public var ipAddress: Swift.String?
        /// The domain name of the server.
        public var ntpServerName: Swift.String?

        public init(
            connectionStatus: PanoramaClientTypes.NetworkConnectionStatus? = nil,
            ipAddress: Swift.String? = nil,
            ntpServerName: Swift.String? = nil
        )
        {
            self.connectionStatus = connectionStatus
            self.ipAddress = ipAddress
            self.ntpServerName = ntpServerName
        }
    }
}

extension PanoramaClientTypes {

    /// The network status of a device.
    public struct NetworkStatus: Swift.Sendable {
        /// The status of Ethernet port 0.
        public var ethernet0Status: PanoramaClientTypes.EthernetStatus?
        /// The status of Ethernet port 1.
        public var ethernet1Status: PanoramaClientTypes.EthernetStatus?
        /// When the network status changed.
        public var lastUpdatedTime: Foundation.Date?
        /// Details about a network time protocol (NTP) server connection.
        public var ntpStatus: PanoramaClientTypes.NtpStatus?

        public init(
            ethernet0Status: PanoramaClientTypes.EthernetStatus? = nil,
            ethernet1Status: PanoramaClientTypes.EthernetStatus? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            ntpStatus: PanoramaClientTypes.NtpStatus? = nil
        )
        {
            self.ethernet0Status = ethernet0Status
            self.ethernet1Status = ethernet1Status
            self.lastUpdatedTime = lastUpdatedTime
            self.ntpStatus = ntpStatus
        }
    }
}

extension PanoramaClientTypes {

    public enum DeviceAggregatedStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awaitingProvisioning
        case deleting
        case error
        case failed
        case leaseExpired
        case offline
        case online
        case pending
        case rebooting
        case updateNeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceAggregatedStatus] {
            return [
                .awaitingProvisioning,
                .deleting,
                .error,
                .failed,
                .leaseExpired,
                .offline,
                .online,
                .pending,
                .rebooting,
                .updateNeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awaitingProvisioning: return "AWAITING_PROVISIONING"
            case .deleting: return "DELETING"
            case .error: return "ERROR"
            case .failed: return "FAILED"
            case .leaseExpired: return "LEASE_EXPIRED"
            case .offline: return "OFFLINE"
            case .online: return "ONLINE"
            case .pending: return "PENDING"
            case .rebooting: return "REBOOTING"
            case .updateNeeded: return "UPDATE_NEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PanoramaClientTypes {

    public enum DeviceConnectionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awaitingCredentials
        case error
        case notAvailable
        case offline
        case online
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceConnectionStatus] {
            return [
                .awaitingCredentials,
                .error,
                .notAvailable,
                .offline,
                .online
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awaitingCredentials: return "AWAITING_CREDENTIALS"
            case .error: return "ERROR"
            case .notAvailable: return "NOT_AVAILABLE"
            case .offline: return "OFFLINE"
            case .online: return "ONLINE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PanoramaClientTypes {

    public enum UpdateProgress: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case downloading
        case failed
        case inProgress
        case pending
        case rebooting
        case verifying
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateProgress] {
            return [
                .completed,
                .downloading,
                .failed,
                .inProgress,
                .pending,
                .rebooting,
                .verifying
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .downloading: return "DOWNLOADING"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case .rebooting: return "REBOOTING"
            case .verifying: return "VERIFYING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PanoramaClientTypes {

    /// Returns information about the latest device job.
    public struct LatestDeviceJob: Swift.Sendable {
        /// The target version of the device software.
        public var imageVersion: Swift.String?
        /// The job's type.
        public var jobType: PanoramaClientTypes.JobType?
        /// Status of the latest device job.
        public var status: PanoramaClientTypes.UpdateProgress?

        public init(
            imageVersion: Swift.String? = nil,
            jobType: PanoramaClientTypes.JobType? = nil,
            status: PanoramaClientTypes.UpdateProgress? = nil
        )
        {
            self.imageVersion = imageVersion
            self.jobType = jobType
            self.status = status
        }
    }
}

extension PanoramaClientTypes {

    /// A static IP configuration.
    public struct StaticIpConnectionInfo: Swift.Sendable {
        /// The connection's default gateway.
        /// This member is required.
        public var defaultGateway: Swift.String?
        /// The connection's DNS address.
        /// This member is required.
        public var dns: [Swift.String]?
        /// The connection's IP address.
        /// This member is required.
        public var ipAddress: Swift.String?
        /// The connection's DNS mask.
        /// This member is required.
        public var mask: Swift.String?

        public init(
            defaultGateway: Swift.String? = nil,
            dns: [Swift.String]? = nil,
            ipAddress: Swift.String? = nil,
            mask: Swift.String? = nil
        )
        {
            self.defaultGateway = defaultGateway
            self.dns = dns
            self.ipAddress = ipAddress
            self.mask = mask
        }
    }
}

extension PanoramaClientTypes {

    /// A device's network configuration.
    public struct EthernetPayload: Swift.Sendable {
        /// How the device gets an IP address.
        /// This member is required.
        public var connectionType: PanoramaClientTypes.ConnectionType?
        /// Network configuration for a static IP connection.
        public var staticIpConnectionInfo: PanoramaClientTypes.StaticIpConnectionInfo?

        public init(
            connectionType: PanoramaClientTypes.ConnectionType? = nil,
            staticIpConnectionInfo: PanoramaClientTypes.StaticIpConnectionInfo? = nil
        )
        {
            self.connectionType = connectionType
            self.staticIpConnectionInfo = staticIpConnectionInfo
        }
    }
}

extension PanoramaClientTypes {

    /// Network time protocol (NTP) server settings. Use this option to connect to local NTP servers instead of pool.ntp.org.
    public struct NtpPayload: Swift.Sendable {
        /// NTP servers to use, in order of preference.
        /// This member is required.
        public var ntpServers: [Swift.String]?

        public init(
            ntpServers: [Swift.String]? = nil
        )
        {
            self.ntpServers = ntpServers
        }
    }
}

extension PanoramaClientTypes {

    /// The network configuration for a device.
    public struct NetworkPayload: Swift.Sendable {
        /// Settings for Ethernet port 0.
        public var ethernet0: PanoramaClientTypes.EthernetPayload?
        /// Settings for Ethernet port 1.
        public var ethernet1: PanoramaClientTypes.EthernetPayload?
        /// Network time protocol (NTP) server settings.
        public var ntp: PanoramaClientTypes.NtpPayload?

        public init(
            ethernet0: PanoramaClientTypes.EthernetPayload? = nil,
            ethernet1: PanoramaClientTypes.EthernetPayload? = nil,
            ntp: PanoramaClientTypes.NtpPayload? = nil
        )
        {
            self.ethernet0 = ethernet0
            self.ethernet1 = ethernet1
            self.ntp = ntp
        }
    }
}

extension PanoramaClientTypes {

    public enum DeviceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awaitingProvisioning
        case deleting
        case error
        case failed
        case pending
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceStatus] {
            return [
                .awaitingProvisioning,
                .deleting,
                .error,
                .failed,
                .pending,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awaitingProvisioning: return "AWAITING_PROVISIONING"
            case .deleting: return "DELETING"
            case .error: return "ERROR"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PanoramaClientTypes {

    public enum DeviceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case panoramaAppliance
        case panoramaApplianceDeveloperKit
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceType] {
            return [
                .panoramaAppliance,
                .panoramaApplianceDeveloperKit
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .panoramaAppliance: return "PANORAMA_APPLIANCE"
            case .panoramaApplianceDeveloperKit: return "PANORAMA_APPLIANCE_DEVELOPER_KIT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeDeviceOutput: Swift.Sendable {
    /// Beta software releases available for the device.
    public var alternateSoftwares: [PanoramaClientTypes.AlternateSoftwareMetadata]?
    /// The device's ARN.
    public var arn: Swift.String?
    /// The device's maker.
    public var brand: PanoramaClientTypes.DeviceBrand?
    /// When the device was created.
    public var createdTime: Foundation.Date?
    /// The device's networking status.
    public var currentNetworkingStatus: PanoramaClientTypes.NetworkStatus?
    /// The device's current software version.
    public var currentSoftware: Swift.String?
    /// The device's description.
    public var description: Swift.String?
    /// A device's aggregated status. Including the device's connection status, provisioning status, and lease status.
    public var deviceAggregatedStatus: PanoramaClientTypes.DeviceAggregatedStatus?
    /// The device's connection status.
    public var deviceConnectionStatus: PanoramaClientTypes.DeviceConnectionStatus?
    /// The device's ID.
    public var deviceId: Swift.String?
    /// The most recent beta software release.
    public var latestAlternateSoftware: Swift.String?
    /// A device's latest job. Includes the target image version, and the job status.
    public var latestDeviceJob: PanoramaClientTypes.LatestDeviceJob?
    /// The latest software version available for the device.
    public var latestSoftware: Swift.String?
    /// The device's lease expiration time.
    public var leaseExpirationTime: Foundation.Date?
    /// The device's name.
    public var name: Swift.String?
    /// The device's networking configuration.
    public var networkingConfiguration: PanoramaClientTypes.NetworkPayload?
    /// The device's provisioning status.
    public var provisioningStatus: PanoramaClientTypes.DeviceStatus?
    /// The device's serial number.
    public var serialNumber: Swift.String?
    /// The device's tags.
    public var tags: [Swift.String: Swift.String]?
    /// The device's type.
    public var type: PanoramaClientTypes.DeviceType?

    public init(
        alternateSoftwares: [PanoramaClientTypes.AlternateSoftwareMetadata]? = nil,
        arn: Swift.String? = nil,
        brand: PanoramaClientTypes.DeviceBrand? = nil,
        createdTime: Foundation.Date? = nil,
        currentNetworkingStatus: PanoramaClientTypes.NetworkStatus? = nil,
        currentSoftware: Swift.String? = nil,
        description: Swift.String? = nil,
        deviceAggregatedStatus: PanoramaClientTypes.DeviceAggregatedStatus? = nil,
        deviceConnectionStatus: PanoramaClientTypes.DeviceConnectionStatus? = nil,
        deviceId: Swift.String? = nil,
        latestAlternateSoftware: Swift.String? = nil,
        latestDeviceJob: PanoramaClientTypes.LatestDeviceJob? = nil,
        latestSoftware: Swift.String? = nil,
        leaseExpirationTime: Foundation.Date? = nil,
        name: Swift.String? = nil,
        networkingConfiguration: PanoramaClientTypes.NetworkPayload? = nil,
        provisioningStatus: PanoramaClientTypes.DeviceStatus? = nil,
        serialNumber: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        type: PanoramaClientTypes.DeviceType? = nil
    )
    {
        self.alternateSoftwares = alternateSoftwares
        self.arn = arn
        self.brand = brand
        self.createdTime = createdTime
        self.currentNetworkingStatus = currentNetworkingStatus
        self.currentSoftware = currentSoftware
        self.description = description
        self.deviceAggregatedStatus = deviceAggregatedStatus
        self.deviceConnectionStatus = deviceConnectionStatus
        self.deviceId = deviceId
        self.latestAlternateSoftware = latestAlternateSoftware
        self.latestDeviceJob = latestDeviceJob
        self.latestSoftware = latestSoftware
        self.leaseExpirationTime = leaseExpirationTime
        self.name = name
        self.networkingConfiguration = networkingConfiguration
        self.provisioningStatus = provisioningStatus
        self.serialNumber = serialNumber
        self.tags = tags
        self.type = type
    }
}

public struct DescribeDeviceJobInput: Swift.Sendable {
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

public struct DescribeDeviceJobOutput: Swift.Sendable {
    /// When the job was created.
    public var createdTime: Foundation.Date?
    /// The device's ARN.
    public var deviceArn: Swift.String?
    /// The device's ID.
    public var deviceId: Swift.String?
    /// The device's name.
    public var deviceName: Swift.String?
    /// The device's type.
    public var deviceType: PanoramaClientTypes.DeviceType?
    /// For an OTA job, the target version of the device software.
    public var imageVersion: Swift.String?
    /// The job's ID.
    public var jobId: Swift.String?
    /// The job's type.
    public var jobType: PanoramaClientTypes.JobType?
    /// The job's status.
    public var status: PanoramaClientTypes.UpdateProgress?

    public init(
        createdTime: Foundation.Date? = nil,
        deviceArn: Swift.String? = nil,
        deviceId: Swift.String? = nil,
        deviceName: Swift.String? = nil,
        deviceType: PanoramaClientTypes.DeviceType? = nil,
        imageVersion: Swift.String? = nil,
        jobId: Swift.String? = nil,
        jobType: PanoramaClientTypes.JobType? = nil,
        status: PanoramaClientTypes.UpdateProgress? = nil
    )
    {
        self.createdTime = createdTime
        self.deviceArn = deviceArn
        self.deviceId = deviceId
        self.deviceName = deviceName
        self.deviceType = deviceType
        self.imageVersion = imageVersion
        self.jobId = jobId
        self.jobType = jobType
        self.status = status
    }
}

public struct DescribeNodeInput: Swift.Sendable {
    /// The node's ID.
    /// This member is required.
    public var nodeId: Swift.String?
    /// The account ID of the node's owner.
    public var ownerAccount: Swift.String?

    public init(
        nodeId: Swift.String? = nil,
        ownerAccount: Swift.String? = nil
    )
    {
        self.nodeId = nodeId
        self.ownerAccount = ownerAccount
    }
}

extension PanoramaClientTypes {

    public enum NodeCategory: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case businessLogic
        case mediaSink
        case mediaSource
        case mlModel
        case sdkUnknown(Swift.String)

        public static var allCases: [NodeCategory] {
            return [
                .businessLogic,
                .mediaSink,
                .mediaSource,
                .mlModel
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .businessLogic: return "BUSINESS_LOGIC"
            case .mediaSink: return "MEDIA_SINK"
            case .mediaSource: return "MEDIA_SOURCE"
            case .mlModel: return "ML_MODEL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PanoramaClientTypes {

    public enum PortType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case boolean
        case float32
        case int32
        case media
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [PortType] {
            return [
                .boolean,
                .float32,
                .int32,
                .media,
                .string
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "BOOLEAN"
            case .float32: return "FLOAT32"
            case .int32: return "INT32"
            case .media: return "MEDIA"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PanoramaClientTypes {

    /// A node input port.
    public struct NodeInputPort: Swift.Sendable {
        /// The input port's default value.
        public var defaultValue: Swift.String?
        /// The input port's description.
        public var description: Swift.String?
        /// The input port's max connections.
        public var maxConnections: Swift.Int
        /// The input port's name.
        public var name: Swift.String?
        /// The input port's type.
        public var type: PanoramaClientTypes.PortType?

        public init(
            defaultValue: Swift.String? = nil,
            description: Swift.String? = nil,
            maxConnections: Swift.Int = 0,
            name: Swift.String? = nil,
            type: PanoramaClientTypes.PortType? = nil
        )
        {
            self.defaultValue = defaultValue
            self.description = description
            self.maxConnections = maxConnections
            self.name = name
            self.type = type
        }
    }
}

extension PanoramaClientTypes {

    /// A node output port.
    public struct NodeOutputPort: Swift.Sendable {
        /// The output port's description.
        public var description: Swift.String?
        /// The output port's name.
        public var name: Swift.String?
        /// The output port's type.
        public var type: PanoramaClientTypes.PortType?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            type: PanoramaClientTypes.PortType? = nil
        )
        {
            self.description = description
            self.name = name
            self.type = type
        }
    }
}

extension PanoramaClientTypes {

    /// A node interface.
    public struct NodeInterface: Swift.Sendable {
        /// The node interface's inputs.
        /// This member is required.
        public var inputs: [PanoramaClientTypes.NodeInputPort]?
        /// The node interface's outputs.
        /// This member is required.
        public var outputs: [PanoramaClientTypes.NodeOutputPort]?

        public init(
            inputs: [PanoramaClientTypes.NodeInputPort]? = nil,
            outputs: [PanoramaClientTypes.NodeOutputPort]? = nil
        )
        {
            self.inputs = inputs
            self.outputs = outputs
        }
    }
}

public struct DescribeNodeOutput: Swift.Sendable {
    /// The node's asset name.
    public var assetName: Swift.String?
    /// The node's category.
    /// This member is required.
    public var category: PanoramaClientTypes.NodeCategory?
    /// When the node was created.
    /// This member is required.
    public var createdTime: Foundation.Date?
    /// The node's description.
    /// This member is required.
    public var description: Swift.String?
    /// When the node was updated.
    /// This member is required.
    public var lastUpdatedTime: Foundation.Date?
    /// The node's name.
    /// This member is required.
    public var name: Swift.String?
    /// The node's ID.
    /// This member is required.
    public var nodeId: Swift.String?
    /// The node's interface.
    /// This member is required.
    public var nodeInterface: PanoramaClientTypes.NodeInterface?
    /// The account ID of the node's owner.
    /// This member is required.
    public var ownerAccount: Swift.String?
    /// The node's ARN.
    public var packageArn: Swift.String?
    /// The node's package ID.
    /// This member is required.
    public var packageId: Swift.String?
    /// The node's package name.
    /// This member is required.
    public var packageName: Swift.String?
    /// The node's package version.
    /// This member is required.
    public var packageVersion: Swift.String?
    /// The node's patch version.
    /// This member is required.
    public var patchVersion: Swift.String?

    public init(
        assetName: Swift.String? = nil,
        category: PanoramaClientTypes.NodeCategory? = nil,
        createdTime: Foundation.Date? = nil,
        description: Swift.String? = nil,
        lastUpdatedTime: Foundation.Date? = nil,
        name: Swift.String? = nil,
        nodeId: Swift.String? = nil,
        nodeInterface: PanoramaClientTypes.NodeInterface? = nil,
        ownerAccount: Swift.String? = nil,
        packageArn: Swift.String? = nil,
        packageId: Swift.String? = nil,
        packageName: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        patchVersion: Swift.String? = nil
    )
    {
        self.assetName = assetName
        self.category = category
        self.createdTime = createdTime
        self.description = description
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.nodeId = nodeId
        self.nodeInterface = nodeInterface
        self.ownerAccount = ownerAccount
        self.packageArn = packageArn
        self.packageId = packageId
        self.packageName = packageName
        self.packageVersion = packageVersion
        self.patchVersion = patchVersion
    }
}

public struct DescribeNodeFromTemplateJobInput: Swift.Sendable {
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

extension PanoramaClientTypes {

    public enum NodeFromTemplateJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case pending
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [NodeFromTemplateJobStatus] {
            return [
                .failed,
                .pending,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeNodeFromTemplateJobOutput: Swift.Sendable {
    /// When the job was created.
    /// This member is required.
    public var createdTime: Foundation.Date?
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?
    /// The job's tags.
    public var jobTags: [PanoramaClientTypes.JobResourceTags]?
    /// When the job was updated.
    /// This member is required.
    public var lastUpdatedTime: Foundation.Date?
    /// The node's description.
    public var nodeDescription: Swift.String?
    /// The node's name.
    /// This member is required.
    public var nodeName: Swift.String?
    /// The job's output package name.
    /// This member is required.
    public var outputPackageName: Swift.String?
    /// The job's output package version.
    /// This member is required.
    public var outputPackageVersion: Swift.String?
    /// The job's status.
    /// This member is required.
    public var status: PanoramaClientTypes.NodeFromTemplateJobStatus?
    /// The job's status message.
    /// This member is required.
    public var statusMessage: Swift.String?
    /// The job's template parameters.
    /// This member is required.
    public var templateParameters: [Swift.String: Swift.String]?
    /// The job's template type.
    /// This member is required.
    public var templateType: PanoramaClientTypes.TemplateType?

    public init(
        createdTime: Foundation.Date? = nil,
        jobId: Swift.String? = nil,
        jobTags: [PanoramaClientTypes.JobResourceTags]? = nil,
        lastUpdatedTime: Foundation.Date? = nil,
        nodeDescription: Swift.String? = nil,
        nodeName: Swift.String? = nil,
        outputPackageName: Swift.String? = nil,
        outputPackageVersion: Swift.String? = nil,
        status: PanoramaClientTypes.NodeFromTemplateJobStatus? = nil,
        statusMessage: Swift.String? = nil,
        templateParameters: [Swift.String: Swift.String]? = nil,
        templateType: PanoramaClientTypes.TemplateType? = nil
    )
    {
        self.createdTime = createdTime
        self.jobId = jobId
        self.jobTags = jobTags
        self.lastUpdatedTime = lastUpdatedTime
        self.nodeDescription = nodeDescription
        self.nodeName = nodeName
        self.outputPackageName = outputPackageName
        self.outputPackageVersion = outputPackageVersion
        self.status = status
        self.statusMessage = statusMessage
        self.templateParameters = templateParameters
        self.templateType = templateType
    }
}

extension DescribeNodeFromTemplateJobOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeNodeFromTemplateJobOutput(createdTime: \(Swift.String(describing: createdTime)), jobId: \(Swift.String(describing: jobId)), jobTags: \(Swift.String(describing: jobTags)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), nodeDescription: \(Swift.String(describing: nodeDescription)), nodeName: \(Swift.String(describing: nodeName)), outputPackageName: \(Swift.String(describing: outputPackageName)), outputPackageVersion: \(Swift.String(describing: outputPackageVersion)), status: \(Swift.String(describing: status)), statusMessage: \(Swift.String(describing: statusMessage)), templateType: \(Swift.String(describing: templateType)), templateParameters: [keys: \(Swift.String(describing: templateParameters?.keys)), values: \"CONTENT_REDACTED\"])"}
}

public struct DescribePackageInput: Swift.Sendable {
    /// The package's ID.
    /// This member is required.
    public var packageId: Swift.String?

    public init(
        packageId: Swift.String? = nil
    )
    {
        self.packageId = packageId
    }
}

public struct DescribePackageOutput: Swift.Sendable {
    /// The package's ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// When the package was created.
    /// This member is required.
    public var createdTime: Foundation.Date?
    /// The package's ID.
    /// This member is required.
    public var packageId: Swift.String?
    /// The package's name.
    /// This member is required.
    public var packageName: Swift.String?
    /// ARNs of accounts that have read access to the package.
    public var readAccessPrincipalArns: [Swift.String]?
    /// The package's storage location.
    /// This member is required.
    public var storageLocation: PanoramaClientTypes.StorageLocation?
    /// The package's tags.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?
    /// ARNs of accounts that have write access to the package.
    public var writeAccessPrincipalArns: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        createdTime: Foundation.Date? = nil,
        packageId: Swift.String? = nil,
        packageName: Swift.String? = nil,
        readAccessPrincipalArns: [Swift.String]? = nil,
        storageLocation: PanoramaClientTypes.StorageLocation? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        writeAccessPrincipalArns: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.packageId = packageId
        self.packageName = packageName
        self.readAccessPrincipalArns = readAccessPrincipalArns
        self.storageLocation = storageLocation
        self.tags = tags
        self.writeAccessPrincipalArns = writeAccessPrincipalArns
    }
}

public struct DescribePackageImportJobInput: Swift.Sendable {
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

extension PanoramaClientTypes {

    /// The location of an output object in Amazon S3.
    public struct OutPutS3Location: Swift.Sendable {
        /// The object's bucket.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The object's key.
        /// This member is required.
        public var objectKey: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            objectKey: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.objectKey = objectKey
        }
    }
}

extension PanoramaClientTypes {

    /// Results of a package import job.
    public struct PackageImportJobOutput: Swift.Sendable {
        /// The package's output location.
        /// This member is required.
        public var outputS3Location: PanoramaClientTypes.OutPutS3Location?
        /// The package's ID.
        /// This member is required.
        public var packageId: Swift.String?
        /// The package's version.
        /// This member is required.
        public var packageVersion: Swift.String?
        /// The package's patch version.
        /// This member is required.
        public var patchVersion: Swift.String?

        public init(
            outputS3Location: PanoramaClientTypes.OutPutS3Location? = nil,
            packageId: Swift.String? = nil,
            packageVersion: Swift.String? = nil,
            patchVersion: Swift.String? = nil
        )
        {
            self.outputS3Location = outputS3Location
            self.packageId = packageId
            self.packageVersion = packageVersion
            self.patchVersion = patchVersion
        }
    }
}

extension PanoramaClientTypes {

    public enum PackageImportJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case pending
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageImportJobStatus] {
            return [
                .failed,
                .pending,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribePackageImportJobOutput: Swift.Sendable {
    /// The job's client token.
    public var clientToken: Swift.String?
    /// When the job was created.
    /// This member is required.
    public var createdTime: Foundation.Date?
    /// The job's input config.
    /// This member is required.
    public var inputConfig: PanoramaClientTypes.PackageImportJobInputConfig?
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?
    /// The job's tags.
    public var jobTags: [PanoramaClientTypes.JobResourceTags]?
    /// The job's type.
    /// This member is required.
    public var jobType: PanoramaClientTypes.PackageImportJobType?
    /// When the job was updated.
    /// This member is required.
    public var lastUpdatedTime: Foundation.Date?
    /// The job's output.
    /// This member is required.
    public var output: PanoramaClientTypes.PackageImportJobOutput?
    /// The job's output config.
    /// This member is required.
    public var outputConfig: PanoramaClientTypes.PackageImportJobOutputConfig?
    /// The job's status.
    /// This member is required.
    public var status: PanoramaClientTypes.PackageImportJobStatus?
    /// The job's status message.
    /// This member is required.
    public var statusMessage: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        createdTime: Foundation.Date? = nil,
        inputConfig: PanoramaClientTypes.PackageImportJobInputConfig? = nil,
        jobId: Swift.String? = nil,
        jobTags: [PanoramaClientTypes.JobResourceTags]? = nil,
        jobType: PanoramaClientTypes.PackageImportJobType? = nil,
        lastUpdatedTime: Foundation.Date? = nil,
        output: PanoramaClientTypes.PackageImportJobOutput? = nil,
        outputConfig: PanoramaClientTypes.PackageImportJobOutputConfig? = nil,
        status: PanoramaClientTypes.PackageImportJobStatus? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.createdTime = createdTime
        self.inputConfig = inputConfig
        self.jobId = jobId
        self.jobTags = jobTags
        self.jobType = jobType
        self.lastUpdatedTime = lastUpdatedTime
        self.output = output
        self.outputConfig = outputConfig
        self.status = status
        self.statusMessage = statusMessage
    }
}

public struct DescribePackageVersionInput: Swift.Sendable {
    /// The version's owner account.
    public var ownerAccount: Swift.String?
    /// The version's ID.
    /// This member is required.
    public var packageId: Swift.String?
    /// The version's version.
    /// This member is required.
    public var packageVersion: Swift.String?
    /// The version's patch version.
    public var patchVersion: Swift.String?

    public init(
        ownerAccount: Swift.String? = nil,
        packageId: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        patchVersion: Swift.String? = nil
    )
    {
        self.ownerAccount = ownerAccount
        self.packageId = packageId
        self.packageVersion = packageVersion
        self.patchVersion = patchVersion
    }
}

extension PanoramaClientTypes {

    public enum PackageVersionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleting
        case failed
        case registerCompleted
        case registerPending
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageVersionStatus] {
            return [
                .deleting,
                .failed,
                .registerCompleted,
                .registerPending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .registerCompleted: return "REGISTER_COMPLETED"
            case .registerPending: return "REGISTER_PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribePackageVersionOutput: Swift.Sendable {
    /// Whether the version is the latest available.
    /// This member is required.
    public var isLatestPatch: Swift.Bool
    /// The account ID of the version's owner.
    public var ownerAccount: Swift.String?
    /// The ARN of the package.
    public var packageArn: Swift.String?
    /// The version's ID.
    /// This member is required.
    public var packageId: Swift.String?
    /// The version's name.
    /// This member is required.
    public var packageName: Swift.String?
    /// The version's version.
    /// This member is required.
    public var packageVersion: Swift.String?
    /// The version's patch version.
    /// This member is required.
    public var patchVersion: Swift.String?
    /// The version's registered time.
    public var registeredTime: Foundation.Date?
    /// The version's status.
    /// This member is required.
    public var status: PanoramaClientTypes.PackageVersionStatus?
    /// The version's status description.
    public var statusDescription: Swift.String?

    public init(
        isLatestPatch: Swift.Bool = false,
        ownerAccount: Swift.String? = nil,
        packageArn: Swift.String? = nil,
        packageId: Swift.String? = nil,
        packageName: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        patchVersion: Swift.String? = nil,
        registeredTime: Foundation.Date? = nil,
        status: PanoramaClientTypes.PackageVersionStatus? = nil,
        statusDescription: Swift.String? = nil
    )
    {
        self.isLatestPatch = isLatestPatch
        self.ownerAccount = ownerAccount
        self.packageArn = packageArn
        self.packageId = packageId
        self.packageName = packageName
        self.packageVersion = packageVersion
        self.patchVersion = patchVersion
        self.registeredTime = registeredTime
        self.status = status
        self.statusDescription = statusDescription
    }
}

extension PanoramaClientTypes {

    /// A device.
    public struct Device: Swift.Sendable {
        /// The device's maker.
        public var brand: PanoramaClientTypes.DeviceBrand?
        /// When the device was created.
        public var createdTime: Foundation.Date?
        /// A device's current software.
        public var currentSoftware: Swift.String?
        /// A description for the device.
        public var description: Swift.String?
        /// A device's aggregated status. Including the device's connection status, provisioning status, and lease status.
        public var deviceAggregatedStatus: PanoramaClientTypes.DeviceAggregatedStatus?
        /// The device's ID.
        public var deviceId: Swift.String?
        /// When the device was updated.
        public var lastUpdatedTime: Foundation.Date?
        /// A device's latest job. Includes the target image version, and the update job status.
        public var latestDeviceJob: PanoramaClientTypes.LatestDeviceJob?
        /// The device's lease expiration time.
        public var leaseExpirationTime: Foundation.Date?
        /// The device's name.
        public var name: Swift.String?
        /// The device's provisioning status.
        public var provisioningStatus: PanoramaClientTypes.DeviceStatus?
        /// The device's tags.
        public var tags: [Swift.String: Swift.String]?
        /// The device's type.
        public var type: PanoramaClientTypes.DeviceType?

        public init(
            brand: PanoramaClientTypes.DeviceBrand? = nil,
            createdTime: Foundation.Date? = nil,
            currentSoftware: Swift.String? = nil,
            description: Swift.String? = nil,
            deviceAggregatedStatus: PanoramaClientTypes.DeviceAggregatedStatus? = nil,
            deviceId: Swift.String? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            latestDeviceJob: PanoramaClientTypes.LatestDeviceJob? = nil,
            leaseExpirationTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            provisioningStatus: PanoramaClientTypes.DeviceStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            type: PanoramaClientTypes.DeviceType? = nil
        )
        {
            self.brand = brand
            self.createdTime = createdTime
            self.currentSoftware = currentSoftware
            self.description = description
            self.deviceAggregatedStatus = deviceAggregatedStatus
            self.deviceId = deviceId
            self.lastUpdatedTime = lastUpdatedTime
            self.latestDeviceJob = latestDeviceJob
            self.leaseExpirationTime = leaseExpirationTime
            self.name = name
            self.provisioningStatus = provisioningStatus
            self.tags = tags
            self.type = type
        }
    }
}

extension PanoramaClientTypes {

    /// A job that runs on a device.
    public struct DeviceJob: Swift.Sendable {
        /// When the job was created.
        public var createdTime: Foundation.Date?
        /// The ID of the target device.
        public var deviceId: Swift.String?
        /// The name of the target device
        public var deviceName: Swift.String?
        /// The job's ID.
        public var jobId: Swift.String?
        /// The job's type.
        public var jobType: PanoramaClientTypes.JobType?

        public init(
            createdTime: Foundation.Date? = nil,
            deviceId: Swift.String? = nil,
            deviceName: Swift.String? = nil,
            jobId: Swift.String? = nil,
            jobType: PanoramaClientTypes.JobType? = nil
        )
        {
            self.createdTime = createdTime
            self.deviceId = deviceId
            self.deviceName = deviceName
            self.jobId = jobId
            self.jobType = jobType
        }
    }
}

public struct ListApplicationInstanceDependenciesInput: Swift.Sendable {
    /// The application instance's ID.
    /// This member is required.
    public var applicationInstanceId: Swift.String?
    /// The maximum number of application instance dependencies to return in one page of results.
    public var maxResults: Swift.Int
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        applicationInstanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationInstanceId = applicationInstanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension PanoramaClientTypes {

    /// A package object.
    public struct PackageObject: Swift.Sendable {
        /// The object's name.
        /// This member is required.
        public var name: Swift.String?
        /// The object's package version.
        /// This member is required.
        public var packageVersion: Swift.String?
        /// The object's patch version.
        /// This member is required.
        public var patchVersion: Swift.String?

        public init(
            name: Swift.String? = nil,
            packageVersion: Swift.String? = nil,
            patchVersion: Swift.String? = nil
        )
        {
            self.name = name
            self.packageVersion = packageVersion
            self.patchVersion = patchVersion
        }
    }
}

public struct ListApplicationInstanceDependenciesOutput: Swift.Sendable {
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of package objects.
    public var packageObjects: [PanoramaClientTypes.PackageObject]?

    public init(
        nextToken: Swift.String? = nil,
        packageObjects: [PanoramaClientTypes.PackageObject]? = nil
    )
    {
        self.nextToken = nextToken
        self.packageObjects = packageObjects
    }
}

public struct ListApplicationInstanceNodeInstancesInput: Swift.Sendable {
    /// The node instances' application instance ID.
    /// This member is required.
    public var applicationInstanceId: Swift.String?
    /// The maximum number of node instances to return in one page of results.
    public var maxResults: Swift.Int
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        applicationInstanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationInstanceId = applicationInstanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension PanoramaClientTypes {

    public enum NodeInstanceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case error
        case notAvailable
        case paused
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [NodeInstanceStatus] {
            return [
                .error,
                .notAvailable,
                .paused,
                .running
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .notAvailable: return "NOT_AVAILABLE"
            case .paused: return "PAUSED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PanoramaClientTypes {

    /// A node instance.
    public struct NodeInstance: Swift.Sendable {
        /// The instance's current status.
        /// This member is required.
        public var currentStatus: PanoramaClientTypes.NodeInstanceStatus?
        /// The node's ID.
        public var nodeId: Swift.String?
        /// The instance's ID.
        /// This member is required.
        public var nodeInstanceId: Swift.String?
        /// The instance's name.
        public var nodeName: Swift.String?
        /// The instance's package name.
        public var packageName: Swift.String?
        /// The instance's package patch version.
        public var packagePatchVersion: Swift.String?
        /// The instance's package version.
        public var packageVersion: Swift.String?

        public init(
            currentStatus: PanoramaClientTypes.NodeInstanceStatus? = nil,
            nodeId: Swift.String? = nil,
            nodeInstanceId: Swift.String? = nil,
            nodeName: Swift.String? = nil,
            packageName: Swift.String? = nil,
            packagePatchVersion: Swift.String? = nil,
            packageVersion: Swift.String? = nil
        )
        {
            self.currentStatus = currentStatus
            self.nodeId = nodeId
            self.nodeInstanceId = nodeInstanceId
            self.nodeName = nodeName
            self.packageName = packageName
            self.packagePatchVersion = packagePatchVersion
            self.packageVersion = packageVersion
        }
    }
}

public struct ListApplicationInstanceNodeInstancesOutput: Swift.Sendable {
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of node instances.
    public var nodeInstances: [PanoramaClientTypes.NodeInstance]?

    public init(
        nextToken: Swift.String? = nil,
        nodeInstances: [PanoramaClientTypes.NodeInstance]? = nil
    )
    {
        self.nextToken = nextToken
        self.nodeInstances = nodeInstances
    }
}

extension PanoramaClientTypes {

    public enum StatusFilter: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deploymentError
        case deploymentFailed
        case deploymentSucceeded
        case processingDeployment
        case processingRemoval
        case removalFailed
        case removalSucceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [StatusFilter] {
            return [
                .deploymentError,
                .deploymentFailed,
                .deploymentSucceeded,
                .processingDeployment,
                .processingRemoval,
                .removalFailed,
                .removalSucceeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deploymentError: return "DEPLOYMENT_ERROR"
            case .deploymentFailed: return "DEPLOYMENT_FAILED"
            case .deploymentSucceeded: return "DEPLOYMENT_SUCCEEDED"
            case .processingDeployment: return "PROCESSING_DEPLOYMENT"
            case .processingRemoval: return "PROCESSING_REMOVAL"
            case .removalFailed: return "REMOVAL_FAILED"
            case .removalSucceeded: return "REMOVAL_SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListApplicationInstancesInput: Swift.Sendable {
    /// The application instances' device ID.
    public var deviceId: Swift.String?
    /// The maximum number of application instances to return in one page of results.
    public var maxResults: Swift.Int
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// Only include instances with a specific status.
    public var statusFilter: PanoramaClientTypes.StatusFilter?

    public init(
        deviceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        statusFilter: PanoramaClientTypes.StatusFilter? = nil
    )
    {
        self.deviceId = deviceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.statusFilter = statusFilter
    }
}

public struct ListApplicationInstancesOutput: Swift.Sendable {
    /// A list of application instances.
    public var applicationInstances: [PanoramaClientTypes.ApplicationInstance]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init(
        applicationInstances: [PanoramaClientTypes.ApplicationInstance]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationInstances = applicationInstances
        self.nextToken = nextToken
    }
}

extension PanoramaClientTypes {

    public enum ListDevicesSortBy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createdTime
        case deviceAggregatedStatus
        case deviceId
        case name
        case sdkUnknown(Swift.String)

        public static var allCases: [ListDevicesSortBy] {
            return [
                .createdTime,
                .deviceAggregatedStatus,
                .deviceId,
                .name
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createdTime: return "CREATED_TIME"
            case .deviceAggregatedStatus: return "DEVICE_AGGREGATED_STATUS"
            case .deviceId: return "DEVICE_ID"
            case .name: return "NAME"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PanoramaClientTypes {

    public enum SortOrder: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListDevicesInput: Swift.Sendable {
    /// Filter based on a device's status.
    public var deviceAggregatedStatusFilter: PanoramaClientTypes.DeviceAggregatedStatus?
    /// The maximum number of devices to return in one page of results.
    public var maxResults: Swift.Int
    /// Filter based on device's name. Prefixes supported.
    public var nameFilter: Swift.String?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The target column to be sorted on. Default column sort is CREATED_TIME.
    public var sortBy: PanoramaClientTypes.ListDevicesSortBy?
    /// The sorting order for the returned list. SortOrder is DESCENDING by default based on CREATED_TIME. Otherwise, SortOrder is ASCENDING.
    public var sortOrder: PanoramaClientTypes.SortOrder?

    public init(
        deviceAggregatedStatusFilter: PanoramaClientTypes.DeviceAggregatedStatus? = nil,
        maxResults: Swift.Int = 0,
        nameFilter: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortBy: PanoramaClientTypes.ListDevicesSortBy? = nil,
        sortOrder: PanoramaClientTypes.SortOrder? = nil
    )
    {
        self.deviceAggregatedStatusFilter = deviceAggregatedStatusFilter
        self.maxResults = maxResults
        self.nameFilter = nameFilter
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

public struct ListDevicesOutput: Swift.Sendable {
    /// A list of devices.
    /// This member is required.
    public var devices: [PanoramaClientTypes.Device]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init(
        devices: [PanoramaClientTypes.Device]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.devices = devices
        self.nextToken = nextToken
    }
}

public struct ListDevicesJobsInput: Swift.Sendable {
    /// Filter results by the job's target device ID.
    public var deviceId: Swift.String?
    /// The maximum number of device jobs to return in one page of results.
    public var maxResults: Swift.Int
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        deviceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListDevicesJobsOutput: Swift.Sendable {
    /// A list of jobs.
    public var deviceJobs: [PanoramaClientTypes.DeviceJob]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init(
        deviceJobs: [PanoramaClientTypes.DeviceJob]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceJobs = deviceJobs
        self.nextToken = nextToken
    }
}

public struct ListNodeFromTemplateJobsInput: Swift.Sendable {
    /// The maximum number of node from template jobs to return in one page of results.
    public var maxResults: Swift.Int
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension PanoramaClientTypes {

    /// A job to create a camera stream node.
    public struct NodeFromTemplateJob: Swift.Sendable {
        /// When the job was created.
        public var createdTime: Foundation.Date?
        /// The job's ID.
        public var jobId: Swift.String?
        /// The node's name.
        public var nodeName: Swift.String?
        /// The job's status.
        public var status: PanoramaClientTypes.NodeFromTemplateJobStatus?
        /// The job's status message.
        public var statusMessage: Swift.String?
        /// The job's template type.
        public var templateType: PanoramaClientTypes.TemplateType?

        public init(
            createdTime: Foundation.Date? = nil,
            jobId: Swift.String? = nil,
            nodeName: Swift.String? = nil,
            status: PanoramaClientTypes.NodeFromTemplateJobStatus? = nil,
            statusMessage: Swift.String? = nil,
            templateType: PanoramaClientTypes.TemplateType? = nil
        )
        {
            self.createdTime = createdTime
            self.jobId = jobId
            self.nodeName = nodeName
            self.status = status
            self.statusMessage = statusMessage
            self.templateType = templateType
        }
    }
}

public struct ListNodeFromTemplateJobsOutput: Swift.Sendable {
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of jobs.
    /// This member is required.
    public var nodeFromTemplateJobs: [PanoramaClientTypes.NodeFromTemplateJob]?

    public init(
        nextToken: Swift.String? = nil,
        nodeFromTemplateJobs: [PanoramaClientTypes.NodeFromTemplateJob]? = nil
    )
    {
        self.nextToken = nextToken
        self.nodeFromTemplateJobs = nodeFromTemplateJobs
    }
}

public struct ListNodesInput: Swift.Sendable {
    /// Search for nodes by category.
    public var category: PanoramaClientTypes.NodeCategory?
    /// The maximum number of nodes to return in one page of results.
    public var maxResults: Swift.Int
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// Search for nodes by the account ID of the nodes' owner.
    public var ownerAccount: Swift.String?
    /// Search for nodes by name.
    public var packageName: Swift.String?
    /// Search for nodes by version.
    public var packageVersion: Swift.String?
    /// Search for nodes by patch version.
    public var patchVersion: Swift.String?

    public init(
        category: PanoramaClientTypes.NodeCategory? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        ownerAccount: Swift.String? = nil,
        packageName: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        patchVersion: Swift.String? = nil
    )
    {
        self.category = category
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.ownerAccount = ownerAccount
        self.packageName = packageName
        self.packageVersion = packageVersion
        self.patchVersion = patchVersion
    }
}

extension PanoramaClientTypes {

    /// An application node that represents a camera stream, a model, code, or output.
    public struct Node: Swift.Sendable {
        /// The node's category.
        /// This member is required.
        public var category: PanoramaClientTypes.NodeCategory?
        /// When the node was created.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// The node's description.
        public var description: Swift.String?
        /// The node's name.
        /// This member is required.
        public var name: Swift.String?
        /// The node's ID.
        /// This member is required.
        public var nodeId: Swift.String?
        /// The account ID of the node's owner.
        public var ownerAccount: Swift.String?
        /// The node's ARN.
        public var packageArn: Swift.String?
        /// The node's package ID.
        /// This member is required.
        public var packageId: Swift.String?
        /// The node's package name.
        /// This member is required.
        public var packageName: Swift.String?
        /// The node's package version.
        /// This member is required.
        public var packageVersion: Swift.String?
        /// The node's patch version.
        /// This member is required.
        public var patchVersion: Swift.String?

        public init(
            category: PanoramaClientTypes.NodeCategory? = nil,
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            nodeId: Swift.String? = nil,
            ownerAccount: Swift.String? = nil,
            packageArn: Swift.String? = nil,
            packageId: Swift.String? = nil,
            packageName: Swift.String? = nil,
            packageVersion: Swift.String? = nil,
            patchVersion: Swift.String? = nil
        )
        {
            self.category = category
            self.createdTime = createdTime
            self.description = description
            self.name = name
            self.nodeId = nodeId
            self.ownerAccount = ownerAccount
            self.packageArn = packageArn
            self.packageId = packageId
            self.packageName = packageName
            self.packageVersion = packageVersion
            self.patchVersion = patchVersion
        }
    }
}

public struct ListNodesOutput: Swift.Sendable {
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of nodes.
    public var nodes: [PanoramaClientTypes.Node]?

    public init(
        nextToken: Swift.String? = nil,
        nodes: [PanoramaClientTypes.Node]? = nil
    )
    {
        self.nextToken = nextToken
        self.nodes = nodes
    }
}

public struct ListPackageImportJobsInput: Swift.Sendable {
    /// The maximum number of package import jobs to return in one page of results.
    public var maxResults: Swift.Int
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension PanoramaClientTypes {

    /// A job to import a package version.
    public struct PackageImportJob: Swift.Sendable {
        /// When the job was created.
        public var createdTime: Foundation.Date?
        /// The job's ID.
        public var jobId: Swift.String?
        /// The job's type.
        public var jobType: PanoramaClientTypes.PackageImportJobType?
        /// When the job was updated.
        public var lastUpdatedTime: Foundation.Date?
        /// The job's status.
        public var status: PanoramaClientTypes.PackageImportJobStatus?
        /// The job's status message.
        public var statusMessage: Swift.String?

        public init(
            createdTime: Foundation.Date? = nil,
            jobId: Swift.String? = nil,
            jobType: PanoramaClientTypes.PackageImportJobType? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            status: PanoramaClientTypes.PackageImportJobStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.createdTime = createdTime
            self.jobId = jobId
            self.jobType = jobType
            self.lastUpdatedTime = lastUpdatedTime
            self.status = status
            self.statusMessage = statusMessage
        }
    }
}

public struct ListPackageImportJobsOutput: Swift.Sendable {
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of package import jobs.
    /// This member is required.
    public var packageImportJobs: [PanoramaClientTypes.PackageImportJob]?

    public init(
        nextToken: Swift.String? = nil,
        packageImportJobs: [PanoramaClientTypes.PackageImportJob]? = nil
    )
    {
        self.nextToken = nextToken
        self.packageImportJobs = packageImportJobs
    }
}

public struct ListPackagesInput: Swift.Sendable {
    /// The maximum number of packages to return in one page of results.
    public var maxResults: Swift.Int
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension PanoramaClientTypes {

    /// A package summary.
    public struct PackageListItem: Swift.Sendable {
        /// The package's ARN.
        public var arn: Swift.String?
        /// When the package was created.
        public var createdTime: Foundation.Date?
        /// The package's ID.
        public var packageId: Swift.String?
        /// The package's name.
        public var packageName: Swift.String?
        /// The package's tags.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            packageId: Swift.String? = nil,
            packageName: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.packageId = packageId
            self.packageName = packageName
            self.tags = tags
        }
    }
}

public struct ListPackagesOutput: Swift.Sendable {
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of packages.
    public var packages: [PanoramaClientTypes.PackageListItem]?

    public init(
        nextToken: Swift.String? = nil,
        packages: [PanoramaClientTypes.PackageListItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.packages = packages
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The resource's ARN.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// A list of tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

extension PanoramaClientTypes {

    public enum NodeSignalValue: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case pause
        case resume
        case sdkUnknown(Swift.String)

        public static var allCases: [NodeSignalValue] {
            return [
                .pause,
                .resume
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .pause: return "PAUSE"
            case .resume: return "RESUME"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PanoramaClientTypes {

    /// A signal to a camera node to start or stop processing video.
    public struct NodeSignal: Swift.Sendable {
        /// The camera node's name, from the application manifest.
        /// This member is required.
        public var nodeInstanceId: Swift.String?
        /// The signal value.
        /// This member is required.
        public var signal: PanoramaClientTypes.NodeSignalValue?

        public init(
            nodeInstanceId: Swift.String? = nil,
            signal: PanoramaClientTypes.NodeSignalValue? = nil
        )
        {
            self.nodeInstanceId = nodeInstanceId
            self.signal = signal
        }
    }
}

public struct ProvisionDeviceInput: Swift.Sendable {
    /// A description for the device.
    public var description: Swift.String?
    /// A name for the device.
    /// This member is required.
    public var name: Swift.String?
    /// A networking configuration for the device.
    public var networkingConfiguration: PanoramaClientTypes.NetworkPayload?
    /// Tags for the device.
    public var tags: [Swift.String: Swift.String]?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        networkingConfiguration: PanoramaClientTypes.NetworkPayload? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.description = description
        self.name = name
        self.networkingConfiguration = networkingConfiguration
        self.tags = tags
    }
}

public struct ProvisionDeviceOutput: Swift.Sendable {
    /// The device's ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// The device's configuration bundle.
    public var certificates: Foundation.Data?
    /// The device's ID.
    public var deviceId: Swift.String?
    /// The device's IoT thing name.
    public var iotThingName: Swift.String?
    /// The device's status.
    /// This member is required.
    public var status: PanoramaClientTypes.DeviceStatus?

    public init(
        arn: Swift.String? = nil,
        certificates: Foundation.Data? = nil,
        deviceId: Swift.String? = nil,
        iotThingName: Swift.String? = nil,
        status: PanoramaClientTypes.DeviceStatus? = nil
    )
    {
        self.arn = arn
        self.certificates = certificates
        self.deviceId = deviceId
        self.iotThingName = iotThingName
        self.status = status
    }
}

public struct RegisterPackageVersionInput: Swift.Sendable {
    /// Whether to mark the new version as the latest version.
    public var markLatest: Swift.Bool
    /// An owner account.
    public var ownerAccount: Swift.String?
    /// A package ID.
    /// This member is required.
    public var packageId: Swift.String?
    /// A package version.
    /// This member is required.
    public var packageVersion: Swift.String?
    /// A patch version.
    /// This member is required.
    public var patchVersion: Swift.String?

    public init(
        markLatest: Swift.Bool = false,
        ownerAccount: Swift.String? = nil,
        packageId: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        patchVersion: Swift.String? = nil
    )
    {
        self.markLatest = markLatest
        self.ownerAccount = ownerAccount
        self.packageId = packageId
        self.packageVersion = packageVersion
        self.patchVersion = patchVersion
    }
}

public struct RegisterPackageVersionOutput: Swift.Sendable {

    public init() { }
}

public struct RemoveApplicationInstanceInput: Swift.Sendable {
    /// An application instance ID.
    /// This member is required.
    public var applicationInstanceId: Swift.String?

    public init(
        applicationInstanceId: Swift.String? = nil
    )
    {
        self.applicationInstanceId = applicationInstanceId
    }
}

public struct RemoveApplicationInstanceOutput: Swift.Sendable {

    public init() { }
}

public struct SignalApplicationInstanceNodeInstancesInput: Swift.Sendable {
    /// An application instance ID.
    /// This member is required.
    public var applicationInstanceId: Swift.String?
    /// A list of signals.
    /// This member is required.
    public var nodeSignals: [PanoramaClientTypes.NodeSignal]?

    public init(
        applicationInstanceId: Swift.String? = nil,
        nodeSignals: [PanoramaClientTypes.NodeSignal]? = nil
    )
    {
        self.applicationInstanceId = applicationInstanceId
        self.nodeSignals = nodeSignals
    }
}

public struct SignalApplicationInstanceNodeInstancesOutput: Swift.Sendable {
    /// An application instance ID.
    /// This member is required.
    public var applicationInstanceId: Swift.String?

    public init(
        applicationInstanceId: Swift.String? = nil
    )
    {
        self.applicationInstanceId = applicationInstanceId
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The resource's ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tags for the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The resource's ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tag keys to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateDeviceMetadataInput: Swift.Sendable {
    /// A description for the device.
    public var description: Swift.String?
    /// The device's ID.
    /// This member is required.
    public var deviceId: Swift.String?

    public init(
        description: Swift.String? = nil,
        deviceId: Swift.String? = nil
    )
    {
        self.description = description
        self.deviceId = deviceId
    }
}

public struct UpdateDeviceMetadataOutput: Swift.Sendable {
    /// The device's ID.
    public var deviceId: Swift.String?

    public init(
        deviceId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
    }
}

extension CreateApplicationInstanceInput {

    static func urlPathProvider(_ value: CreateApplicationInstanceInput) -> Swift.String? {
        return "/application-instances"
    }
}

extension CreateJobForDevicesInput {

    static func urlPathProvider(_ value: CreateJobForDevicesInput) -> Swift.String? {
        return "/jobs"
    }
}

extension CreateNodeFromTemplateJobInput {

    static func urlPathProvider(_ value: CreateNodeFromTemplateJobInput) -> Swift.String? {
        return "/packages/template-job"
    }
}

extension CreatePackageInput {

    static func urlPathProvider(_ value: CreatePackageInput) -> Swift.String? {
        return "/packages"
    }
}

extension CreatePackageImportJobInput {

    static func urlPathProvider(_ value: CreatePackageImportJobInput) -> Swift.String? {
        return "/packages/import-jobs"
    }
}

extension DeleteDeviceInput {

    static func urlPathProvider(_ value: DeleteDeviceInput) -> Swift.String? {
        guard let deviceId = value.deviceId else {
            return nil
        }
        return "/devices/\(deviceId.urlPercentEncoding())"
    }
}

extension DeletePackageInput {

    static func urlPathProvider(_ value: DeletePackageInput) -> Swift.String? {
        guard let packageId = value.packageId else {
            return nil
        }
        return "/packages/\(packageId.urlPercentEncoding())"
    }
}

extension DeletePackageInput {

    static func queryItemProvider(_ value: DeletePackageInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if value.forceDelete != false {
            let forceDeleteQueryItem = Smithy.URIQueryItem(name: "ForceDelete".urlPercentEncoding(), value: Swift.String(value.forceDelete).urlPercentEncoding())
            items.append(forceDeleteQueryItem)
        }
        return items
    }
}

extension DeregisterPackageVersionInput {

    static func urlPathProvider(_ value: DeregisterPackageVersionInput) -> Swift.String? {
        guard let packageId = value.packageId else {
            return nil
        }
        guard let packageVersion = value.packageVersion else {
            return nil
        }
        guard let patchVersion = value.patchVersion else {
            return nil
        }
        return "/packages/\(packageId.urlPercentEncoding())/versions/\(packageVersion.urlPercentEncoding())/patch/\(patchVersion.urlPercentEncoding())"
    }
}

extension DeregisterPackageVersionInput {

    static func queryItemProvider(_ value: DeregisterPackageVersionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let updatedLatestPatchVersion = value.updatedLatestPatchVersion {
            let updatedLatestPatchVersionQueryItem = Smithy.URIQueryItem(name: "UpdatedLatestPatchVersion".urlPercentEncoding(), value: Swift.String(updatedLatestPatchVersion).urlPercentEncoding())
            items.append(updatedLatestPatchVersionQueryItem)
        }
        if let ownerAccount = value.ownerAccount {
            let ownerAccountQueryItem = Smithy.URIQueryItem(name: "OwnerAccount".urlPercentEncoding(), value: Swift.String(ownerAccount).urlPercentEncoding())
            items.append(ownerAccountQueryItem)
        }
        return items
    }
}

extension DescribeApplicationInstanceInput {

    static func urlPathProvider(_ value: DescribeApplicationInstanceInput) -> Swift.String? {
        guard let applicationInstanceId = value.applicationInstanceId else {
            return nil
        }
        return "/application-instances/\(applicationInstanceId.urlPercentEncoding())"
    }
}

extension DescribeApplicationInstanceDetailsInput {

    static func urlPathProvider(_ value: DescribeApplicationInstanceDetailsInput) -> Swift.String? {
        guard let applicationInstanceId = value.applicationInstanceId else {
            return nil
        }
        return "/application-instances/\(applicationInstanceId.urlPercentEncoding())/details"
    }
}

extension DescribeDeviceInput {

    static func urlPathProvider(_ value: DescribeDeviceInput) -> Swift.String? {
        guard let deviceId = value.deviceId else {
            return nil
        }
        return "/devices/\(deviceId.urlPercentEncoding())"
    }
}

extension DescribeDeviceJobInput {

    static func urlPathProvider(_ value: DescribeDeviceJobInput) -> Swift.String? {
        guard let jobId = value.jobId else {
            return nil
        }
        return "/jobs/\(jobId.urlPercentEncoding())"
    }
}

extension DescribeNodeInput {

    static func urlPathProvider(_ value: DescribeNodeInput) -> Swift.String? {
        guard let nodeId = value.nodeId else {
            return nil
        }
        return "/nodes/\(nodeId.urlPercentEncoding())"
    }
}

extension DescribeNodeInput {

    static func queryItemProvider(_ value: DescribeNodeInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let ownerAccount = value.ownerAccount {
            let ownerAccountQueryItem = Smithy.URIQueryItem(name: "OwnerAccount".urlPercentEncoding(), value: Swift.String(ownerAccount).urlPercentEncoding())
            items.append(ownerAccountQueryItem)
        }
        return items
    }
}

extension DescribeNodeFromTemplateJobInput {

    static func urlPathProvider(_ value: DescribeNodeFromTemplateJobInput) -> Swift.String? {
        guard let jobId = value.jobId else {
            return nil
        }
        return "/packages/template-job/\(jobId.urlPercentEncoding())"
    }
}

extension DescribePackageInput {

    static func urlPathProvider(_ value: DescribePackageInput) -> Swift.String? {
        guard let packageId = value.packageId else {
            return nil
        }
        return "/packages/metadata/\(packageId.urlPercentEncoding())"
    }
}

extension DescribePackageImportJobInput {

    static func urlPathProvider(_ value: DescribePackageImportJobInput) -> Swift.String? {
        guard let jobId = value.jobId else {
            return nil
        }
        return "/packages/import-jobs/\(jobId.urlPercentEncoding())"
    }
}

extension DescribePackageVersionInput {

    static func urlPathProvider(_ value: DescribePackageVersionInput) -> Swift.String? {
        guard let packageId = value.packageId else {
            return nil
        }
        guard let packageVersion = value.packageVersion else {
            return nil
        }
        return "/packages/metadata/\(packageId.urlPercentEncoding())/versions/\(packageVersion.urlPercentEncoding())"
    }
}

extension DescribePackageVersionInput {

    static func queryItemProvider(_ value: DescribePackageVersionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let patchVersion = value.patchVersion {
            let patchVersionQueryItem = Smithy.URIQueryItem(name: "PatchVersion".urlPercentEncoding(), value: Swift.String(patchVersion).urlPercentEncoding())
            items.append(patchVersionQueryItem)
        }
        if let ownerAccount = value.ownerAccount {
            let ownerAccountQueryItem = Smithy.URIQueryItem(name: "OwnerAccount".urlPercentEncoding(), value: Swift.String(ownerAccount).urlPercentEncoding())
            items.append(ownerAccountQueryItem)
        }
        return items
    }
}

extension ListApplicationInstanceDependenciesInput {

    static func urlPathProvider(_ value: ListApplicationInstanceDependenciesInput) -> Swift.String? {
        guard let applicationInstanceId = value.applicationInstanceId else {
            return nil
        }
        return "/application-instances/\(applicationInstanceId.urlPercentEncoding())/package-dependencies"
    }
}

extension ListApplicationInstanceDependenciesInput {

    static func queryItemProvider(_ value: ListApplicationInstanceDependenciesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if value.maxResults != 0 {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(value.maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListApplicationInstanceNodeInstancesInput {

    static func urlPathProvider(_ value: ListApplicationInstanceNodeInstancesInput) -> Swift.String? {
        guard let applicationInstanceId = value.applicationInstanceId else {
            return nil
        }
        return "/application-instances/\(applicationInstanceId.urlPercentEncoding())/node-instances"
    }
}

extension ListApplicationInstanceNodeInstancesInput {

    static func queryItemProvider(_ value: ListApplicationInstanceNodeInstancesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if value.maxResults != 0 {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(value.maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListApplicationInstancesInput {

    static func urlPathProvider(_ value: ListApplicationInstancesInput) -> Swift.String? {
        return "/application-instances"
    }
}

extension ListApplicationInstancesInput {

    static func queryItemProvider(_ value: ListApplicationInstancesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let deviceId = value.deviceId {
            let deviceIdQueryItem = Smithy.URIQueryItem(name: "deviceId".urlPercentEncoding(), value: Swift.String(deviceId).urlPercentEncoding())
            items.append(deviceIdQueryItem)
        }
        if value.maxResults != 0 {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(value.maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let statusFilter = value.statusFilter {
            let statusFilterQueryItem = Smithy.URIQueryItem(name: "statusFilter".urlPercentEncoding(), value: Swift.String(statusFilter.rawValue).urlPercentEncoding())
            items.append(statusFilterQueryItem)
        }
        return items
    }
}

extension ListDevicesInput {

    static func urlPathProvider(_ value: ListDevicesInput) -> Swift.String? {
        return "/devices"
    }
}

extension ListDevicesInput {

    static func queryItemProvider(_ value: ListDevicesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nameFilter = value.nameFilter {
            let nameFilterQueryItem = Smithy.URIQueryItem(name: "NameFilter".urlPercentEncoding(), value: Swift.String(nameFilter).urlPercentEncoding())
            items.append(nameFilterQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let sortBy = value.sortBy {
            let sortByQueryItem = Smithy.URIQueryItem(name: "SortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
            items.append(sortByQueryItem)
        }
        if value.maxResults != 0 {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(value.maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = Smithy.URIQueryItem(name: "SortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let deviceAggregatedStatusFilter = value.deviceAggregatedStatusFilter {
            let deviceAggregatedStatusFilterQueryItem = Smithy.URIQueryItem(name: "DeviceAggregatedStatusFilter".urlPercentEncoding(), value: Swift.String(deviceAggregatedStatusFilter.rawValue).urlPercentEncoding())
            items.append(deviceAggregatedStatusFilterQueryItem)
        }
        return items
    }
}

extension ListDevicesJobsInput {

    static func urlPathProvider(_ value: ListDevicesJobsInput) -> Swift.String? {
        return "/jobs"
    }
}

extension ListDevicesJobsInput {

    static func queryItemProvider(_ value: ListDevicesJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let deviceId = value.deviceId {
            let deviceIdQueryItem = Smithy.URIQueryItem(name: "DeviceId".urlPercentEncoding(), value: Swift.String(deviceId).urlPercentEncoding())
            items.append(deviceIdQueryItem)
        }
        if value.maxResults != 0 {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(value.maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListNodeFromTemplateJobsInput {

    static func urlPathProvider(_ value: ListNodeFromTemplateJobsInput) -> Swift.String? {
        return "/packages/template-job"
    }
}

extension ListNodeFromTemplateJobsInput {

    static func queryItemProvider(_ value: ListNodeFromTemplateJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if value.maxResults != 0 {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(value.maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListNodesInput {

    static func urlPathProvider(_ value: ListNodesInput) -> Swift.String? {
        return "/nodes"
    }
}

extension ListNodesInput {

    static func queryItemProvider(_ value: ListNodesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let patchVersion = value.patchVersion {
            let patchVersionQueryItem = Smithy.URIQueryItem(name: "patchVersion".urlPercentEncoding(), value: Swift.String(patchVersion).urlPercentEncoding())
            items.append(patchVersionQueryItem)
        }
        if let category = value.category {
            let categoryQueryItem = Smithy.URIQueryItem(name: "category".urlPercentEncoding(), value: Swift.String(category.rawValue).urlPercentEncoding())
            items.append(categoryQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let packageName = value.packageName {
            let packageNameQueryItem = Smithy.URIQueryItem(name: "packageName".urlPercentEncoding(), value: Swift.String(packageName).urlPercentEncoding())
            items.append(packageNameQueryItem)
        }
        if value.maxResults != 0 {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(value.maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let ownerAccount = value.ownerAccount {
            let ownerAccountQueryItem = Smithy.URIQueryItem(name: "ownerAccount".urlPercentEncoding(), value: Swift.String(ownerAccount).urlPercentEncoding())
            items.append(ownerAccountQueryItem)
        }
        if let packageVersion = value.packageVersion {
            let packageVersionQueryItem = Smithy.URIQueryItem(name: "packageVersion".urlPercentEncoding(), value: Swift.String(packageVersion).urlPercentEncoding())
            items.append(packageVersionQueryItem)
        }
        return items
    }
}

extension ListPackageImportJobsInput {

    static func urlPathProvider(_ value: ListPackageImportJobsInput) -> Swift.String? {
        return "/packages/import-jobs"
    }
}

extension ListPackageImportJobsInput {

    static func queryItemProvider(_ value: ListPackageImportJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if value.maxResults != 0 {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(value.maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListPackagesInput {

    static func urlPathProvider(_ value: ListPackagesInput) -> Swift.String? {
        return "/packages"
    }
}

extension ListPackagesInput {

    static func queryItemProvider(_ value: ListPackagesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if value.maxResults != 0 {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(value.maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension ProvisionDeviceInput {

    static func urlPathProvider(_ value: ProvisionDeviceInput) -> Swift.String? {
        return "/devices"
    }
}

extension RegisterPackageVersionInput {

    static func urlPathProvider(_ value: RegisterPackageVersionInput) -> Swift.String? {
        guard let packageId = value.packageId else {
            return nil
        }
        guard let packageVersion = value.packageVersion else {
            return nil
        }
        guard let patchVersion = value.patchVersion else {
            return nil
        }
        return "/packages/\(packageId.urlPercentEncoding())/versions/\(packageVersion.urlPercentEncoding())/patch/\(patchVersion.urlPercentEncoding())"
    }
}

extension RemoveApplicationInstanceInput {

    static func urlPathProvider(_ value: RemoveApplicationInstanceInput) -> Swift.String? {
        guard let applicationInstanceId = value.applicationInstanceId else {
            return nil
        }
        return "/application-instances/\(applicationInstanceId.urlPercentEncoding())"
    }
}

extension SignalApplicationInstanceNodeInstancesInput {

    static func urlPathProvider(_ value: SignalApplicationInstanceNodeInstancesInput) -> Swift.String? {
        guard let applicationInstanceId = value.applicationInstanceId else {
            return nil
        }
        return "/application-instances/\(applicationInstanceId.urlPercentEncoding())/node-signals"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateDeviceMetadataInput {

    static func urlPathProvider(_ value: UpdateDeviceMetadataInput) -> Swift.String? {
        guard let deviceId = value.deviceId else {
            return nil
        }
        return "/devices/\(deviceId.urlPercentEncoding())"
    }
}

extension CreateApplicationInstanceInput {

    static func write(value: CreateApplicationInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationInstanceIdToReplace"].write(value.applicationInstanceIdToReplace)
        try writer["DefaultRuntimeContextDevice"].write(value.defaultRuntimeContextDevice)
        try writer["Description"].write(value.description)
        try writer["ManifestOverridesPayload"].write(value.manifestOverridesPayload, with: PanoramaClientTypes.ManifestOverridesPayload.write(value:to:))
        try writer["ManifestPayload"].write(value.manifestPayload, with: PanoramaClientTypes.ManifestPayload.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["RuntimeRoleArn"].write(value.runtimeRoleArn)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateJobForDevicesInput {

    static func write(value: CreateJobForDevicesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceIds"].writeList(value.deviceIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DeviceJobConfig"].write(value.deviceJobConfig, with: PanoramaClientTypes.DeviceJobConfig.write(value:to:))
        try writer["JobType"].write(value.jobType)
    }
}

extension CreateNodeFromTemplateJobInput {

    static func write(value: CreateNodeFromTemplateJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["JobTags"].writeList(value.jobTags, memberWritingClosure: PanoramaClientTypes.JobResourceTags.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NodeDescription"].write(value.nodeDescription)
        try writer["NodeName"].write(value.nodeName)
        try writer["OutputPackageName"].write(value.outputPackageName)
        try writer["OutputPackageVersion"].write(value.outputPackageVersion)
        try writer["TemplateParameters"].writeMap(value.templateParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["TemplateType"].write(value.templateType)
    }
}

extension CreatePackageInput {

    static func write(value: CreatePackageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PackageName"].write(value.packageName)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreatePackageImportJobInput {

    static func write(value: CreatePackageImportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["InputConfig"].write(value.inputConfig, with: PanoramaClientTypes.PackageImportJobInputConfig.write(value:to:))
        try writer["JobTags"].writeList(value.jobTags, memberWritingClosure: PanoramaClientTypes.JobResourceTags.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["JobType"].write(value.jobType)
        try writer["OutputConfig"].write(value.outputConfig, with: PanoramaClientTypes.PackageImportJobOutputConfig.write(value:to:))
    }
}

extension ProvisionDeviceInput {

    static func write(value: ProvisionDeviceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["NetworkingConfiguration"].write(value.networkingConfiguration, with: PanoramaClientTypes.NetworkPayload.write(value:to:))
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension RegisterPackageVersionInput {

    static func write(value: RegisterPackageVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MarkLatest"].write(value.markLatest)
        try writer["OwnerAccount"].write(value.ownerAccount)
    }
}

extension SignalApplicationInstanceNodeInstancesInput {

    static func write(value: SignalApplicationInstanceNodeInstancesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NodeSignals"].writeList(value.nodeSignals, memberWritingClosure: PanoramaClientTypes.NodeSignal.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateDeviceMetadataInput {

    static func write(value: UpdateDeviceMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
    }
}

extension CreateApplicationInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateApplicationInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateApplicationInstanceOutput()
        value.applicationInstanceId = try reader["ApplicationInstanceId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateJobForDevicesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateJobForDevicesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateJobForDevicesOutput()
        value.jobs = try reader["Jobs"].readListIfPresent(memberReadingClosure: PanoramaClientTypes.Job.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CreateNodeFromTemplateJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateNodeFromTemplateJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateNodeFromTemplateJobOutput()
        value.jobId = try reader["JobId"].readIfPresent() ?? ""
        return value
    }
}

extension CreatePackageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePackageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePackageOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.packageId = try reader["PackageId"].readIfPresent()
        value.storageLocation = try reader["StorageLocation"].readIfPresent(with: PanoramaClientTypes.StorageLocation.read(from:))
        return value
    }
}

extension CreatePackageImportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePackageImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePackageImportJobOutput()
        value.jobId = try reader["JobId"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteDeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDeviceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDeviceOutput()
        value.deviceId = try reader["DeviceId"].readIfPresent()
        return value
    }
}

extension DeletePackageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePackageOutput {
        return DeletePackageOutput()
    }
}

extension DeregisterPackageVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeregisterPackageVersionOutput {
        return DeregisterPackageVersionOutput()
    }
}

extension DescribeApplicationInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeApplicationInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeApplicationInstanceOutput()
        value.applicationInstanceId = try reader["ApplicationInstanceId"].readIfPresent()
        value.applicationInstanceIdToReplace = try reader["ApplicationInstanceIdToReplace"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.defaultRuntimeContextDevice = try reader["DefaultRuntimeContextDevice"].readIfPresent()
        value.defaultRuntimeContextDeviceName = try reader["DefaultRuntimeContextDeviceName"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.healthStatus = try reader["HealthStatus"].readIfPresent()
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["Name"].readIfPresent()
        value.runtimeContextStates = try reader["RuntimeContextStates"].readListIfPresent(memberReadingClosure: PanoramaClientTypes.ReportedRuntimeContextState.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.runtimeRoleArn = try reader["RuntimeRoleArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusDescription = try reader["StatusDescription"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension DescribeApplicationInstanceDetailsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeApplicationInstanceDetailsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeApplicationInstanceDetailsOutput()
        value.applicationInstanceId = try reader["ApplicationInstanceId"].readIfPresent()
        value.applicationInstanceIdToReplace = try reader["ApplicationInstanceIdToReplace"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.defaultRuntimeContextDevice = try reader["DefaultRuntimeContextDevice"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.manifestOverridesPayload = try reader["ManifestOverridesPayload"].readIfPresent(with: PanoramaClientTypes.ManifestOverridesPayload.read(from:))
        value.manifestPayload = try reader["ManifestPayload"].readIfPresent(with: PanoramaClientTypes.ManifestPayload.read(from:))
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension DescribeDeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDeviceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDeviceOutput()
        value.alternateSoftwares = try reader["AlternateSoftwares"].readListIfPresent(memberReadingClosure: PanoramaClientTypes.AlternateSoftwareMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.arn = try reader["Arn"].readIfPresent()
        value.brand = try reader["Brand"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.currentNetworkingStatus = try reader["CurrentNetworkingStatus"].readIfPresent(with: PanoramaClientTypes.NetworkStatus.read(from:))
        value.currentSoftware = try reader["CurrentSoftware"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.deviceAggregatedStatus = try reader["DeviceAggregatedStatus"].readIfPresent()
        value.deviceConnectionStatus = try reader["DeviceConnectionStatus"].readIfPresent()
        value.deviceId = try reader["DeviceId"].readIfPresent()
        value.latestAlternateSoftware = try reader["LatestAlternateSoftware"].readIfPresent()
        value.latestDeviceJob = try reader["LatestDeviceJob"].readIfPresent(with: PanoramaClientTypes.LatestDeviceJob.read(from:))
        value.latestSoftware = try reader["LatestSoftware"].readIfPresent()
        value.leaseExpirationTime = try reader["LeaseExpirationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["Name"].readIfPresent()
        value.networkingConfiguration = try reader["NetworkingConfiguration"].readIfPresent(with: PanoramaClientTypes.NetworkPayload.read(from:))
        value.provisioningStatus = try reader["ProvisioningStatus"].readIfPresent()
        value.serialNumber = try reader["SerialNumber"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension DescribeDeviceJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDeviceJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDeviceJobOutput()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deviceArn = try reader["DeviceArn"].readIfPresent()
        value.deviceId = try reader["DeviceId"].readIfPresent()
        value.deviceName = try reader["DeviceName"].readIfPresent()
        value.deviceType = try reader["DeviceType"].readIfPresent()
        value.imageVersion = try reader["ImageVersion"].readIfPresent()
        value.jobId = try reader["JobId"].readIfPresent()
        value.jobType = try reader["JobType"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension DescribeNodeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeNodeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeNodeOutput()
        value.assetName = try reader["AssetName"].readIfPresent()
        value.category = try reader["Category"].readIfPresent() ?? .sdkUnknown("")
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["Description"].readIfPresent() ?? ""
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.nodeId = try reader["NodeId"].readIfPresent() ?? ""
        value.nodeInterface = try reader["NodeInterface"].readIfPresent(with: PanoramaClientTypes.NodeInterface.read(from:))
        value.ownerAccount = try reader["OwnerAccount"].readIfPresent() ?? ""
        value.packageArn = try reader["PackageArn"].readIfPresent()
        value.packageId = try reader["PackageId"].readIfPresent() ?? ""
        value.packageName = try reader["PackageName"].readIfPresent() ?? ""
        value.packageVersion = try reader["PackageVersion"].readIfPresent() ?? ""
        value.patchVersion = try reader["PatchVersion"].readIfPresent() ?? ""
        return value
    }
}

extension DescribeNodeFromTemplateJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeNodeFromTemplateJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeNodeFromTemplateJobOutput()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.jobId = try reader["JobId"].readIfPresent() ?? ""
        value.jobTags = try reader["JobTags"].readListIfPresent(memberReadingClosure: PanoramaClientTypes.JobResourceTags.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.nodeDescription = try reader["NodeDescription"].readIfPresent()
        value.nodeName = try reader["NodeName"].readIfPresent() ?? ""
        value.outputPackageName = try reader["OutputPackageName"].readIfPresent() ?? ""
        value.outputPackageVersion = try reader["OutputPackageVersion"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.statusMessage = try reader["StatusMessage"].readIfPresent() ?? ""
        value.templateParameters = try reader["TemplateParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.templateType = try reader["TemplateType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DescribePackageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribePackageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribePackageOutput()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.packageId = try reader["PackageId"].readIfPresent() ?? ""
        value.packageName = try reader["PackageName"].readIfPresent() ?? ""
        value.readAccessPrincipalArns = try reader["ReadAccessPrincipalArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.storageLocation = try reader["StorageLocation"].readIfPresent(with: PanoramaClientTypes.StorageLocation.read(from:))
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.writeAccessPrincipalArns = try reader["WriteAccessPrincipalArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribePackageImportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribePackageImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribePackageImportJobOutput()
        value.clientToken = try reader["ClientToken"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.inputConfig = try reader["InputConfig"].readIfPresent(with: PanoramaClientTypes.PackageImportJobInputConfig.read(from:))
        value.jobId = try reader["JobId"].readIfPresent() ?? ""
        value.jobTags = try reader["JobTags"].readListIfPresent(memberReadingClosure: PanoramaClientTypes.JobResourceTags.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.jobType = try reader["JobType"].readIfPresent() ?? .sdkUnknown("")
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.output = try reader["Output"].readIfPresent(with: PanoramaClientTypes.PackageImportJobOutput.read(from:))
        value.outputConfig = try reader["OutputConfig"].readIfPresent(with: PanoramaClientTypes.PackageImportJobOutputConfig.read(from:))
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.statusMessage = try reader["StatusMessage"].readIfPresent() ?? ""
        return value
    }
}

extension DescribePackageVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribePackageVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribePackageVersionOutput()
        value.isLatestPatch = try reader["IsLatestPatch"].readIfPresent() ?? false
        value.ownerAccount = try reader["OwnerAccount"].readIfPresent()
        value.packageArn = try reader["PackageArn"].readIfPresent()
        value.packageId = try reader["PackageId"].readIfPresent() ?? ""
        value.packageName = try reader["PackageName"].readIfPresent() ?? ""
        value.packageVersion = try reader["PackageVersion"].readIfPresent() ?? ""
        value.patchVersion = try reader["PatchVersion"].readIfPresent() ?? ""
        value.registeredTime = try reader["RegisteredTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.statusDescription = try reader["StatusDescription"].readIfPresent()
        return value
    }
}

extension ListApplicationInstanceDependenciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListApplicationInstanceDependenciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListApplicationInstanceDependenciesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.packageObjects = try reader["PackageObjects"].readListIfPresent(memberReadingClosure: PanoramaClientTypes.PackageObject.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListApplicationInstanceNodeInstancesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListApplicationInstanceNodeInstancesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListApplicationInstanceNodeInstancesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.nodeInstances = try reader["NodeInstances"].readListIfPresent(memberReadingClosure: PanoramaClientTypes.NodeInstance.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListApplicationInstancesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListApplicationInstancesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListApplicationInstancesOutput()
        value.applicationInstances = try reader["ApplicationInstances"].readListIfPresent(memberReadingClosure: PanoramaClientTypes.ApplicationInstance.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListDevicesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDevicesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDevicesOutput()
        value.devices = try reader["Devices"].readListIfPresent(memberReadingClosure: PanoramaClientTypes.Device.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListDevicesJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDevicesJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDevicesJobsOutput()
        value.deviceJobs = try reader["DeviceJobs"].readListIfPresent(memberReadingClosure: PanoramaClientTypes.DeviceJob.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListNodeFromTemplateJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListNodeFromTemplateJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListNodeFromTemplateJobsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.nodeFromTemplateJobs = try reader["NodeFromTemplateJobs"].readListIfPresent(memberReadingClosure: PanoramaClientTypes.NodeFromTemplateJob.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListNodesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListNodesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListNodesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.nodes = try reader["Nodes"].readListIfPresent(memberReadingClosure: PanoramaClientTypes.Node.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListPackageImportJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPackageImportJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPackageImportJobsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.packageImportJobs = try reader["PackageImportJobs"].readListIfPresent(memberReadingClosure: PanoramaClientTypes.PackageImportJob.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListPackagesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPackagesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPackagesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.packages = try reader["Packages"].readListIfPresent(memberReadingClosure: PanoramaClientTypes.PackageListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ProvisionDeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ProvisionDeviceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ProvisionDeviceOutput()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.certificates = try reader["Certificates"].readIfPresent()
        value.deviceId = try reader["DeviceId"].readIfPresent()
        value.iotThingName = try reader["IotThingName"].readIfPresent()
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension RegisterPackageVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterPackageVersionOutput {
        return RegisterPackageVersionOutput()
    }
}

extension RemoveApplicationInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveApplicationInstanceOutput {
        return RemoveApplicationInstanceOutput()
    }
}

extension SignalApplicationInstanceNodeInstancesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SignalApplicationInstanceNodeInstancesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SignalApplicationInstanceNodeInstancesOutput()
        value.applicationInstanceId = try reader["ApplicationInstanceId"].readIfPresent() ?? ""
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateDeviceMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDeviceMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDeviceMetadataOutput()
        value.deviceId = try reader["DeviceId"].readIfPresent()
        return value
    }
}

enum CreateApplicationInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateJobForDevicesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateNodeFromTemplateJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePackageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePackageImportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePackageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeregisterPackageVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeApplicationInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeApplicationInstanceDetailsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDeviceJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeNodeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeNodeFromTemplateJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribePackageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribePackageImportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribePackageVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListApplicationInstanceDependenciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListApplicationInstanceNodeInstancesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListApplicationInstancesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDevicesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDevicesJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListNodeFromTemplateJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListNodesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPackageImportJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPackagesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ProvisionDeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterPackageVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveApplicationInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SignalApplicationInstanceNodeInstancesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDeviceMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["QuotaCode"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent()
        value.properties.resourceType = try reader["ResourceType"].readIfPresent()
        value.properties.serviceCode = try reader["ServiceCode"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.errorArguments = try reader["ErrorArguments"].readListIfPresent(memberReadingClosure: PanoramaClientTypes.ValidationExceptionErrorArgument.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.errorId = try reader["ErrorId"].readIfPresent()
        value.properties.fields = try reader["Fields"].readListIfPresent(memberReadingClosure: PanoramaClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.reason = try reader["Reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.errorArguments = try reader["ErrorArguments"].readListIfPresent(memberReadingClosure: PanoramaClientTypes.ConflictExceptionErrorArgument.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.errorId = try reader["ErrorId"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PanoramaClientTypes.Job {

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.Job {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PanoramaClientTypes.Job()
        value.jobId = try reader["JobId"].readIfPresent()
        value.deviceId = try reader["DeviceId"].readIfPresent()
        return value
    }
}

extension PanoramaClientTypes.StorageLocation {

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.StorageLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PanoramaClientTypes.StorageLocation()
        value.bucket = try reader["Bucket"].readIfPresent() ?? ""
        value.repoPrefixLocation = try reader["RepoPrefixLocation"].readIfPresent() ?? ""
        value.generatedPrefixLocation = try reader["GeneratedPrefixLocation"].readIfPresent() ?? ""
        value.binaryPrefixLocation = try reader["BinaryPrefixLocation"].readIfPresent() ?? ""
        value.manifestPrefixLocation = try reader["ManifestPrefixLocation"].readIfPresent() ?? ""
        return value
    }
}

extension PanoramaClientTypes.ReportedRuntimeContextState {

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.ReportedRuntimeContextState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PanoramaClientTypes.ReportedRuntimeContextState()
        value.desiredState = try reader["DesiredState"].readIfPresent() ?? .sdkUnknown("")
        value.runtimeContextName = try reader["RuntimeContextName"].readIfPresent() ?? ""
        value.deviceReportedStatus = try reader["DeviceReportedStatus"].readIfPresent() ?? .sdkUnknown("")
        value.deviceReportedTime = try reader["DeviceReportedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension PanoramaClientTypes.ManifestPayload {

    static func write(value: PanoramaClientTypes.ManifestPayload?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .payloaddata(payloaddata):
                try writer["PayloadData"].write(payloaddata)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.ManifestPayload {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "PayloadData":
                return .payloaddata(try reader["PayloadData"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension PanoramaClientTypes.ManifestOverridesPayload {

    static func write(value: PanoramaClientTypes.ManifestOverridesPayload?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .payloaddata(payloaddata):
                try writer["PayloadData"].write(payloaddata)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.ManifestOverridesPayload {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "PayloadData":
                return .payloaddata(try reader["PayloadData"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension PanoramaClientTypes.NetworkPayload {

    static func write(value: PanoramaClientTypes.NetworkPayload?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Ethernet0"].write(value.ethernet0, with: PanoramaClientTypes.EthernetPayload.write(value:to:))
        try writer["Ethernet1"].write(value.ethernet1, with: PanoramaClientTypes.EthernetPayload.write(value:to:))
        try writer["Ntp"].write(value.ntp, with: PanoramaClientTypes.NtpPayload.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.NetworkPayload {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PanoramaClientTypes.NetworkPayload()
        value.ethernet0 = try reader["Ethernet0"].readIfPresent(with: PanoramaClientTypes.EthernetPayload.read(from:))
        value.ethernet1 = try reader["Ethernet1"].readIfPresent(with: PanoramaClientTypes.EthernetPayload.read(from:))
        value.ntp = try reader["Ntp"].readIfPresent(with: PanoramaClientTypes.NtpPayload.read(from:))
        return value
    }
}

extension PanoramaClientTypes.NtpPayload {

    static func write(value: PanoramaClientTypes.NtpPayload?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NtpServers"].writeList(value.ntpServers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.NtpPayload {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PanoramaClientTypes.NtpPayload()
        value.ntpServers = try reader["NtpServers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension PanoramaClientTypes.EthernetPayload {

    static func write(value: PanoramaClientTypes.EthernetPayload?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectionType"].write(value.connectionType)
        try writer["StaticIpConnectionInfo"].write(value.staticIpConnectionInfo, with: PanoramaClientTypes.StaticIpConnectionInfo.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.EthernetPayload {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PanoramaClientTypes.EthernetPayload()
        value.connectionType = try reader["ConnectionType"].readIfPresent() ?? .sdkUnknown("")
        value.staticIpConnectionInfo = try reader["StaticIpConnectionInfo"].readIfPresent(with: PanoramaClientTypes.StaticIpConnectionInfo.read(from:))
        return value
    }
}

extension PanoramaClientTypes.StaticIpConnectionInfo {

    static func write(value: PanoramaClientTypes.StaticIpConnectionInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultGateway"].write(value.defaultGateway)
        try writer["Dns"].writeList(value.dns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IpAddress"].write(value.ipAddress)
        try writer["Mask"].write(value.mask)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.StaticIpConnectionInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PanoramaClientTypes.StaticIpConnectionInfo()
        value.ipAddress = try reader["IpAddress"].readIfPresent() ?? ""
        value.mask = try reader["Mask"].readIfPresent() ?? ""
        value.dns = try reader["Dns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.defaultGateway = try reader["DefaultGateway"].readIfPresent() ?? ""
        return value
    }
}

extension PanoramaClientTypes.NetworkStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.NetworkStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PanoramaClientTypes.NetworkStatus()
        value.ethernet0Status = try reader["Ethernet0Status"].readIfPresent(with: PanoramaClientTypes.EthernetStatus.read(from:))
        value.ethernet1Status = try reader["Ethernet1Status"].readIfPresent(with: PanoramaClientTypes.EthernetStatus.read(from:))
        value.ntpStatus = try reader["NtpStatus"].readIfPresent(with: PanoramaClientTypes.NtpStatus.read(from:))
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension PanoramaClientTypes.NtpStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.NtpStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PanoramaClientTypes.NtpStatus()
        value.connectionStatus = try reader["ConnectionStatus"].readIfPresent()
        value.ipAddress = try reader["IpAddress"].readIfPresent()
        value.ntpServerName = try reader["NtpServerName"].readIfPresent()
        return value
    }
}

extension PanoramaClientTypes.EthernetStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.EthernetStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PanoramaClientTypes.EthernetStatus()
        value.ipAddress = try reader["IpAddress"].readIfPresent()
        value.connectionStatus = try reader["ConnectionStatus"].readIfPresent()
        value.hwAddress = try reader["HwAddress"].readIfPresent()
        return value
    }
}

extension PanoramaClientTypes.AlternateSoftwareMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.AlternateSoftwareMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PanoramaClientTypes.AlternateSoftwareMetadata()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension PanoramaClientTypes.LatestDeviceJob {

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.LatestDeviceJob {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PanoramaClientTypes.LatestDeviceJob()
        value.imageVersion = try reader["ImageVersion"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.jobType = try reader["JobType"].readIfPresent()
        return value
    }
}

extension PanoramaClientTypes.NodeInterface {

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.NodeInterface {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PanoramaClientTypes.NodeInterface()
        value.inputs = try reader["Inputs"].readListIfPresent(memberReadingClosure: PanoramaClientTypes.NodeInputPort.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.outputs = try reader["Outputs"].readListIfPresent(memberReadingClosure: PanoramaClientTypes.NodeOutputPort.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension PanoramaClientTypes.NodeOutputPort {

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.NodeOutputPort {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PanoramaClientTypes.NodeOutputPort()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension PanoramaClientTypes.NodeInputPort {

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.NodeInputPort {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PanoramaClientTypes.NodeInputPort()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.defaultValue = try reader["DefaultValue"].readIfPresent()
        value.maxConnections = try reader["MaxConnections"].readIfPresent() ?? 0
        return value
    }
}

extension PanoramaClientTypes.JobResourceTags {

    static func write(value: PanoramaClientTypes.JobResourceTags?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceType"].write(value.resourceType)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.JobResourceTags {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PanoramaClientTypes.JobResourceTags()
        value.resourceType = try reader["ResourceType"].readIfPresent() ?? .sdkUnknown("")
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension PanoramaClientTypes.PackageImportJobInputConfig {

    static func write(value: PanoramaClientTypes.PackageImportJobInputConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PackageVersionInputConfig"].write(value.packageVersionInputConfig, with: PanoramaClientTypes.PackageVersionInputConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.PackageImportJobInputConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PanoramaClientTypes.PackageImportJobInputConfig()
        value.packageVersionInputConfig = try reader["PackageVersionInputConfig"].readIfPresent(with: PanoramaClientTypes.PackageVersionInputConfig.read(from:))
        return value
    }
}

extension PanoramaClientTypes.PackageVersionInputConfig {

    static func write(value: PanoramaClientTypes.PackageVersionInputConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3Location"].write(value.s3Location, with: PanoramaClientTypes.S3Location.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.PackageVersionInputConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PanoramaClientTypes.PackageVersionInputConfig()
        value.s3Location = try reader["S3Location"].readIfPresent(with: PanoramaClientTypes.S3Location.read(from:))
        return value
    }
}

extension PanoramaClientTypes.S3Location {

    static func write(value: PanoramaClientTypes.S3Location?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BucketName"].write(value.bucketName)
        try writer["ObjectKey"].write(value.objectKey)
        try writer["Region"].write(value.region)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.S3Location {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PanoramaClientTypes.S3Location()
        value.region = try reader["Region"].readIfPresent()
        value.bucketName = try reader["BucketName"].readIfPresent() ?? ""
        value.objectKey = try reader["ObjectKey"].readIfPresent() ?? ""
        return value
    }
}

extension PanoramaClientTypes.PackageImportJobOutputConfig {

    static func write(value: PanoramaClientTypes.PackageImportJobOutputConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PackageVersionOutputConfig"].write(value.packageVersionOutputConfig, with: PanoramaClientTypes.PackageVersionOutputConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.PackageImportJobOutputConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PanoramaClientTypes.PackageImportJobOutputConfig()
        value.packageVersionOutputConfig = try reader["PackageVersionOutputConfig"].readIfPresent(with: PanoramaClientTypes.PackageVersionOutputConfig.read(from:))
        return value
    }
}

extension PanoramaClientTypes.PackageVersionOutputConfig {

    static func write(value: PanoramaClientTypes.PackageVersionOutputConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MarkLatest"].write(value.markLatest)
        try writer["PackageName"].write(value.packageName)
        try writer["PackageVersion"].write(value.packageVersion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.PackageVersionOutputConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PanoramaClientTypes.PackageVersionOutputConfig()
        value.packageName = try reader["PackageName"].readIfPresent() ?? ""
        value.packageVersion = try reader["PackageVersion"].readIfPresent() ?? ""
        value.markLatest = try reader["MarkLatest"].readIfPresent() ?? false
        return value
    }
}

extension PanoramaClientTypes.PackageImportJobOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.PackageImportJobOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PanoramaClientTypes.PackageImportJobOutput()
        value.packageId = try reader["PackageId"].readIfPresent() ?? ""
        value.packageVersion = try reader["PackageVersion"].readIfPresent() ?? ""
        value.patchVersion = try reader["PatchVersion"].readIfPresent() ?? ""
        value.outputS3Location = try reader["OutputS3Location"].readIfPresent(with: PanoramaClientTypes.OutPutS3Location.read(from:))
        return value
    }
}

extension PanoramaClientTypes.OutPutS3Location {

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.OutPutS3Location {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PanoramaClientTypes.OutPutS3Location()
        value.bucketName = try reader["BucketName"].readIfPresent() ?? ""
        value.objectKey = try reader["ObjectKey"].readIfPresent() ?? ""
        return value
    }
}

extension PanoramaClientTypes.PackageObject {

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.PackageObject {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PanoramaClientTypes.PackageObject()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.packageVersion = try reader["PackageVersion"].readIfPresent() ?? ""
        value.patchVersion = try reader["PatchVersion"].readIfPresent() ?? ""
        return value
    }
}

extension PanoramaClientTypes.NodeInstance {

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.NodeInstance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PanoramaClientTypes.NodeInstance()
        value.nodeInstanceId = try reader["NodeInstanceId"].readIfPresent() ?? ""
        value.nodeId = try reader["NodeId"].readIfPresent()
        value.packageName = try reader["PackageName"].readIfPresent()
        value.packageVersion = try reader["PackageVersion"].readIfPresent()
        value.packagePatchVersion = try reader["PackagePatchVersion"].readIfPresent()
        value.nodeName = try reader["NodeName"].readIfPresent()
        value.currentStatus = try reader["CurrentStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension PanoramaClientTypes.ApplicationInstance {

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.ApplicationInstance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PanoramaClientTypes.ApplicationInstance()
        value.name = try reader["Name"].readIfPresent()
        value.applicationInstanceId = try reader["ApplicationInstanceId"].readIfPresent()
        value.defaultRuntimeContextDevice = try reader["DefaultRuntimeContextDevice"].readIfPresent()
        value.defaultRuntimeContextDeviceName = try reader["DefaultRuntimeContextDeviceName"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.healthStatus = try reader["HealthStatus"].readIfPresent()
        value.statusDescription = try reader["StatusDescription"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.arn = try reader["Arn"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.runtimeContextStates = try reader["RuntimeContextStates"].readListIfPresent(memberReadingClosure: PanoramaClientTypes.ReportedRuntimeContextState.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PanoramaClientTypes.Device {

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.Device {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PanoramaClientTypes.Device()
        value.deviceId = try reader["DeviceId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.provisioningStatus = try reader["ProvisioningStatus"].readIfPresent()
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.leaseExpirationTime = try reader["LeaseExpirationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.brand = try reader["Brand"].readIfPresent()
        value.currentSoftware = try reader["CurrentSoftware"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.type = try reader["Type"].readIfPresent()
        value.latestDeviceJob = try reader["LatestDeviceJob"].readIfPresent(with: PanoramaClientTypes.LatestDeviceJob.read(from:))
        value.deviceAggregatedStatus = try reader["DeviceAggregatedStatus"].readIfPresent()
        return value
    }
}

extension PanoramaClientTypes.DeviceJob {

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.DeviceJob {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PanoramaClientTypes.DeviceJob()
        value.deviceName = try reader["DeviceName"].readIfPresent()
        value.deviceId = try reader["DeviceId"].readIfPresent()
        value.jobId = try reader["JobId"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.jobType = try reader["JobType"].readIfPresent()
        return value
    }
}

extension PanoramaClientTypes.NodeFromTemplateJob {

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.NodeFromTemplateJob {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PanoramaClientTypes.NodeFromTemplateJob()
        value.jobId = try reader["JobId"].readIfPresent()
        value.templateType = try reader["TemplateType"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.nodeName = try reader["NodeName"].readIfPresent()
        return value
    }
}

extension PanoramaClientTypes.Node {

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.Node {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PanoramaClientTypes.Node()
        value.nodeId = try reader["NodeId"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.category = try reader["Category"].readIfPresent() ?? .sdkUnknown("")
        value.ownerAccount = try reader["OwnerAccount"].readIfPresent()
        value.packageName = try reader["PackageName"].readIfPresent() ?? ""
        value.packageId = try reader["PackageId"].readIfPresent() ?? ""
        value.packageArn = try reader["PackageArn"].readIfPresent()
        value.packageVersion = try reader["PackageVersion"].readIfPresent() ?? ""
        value.patchVersion = try reader["PatchVersion"].readIfPresent() ?? ""
        value.description = try reader["Description"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension PanoramaClientTypes.PackageImportJob {

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.PackageImportJob {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PanoramaClientTypes.PackageImportJob()
        value.jobId = try reader["JobId"].readIfPresent()
        value.jobType = try reader["JobType"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension PanoramaClientTypes.PackageListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.PackageListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PanoramaClientTypes.PackageListItem()
        value.packageId = try reader["PackageId"].readIfPresent()
        value.packageName = try reader["PackageName"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension PanoramaClientTypes.ValidationExceptionErrorArgument {

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.ValidationExceptionErrorArgument {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PanoramaClientTypes.ValidationExceptionErrorArgument()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension PanoramaClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PanoramaClientTypes.ValidationExceptionField()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.message = try reader["Message"].readIfPresent() ?? ""
        return value
    }
}

extension PanoramaClientTypes.ConflictExceptionErrorArgument {

    static func read(from reader: SmithyJSON.Reader) throws -> PanoramaClientTypes.ConflictExceptionErrorArgument {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PanoramaClientTypes.ConflictExceptionErrorArgument()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension PanoramaClientTypes.DeviceJobConfig {

    static func write(value: PanoramaClientTypes.DeviceJobConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OTAJobConfig"].write(value.otaJobConfig, with: PanoramaClientTypes.OTAJobConfig.write(value:to:))
    }
}

extension PanoramaClientTypes.OTAJobConfig {

    static func write(value: PanoramaClientTypes.OTAJobConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowMajorVersionUpdate"].write(value.allowMajorVersionUpdate)
        try writer["ImageVersion"].write(value.imageVersion)
    }
}

extension PanoramaClientTypes.NodeSignal {

    static func write(value: PanoramaClientTypes.NodeSignal?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NodeInstanceId"].write(value.nodeInstanceId)
        try writer["Signal"].write(value.signal)
    }
}

public enum PanoramaClientTypes {}
