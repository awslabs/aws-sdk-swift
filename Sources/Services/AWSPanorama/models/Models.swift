// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requestor does not have permission to access the target action or resource.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PanoramaClientTypes.AlternateSoftwareMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension PanoramaClientTypes {
    /// Details about a beta appliance software update.
    public struct AlternateSoftwareMetadata: Swift.Equatable {
        /// The appliance software version.
        public var version: Swift.String?

        public init(
            version: Swift.String? = nil
        )
        {
            self.version = version
        }
    }

}

extension PanoramaClientTypes.ApplicationInstance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationInstanceId = "ApplicationInstanceId"
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case defaultRuntimeContextDevice = "DefaultRuntimeContextDevice"
        case defaultRuntimeContextDeviceName = "DefaultRuntimeContextDeviceName"
        case description = "Description"
        case healthStatus = "HealthStatus"
        case name = "Name"
        case runtimeContextStates = "RuntimeContextStates"
        case status = "Status"
        case statusDescription = "StatusDescription"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationInstanceId = self.applicationInstanceId {
            try encodeContainer.encode(applicationInstanceId, forKey: .applicationInstanceId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let defaultRuntimeContextDevice = self.defaultRuntimeContextDevice {
            try encodeContainer.encode(defaultRuntimeContextDevice, forKey: .defaultRuntimeContextDevice)
        }
        if let defaultRuntimeContextDeviceName = self.defaultRuntimeContextDeviceName {
            try encodeContainer.encode(defaultRuntimeContextDeviceName, forKey: .defaultRuntimeContextDeviceName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let healthStatus = self.healthStatus {
            try encodeContainer.encode(healthStatus.rawValue, forKey: .healthStatus)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let runtimeContextStates = runtimeContextStates {
            var runtimeContextStatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .runtimeContextStates)
            for reportedruntimecontextstate0 in runtimeContextStates {
                try runtimeContextStatesContainer.encode(reportedruntimecontextstate0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDescription = self.statusDescription {
            try encodeContainer.encode(statusDescription, forKey: .statusDescription)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let applicationInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationInstanceId)
        applicationInstanceId = applicationInstanceIdDecoded
        let defaultRuntimeContextDeviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultRuntimeContextDevice)
        defaultRuntimeContextDevice = defaultRuntimeContextDeviceDecoded
        let defaultRuntimeContextDeviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultRuntimeContextDeviceName)
        defaultRuntimeContextDeviceName = defaultRuntimeContextDeviceNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.ApplicationInstanceStatus.self, forKey: .status)
        status = statusDecoded
        let healthStatusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.ApplicationInstanceHealthStatus.self, forKey: .healthStatus)
        healthStatus = healthStatusDecoded
        let statusDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDescription)
        statusDescription = statusDescriptionDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let runtimeContextStatesContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.ReportedRuntimeContextState?].self, forKey: .runtimeContextStates)
        var runtimeContextStatesDecoded0:[PanoramaClientTypes.ReportedRuntimeContextState]? = nil
        if let runtimeContextStatesContainer = runtimeContextStatesContainer {
            runtimeContextStatesDecoded0 = [PanoramaClientTypes.ReportedRuntimeContextState]()
            for structure0 in runtimeContextStatesContainer {
                if let structure0 = structure0 {
                    runtimeContextStatesDecoded0?.append(structure0)
                }
            }
        }
        runtimeContextStates = runtimeContextStatesDecoded0
    }
}

extension PanoramaClientTypes {
    /// An application instance on a device.
    public struct ApplicationInstance: Swift.Equatable {
        /// The application instance's ID.
        public var applicationInstanceId: Swift.String?
        /// The application instance's ARN.
        public var arn: Swift.String?
        /// When the application instance was created.
        public var createdTime: ClientRuntime.Date?
        /// The device's ID.
        public var defaultRuntimeContextDevice: Swift.String?
        /// The device's name.
        public var defaultRuntimeContextDeviceName: Swift.String?
        /// The application instance's description.
        public var description: Swift.String?
        /// The application instance's health status.
        public var healthStatus: PanoramaClientTypes.ApplicationInstanceHealthStatus?
        /// The application instance's name.
        public var name: Swift.String?
        /// The application's state.
        public var runtimeContextStates: [PanoramaClientTypes.ReportedRuntimeContextState]?
        /// The application instance's status.
        public var status: PanoramaClientTypes.ApplicationInstanceStatus?
        /// The application instance's status description.
        public var statusDescription: Swift.String?
        /// The application instance's tags.
        public var tags: [Swift.String:Swift.String]?

        public init(
            applicationInstanceId: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            defaultRuntimeContextDevice: Swift.String? = nil,
            defaultRuntimeContextDeviceName: Swift.String? = nil,
            description: Swift.String? = nil,
            healthStatus: PanoramaClientTypes.ApplicationInstanceHealthStatus? = nil,
            name: Swift.String? = nil,
            runtimeContextStates: [PanoramaClientTypes.ReportedRuntimeContextState]? = nil,
            status: PanoramaClientTypes.ApplicationInstanceStatus? = nil,
            statusDescription: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.applicationInstanceId = applicationInstanceId
            self.arn = arn
            self.createdTime = createdTime
            self.defaultRuntimeContextDevice = defaultRuntimeContextDevice
            self.defaultRuntimeContextDeviceName = defaultRuntimeContextDeviceName
            self.description = description
            self.healthStatus = healthStatus
            self.name = name
            self.runtimeContextStates = runtimeContextStates
            self.status = status
            self.statusDescription = statusDescription
            self.tags = tags
        }
    }

}

extension PanoramaClientTypes {
    public enum ApplicationInstanceHealthStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case notAvailable
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationInstanceHealthStatus] {
            return [
                .error,
                .notAvailable,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .notAvailable: return "NOT_AVAILABLE"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationInstanceHealthStatus(rawValue: rawValue) ?? ApplicationInstanceHealthStatus.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes {
    public enum ApplicationInstanceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deploymentError
        case deploymentFailed
        case deploymentInProgress
        case deploymentPending
        case deploymentRequested
        case deploymentSucceeded
        case removalFailed
        case removalInProgress
        case removalPending
        case removalRequested
        case removalSucceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationInstanceStatus] {
            return [
                .deploymentError,
                .deploymentFailed,
                .deploymentInProgress,
                .deploymentPending,
                .deploymentRequested,
                .deploymentSucceeded,
                .removalFailed,
                .removalInProgress,
                .removalPending,
                .removalRequested,
                .removalSucceeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deploymentError: return "DEPLOYMENT_ERROR"
            case .deploymentFailed: return "DEPLOYMENT_FAILED"
            case .deploymentInProgress: return "DEPLOYMENT_IN_PROGRESS"
            case .deploymentPending: return "DEPLOYMENT_PENDING"
            case .deploymentRequested: return "DEPLOYMENT_REQUESTED"
            case .deploymentSucceeded: return "DEPLOYMENT_SUCCEEDED"
            case .removalFailed: return "REMOVAL_FAILED"
            case .removalInProgress: return "REMOVAL_IN_PROGRESS"
            case .removalPending: return "REMOVAL_PENDING"
            case .removalRequested: return "REMOVAL_REQUESTED"
            case .removalSucceeded: return "REMOVAL_SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationInstanceStatus(rawValue: rawValue) ?? ApplicationInstanceStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorArguments = output.errorArguments
            self.properties.errorId = output.errorId
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.errorArguments = nil
            self.properties.errorId = nil
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The target resource is in use.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A list of attributes that led to the exception and their values.
        public internal(set) var errorArguments: [PanoramaClientTypes.ConflictExceptionErrorArgument]? = nil
        /// A unique ID for the error.
        public internal(set) var errorId: Swift.String? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The resource's ID.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource's type.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorArguments: [PanoramaClientTypes.ConflictExceptionErrorArgument]? = nil,
        errorId: Swift.String? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.errorArguments = errorArguments
        self.properties.errorId = errorId
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let errorId: Swift.String?
    let errorArguments: [PanoramaClientTypes.ConflictExceptionErrorArgument]?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorArguments = "ErrorArguments"
        case errorId = "ErrorId"
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let errorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorId)
        errorId = errorIdDecoded
        let errorArgumentsContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.ConflictExceptionErrorArgument?].self, forKey: .errorArguments)
        var errorArgumentsDecoded0:[PanoramaClientTypes.ConflictExceptionErrorArgument]? = nil
        if let errorArgumentsContainer = errorArgumentsContainer {
            errorArgumentsDecoded0 = [PanoramaClientTypes.ConflictExceptionErrorArgument]()
            for structure0 in errorArgumentsContainer {
                if let structure0 = structure0 {
                    errorArgumentsDecoded0?.append(structure0)
                }
            }
        }
        errorArguments = errorArgumentsDecoded0
    }
}

extension PanoramaClientTypes.ConflictExceptionErrorArgument: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension PanoramaClientTypes {
    /// A conflict exception error argument.
    public struct ConflictExceptionErrorArgument: Swift.Equatable {
        /// The error argument's name.
        /// This member is required.
        public var name: Swift.String?
        /// The error argument's value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension PanoramaClientTypes {
    public enum ConnectionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dhcp
        case staticIp
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionType] {
            return [
                .dhcp,
                .staticIp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dhcp: return "DHCP"
            case .staticIp: return "STATIC_IP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionType(rawValue: rawValue) ?? ConnectionType.sdkUnknown(rawValue)
        }
    }
}

extension CreateApplicationInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationInstanceIdToReplace = "ApplicationInstanceIdToReplace"
        case defaultRuntimeContextDevice = "DefaultRuntimeContextDevice"
        case description = "Description"
        case manifestOverridesPayload = "ManifestOverridesPayload"
        case manifestPayload = "ManifestPayload"
        case name = "Name"
        case runtimeRoleArn = "RuntimeRoleArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationInstanceIdToReplace = self.applicationInstanceIdToReplace {
            try encodeContainer.encode(applicationInstanceIdToReplace, forKey: .applicationInstanceIdToReplace)
        }
        if let defaultRuntimeContextDevice = self.defaultRuntimeContextDevice {
            try encodeContainer.encode(defaultRuntimeContextDevice, forKey: .defaultRuntimeContextDevice)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let manifestOverridesPayload = self.manifestOverridesPayload {
            try encodeContainer.encode(manifestOverridesPayload, forKey: .manifestOverridesPayload)
        }
        if let manifestPayload = self.manifestPayload {
            try encodeContainer.encode(manifestPayload, forKey: .manifestPayload)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let runtimeRoleArn = self.runtimeRoleArn {
            try encodeContainer.encode(runtimeRoleArn, forKey: .runtimeRoleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateApplicationInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/application-instances"
    }
}

public struct CreateApplicationInstanceInput: Swift.Equatable {
    /// The ID of an application instance to replace with the new instance.
    public var applicationInstanceIdToReplace: Swift.String?
    /// A device's ID.
    /// This member is required.
    public var defaultRuntimeContextDevice: Swift.String?
    /// A description for the application instance.
    public var description: Swift.String?
    /// Setting overrides for the application manifest.
    public var manifestOverridesPayload: PanoramaClientTypes.ManifestOverridesPayload?
    /// The application's manifest document.
    /// This member is required.
    public var manifestPayload: PanoramaClientTypes.ManifestPayload?
    /// A name for the application instance.
    public var name: Swift.String?
    /// The ARN of a runtime role for the application instance.
    public var runtimeRoleArn: Swift.String?
    /// Tags for the application instance.
    public var tags: [Swift.String:Swift.String]?

    public init(
        applicationInstanceIdToReplace: Swift.String? = nil,
        defaultRuntimeContextDevice: Swift.String? = nil,
        description: Swift.String? = nil,
        manifestOverridesPayload: PanoramaClientTypes.ManifestOverridesPayload? = nil,
        manifestPayload: PanoramaClientTypes.ManifestPayload? = nil,
        name: Swift.String? = nil,
        runtimeRoleArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.applicationInstanceIdToReplace = applicationInstanceIdToReplace
        self.defaultRuntimeContextDevice = defaultRuntimeContextDevice
        self.description = description
        self.manifestOverridesPayload = manifestOverridesPayload
        self.manifestPayload = manifestPayload
        self.name = name
        self.runtimeRoleArn = runtimeRoleArn
        self.tags = tags
    }
}

struct CreateApplicationInstanceInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let manifestPayload: PanoramaClientTypes.ManifestPayload?
    let manifestOverridesPayload: PanoramaClientTypes.ManifestOverridesPayload?
    let applicationInstanceIdToReplace: Swift.String?
    let runtimeRoleArn: Swift.String?
    let defaultRuntimeContextDevice: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateApplicationInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationInstanceIdToReplace = "ApplicationInstanceIdToReplace"
        case defaultRuntimeContextDevice = "DefaultRuntimeContextDevice"
        case description = "Description"
        case manifestOverridesPayload = "ManifestOverridesPayload"
        case manifestPayload = "ManifestPayload"
        case name = "Name"
        case runtimeRoleArn = "RuntimeRoleArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let manifestPayloadDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.ManifestPayload.self, forKey: .manifestPayload)
        manifestPayload = manifestPayloadDecoded
        let manifestOverridesPayloadDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.ManifestOverridesPayload.self, forKey: .manifestOverridesPayload)
        manifestOverridesPayload = manifestOverridesPayloadDecoded
        let applicationInstanceIdToReplaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationInstanceIdToReplace)
        applicationInstanceIdToReplace = applicationInstanceIdToReplaceDecoded
        let runtimeRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runtimeRoleArn)
        runtimeRoleArn = runtimeRoleArnDecoded
        let defaultRuntimeContextDeviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultRuntimeContextDevice)
        defaultRuntimeContextDevice = defaultRuntimeContextDeviceDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateApplicationInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateApplicationInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationInstanceId = output.applicationInstanceId
        } else {
            self.applicationInstanceId = nil
        }
    }
}

public struct CreateApplicationInstanceOutput: Swift.Equatable {
    /// The application instance's ID.
    /// This member is required.
    public var applicationInstanceId: Swift.String?

    public init(
        applicationInstanceId: Swift.String? = nil
    )
    {
        self.applicationInstanceId = applicationInstanceId
    }
}

struct CreateApplicationInstanceOutputBody: Swift.Equatable {
    let applicationInstanceId: Swift.String?
}

extension CreateApplicationInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationInstanceId = "ApplicationInstanceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationInstanceId)
        applicationInstanceId = applicationInstanceIdDecoded
    }
}

enum CreateApplicationInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateJobForDevicesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceIds = "DeviceIds"
        case deviceJobConfig = "DeviceJobConfig"
        case jobType = "JobType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceIds = deviceIds {
            var deviceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceIds)
            for deviceid0 in deviceIds {
                try deviceIdsContainer.encode(deviceid0)
            }
        }
        if let deviceJobConfig = self.deviceJobConfig {
            try encodeContainer.encode(deviceJobConfig, forKey: .deviceJobConfig)
        }
        if let jobType = self.jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
    }
}

extension CreateJobForDevicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/jobs"
    }
}

public struct CreateJobForDevicesInput: Swift.Equatable {
    /// ID of target device.
    /// This member is required.
    public var deviceIds: [Swift.String]?
    /// Configuration settings for a software update job.
    public var deviceJobConfig: PanoramaClientTypes.DeviceJobConfig?
    /// The type of job to run.
    /// This member is required.
    public var jobType: PanoramaClientTypes.JobType?

    public init(
        deviceIds: [Swift.String]? = nil,
        deviceJobConfig: PanoramaClientTypes.DeviceJobConfig? = nil,
        jobType: PanoramaClientTypes.JobType? = nil
    )
    {
        self.deviceIds = deviceIds
        self.deviceJobConfig = deviceJobConfig
        self.jobType = jobType
    }
}

struct CreateJobForDevicesInputBody: Swift.Equatable {
    let deviceIds: [Swift.String]?
    let deviceJobConfig: PanoramaClientTypes.DeviceJobConfig?
    let jobType: PanoramaClientTypes.JobType?
}

extension CreateJobForDevicesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceIds = "DeviceIds"
        case deviceJobConfig = "DeviceJobConfig"
        case jobType = "JobType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceIds)
        var deviceIdsDecoded0:[Swift.String]? = nil
        if let deviceIdsContainer = deviceIdsContainer {
            deviceIdsDecoded0 = [Swift.String]()
            for string0 in deviceIdsContainer {
                if let string0 = string0 {
                    deviceIdsDecoded0?.append(string0)
                }
            }
        }
        deviceIds = deviceIdsDecoded0
        let deviceJobConfigDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.DeviceJobConfig.self, forKey: .deviceJobConfig)
        deviceJobConfig = deviceJobConfigDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
    }
}

extension CreateJobForDevicesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateJobForDevicesOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobs = output.jobs
        } else {
            self.jobs = nil
        }
    }
}

public struct CreateJobForDevicesOutput: Swift.Equatable {
    /// A list of jobs.
    /// This member is required.
    public var jobs: [PanoramaClientTypes.Job]?

    public init(
        jobs: [PanoramaClientTypes.Job]? = nil
    )
    {
        self.jobs = jobs
    }
}

struct CreateJobForDevicesOutputBody: Swift.Equatable {
    let jobs: [PanoramaClientTypes.Job]?
}

extension CreateJobForDevicesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs = "Jobs"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.Job?].self, forKey: .jobs)
        var jobsDecoded0:[PanoramaClientTypes.Job]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [PanoramaClientTypes.Job]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
    }
}

enum CreateJobForDevicesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateNodeFromTemplateJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobTags = "JobTags"
        case nodeDescription = "NodeDescription"
        case nodeName = "NodeName"
        case outputPackageName = "OutputPackageName"
        case outputPackageVersion = "OutputPackageVersion"
        case templateParameters = "TemplateParameters"
        case templateType = "TemplateType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobTags = jobTags {
            var jobTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .jobTags)
            for jobresourcetags0 in jobTags {
                try jobTagsContainer.encode(jobresourcetags0)
            }
        }
        if let nodeDescription = self.nodeDescription {
            try encodeContainer.encode(nodeDescription, forKey: .nodeDescription)
        }
        if let nodeName = self.nodeName {
            try encodeContainer.encode(nodeName, forKey: .nodeName)
        }
        if let outputPackageName = self.outputPackageName {
            try encodeContainer.encode(outputPackageName, forKey: .outputPackageName)
        }
        if let outputPackageVersion = self.outputPackageVersion {
            try encodeContainer.encode(outputPackageVersion, forKey: .outputPackageVersion)
        }
        if let templateParameters = templateParameters {
            var templateParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .templateParameters)
            for (dictKey0, templateParametersMap0) in templateParameters {
                try templateParametersContainer.encode(templateParametersMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let templateType = self.templateType {
            try encodeContainer.encode(templateType.rawValue, forKey: .templateType)
        }
    }
}

extension CreateNodeFromTemplateJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/packages/template-job"
    }
}

public struct CreateNodeFromTemplateJobInput: Swift.Equatable {
    /// Tags for the job.
    public var jobTags: [PanoramaClientTypes.JobResourceTags]?
    /// A description for the node.
    public var nodeDescription: Swift.String?
    /// A name for the node.
    /// This member is required.
    public var nodeName: Swift.String?
    /// An output package name for the node.
    /// This member is required.
    public var outputPackageName: Swift.String?
    /// An output package version for the node.
    /// This member is required.
    public var outputPackageVersion: Swift.String?
    /// Template parameters for the node.
    /// This member is required.
    public var templateParameters: [Swift.String:Swift.String]?
    /// The type of node.
    /// This member is required.
    public var templateType: PanoramaClientTypes.TemplateType?

    public init(
        jobTags: [PanoramaClientTypes.JobResourceTags]? = nil,
        nodeDescription: Swift.String? = nil,
        nodeName: Swift.String? = nil,
        outputPackageName: Swift.String? = nil,
        outputPackageVersion: Swift.String? = nil,
        templateParameters: [Swift.String:Swift.String]? = nil,
        templateType: PanoramaClientTypes.TemplateType? = nil
    )
    {
        self.jobTags = jobTags
        self.nodeDescription = nodeDescription
        self.nodeName = nodeName
        self.outputPackageName = outputPackageName
        self.outputPackageVersion = outputPackageVersion
        self.templateParameters = templateParameters
        self.templateType = templateType
    }
}

struct CreateNodeFromTemplateJobInputBody: Swift.Equatable {
    let templateType: PanoramaClientTypes.TemplateType?
    let outputPackageName: Swift.String?
    let outputPackageVersion: Swift.String?
    let nodeName: Swift.String?
    let nodeDescription: Swift.String?
    let templateParameters: [Swift.String:Swift.String]?
    let jobTags: [PanoramaClientTypes.JobResourceTags]?
}

extension CreateNodeFromTemplateJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobTags = "JobTags"
        case nodeDescription = "NodeDescription"
        case nodeName = "NodeName"
        case outputPackageName = "OutputPackageName"
        case outputPackageVersion = "OutputPackageVersion"
        case templateParameters = "TemplateParameters"
        case templateType = "TemplateType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateTypeDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.TemplateType.self, forKey: .templateType)
        templateType = templateTypeDecoded
        let outputPackageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputPackageName)
        outputPackageName = outputPackageNameDecoded
        let outputPackageVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputPackageVersion)
        outputPackageVersion = outputPackageVersionDecoded
        let nodeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeName)
        nodeName = nodeNameDecoded
        let nodeDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeDescription)
        nodeDescription = nodeDescriptionDecoded
        let templateParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .templateParameters)
        var templateParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let templateParametersContainer = templateParametersContainer {
            templateParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, templatevalue0) in templateParametersContainer {
                if let templatevalue0 = templatevalue0 {
                    templateParametersDecoded0?[key0] = templatevalue0
                }
            }
        }
        templateParameters = templateParametersDecoded0
        let jobTagsContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.JobResourceTags?].self, forKey: .jobTags)
        var jobTagsDecoded0:[PanoramaClientTypes.JobResourceTags]? = nil
        if let jobTagsContainer = jobTagsContainer {
            jobTagsDecoded0 = [PanoramaClientTypes.JobResourceTags]()
            for structure0 in jobTagsContainer {
                if let structure0 = structure0 {
                    jobTagsDecoded0?.append(structure0)
                }
            }
        }
        jobTags = jobTagsDecoded0
    }
}

extension CreateNodeFromTemplateJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateNodeFromTemplateJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct CreateNodeFromTemplateJobOutput: Swift.Equatable {
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct CreateNodeFromTemplateJobOutputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension CreateNodeFromTemplateJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

enum CreateNodeFromTemplateJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePackageImportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case inputConfig = "InputConfig"
        case jobTags = "JobTags"
        case jobType = "JobType"
        case outputConfig = "OutputConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let inputConfig = self.inputConfig {
            try encodeContainer.encode(inputConfig, forKey: .inputConfig)
        }
        if let jobTags = jobTags {
            var jobTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .jobTags)
            for jobresourcetags0 in jobTags {
                try jobTagsContainer.encode(jobresourcetags0)
            }
        }
        if let jobType = self.jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
        if let outputConfig = self.outputConfig {
            try encodeContainer.encode(outputConfig, forKey: .outputConfig)
        }
    }
}

extension CreatePackageImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/packages/import-jobs"
    }
}

public struct CreatePackageImportJobInput: Swift.Equatable {
    /// A client token for the package import job.
    /// This member is required.
    public var clientToken: Swift.String?
    /// An input config for the package import job.
    /// This member is required.
    public var inputConfig: PanoramaClientTypes.PackageImportJobInputConfig?
    /// Tags for the package import job.
    public var jobTags: [PanoramaClientTypes.JobResourceTags]?
    /// A job type for the package import job.
    /// This member is required.
    public var jobType: PanoramaClientTypes.PackageImportJobType?
    /// An output config for the package import job.
    /// This member is required.
    public var outputConfig: PanoramaClientTypes.PackageImportJobOutputConfig?

    public init(
        clientToken: Swift.String? = nil,
        inputConfig: PanoramaClientTypes.PackageImportJobInputConfig? = nil,
        jobTags: [PanoramaClientTypes.JobResourceTags]? = nil,
        jobType: PanoramaClientTypes.PackageImportJobType? = nil,
        outputConfig: PanoramaClientTypes.PackageImportJobOutputConfig? = nil
    )
    {
        self.clientToken = clientToken
        self.inputConfig = inputConfig
        self.jobTags = jobTags
        self.jobType = jobType
        self.outputConfig = outputConfig
    }
}

struct CreatePackageImportJobInputBody: Swift.Equatable {
    let jobType: PanoramaClientTypes.PackageImportJobType?
    let inputConfig: PanoramaClientTypes.PackageImportJobInputConfig?
    let outputConfig: PanoramaClientTypes.PackageImportJobOutputConfig?
    let clientToken: Swift.String?
    let jobTags: [PanoramaClientTypes.JobResourceTags]?
}

extension CreatePackageImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case inputConfig = "InputConfig"
        case jobTags = "JobTags"
        case jobType = "JobType"
        case outputConfig = "OutputConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobTypeDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.PackageImportJobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let inputConfigDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.PackageImportJobInputConfig.self, forKey: .inputConfig)
        inputConfig = inputConfigDecoded
        let outputConfigDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.PackageImportJobOutputConfig.self, forKey: .outputConfig)
        outputConfig = outputConfigDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let jobTagsContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.JobResourceTags?].self, forKey: .jobTags)
        var jobTagsDecoded0:[PanoramaClientTypes.JobResourceTags]? = nil
        if let jobTagsContainer = jobTagsContainer {
            jobTagsDecoded0 = [PanoramaClientTypes.JobResourceTags]()
            for structure0 in jobTagsContainer {
                if let structure0 = structure0 {
                    jobTagsDecoded0?.append(structure0)
                }
            }
        }
        jobTags = jobTagsDecoded0
    }
}

extension CreatePackageImportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePackageImportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct CreatePackageImportJobOutput: Swift.Equatable {
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct CreatePackageImportJobOutputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension CreatePackageImportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

enum CreatePackageImportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePackageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case packageName = "PackageName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let packageName = self.packageName {
            try encodeContainer.encode(packageName, forKey: .packageName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreatePackageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/packages"
    }
}

public struct CreatePackageInput: Swift.Equatable {
    /// A name for the package.
    /// This member is required.
    public var packageName: Swift.String?
    /// Tags for the package.
    public var tags: [Swift.String:Swift.String]?

    public init(
        packageName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.packageName = packageName
        self.tags = tags
    }
}

struct CreatePackageInputBody: Swift.Equatable {
    let packageName: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreatePackageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case packageName = "PackageName"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePackageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePackageOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.packageId = output.packageId
            self.storageLocation = output.storageLocation
        } else {
            self.arn = nil
            self.packageId = nil
            self.storageLocation = nil
        }
    }
}

public struct CreatePackageOutput: Swift.Equatable {
    /// The package's ARN.
    public var arn: Swift.String?
    /// The package's ID.
    public var packageId: Swift.String?
    /// The package's storage location.
    /// This member is required.
    public var storageLocation: PanoramaClientTypes.StorageLocation?

    public init(
        arn: Swift.String? = nil,
        packageId: Swift.String? = nil,
        storageLocation: PanoramaClientTypes.StorageLocation? = nil
    )
    {
        self.arn = arn
        self.packageId = packageId
        self.storageLocation = storageLocation
    }
}

struct CreatePackageOutputBody: Swift.Equatable {
    let packageId: Swift.String?
    let arn: Swift.String?
    let storageLocation: PanoramaClientTypes.StorageLocation?
}

extension CreatePackageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case packageId = "PackageId"
        case storageLocation = "StorageLocation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageId)
        packageId = packageIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let storageLocationDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.StorageLocation.self, forKey: .storageLocation)
        storageLocation = storageLocationDecoded
    }
}

enum CreatePackageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let deviceId = deviceId else {
            return nil
        }
        return "/devices/\(deviceId.urlPercentEncoding())"
    }
}

public struct DeleteDeviceInput: Swift.Equatable {
    /// The device's ID.
    /// This member is required.
    public var deviceId: Swift.String?

    public init(
        deviceId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
    }
}

struct DeleteDeviceInputBody: Swift.Equatable {
}

extension DeleteDeviceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDeviceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteDeviceOutputBody = try responseDecoder.decode(responseBody: data)
            self.deviceId = output.deviceId
        } else {
            self.deviceId = nil
        }
    }
}

public struct DeleteDeviceOutput: Swift.Equatable {
    /// The device's ID.
    public var deviceId: Swift.String?

    public init(
        deviceId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
    }
}

struct DeleteDeviceOutputBody: Swift.Equatable {
    let deviceId: Swift.String?
}

extension DeleteDeviceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
    }
}

enum DeleteDeviceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePackageInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if forceDelete != false {
                let forceDeleteQueryItem = ClientRuntime.URLQueryItem(name: "ForceDelete".urlPercentEncoding(), value: Swift.String(forceDelete).urlPercentEncoding())
                items.append(forceDeleteQueryItem)
            }
            return items
        }
    }
}

extension DeletePackageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let packageId = packageId else {
            return nil
        }
        return "/packages/\(packageId.urlPercentEncoding())"
    }
}

public struct DeletePackageInput: Swift.Equatable {
    /// Delete the package even if it has artifacts stored in its access point. Deletes the package's artifacts from Amazon S3.
    public var forceDelete: Swift.Bool
    /// The package's ID.
    /// This member is required.
    public var packageId: Swift.String?

    public init(
        forceDelete: Swift.Bool = false,
        packageId: Swift.String? = nil
    )
    {
        self.forceDelete = forceDelete
        self.packageId = packageId
    }
}

struct DeletePackageInputBody: Swift.Equatable {
}

extension DeletePackageInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeletePackageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePackageOutput: Swift.Equatable {

    public init() { }
}

enum DeletePackageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeregisterPackageVersionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let updatedLatestPatchVersion = updatedLatestPatchVersion {
                let updatedLatestPatchVersionQueryItem = ClientRuntime.URLQueryItem(name: "UpdatedLatestPatchVersion".urlPercentEncoding(), value: Swift.String(updatedLatestPatchVersion).urlPercentEncoding())
                items.append(updatedLatestPatchVersionQueryItem)
            }
            if let ownerAccount = ownerAccount {
                let ownerAccountQueryItem = ClientRuntime.URLQueryItem(name: "OwnerAccount".urlPercentEncoding(), value: Swift.String(ownerAccount).urlPercentEncoding())
                items.append(ownerAccountQueryItem)
            }
            return items
        }
    }
}

extension DeregisterPackageVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let packageId = packageId else {
            return nil
        }
        guard let packageVersion = packageVersion else {
            return nil
        }
        guard let patchVersion = patchVersion else {
            return nil
        }
        return "/packages/\(packageId.urlPercentEncoding())/versions/\(packageVersion.urlPercentEncoding())/patch/\(patchVersion.urlPercentEncoding())"
    }
}

public struct DeregisterPackageVersionInput: Swift.Equatable {
    /// An owner account.
    public var ownerAccount: Swift.String?
    /// A package ID.
    /// This member is required.
    public var packageId: Swift.String?
    /// A package version.
    /// This member is required.
    public var packageVersion: Swift.String?
    /// A patch version.
    /// This member is required.
    public var patchVersion: Swift.String?
    /// If the version was marked latest, the new version to maker as latest.
    public var updatedLatestPatchVersion: Swift.String?

    public init(
        ownerAccount: Swift.String? = nil,
        packageId: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        patchVersion: Swift.String? = nil,
        updatedLatestPatchVersion: Swift.String? = nil
    )
    {
        self.ownerAccount = ownerAccount
        self.packageId = packageId
        self.packageVersion = packageVersion
        self.patchVersion = patchVersion
        self.updatedLatestPatchVersion = updatedLatestPatchVersion
    }
}

struct DeregisterPackageVersionInputBody: Swift.Equatable {
}

extension DeregisterPackageVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeregisterPackageVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeregisterPackageVersionOutput: Swift.Equatable {

    public init() { }
}

enum DeregisterPackageVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeApplicationInstanceDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationInstanceId = applicationInstanceId else {
            return nil
        }
        return "/application-instances/\(applicationInstanceId.urlPercentEncoding())/details"
    }
}

public struct DescribeApplicationInstanceDetailsInput: Swift.Equatable {
    /// The application instance's ID.
    /// This member is required.
    public var applicationInstanceId: Swift.String?

    public init(
        applicationInstanceId: Swift.String? = nil
    )
    {
        self.applicationInstanceId = applicationInstanceId
    }
}

struct DescribeApplicationInstanceDetailsInputBody: Swift.Equatable {
}

extension DescribeApplicationInstanceDetailsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeApplicationInstanceDetailsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeApplicationInstanceDetailsOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationInstanceId = output.applicationInstanceId
            self.applicationInstanceIdToReplace = output.applicationInstanceIdToReplace
            self.createdTime = output.createdTime
            self.defaultRuntimeContextDevice = output.defaultRuntimeContextDevice
            self.description = output.description
            self.manifestOverridesPayload = output.manifestOverridesPayload
            self.manifestPayload = output.manifestPayload
            self.name = output.name
        } else {
            self.applicationInstanceId = nil
            self.applicationInstanceIdToReplace = nil
            self.createdTime = nil
            self.defaultRuntimeContextDevice = nil
            self.description = nil
            self.manifestOverridesPayload = nil
            self.manifestPayload = nil
            self.name = nil
        }
    }
}

public struct DescribeApplicationInstanceDetailsOutput: Swift.Equatable {
    /// The application instance's ID.
    public var applicationInstanceId: Swift.String?
    /// The ID of the application instance that this instance replaced.
    public var applicationInstanceIdToReplace: Swift.String?
    /// When the application instance was created.
    public var createdTime: ClientRuntime.Date?
    /// The application instance's default runtime context device.
    public var defaultRuntimeContextDevice: Swift.String?
    /// The application instance's description.
    public var description: Swift.String?
    /// Parameter overrides for the configuration manifest.
    public var manifestOverridesPayload: PanoramaClientTypes.ManifestOverridesPayload?
    /// The application instance's configuration manifest.
    public var manifestPayload: PanoramaClientTypes.ManifestPayload?
    /// The application instance's name.
    public var name: Swift.String?

    public init(
        applicationInstanceId: Swift.String? = nil,
        applicationInstanceIdToReplace: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        defaultRuntimeContextDevice: Swift.String? = nil,
        description: Swift.String? = nil,
        manifestOverridesPayload: PanoramaClientTypes.ManifestOverridesPayload? = nil,
        manifestPayload: PanoramaClientTypes.ManifestPayload? = nil,
        name: Swift.String? = nil
    )
    {
        self.applicationInstanceId = applicationInstanceId
        self.applicationInstanceIdToReplace = applicationInstanceIdToReplace
        self.createdTime = createdTime
        self.defaultRuntimeContextDevice = defaultRuntimeContextDevice
        self.description = description
        self.manifestOverridesPayload = manifestOverridesPayload
        self.manifestPayload = manifestPayload
        self.name = name
    }
}

struct DescribeApplicationInstanceDetailsOutputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let defaultRuntimeContextDevice: Swift.String?
    let manifestPayload: PanoramaClientTypes.ManifestPayload?
    let manifestOverridesPayload: PanoramaClientTypes.ManifestOverridesPayload?
    let applicationInstanceIdToReplace: Swift.String?
    let createdTime: ClientRuntime.Date?
    let applicationInstanceId: Swift.String?
}

extension DescribeApplicationInstanceDetailsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationInstanceId = "ApplicationInstanceId"
        case applicationInstanceIdToReplace = "ApplicationInstanceIdToReplace"
        case createdTime = "CreatedTime"
        case defaultRuntimeContextDevice = "DefaultRuntimeContextDevice"
        case description = "Description"
        case manifestOverridesPayload = "ManifestOverridesPayload"
        case manifestPayload = "ManifestPayload"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let defaultRuntimeContextDeviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultRuntimeContextDevice)
        defaultRuntimeContextDevice = defaultRuntimeContextDeviceDecoded
        let manifestPayloadDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.ManifestPayload.self, forKey: .manifestPayload)
        manifestPayload = manifestPayloadDecoded
        let manifestOverridesPayloadDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.ManifestOverridesPayload.self, forKey: .manifestOverridesPayload)
        manifestOverridesPayload = manifestOverridesPayloadDecoded
        let applicationInstanceIdToReplaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationInstanceIdToReplace)
        applicationInstanceIdToReplace = applicationInstanceIdToReplaceDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let applicationInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationInstanceId)
        applicationInstanceId = applicationInstanceIdDecoded
    }
}

enum DescribeApplicationInstanceDetailsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeApplicationInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationInstanceId = applicationInstanceId else {
            return nil
        }
        return "/application-instances/\(applicationInstanceId.urlPercentEncoding())"
    }
}

public struct DescribeApplicationInstanceInput: Swift.Equatable {
    /// The application instance's ID.
    /// This member is required.
    public var applicationInstanceId: Swift.String?

    public init(
        applicationInstanceId: Swift.String? = nil
    )
    {
        self.applicationInstanceId = applicationInstanceId
    }
}

struct DescribeApplicationInstanceInputBody: Swift.Equatable {
}

extension DescribeApplicationInstanceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeApplicationInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeApplicationInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationInstanceId = output.applicationInstanceId
            self.applicationInstanceIdToReplace = output.applicationInstanceIdToReplace
            self.arn = output.arn
            self.createdTime = output.createdTime
            self.defaultRuntimeContextDevice = output.defaultRuntimeContextDevice
            self.defaultRuntimeContextDeviceName = output.defaultRuntimeContextDeviceName
            self.description = output.description
            self.healthStatus = output.healthStatus
            self.lastUpdatedTime = output.lastUpdatedTime
            self.name = output.name
            self.runtimeContextStates = output.runtimeContextStates
            self.runtimeRoleArn = output.runtimeRoleArn
            self.status = output.status
            self.statusDescription = output.statusDescription
            self.tags = output.tags
        } else {
            self.applicationInstanceId = nil
            self.applicationInstanceIdToReplace = nil
            self.arn = nil
            self.createdTime = nil
            self.defaultRuntimeContextDevice = nil
            self.defaultRuntimeContextDeviceName = nil
            self.description = nil
            self.healthStatus = nil
            self.lastUpdatedTime = nil
            self.name = nil
            self.runtimeContextStates = nil
            self.runtimeRoleArn = nil
            self.status = nil
            self.statusDescription = nil
            self.tags = nil
        }
    }
}

public struct DescribeApplicationInstanceOutput: Swift.Equatable {
    /// The application instance's ID.
    public var applicationInstanceId: Swift.String?
    /// The ID of the application instance that this instance replaced.
    public var applicationInstanceIdToReplace: Swift.String?
    /// The application instance's ARN.
    public var arn: Swift.String?
    /// When the application instance was created.
    public var createdTime: ClientRuntime.Date?
    /// The device's ID.
    public var defaultRuntimeContextDevice: Swift.String?
    /// The device's bane.
    public var defaultRuntimeContextDeviceName: Swift.String?
    /// The application instance's description.
    public var description: Swift.String?
    /// The application instance's health status.
    public var healthStatus: PanoramaClientTypes.ApplicationInstanceHealthStatus?
    /// The application instance was updated.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The application instance's name.
    public var name: Swift.String?
    /// The application instance's state.
    public var runtimeContextStates: [PanoramaClientTypes.ReportedRuntimeContextState]?
    /// The application instance's runtime role ARN.
    public var runtimeRoleArn: Swift.String?
    /// The application instance's status.
    public var status: PanoramaClientTypes.ApplicationInstanceStatus?
    /// The application instance's status description.
    public var statusDescription: Swift.String?
    /// The application instance's tags.
    public var tags: [Swift.String:Swift.String]?

    public init(
        applicationInstanceId: Swift.String? = nil,
        applicationInstanceIdToReplace: Swift.String? = nil,
        arn: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        defaultRuntimeContextDevice: Swift.String? = nil,
        defaultRuntimeContextDeviceName: Swift.String? = nil,
        description: Swift.String? = nil,
        healthStatus: PanoramaClientTypes.ApplicationInstanceHealthStatus? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        runtimeContextStates: [PanoramaClientTypes.ReportedRuntimeContextState]? = nil,
        runtimeRoleArn: Swift.String? = nil,
        status: PanoramaClientTypes.ApplicationInstanceStatus? = nil,
        statusDescription: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.applicationInstanceId = applicationInstanceId
        self.applicationInstanceIdToReplace = applicationInstanceIdToReplace
        self.arn = arn
        self.createdTime = createdTime
        self.defaultRuntimeContextDevice = defaultRuntimeContextDevice
        self.defaultRuntimeContextDeviceName = defaultRuntimeContextDeviceName
        self.description = description
        self.healthStatus = healthStatus
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.runtimeContextStates = runtimeContextStates
        self.runtimeRoleArn = runtimeRoleArn
        self.status = status
        self.statusDescription = statusDescription
        self.tags = tags
    }
}

struct DescribeApplicationInstanceOutputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let defaultRuntimeContextDevice: Swift.String?
    let defaultRuntimeContextDeviceName: Swift.String?
    let applicationInstanceIdToReplace: Swift.String?
    let runtimeRoleArn: Swift.String?
    let status: PanoramaClientTypes.ApplicationInstanceStatus?
    let healthStatus: PanoramaClientTypes.ApplicationInstanceHealthStatus?
    let statusDescription: Swift.String?
    let createdTime: ClientRuntime.Date?
    let lastUpdatedTime: ClientRuntime.Date?
    let applicationInstanceId: Swift.String?
    let arn: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let runtimeContextStates: [PanoramaClientTypes.ReportedRuntimeContextState]?
}

extension DescribeApplicationInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationInstanceId = "ApplicationInstanceId"
        case applicationInstanceIdToReplace = "ApplicationInstanceIdToReplace"
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case defaultRuntimeContextDevice = "DefaultRuntimeContextDevice"
        case defaultRuntimeContextDeviceName = "DefaultRuntimeContextDeviceName"
        case description = "Description"
        case healthStatus = "HealthStatus"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case runtimeContextStates = "RuntimeContextStates"
        case runtimeRoleArn = "RuntimeRoleArn"
        case status = "Status"
        case statusDescription = "StatusDescription"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let defaultRuntimeContextDeviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultRuntimeContextDevice)
        defaultRuntimeContextDevice = defaultRuntimeContextDeviceDecoded
        let defaultRuntimeContextDeviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultRuntimeContextDeviceName)
        defaultRuntimeContextDeviceName = defaultRuntimeContextDeviceNameDecoded
        let applicationInstanceIdToReplaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationInstanceIdToReplace)
        applicationInstanceIdToReplace = applicationInstanceIdToReplaceDecoded
        let runtimeRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runtimeRoleArn)
        runtimeRoleArn = runtimeRoleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.ApplicationInstanceStatus.self, forKey: .status)
        status = statusDecoded
        let healthStatusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.ApplicationInstanceHealthStatus.self, forKey: .healthStatus)
        healthStatus = healthStatusDecoded
        let statusDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDescription)
        statusDescription = statusDescriptionDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let applicationInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationInstanceId)
        applicationInstanceId = applicationInstanceIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let runtimeContextStatesContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.ReportedRuntimeContextState?].self, forKey: .runtimeContextStates)
        var runtimeContextStatesDecoded0:[PanoramaClientTypes.ReportedRuntimeContextState]? = nil
        if let runtimeContextStatesContainer = runtimeContextStatesContainer {
            runtimeContextStatesDecoded0 = [PanoramaClientTypes.ReportedRuntimeContextState]()
            for structure0 in runtimeContextStatesContainer {
                if let structure0 = structure0 {
                    runtimeContextStatesDecoded0?.append(structure0)
                }
            }
        }
        runtimeContextStates = runtimeContextStatesDecoded0
    }
}

enum DescribeApplicationInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let deviceId = deviceId else {
            return nil
        }
        return "/devices/\(deviceId.urlPercentEncoding())"
    }
}

public struct DescribeDeviceInput: Swift.Equatable {
    /// The device's ID.
    /// This member is required.
    public var deviceId: Swift.String?

    public init(
        deviceId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
    }
}

struct DescribeDeviceInputBody: Swift.Equatable {
}

extension DescribeDeviceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDeviceJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/jobs/\(jobId.urlPercentEncoding())"
    }
}

public struct DescribeDeviceJobInput: Swift.Equatable {
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeDeviceJobInputBody: Swift.Equatable {
}

extension DescribeDeviceJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDeviceJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeDeviceJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdTime = output.createdTime
            self.deviceArn = output.deviceArn
            self.deviceId = output.deviceId
            self.deviceName = output.deviceName
            self.deviceType = output.deviceType
            self.imageVersion = output.imageVersion
            self.jobId = output.jobId
            self.jobType = output.jobType
            self.status = output.status
        } else {
            self.createdTime = nil
            self.deviceArn = nil
            self.deviceId = nil
            self.deviceName = nil
            self.deviceType = nil
            self.imageVersion = nil
            self.jobId = nil
            self.jobType = nil
            self.status = nil
        }
    }
}

public struct DescribeDeviceJobOutput: Swift.Equatable {
    /// When the job was created.
    public var createdTime: ClientRuntime.Date?
    /// The device's ARN.
    public var deviceArn: Swift.String?
    /// The device's ID.
    public var deviceId: Swift.String?
    /// The device's name.
    public var deviceName: Swift.String?
    /// The device's type.
    public var deviceType: PanoramaClientTypes.DeviceType?
    /// For an OTA job, the target version of the device software.
    public var imageVersion: Swift.String?
    /// The job's ID.
    public var jobId: Swift.String?
    /// The job's type.
    public var jobType: PanoramaClientTypes.JobType?
    /// The job's status.
    public var status: PanoramaClientTypes.UpdateProgress?

    public init(
        createdTime: ClientRuntime.Date? = nil,
        deviceArn: Swift.String? = nil,
        deviceId: Swift.String? = nil,
        deviceName: Swift.String? = nil,
        deviceType: PanoramaClientTypes.DeviceType? = nil,
        imageVersion: Swift.String? = nil,
        jobId: Swift.String? = nil,
        jobType: PanoramaClientTypes.JobType? = nil,
        status: PanoramaClientTypes.UpdateProgress? = nil
    )
    {
        self.createdTime = createdTime
        self.deviceArn = deviceArn
        self.deviceId = deviceId
        self.deviceName = deviceName
        self.deviceType = deviceType
        self.imageVersion = imageVersion
        self.jobId = jobId
        self.jobType = jobType
        self.status = status
    }
}

struct DescribeDeviceJobOutputBody: Swift.Equatable {
    let jobId: Swift.String?
    let deviceId: Swift.String?
    let deviceArn: Swift.String?
    let deviceName: Swift.String?
    let deviceType: PanoramaClientTypes.DeviceType?
    let imageVersion: Swift.String?
    let status: PanoramaClientTypes.UpdateProgress?
    let createdTime: ClientRuntime.Date?
    let jobType: PanoramaClientTypes.JobType?
}

extension DescribeDeviceJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case deviceArn = "DeviceArn"
        case deviceId = "DeviceId"
        case deviceName = "DeviceName"
        case deviceType = "DeviceType"
        case imageVersion = "ImageVersion"
        case jobId = "JobId"
        case jobType = "JobType"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let deviceTypeDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.DeviceType.self, forKey: .deviceType)
        deviceType = deviceTypeDecoded
        let imageVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageVersion)
        imageVersion = imageVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.UpdateProgress.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
    }
}

enum DescribeDeviceJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeDeviceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeDeviceOutputBody = try responseDecoder.decode(responseBody: data)
            self.alternateSoftwares = output.alternateSoftwares
            self.arn = output.arn
            self.brand = output.brand
            self.createdTime = output.createdTime
            self.currentNetworkingStatus = output.currentNetworkingStatus
            self.currentSoftware = output.currentSoftware
            self.description = output.description
            self.deviceAggregatedStatus = output.deviceAggregatedStatus
            self.deviceConnectionStatus = output.deviceConnectionStatus
            self.deviceId = output.deviceId
            self.latestAlternateSoftware = output.latestAlternateSoftware
            self.latestDeviceJob = output.latestDeviceJob
            self.latestSoftware = output.latestSoftware
            self.leaseExpirationTime = output.leaseExpirationTime
            self.name = output.name
            self.networkingConfiguration = output.networkingConfiguration
            self.provisioningStatus = output.provisioningStatus
            self.serialNumber = output.serialNumber
            self.tags = output.tags
            self.type = output.type
        } else {
            self.alternateSoftwares = nil
            self.arn = nil
            self.brand = nil
            self.createdTime = nil
            self.currentNetworkingStatus = nil
            self.currentSoftware = nil
            self.description = nil
            self.deviceAggregatedStatus = nil
            self.deviceConnectionStatus = nil
            self.deviceId = nil
            self.latestAlternateSoftware = nil
            self.latestDeviceJob = nil
            self.latestSoftware = nil
            self.leaseExpirationTime = nil
            self.name = nil
            self.networkingConfiguration = nil
            self.provisioningStatus = nil
            self.serialNumber = nil
            self.tags = nil
            self.type = nil
        }
    }
}

public struct DescribeDeviceOutput: Swift.Equatable {
    /// Beta software releases available for the device.
    public var alternateSoftwares: [PanoramaClientTypes.AlternateSoftwareMetadata]?
    /// The device's ARN.
    public var arn: Swift.String?
    /// The device's maker.
    public var brand: PanoramaClientTypes.DeviceBrand?
    /// When the device was created.
    public var createdTime: ClientRuntime.Date?
    /// The device's networking status.
    public var currentNetworkingStatus: PanoramaClientTypes.NetworkStatus?
    /// The device's current software version.
    public var currentSoftware: Swift.String?
    /// The device's description.
    public var description: Swift.String?
    /// A device's aggregated status. Including the device's connection status, provisioning status, and lease status.
    public var deviceAggregatedStatus: PanoramaClientTypes.DeviceAggregatedStatus?
    /// The device's connection status.
    public var deviceConnectionStatus: PanoramaClientTypes.DeviceConnectionStatus?
    /// The device's ID.
    public var deviceId: Swift.String?
    /// The most recent beta software release.
    public var latestAlternateSoftware: Swift.String?
    /// A device's latest job. Includes the target image version, and the job status.
    public var latestDeviceJob: PanoramaClientTypes.LatestDeviceJob?
    /// The latest software version available for the device.
    public var latestSoftware: Swift.String?
    /// The device's lease expiration time.
    public var leaseExpirationTime: ClientRuntime.Date?
    /// The device's name.
    public var name: Swift.String?
    /// The device's networking configuration.
    public var networkingConfiguration: PanoramaClientTypes.NetworkPayload?
    /// The device's provisioning status.
    public var provisioningStatus: PanoramaClientTypes.DeviceStatus?
    /// The device's serial number.
    public var serialNumber: Swift.String?
    /// The device's tags.
    public var tags: [Swift.String:Swift.String]?
    /// The device's type.
    public var type: PanoramaClientTypes.DeviceType?

    public init(
        alternateSoftwares: [PanoramaClientTypes.AlternateSoftwareMetadata]? = nil,
        arn: Swift.String? = nil,
        brand: PanoramaClientTypes.DeviceBrand? = nil,
        createdTime: ClientRuntime.Date? = nil,
        currentNetworkingStatus: PanoramaClientTypes.NetworkStatus? = nil,
        currentSoftware: Swift.String? = nil,
        description: Swift.String? = nil,
        deviceAggregatedStatus: PanoramaClientTypes.DeviceAggregatedStatus? = nil,
        deviceConnectionStatus: PanoramaClientTypes.DeviceConnectionStatus? = nil,
        deviceId: Swift.String? = nil,
        latestAlternateSoftware: Swift.String? = nil,
        latestDeviceJob: PanoramaClientTypes.LatestDeviceJob? = nil,
        latestSoftware: Swift.String? = nil,
        leaseExpirationTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        networkingConfiguration: PanoramaClientTypes.NetworkPayload? = nil,
        provisioningStatus: PanoramaClientTypes.DeviceStatus? = nil,
        serialNumber: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: PanoramaClientTypes.DeviceType? = nil
    )
    {
        self.alternateSoftwares = alternateSoftwares
        self.arn = arn
        self.brand = brand
        self.createdTime = createdTime
        self.currentNetworkingStatus = currentNetworkingStatus
        self.currentSoftware = currentSoftware
        self.description = description
        self.deviceAggregatedStatus = deviceAggregatedStatus
        self.deviceConnectionStatus = deviceConnectionStatus
        self.deviceId = deviceId
        self.latestAlternateSoftware = latestAlternateSoftware
        self.latestDeviceJob = latestDeviceJob
        self.latestSoftware = latestSoftware
        self.leaseExpirationTime = leaseExpirationTime
        self.name = name
        self.networkingConfiguration = networkingConfiguration
        self.provisioningStatus = provisioningStatus
        self.serialNumber = serialNumber
        self.tags = tags
        self.type = type
    }
}

struct DescribeDeviceOutputBody: Swift.Equatable {
    let deviceId: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let description: Swift.String?
    let type: PanoramaClientTypes.DeviceType?
    let deviceConnectionStatus: PanoramaClientTypes.DeviceConnectionStatus?
    let createdTime: ClientRuntime.Date?
    let provisioningStatus: PanoramaClientTypes.DeviceStatus?
    let latestSoftware: Swift.String?
    let currentSoftware: Swift.String?
    let serialNumber: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let networkingConfiguration: PanoramaClientTypes.NetworkPayload?
    let currentNetworkingStatus: PanoramaClientTypes.NetworkStatus?
    let leaseExpirationTime: ClientRuntime.Date?
    let alternateSoftwares: [PanoramaClientTypes.AlternateSoftwareMetadata]?
    let latestAlternateSoftware: Swift.String?
    let brand: PanoramaClientTypes.DeviceBrand?
    let latestDeviceJob: PanoramaClientTypes.LatestDeviceJob?
    let deviceAggregatedStatus: PanoramaClientTypes.DeviceAggregatedStatus?
}

extension DescribeDeviceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alternateSoftwares = "AlternateSoftwares"
        case arn = "Arn"
        case brand = "Brand"
        case createdTime = "CreatedTime"
        case currentNetworkingStatus = "CurrentNetworkingStatus"
        case currentSoftware = "CurrentSoftware"
        case description = "Description"
        case deviceAggregatedStatus = "DeviceAggregatedStatus"
        case deviceConnectionStatus = "DeviceConnectionStatus"
        case deviceId = "DeviceId"
        case latestAlternateSoftware = "LatestAlternateSoftware"
        case latestDeviceJob = "LatestDeviceJob"
        case latestSoftware = "LatestSoftware"
        case leaseExpirationTime = "LeaseExpirationTime"
        case name = "Name"
        case networkingConfiguration = "NetworkingConfiguration"
        case provisioningStatus = "ProvisioningStatus"
        case serialNumber = "SerialNumber"
        case tags = "Tags"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.DeviceType.self, forKey: .type)
        type = typeDecoded
        let deviceConnectionStatusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.DeviceConnectionStatus.self, forKey: .deviceConnectionStatus)
        deviceConnectionStatus = deviceConnectionStatusDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let provisioningStatusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.DeviceStatus.self, forKey: .provisioningStatus)
        provisioningStatus = provisioningStatusDecoded
        let latestSoftwareDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestSoftware)
        latestSoftware = latestSoftwareDecoded
        let currentSoftwareDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentSoftware)
        currentSoftware = currentSoftwareDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let networkingConfigurationDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.NetworkPayload.self, forKey: .networkingConfiguration)
        networkingConfiguration = networkingConfigurationDecoded
        let currentNetworkingStatusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.NetworkStatus.self, forKey: .currentNetworkingStatus)
        currentNetworkingStatus = currentNetworkingStatusDecoded
        let leaseExpirationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .leaseExpirationTime)
        leaseExpirationTime = leaseExpirationTimeDecoded
        let alternateSoftwaresContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.AlternateSoftwareMetadata?].self, forKey: .alternateSoftwares)
        var alternateSoftwaresDecoded0:[PanoramaClientTypes.AlternateSoftwareMetadata]? = nil
        if let alternateSoftwaresContainer = alternateSoftwaresContainer {
            alternateSoftwaresDecoded0 = [PanoramaClientTypes.AlternateSoftwareMetadata]()
            for structure0 in alternateSoftwaresContainer {
                if let structure0 = structure0 {
                    alternateSoftwaresDecoded0?.append(structure0)
                }
            }
        }
        alternateSoftwares = alternateSoftwaresDecoded0
        let latestAlternateSoftwareDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestAlternateSoftware)
        latestAlternateSoftware = latestAlternateSoftwareDecoded
        let brandDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.DeviceBrand.self, forKey: .brand)
        brand = brandDecoded
        let latestDeviceJobDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.LatestDeviceJob.self, forKey: .latestDeviceJob)
        latestDeviceJob = latestDeviceJobDecoded
        let deviceAggregatedStatusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.DeviceAggregatedStatus.self, forKey: .deviceAggregatedStatus)
        deviceAggregatedStatus = deviceAggregatedStatusDecoded
    }
}

enum DescribeDeviceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeNodeFromTemplateJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/packages/template-job/\(jobId.urlPercentEncoding())"
    }
}

public struct DescribeNodeFromTemplateJobInput: Swift.Equatable {
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeNodeFromTemplateJobInputBody: Swift.Equatable {
}

extension DescribeNodeFromTemplateJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeNodeFromTemplateJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeNodeFromTemplateJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdTime = output.createdTime
            self.jobId = output.jobId
            self.jobTags = output.jobTags
            self.lastUpdatedTime = output.lastUpdatedTime
            self.nodeDescription = output.nodeDescription
            self.nodeName = output.nodeName
            self.outputPackageName = output.outputPackageName
            self.outputPackageVersion = output.outputPackageVersion
            self.status = output.status
            self.statusMessage = output.statusMessage
            self.templateParameters = output.templateParameters
            self.templateType = output.templateType
        } else {
            self.createdTime = nil
            self.jobId = nil
            self.jobTags = nil
            self.lastUpdatedTime = nil
            self.nodeDescription = nil
            self.nodeName = nil
            self.outputPackageName = nil
            self.outputPackageVersion = nil
            self.status = nil
            self.statusMessage = nil
            self.templateParameters = nil
            self.templateType = nil
        }
    }
}

public struct DescribeNodeFromTemplateJobOutput: Swift.Equatable {
    /// When the job was created.
    /// This member is required.
    public var createdTime: ClientRuntime.Date?
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?
    /// The job's tags.
    public var jobTags: [PanoramaClientTypes.JobResourceTags]?
    /// When the job was updated.
    /// This member is required.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The node's description.
    public var nodeDescription: Swift.String?
    /// The node's name.
    /// This member is required.
    public var nodeName: Swift.String?
    /// The job's output package name.
    /// This member is required.
    public var outputPackageName: Swift.String?
    /// The job's output package version.
    /// This member is required.
    public var outputPackageVersion: Swift.String?
    /// The job's status.
    /// This member is required.
    public var status: PanoramaClientTypes.NodeFromTemplateJobStatus?
    /// The job's status message.
    /// This member is required.
    public var statusMessage: Swift.String?
    /// The job's template parameters.
    /// This member is required.
    public var templateParameters: [Swift.String:Swift.String]?
    /// The job's template type.
    /// This member is required.
    public var templateType: PanoramaClientTypes.TemplateType?

    public init(
        createdTime: ClientRuntime.Date? = nil,
        jobId: Swift.String? = nil,
        jobTags: [PanoramaClientTypes.JobResourceTags]? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        nodeDescription: Swift.String? = nil,
        nodeName: Swift.String? = nil,
        outputPackageName: Swift.String? = nil,
        outputPackageVersion: Swift.String? = nil,
        status: PanoramaClientTypes.NodeFromTemplateJobStatus? = nil,
        statusMessage: Swift.String? = nil,
        templateParameters: [Swift.String:Swift.String]? = nil,
        templateType: PanoramaClientTypes.TemplateType? = nil
    )
    {
        self.createdTime = createdTime
        self.jobId = jobId
        self.jobTags = jobTags
        self.lastUpdatedTime = lastUpdatedTime
        self.nodeDescription = nodeDescription
        self.nodeName = nodeName
        self.outputPackageName = outputPackageName
        self.outputPackageVersion = outputPackageVersion
        self.status = status
        self.statusMessage = statusMessage
        self.templateParameters = templateParameters
        self.templateType = templateType
    }
}

struct DescribeNodeFromTemplateJobOutputBody: Swift.Equatable {
    let jobId: Swift.String?
    let status: PanoramaClientTypes.NodeFromTemplateJobStatus?
    let statusMessage: Swift.String?
    let createdTime: ClientRuntime.Date?
    let lastUpdatedTime: ClientRuntime.Date?
    let outputPackageName: Swift.String?
    let outputPackageVersion: Swift.String?
    let nodeName: Swift.String?
    let nodeDescription: Swift.String?
    let templateType: PanoramaClientTypes.TemplateType?
    let templateParameters: [Swift.String:Swift.String]?
    let jobTags: [PanoramaClientTypes.JobResourceTags]?
}

extension DescribeNodeFromTemplateJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case jobId = "JobId"
        case jobTags = "JobTags"
        case lastUpdatedTime = "LastUpdatedTime"
        case nodeDescription = "NodeDescription"
        case nodeName = "NodeName"
        case outputPackageName = "OutputPackageName"
        case outputPackageVersion = "OutputPackageVersion"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case templateParameters = "TemplateParameters"
        case templateType = "TemplateType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.NodeFromTemplateJobStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let outputPackageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputPackageName)
        outputPackageName = outputPackageNameDecoded
        let outputPackageVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputPackageVersion)
        outputPackageVersion = outputPackageVersionDecoded
        let nodeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeName)
        nodeName = nodeNameDecoded
        let nodeDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeDescription)
        nodeDescription = nodeDescriptionDecoded
        let templateTypeDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.TemplateType.self, forKey: .templateType)
        templateType = templateTypeDecoded
        let templateParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .templateParameters)
        var templateParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let templateParametersContainer = templateParametersContainer {
            templateParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, templatevalue0) in templateParametersContainer {
                if let templatevalue0 = templatevalue0 {
                    templateParametersDecoded0?[key0] = templatevalue0
                }
            }
        }
        templateParameters = templateParametersDecoded0
        let jobTagsContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.JobResourceTags?].self, forKey: .jobTags)
        var jobTagsDecoded0:[PanoramaClientTypes.JobResourceTags]? = nil
        if let jobTagsContainer = jobTagsContainer {
            jobTagsDecoded0 = [PanoramaClientTypes.JobResourceTags]()
            for structure0 in jobTagsContainer {
                if let structure0 = structure0 {
                    jobTagsDecoded0?.append(structure0)
                }
            }
        }
        jobTags = jobTagsDecoded0
    }
}

enum DescribeNodeFromTemplateJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeNodeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let ownerAccount = ownerAccount {
                let ownerAccountQueryItem = ClientRuntime.URLQueryItem(name: "OwnerAccount".urlPercentEncoding(), value: Swift.String(ownerAccount).urlPercentEncoding())
                items.append(ownerAccountQueryItem)
            }
            return items
        }
    }
}

extension DescribeNodeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let nodeId = nodeId else {
            return nil
        }
        return "/nodes/\(nodeId.urlPercentEncoding())"
    }
}

public struct DescribeNodeInput: Swift.Equatable {
    /// The node's ID.
    /// This member is required.
    public var nodeId: Swift.String?
    /// The account ID of the node's owner.
    public var ownerAccount: Swift.String?

    public init(
        nodeId: Swift.String? = nil,
        ownerAccount: Swift.String? = nil
    )
    {
        self.nodeId = nodeId
        self.ownerAccount = ownerAccount
    }
}

struct DescribeNodeInputBody: Swift.Equatable {
}

extension DescribeNodeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeNodeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeNodeOutputBody = try responseDecoder.decode(responseBody: data)
            self.assetName = output.assetName
            self.category = output.category
            self.createdTime = output.createdTime
            self.description = output.description
            self.lastUpdatedTime = output.lastUpdatedTime
            self.name = output.name
            self.nodeId = output.nodeId
            self.nodeInterface = output.nodeInterface
            self.ownerAccount = output.ownerAccount
            self.packageArn = output.packageArn
            self.packageId = output.packageId
            self.packageName = output.packageName
            self.packageVersion = output.packageVersion
            self.patchVersion = output.patchVersion
        } else {
            self.assetName = nil
            self.category = nil
            self.createdTime = nil
            self.description = nil
            self.lastUpdatedTime = nil
            self.name = nil
            self.nodeId = nil
            self.nodeInterface = nil
            self.ownerAccount = nil
            self.packageArn = nil
            self.packageId = nil
            self.packageName = nil
            self.packageVersion = nil
            self.patchVersion = nil
        }
    }
}

public struct DescribeNodeOutput: Swift.Equatable {
    /// The node's asset name.
    public var assetName: Swift.String?
    /// The node's category.
    /// This member is required.
    public var category: PanoramaClientTypes.NodeCategory?
    /// When the node was created.
    /// This member is required.
    public var createdTime: ClientRuntime.Date?
    /// The node's description.
    /// This member is required.
    public var description: Swift.String?
    /// When the node was updated.
    /// This member is required.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The node's name.
    /// This member is required.
    public var name: Swift.String?
    /// The node's ID.
    /// This member is required.
    public var nodeId: Swift.String?
    /// The node's interface.
    /// This member is required.
    public var nodeInterface: PanoramaClientTypes.NodeInterface?
    /// The account ID of the node's owner.
    /// This member is required.
    public var ownerAccount: Swift.String?
    /// The node's ARN.
    public var packageArn: Swift.String?
    /// The node's package ID.
    /// This member is required.
    public var packageId: Swift.String?
    /// The node's package name.
    /// This member is required.
    public var packageName: Swift.String?
    /// The node's package version.
    /// This member is required.
    public var packageVersion: Swift.String?
    /// The node's patch version.
    /// This member is required.
    public var patchVersion: Swift.String?

    public init(
        assetName: Swift.String? = nil,
        category: PanoramaClientTypes.NodeCategory? = nil,
        createdTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        nodeId: Swift.String? = nil,
        nodeInterface: PanoramaClientTypes.NodeInterface? = nil,
        ownerAccount: Swift.String? = nil,
        packageArn: Swift.String? = nil,
        packageId: Swift.String? = nil,
        packageName: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        patchVersion: Swift.String? = nil
    )
    {
        self.assetName = assetName
        self.category = category
        self.createdTime = createdTime
        self.description = description
        self.lastUpdatedTime = lastUpdatedTime
        self.name = name
        self.nodeId = nodeId
        self.nodeInterface = nodeInterface
        self.ownerAccount = ownerAccount
        self.packageArn = packageArn
        self.packageId = packageId
        self.packageName = packageName
        self.packageVersion = packageVersion
        self.patchVersion = patchVersion
    }
}

struct DescribeNodeOutputBody: Swift.Equatable {
    let nodeId: Swift.String?
    let name: Swift.String?
    let category: PanoramaClientTypes.NodeCategory?
    let ownerAccount: Swift.String?
    let packageName: Swift.String?
    let packageId: Swift.String?
    let packageArn: Swift.String?
    let packageVersion: Swift.String?
    let patchVersion: Swift.String?
    let nodeInterface: PanoramaClientTypes.NodeInterface?
    let assetName: Swift.String?
    let description: Swift.String?
    let createdTime: ClientRuntime.Date?
    let lastUpdatedTime: ClientRuntime.Date?
}

extension DescribeNodeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetName = "AssetName"
        case category = "Category"
        case createdTime = "CreatedTime"
        case description = "Description"
        case lastUpdatedTime = "LastUpdatedTime"
        case name = "Name"
        case nodeId = "NodeId"
        case nodeInterface = "NodeInterface"
        case ownerAccount = "OwnerAccount"
        case packageArn = "PackageArn"
        case packageId = "PackageId"
        case packageName = "PackageName"
        case packageVersion = "PackageVersion"
        case patchVersion = "PatchVersion"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeId)
        nodeId = nodeIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.NodeCategory.self, forKey: .category)
        category = categoryDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let packageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageId)
        packageId = packageIdDecoded
        let packageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageArn)
        packageArn = packageArnDecoded
        let packageVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageVersion)
        packageVersion = packageVersionDecoded
        let patchVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchVersion)
        patchVersion = patchVersionDecoded
        let nodeInterfaceDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.NodeInterface.self, forKey: .nodeInterface)
        nodeInterface = nodeInterfaceDecoded
        let assetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetName)
        assetName = assetNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

enum DescribeNodeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribePackageImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/packages/import-jobs/\(jobId.urlPercentEncoding())"
    }
}

public struct DescribePackageImportJobInput: Swift.Equatable {
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribePackageImportJobInputBody: Swift.Equatable {
}

extension DescribePackageImportJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribePackageImportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribePackageImportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.createdTime = output.createdTime
            self.inputConfig = output.inputConfig
            self.jobId = output.jobId
            self.jobTags = output.jobTags
            self.jobType = output.jobType
            self.lastUpdatedTime = output.lastUpdatedTime
            self.output = output.output
            self.outputConfig = output.outputConfig
            self.status = output.status
            self.statusMessage = output.statusMessage
        } else {
            self.clientToken = nil
            self.createdTime = nil
            self.inputConfig = nil
            self.jobId = nil
            self.jobTags = nil
            self.jobType = nil
            self.lastUpdatedTime = nil
            self.output = nil
            self.outputConfig = nil
            self.status = nil
            self.statusMessage = nil
        }
    }
}

public struct DescribePackageImportJobOutput: Swift.Equatable {
    /// The job's client token.
    public var clientToken: Swift.String?
    /// When the job was created.
    /// This member is required.
    public var createdTime: ClientRuntime.Date?
    /// The job's input config.
    /// This member is required.
    public var inputConfig: PanoramaClientTypes.PackageImportJobInputConfig?
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?
    /// The job's tags.
    public var jobTags: [PanoramaClientTypes.JobResourceTags]?
    /// The job's type.
    /// This member is required.
    public var jobType: PanoramaClientTypes.PackageImportJobType?
    /// When the job was updated.
    /// This member is required.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The job's output.
    /// This member is required.
    public var output: PanoramaClientTypes.PackageImportJobOutput?
    /// The job's output config.
    /// This member is required.
    public var outputConfig: PanoramaClientTypes.PackageImportJobOutputConfig?
    /// The job's status.
    /// This member is required.
    public var status: PanoramaClientTypes.PackageImportJobStatus?
    /// The job's status message.
    /// This member is required.
    public var statusMessage: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        inputConfig: PanoramaClientTypes.PackageImportJobInputConfig? = nil,
        jobId: Swift.String? = nil,
        jobTags: [PanoramaClientTypes.JobResourceTags]? = nil,
        jobType: PanoramaClientTypes.PackageImportJobType? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        output: PanoramaClientTypes.PackageImportJobOutput? = nil,
        outputConfig: PanoramaClientTypes.PackageImportJobOutputConfig? = nil,
        status: PanoramaClientTypes.PackageImportJobStatus? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.createdTime = createdTime
        self.inputConfig = inputConfig
        self.jobId = jobId
        self.jobTags = jobTags
        self.jobType = jobType
        self.lastUpdatedTime = lastUpdatedTime
        self.output = output
        self.outputConfig = outputConfig
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct DescribePackageImportJobOutputBody: Swift.Equatable {
    let jobId: Swift.String?
    let clientToken: Swift.String?
    let jobType: PanoramaClientTypes.PackageImportJobType?
    let inputConfig: PanoramaClientTypes.PackageImportJobInputConfig?
    let outputConfig: PanoramaClientTypes.PackageImportJobOutputConfig?
    let output: PanoramaClientTypes.PackageImportJobOutput?
    let createdTime: ClientRuntime.Date?
    let lastUpdatedTime: ClientRuntime.Date?
    let status: PanoramaClientTypes.PackageImportJobStatus?
    let statusMessage: Swift.String?
    let jobTags: [PanoramaClientTypes.JobResourceTags]?
}

extension DescribePackageImportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case createdTime = "CreatedTime"
        case inputConfig = "InputConfig"
        case jobId = "JobId"
        case jobTags = "JobTags"
        case jobType = "JobType"
        case lastUpdatedTime = "LastUpdatedTime"
        case output = "Output"
        case outputConfig = "OutputConfig"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.PackageImportJobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let inputConfigDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.PackageImportJobInputConfig.self, forKey: .inputConfig)
        inputConfig = inputConfigDecoded
        let outputConfigDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.PackageImportJobOutputConfig.self, forKey: .outputConfig)
        outputConfig = outputConfigDecoded
        let outputDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.PackageImportJobOutput.self, forKey: .output)
        output = outputDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.PackageImportJobStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let jobTagsContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.JobResourceTags?].self, forKey: .jobTags)
        var jobTagsDecoded0:[PanoramaClientTypes.JobResourceTags]? = nil
        if let jobTagsContainer = jobTagsContainer {
            jobTagsDecoded0 = [PanoramaClientTypes.JobResourceTags]()
            for structure0 in jobTagsContainer {
                if let structure0 = structure0 {
                    jobTagsDecoded0?.append(structure0)
                }
            }
        }
        jobTags = jobTagsDecoded0
    }
}

enum DescribePackageImportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribePackageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let packageId = packageId else {
            return nil
        }
        return "/packages/metadata/\(packageId.urlPercentEncoding())"
    }
}

public struct DescribePackageInput: Swift.Equatable {
    /// The package's ID.
    /// This member is required.
    public var packageId: Swift.String?

    public init(
        packageId: Swift.String? = nil
    )
    {
        self.packageId = packageId
    }
}

struct DescribePackageInputBody: Swift.Equatable {
}

extension DescribePackageInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribePackageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribePackageOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdTime = output.createdTime
            self.packageId = output.packageId
            self.packageName = output.packageName
            self.readAccessPrincipalArns = output.readAccessPrincipalArns
            self.storageLocation = output.storageLocation
            self.tags = output.tags
            self.writeAccessPrincipalArns = output.writeAccessPrincipalArns
        } else {
            self.arn = nil
            self.createdTime = nil
            self.packageId = nil
            self.packageName = nil
            self.readAccessPrincipalArns = nil
            self.storageLocation = nil
            self.tags = nil
            self.writeAccessPrincipalArns = nil
        }
    }
}

public struct DescribePackageOutput: Swift.Equatable {
    /// The package's ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// When the package was created.
    /// This member is required.
    public var createdTime: ClientRuntime.Date?
    /// The package's ID.
    /// This member is required.
    public var packageId: Swift.String?
    /// The package's name.
    /// This member is required.
    public var packageName: Swift.String?
    /// ARNs of accounts that have read access to the package.
    public var readAccessPrincipalArns: [Swift.String]?
    /// The package's storage location.
    /// This member is required.
    public var storageLocation: PanoramaClientTypes.StorageLocation?
    /// The package's tags.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?
    /// ARNs of accounts that have write access to the package.
    public var writeAccessPrincipalArns: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        createdTime: ClientRuntime.Date? = nil,
        packageId: Swift.String? = nil,
        packageName: Swift.String? = nil,
        readAccessPrincipalArns: [Swift.String]? = nil,
        storageLocation: PanoramaClientTypes.StorageLocation? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        writeAccessPrincipalArns: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.packageId = packageId
        self.packageName = packageName
        self.readAccessPrincipalArns = readAccessPrincipalArns
        self.storageLocation = storageLocation
        self.tags = tags
        self.writeAccessPrincipalArns = writeAccessPrincipalArns
    }
}

struct DescribePackageOutputBody: Swift.Equatable {
    let packageId: Swift.String?
    let packageName: Swift.String?
    let arn: Swift.String?
    let storageLocation: PanoramaClientTypes.StorageLocation?
    let readAccessPrincipalArns: [Swift.String]?
    let writeAccessPrincipalArns: [Swift.String]?
    let createdTime: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension DescribePackageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case packageId = "PackageId"
        case packageName = "PackageName"
        case readAccessPrincipalArns = "ReadAccessPrincipalArns"
        case storageLocation = "StorageLocation"
        case tags = "Tags"
        case writeAccessPrincipalArns = "WriteAccessPrincipalArns"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageId)
        packageId = packageIdDecoded
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let storageLocationDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.StorageLocation.self, forKey: .storageLocation)
        storageLocation = storageLocationDecoded
        let readAccessPrincipalArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .readAccessPrincipalArns)
        var readAccessPrincipalArnsDecoded0:[Swift.String]? = nil
        if let readAccessPrincipalArnsContainer = readAccessPrincipalArnsContainer {
            readAccessPrincipalArnsDecoded0 = [Swift.String]()
            for string0 in readAccessPrincipalArnsContainer {
                if let string0 = string0 {
                    readAccessPrincipalArnsDecoded0?.append(string0)
                }
            }
        }
        readAccessPrincipalArns = readAccessPrincipalArnsDecoded0
        let writeAccessPrincipalArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .writeAccessPrincipalArns)
        var writeAccessPrincipalArnsDecoded0:[Swift.String]? = nil
        if let writeAccessPrincipalArnsContainer = writeAccessPrincipalArnsContainer {
            writeAccessPrincipalArnsDecoded0 = [Swift.String]()
            for string0 in writeAccessPrincipalArnsContainer {
                if let string0 = string0 {
                    writeAccessPrincipalArnsDecoded0?.append(string0)
                }
            }
        }
        writeAccessPrincipalArns = writeAccessPrincipalArnsDecoded0
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum DescribePackageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribePackageVersionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let patchVersion = patchVersion {
                let patchVersionQueryItem = ClientRuntime.URLQueryItem(name: "PatchVersion".urlPercentEncoding(), value: Swift.String(patchVersion).urlPercentEncoding())
                items.append(patchVersionQueryItem)
            }
            if let ownerAccount = ownerAccount {
                let ownerAccountQueryItem = ClientRuntime.URLQueryItem(name: "OwnerAccount".urlPercentEncoding(), value: Swift.String(ownerAccount).urlPercentEncoding())
                items.append(ownerAccountQueryItem)
            }
            return items
        }
    }
}

extension DescribePackageVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let packageId = packageId else {
            return nil
        }
        guard let packageVersion = packageVersion else {
            return nil
        }
        return "/packages/metadata/\(packageId.urlPercentEncoding())/versions/\(packageVersion.urlPercentEncoding())"
    }
}

public struct DescribePackageVersionInput: Swift.Equatable {
    /// The version's owner account.
    public var ownerAccount: Swift.String?
    /// The version's ID.
    /// This member is required.
    public var packageId: Swift.String?
    /// The version's version.
    /// This member is required.
    public var packageVersion: Swift.String?
    /// The version's patch version.
    public var patchVersion: Swift.String?

    public init(
        ownerAccount: Swift.String? = nil,
        packageId: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        patchVersion: Swift.String? = nil
    )
    {
        self.ownerAccount = ownerAccount
        self.packageId = packageId
        self.packageVersion = packageVersion
        self.patchVersion = patchVersion
    }
}

struct DescribePackageVersionInputBody: Swift.Equatable {
}

extension DescribePackageVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribePackageVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribePackageVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.isLatestPatch = output.isLatestPatch
            self.ownerAccount = output.ownerAccount
            self.packageArn = output.packageArn
            self.packageId = output.packageId
            self.packageName = output.packageName
            self.packageVersion = output.packageVersion
            self.patchVersion = output.patchVersion
            self.registeredTime = output.registeredTime
            self.status = output.status
            self.statusDescription = output.statusDescription
        } else {
            self.isLatestPatch = false
            self.ownerAccount = nil
            self.packageArn = nil
            self.packageId = nil
            self.packageName = nil
            self.packageVersion = nil
            self.patchVersion = nil
            self.registeredTime = nil
            self.status = nil
            self.statusDescription = nil
        }
    }
}

public struct DescribePackageVersionOutput: Swift.Equatable {
    /// Whether the version is the latest available.
    /// This member is required.
    public var isLatestPatch: Swift.Bool
    /// The account ID of the version's owner.
    public var ownerAccount: Swift.String?
    /// The ARN of the package.
    public var packageArn: Swift.String?
    /// The version's ID.
    /// This member is required.
    public var packageId: Swift.String?
    /// The version's name.
    /// This member is required.
    public var packageName: Swift.String?
    /// The version's version.
    /// This member is required.
    public var packageVersion: Swift.String?
    /// The version's patch version.
    /// This member is required.
    public var patchVersion: Swift.String?
    /// The version's registered time.
    public var registeredTime: ClientRuntime.Date?
    /// The version's status.
    /// This member is required.
    public var status: PanoramaClientTypes.PackageVersionStatus?
    /// The version's status description.
    public var statusDescription: Swift.String?

    public init(
        isLatestPatch: Swift.Bool = false,
        ownerAccount: Swift.String? = nil,
        packageArn: Swift.String? = nil,
        packageId: Swift.String? = nil,
        packageName: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        patchVersion: Swift.String? = nil,
        registeredTime: ClientRuntime.Date? = nil,
        status: PanoramaClientTypes.PackageVersionStatus? = nil,
        statusDescription: Swift.String? = nil
    )
    {
        self.isLatestPatch = isLatestPatch
        self.ownerAccount = ownerAccount
        self.packageArn = packageArn
        self.packageId = packageId
        self.packageName = packageName
        self.packageVersion = packageVersion
        self.patchVersion = patchVersion
        self.registeredTime = registeredTime
        self.status = status
        self.statusDescription = statusDescription
    }
}

struct DescribePackageVersionOutputBody: Swift.Equatable {
    let ownerAccount: Swift.String?
    let packageId: Swift.String?
    let packageArn: Swift.String?
    let packageName: Swift.String?
    let packageVersion: Swift.String?
    let patchVersion: Swift.String?
    let isLatestPatch: Swift.Bool
    let status: PanoramaClientTypes.PackageVersionStatus?
    let statusDescription: Swift.String?
    let registeredTime: ClientRuntime.Date?
}

extension DescribePackageVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isLatestPatch = "IsLatestPatch"
        case ownerAccount = "OwnerAccount"
        case packageArn = "PackageArn"
        case packageId = "PackageId"
        case packageName = "PackageName"
        case packageVersion = "PackageVersion"
        case patchVersion = "PatchVersion"
        case registeredTime = "RegisteredTime"
        case status = "Status"
        case statusDescription = "StatusDescription"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let packageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageId)
        packageId = packageIdDecoded
        let packageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageArn)
        packageArn = packageArnDecoded
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let packageVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageVersion)
        packageVersion = packageVersionDecoded
        let patchVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchVersion)
        patchVersion = patchVersionDecoded
        let isLatestPatchDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isLatestPatch) ?? false
        isLatestPatch = isLatestPatchDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.PackageVersionStatus.self, forKey: .status)
        status = statusDecoded
        let statusDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDescription)
        statusDescription = statusDescriptionDecoded
        let registeredTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .registeredTime)
        registeredTime = registeredTimeDecoded
    }
}

enum DescribePackageVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PanoramaClientTypes {
    public enum DesiredState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case removed
        case running
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [DesiredState] {
            return [
                .removed,
                .running,
                .stopped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .removed: return "REMOVED"
            case .running: return "RUNNING"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DesiredState(rawValue: rawValue) ?? DesiredState.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes.Device: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case brand = "Brand"
        case createdTime = "CreatedTime"
        case currentSoftware = "CurrentSoftware"
        case description = "Description"
        case deviceAggregatedStatus = "DeviceAggregatedStatus"
        case deviceId = "DeviceId"
        case lastUpdatedTime = "LastUpdatedTime"
        case latestDeviceJob = "LatestDeviceJob"
        case leaseExpirationTime = "LeaseExpirationTime"
        case name = "Name"
        case provisioningStatus = "ProvisioningStatus"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let brand = self.brand {
            try encodeContainer.encode(brand.rawValue, forKey: .brand)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let currentSoftware = self.currentSoftware {
            try encodeContainer.encode(currentSoftware, forKey: .currentSoftware)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceAggregatedStatus = self.deviceAggregatedStatus {
            try encodeContainer.encode(deviceAggregatedStatus.rawValue, forKey: .deviceAggregatedStatus)
        }
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let latestDeviceJob = self.latestDeviceJob {
            try encodeContainer.encode(latestDeviceJob, forKey: .latestDeviceJob)
        }
        if let leaseExpirationTime = self.leaseExpirationTime {
            try encodeContainer.encodeTimestamp(leaseExpirationTime, format: .epochSeconds, forKey: .leaseExpirationTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let provisioningStatus = self.provisioningStatus {
            try encodeContainer.encode(provisioningStatus.rawValue, forKey: .provisioningStatus)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let provisioningStatusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.DeviceStatus.self, forKey: .provisioningStatus)
        provisioningStatus = provisioningStatusDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let leaseExpirationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .leaseExpirationTime)
        leaseExpirationTime = leaseExpirationTimeDecoded
        let brandDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.DeviceBrand.self, forKey: .brand)
        brand = brandDecoded
        let currentSoftwareDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentSoftware)
        currentSoftware = currentSoftwareDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.DeviceType.self, forKey: .type)
        type = typeDecoded
        let latestDeviceJobDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.LatestDeviceJob.self, forKey: .latestDeviceJob)
        latestDeviceJob = latestDeviceJobDecoded
        let deviceAggregatedStatusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.DeviceAggregatedStatus.self, forKey: .deviceAggregatedStatus)
        deviceAggregatedStatus = deviceAggregatedStatusDecoded
    }
}

extension PanoramaClientTypes {
    /// A device.
    public struct Device: Swift.Equatable {
        /// The device's maker.
        public var brand: PanoramaClientTypes.DeviceBrand?
        /// When the device was created.
        public var createdTime: ClientRuntime.Date?
        /// A device's current software.
        public var currentSoftware: Swift.String?
        /// A description for the device.
        public var description: Swift.String?
        /// A device's aggregated status. Including the device's connection status, provisioning status, and lease status.
        public var deviceAggregatedStatus: PanoramaClientTypes.DeviceAggregatedStatus?
        /// The device's ID.
        public var deviceId: Swift.String?
        /// When the device was updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// A device's latest job. Includes the target image version, and the update job status.
        public var latestDeviceJob: PanoramaClientTypes.LatestDeviceJob?
        /// The device's lease expiration time.
        public var leaseExpirationTime: ClientRuntime.Date?
        /// The device's name.
        public var name: Swift.String?
        /// The device's provisioning status.
        public var provisioningStatus: PanoramaClientTypes.DeviceStatus?
        /// The device's tags.
        public var tags: [Swift.String:Swift.String]?
        /// The device's type.
        public var type: PanoramaClientTypes.DeviceType?

        public init(
            brand: PanoramaClientTypes.DeviceBrand? = nil,
            createdTime: ClientRuntime.Date? = nil,
            currentSoftware: Swift.String? = nil,
            description: Swift.String? = nil,
            deviceAggregatedStatus: PanoramaClientTypes.DeviceAggregatedStatus? = nil,
            deviceId: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            latestDeviceJob: PanoramaClientTypes.LatestDeviceJob? = nil,
            leaseExpirationTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            provisioningStatus: PanoramaClientTypes.DeviceStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: PanoramaClientTypes.DeviceType? = nil
        )
        {
            self.brand = brand
            self.createdTime = createdTime
            self.currentSoftware = currentSoftware
            self.description = description
            self.deviceAggregatedStatus = deviceAggregatedStatus
            self.deviceId = deviceId
            self.lastUpdatedTime = lastUpdatedTime
            self.latestDeviceJob = latestDeviceJob
            self.leaseExpirationTime = leaseExpirationTime
            self.name = name
            self.provisioningStatus = provisioningStatus
            self.tags = tags
            self.type = type
        }
    }

}

extension PanoramaClientTypes {
    public enum DeviceAggregatedStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awaitingProvisioning
        case deleting
        case error
        case failed
        case leaseExpired
        case offline
        case online
        case pending
        case rebooting
        case updateNeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceAggregatedStatus] {
            return [
                .awaitingProvisioning,
                .deleting,
                .error,
                .failed,
                .leaseExpired,
                .offline,
                .online,
                .pending,
                .rebooting,
                .updateNeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awaitingProvisioning: return "AWAITING_PROVISIONING"
            case .deleting: return "DELETING"
            case .error: return "ERROR"
            case .failed: return "FAILED"
            case .leaseExpired: return "LEASE_EXPIRED"
            case .offline: return "OFFLINE"
            case .online: return "ONLINE"
            case .pending: return "PENDING"
            case .rebooting: return "REBOOTING"
            case .updateNeeded: return "UPDATE_NEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceAggregatedStatus(rawValue: rawValue) ?? DeviceAggregatedStatus.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes {
    public enum DeviceBrand: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsPanorama
        case lenovo
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceBrand] {
            return [
                .awsPanorama,
                .lenovo,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsPanorama: return "AWS_PANORAMA"
            case .lenovo: return "LENOVO"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceBrand(rawValue: rawValue) ?? DeviceBrand.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes {
    public enum DeviceConnectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awaitingCredentials
        case error
        case notAvailable
        case offline
        case online
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceConnectionStatus] {
            return [
                .awaitingCredentials,
                .error,
                .notAvailable,
                .offline,
                .online,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awaitingCredentials: return "AWAITING_CREDENTIALS"
            case .error: return "ERROR"
            case .notAvailable: return "NOT_AVAILABLE"
            case .offline: return "OFFLINE"
            case .online: return "ONLINE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceConnectionStatus(rawValue: rawValue) ?? DeviceConnectionStatus.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes.DeviceJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case deviceId = "DeviceId"
        case deviceName = "DeviceName"
        case jobId = "JobId"
        case jobType = "JobType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let deviceName = self.deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobType = self.jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
    }
}

extension PanoramaClientTypes {
    /// A job that runs on a device.
    public struct DeviceJob: Swift.Equatable {
        /// When the job was created.
        public var createdTime: ClientRuntime.Date?
        /// The ID of the target device.
        public var deviceId: Swift.String?
        /// The name of the target device
        public var deviceName: Swift.String?
        /// The job's ID.
        public var jobId: Swift.String?
        /// The job's type.
        public var jobType: PanoramaClientTypes.JobType?

        public init(
            createdTime: ClientRuntime.Date? = nil,
            deviceId: Swift.String? = nil,
            deviceName: Swift.String? = nil,
            jobId: Swift.String? = nil,
            jobType: PanoramaClientTypes.JobType? = nil
        )
        {
            self.createdTime = createdTime
            self.deviceId = deviceId
            self.deviceName = deviceName
            self.jobId = jobId
            self.jobType = jobType
        }
    }

}

extension PanoramaClientTypes.DeviceJobConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case otaJobConfig = "OTAJobConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let otaJobConfig = self.otaJobConfig {
            try encodeContainer.encode(otaJobConfig, forKey: .otaJobConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let otaJobConfigDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.OTAJobConfig.self, forKey: .otaJobConfig)
        otaJobConfig = otaJobConfigDecoded
    }
}

extension PanoramaClientTypes {
    /// A job's configuration.
    public struct DeviceJobConfig: Swift.Equatable {
        /// A configuration for an over-the-air (OTA) upgrade. Required for OTA jobs.
        public var otaJobConfig: PanoramaClientTypes.OTAJobConfig?

        public init(
            otaJobConfig: PanoramaClientTypes.OTAJobConfig? = nil
        )
        {
            self.otaJobConfig = otaJobConfig
        }
    }

}

extension PanoramaClientTypes {
    public enum DeviceReportedStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case installError
        case installInProgress
        case launched
        case launchError
        case removalFailed
        case removalInProgress
        case running
        case starting
        case stopped
        case stopping
        case stopError
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceReportedStatus] {
            return [
                .installError,
                .installInProgress,
                .launched,
                .launchError,
                .removalFailed,
                .removalInProgress,
                .running,
                .starting,
                .stopped,
                .stopping,
                .stopError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .installError: return "INSTALL_ERROR"
            case .installInProgress: return "INSTALL_IN_PROGRESS"
            case .launched: return "LAUNCHED"
            case .launchError: return "LAUNCH_ERROR"
            case .removalFailed: return "REMOVAL_FAILED"
            case .removalInProgress: return "REMOVAL_IN_PROGRESS"
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .stopError: return "STOP_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceReportedStatus(rawValue: rawValue) ?? DeviceReportedStatus.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes {
    public enum DeviceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awaitingProvisioning
        case deleting
        case error
        case failed
        case pending
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceStatus] {
            return [
                .awaitingProvisioning,
                .deleting,
                .error,
                .failed,
                .pending,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awaitingProvisioning: return "AWAITING_PROVISIONING"
            case .deleting: return "DELETING"
            case .error: return "ERROR"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceStatus(rawValue: rawValue) ?? DeviceStatus.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes {
    public enum DeviceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case panoramaAppliance
        case panoramaApplianceDeveloperKit
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceType] {
            return [
                .panoramaAppliance,
                .panoramaApplianceDeveloperKit,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .panoramaAppliance: return "PANORAMA_APPLIANCE"
            case .panoramaApplianceDeveloperKit: return "PANORAMA_APPLIANCE_DEVELOPER_KIT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceType(rawValue: rawValue) ?? DeviceType.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes.EthernetPayload: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionType = "ConnectionType"
        case staticIpConnectionInfo = "StaticIpConnectionInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionType = self.connectionType {
            try encodeContainer.encode(connectionType.rawValue, forKey: .connectionType)
        }
        if let staticIpConnectionInfo = self.staticIpConnectionInfo {
            try encodeContainer.encode(staticIpConnectionInfo, forKey: .staticIpConnectionInfo)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionTypeDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let staticIpConnectionInfoDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.StaticIpConnectionInfo.self, forKey: .staticIpConnectionInfo)
        staticIpConnectionInfo = staticIpConnectionInfoDecoded
    }
}

extension PanoramaClientTypes {
    /// A device's network configuration.
    public struct EthernetPayload: Swift.Equatable {
        /// How the device gets an IP address.
        /// This member is required.
        public var connectionType: PanoramaClientTypes.ConnectionType?
        /// Network configuration for a static IP connection.
        public var staticIpConnectionInfo: PanoramaClientTypes.StaticIpConnectionInfo?

        public init(
            connectionType: PanoramaClientTypes.ConnectionType? = nil,
            staticIpConnectionInfo: PanoramaClientTypes.StaticIpConnectionInfo? = nil
        )
        {
            self.connectionType = connectionType
            self.staticIpConnectionInfo = staticIpConnectionInfo
        }
    }

}

extension PanoramaClientTypes.EthernetStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionStatus = "ConnectionStatus"
        case hwAddress = "HwAddress"
        case ipAddress = "IpAddress"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionStatus = self.connectionStatus {
            try encodeContainer.encode(connectionStatus.rawValue, forKey: .connectionStatus)
        }
        if let hwAddress = self.hwAddress {
            try encodeContainer.encode(hwAddress, forKey: .hwAddress)
        }
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let connectionStatusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.NetworkConnectionStatus.self, forKey: .connectionStatus)
        connectionStatus = connectionStatusDecoded
        let hwAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hwAddress)
        hwAddress = hwAddressDecoded
    }
}

extension PanoramaClientTypes {
    /// A device's Ethernet status.
    public struct EthernetStatus: Swift.Equatable {
        /// The device's connection status.
        public var connectionStatus: PanoramaClientTypes.NetworkConnectionStatus?
        /// The device's physical address.
        public var hwAddress: Swift.String?
        /// The device's IP address.
        public var ipAddress: Swift.String?

        public init(
            connectionStatus: PanoramaClientTypes.NetworkConnectionStatus? = nil,
            hwAddress: Swift.String? = nil,
            ipAddress: Swift.String? = nil
        )
        {
            self.connectionStatus = connectionStatus
            self.hwAddress = hwAddress
            self.ipAddress = ipAddress
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = 0
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An internal error occurred.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The number of seconds a client should wait before retrying the call.
        public internal(set) var retryAfterSeconds: Swift.Int = 0
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PanoramaClientTypes.Job: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = self.deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
    }
}

extension PanoramaClientTypes {
    /// A job for a device.
    public struct Job: Swift.Equatable {
        /// The target device's ID.
        public var deviceId: Swift.String?
        /// The job's ID.
        public var jobId: Swift.String?

        public init(
            deviceId: Swift.String? = nil,
            jobId: Swift.String? = nil
        )
        {
            self.deviceId = deviceId
            self.jobId = jobId
        }
    }

}

extension PanoramaClientTypes.JobResourceTags: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceType = "ResourceType"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.JobResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PanoramaClientTypes {
    /// Tags for a job.
    public struct JobResourceTags: Swift.Equatable {
        /// The job's type.
        /// This member is required.
        public var resourceType: PanoramaClientTypes.JobResourceType?
        /// The job's tags.
        /// This member is required.
        public var tags: [Swift.String:Swift.String]?

        public init(
            resourceType: PanoramaClientTypes.JobResourceType? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.resourceType = resourceType
            self.tags = tags
        }
    }

}

extension PanoramaClientTypes {
    public enum JobResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case package
        case sdkUnknown(Swift.String)

        public static var allCases: [JobResourceType] {
            return [
                .package,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .package: return "PACKAGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobResourceType(rawValue: rawValue) ?? JobResourceType.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes {
    public enum JobType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ota
        case reboot
        case sdkUnknown(Swift.String)

        public static var allCases: [JobType] {
            return [
                .ota,
                .reboot,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ota: return "OTA"
            case .reboot: return "REBOOT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobType(rawValue: rawValue) ?? JobType.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes.LatestDeviceJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageVersion = "ImageVersion"
        case jobType = "JobType"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageVersion = self.imageVersion {
            try encodeContainer.encode(imageVersion, forKey: .imageVersion)
        }
        if let jobType = self.jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageVersion)
        imageVersion = imageVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.UpdateProgress.self, forKey: .status)
        status = statusDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
    }
}

extension PanoramaClientTypes {
    /// Returns information about the latest device job.
    public struct LatestDeviceJob: Swift.Equatable {
        /// The target version of the device software.
        public var imageVersion: Swift.String?
        /// The job's type.
        public var jobType: PanoramaClientTypes.JobType?
        /// Status of the latest device job.
        public var status: PanoramaClientTypes.UpdateProgress?

        public init(
            imageVersion: Swift.String? = nil,
            jobType: PanoramaClientTypes.JobType? = nil,
            status: PanoramaClientTypes.UpdateProgress? = nil
        )
        {
            self.imageVersion = imageVersion
            self.jobType = jobType
            self.status = status
        }
    }

}

extension ListApplicationInstanceDependenciesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListApplicationInstanceDependenciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationInstanceId = applicationInstanceId else {
            return nil
        }
        return "/application-instances/\(applicationInstanceId.urlPercentEncoding())/package-dependencies"
    }
}

public struct ListApplicationInstanceDependenciesInput: Swift.Equatable {
    /// The application instance's ID.
    /// This member is required.
    public var applicationInstanceId: Swift.String?
    /// The maximum number of application instance dependencies to return in one page of results.
    public var maxResults: Swift.Int
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        applicationInstanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationInstanceId = applicationInstanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApplicationInstanceDependenciesInputBody: Swift.Equatable {
}

extension ListApplicationInstanceDependenciesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListApplicationInstanceDependenciesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListApplicationInstanceDependenciesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.packageObjects = output.packageObjects
        } else {
            self.nextToken = nil
            self.packageObjects = nil
        }
    }
}

public struct ListApplicationInstanceDependenciesOutput: Swift.Equatable {
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of package objects.
    public var packageObjects: [PanoramaClientTypes.PackageObject]?

    public init(
        nextToken: Swift.String? = nil,
        packageObjects: [PanoramaClientTypes.PackageObject]? = nil
    )
    {
        self.nextToken = nextToken
        self.packageObjects = packageObjects
    }
}

struct ListApplicationInstanceDependenciesOutputBody: Swift.Equatable {
    let packageObjects: [PanoramaClientTypes.PackageObject]?
    let nextToken: Swift.String?
}

extension ListApplicationInstanceDependenciesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case packageObjects = "PackageObjects"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageObjectsContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.PackageObject?].self, forKey: .packageObjects)
        var packageObjectsDecoded0:[PanoramaClientTypes.PackageObject]? = nil
        if let packageObjectsContainer = packageObjectsContainer {
            packageObjectsDecoded0 = [PanoramaClientTypes.PackageObject]()
            for structure0 in packageObjectsContainer {
                if let structure0 = structure0 {
                    packageObjectsDecoded0?.append(structure0)
                }
            }
        }
        packageObjects = packageObjectsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListApplicationInstanceDependenciesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListApplicationInstanceNodeInstancesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListApplicationInstanceNodeInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationInstanceId = applicationInstanceId else {
            return nil
        }
        return "/application-instances/\(applicationInstanceId.urlPercentEncoding())/node-instances"
    }
}

public struct ListApplicationInstanceNodeInstancesInput: Swift.Equatable {
    /// The node instances' application instance ID.
    /// This member is required.
    public var applicationInstanceId: Swift.String?
    /// The maximum number of node instances to return in one page of results.
    public var maxResults: Swift.Int
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        applicationInstanceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationInstanceId = applicationInstanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApplicationInstanceNodeInstancesInputBody: Swift.Equatable {
}

extension ListApplicationInstanceNodeInstancesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListApplicationInstanceNodeInstancesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListApplicationInstanceNodeInstancesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.nodeInstances = output.nodeInstances
        } else {
            self.nextToken = nil
            self.nodeInstances = nil
        }
    }
}

public struct ListApplicationInstanceNodeInstancesOutput: Swift.Equatable {
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of node instances.
    public var nodeInstances: [PanoramaClientTypes.NodeInstance]?

    public init(
        nextToken: Swift.String? = nil,
        nodeInstances: [PanoramaClientTypes.NodeInstance]? = nil
    )
    {
        self.nextToken = nextToken
        self.nodeInstances = nodeInstances
    }
}

struct ListApplicationInstanceNodeInstancesOutputBody: Swift.Equatable {
    let nodeInstances: [PanoramaClientTypes.NodeInstance]?
    let nextToken: Swift.String?
}

extension ListApplicationInstanceNodeInstancesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case nodeInstances = "NodeInstances"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeInstancesContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.NodeInstance?].self, forKey: .nodeInstances)
        var nodeInstancesDecoded0:[PanoramaClientTypes.NodeInstance]? = nil
        if let nodeInstancesContainer = nodeInstancesContainer {
            nodeInstancesDecoded0 = [PanoramaClientTypes.NodeInstance]()
            for structure0 in nodeInstancesContainer {
                if let structure0 = structure0 {
                    nodeInstancesDecoded0?.append(structure0)
                }
            }
        }
        nodeInstances = nodeInstancesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListApplicationInstanceNodeInstancesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListApplicationInstancesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let deviceId = deviceId {
                let deviceIdQueryItem = ClientRuntime.URLQueryItem(name: "deviceId".urlPercentEncoding(), value: Swift.String(deviceId).urlPercentEncoding())
                items.append(deviceIdQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let statusFilter = statusFilter {
                let statusFilterQueryItem = ClientRuntime.URLQueryItem(name: "statusFilter".urlPercentEncoding(), value: Swift.String(statusFilter.rawValue).urlPercentEncoding())
                items.append(statusFilterQueryItem)
            }
            return items
        }
    }
}

extension ListApplicationInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/application-instances"
    }
}

public struct ListApplicationInstancesInput: Swift.Equatable {
    /// The application instances' device ID.
    public var deviceId: Swift.String?
    /// The maximum number of application instances to return in one page of results.
    public var maxResults: Swift.Int
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// Only include instances with a specific status.
    public var statusFilter: PanoramaClientTypes.StatusFilter?

    public init(
        deviceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        statusFilter: PanoramaClientTypes.StatusFilter? = nil
    )
    {
        self.deviceId = deviceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.statusFilter = statusFilter
    }
}

struct ListApplicationInstancesInputBody: Swift.Equatable {
}

extension ListApplicationInstancesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListApplicationInstancesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListApplicationInstancesOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationInstances = output.applicationInstances
            self.nextToken = output.nextToken
        } else {
            self.applicationInstances = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationInstancesOutput: Swift.Equatable {
    /// A list of application instances.
    public var applicationInstances: [PanoramaClientTypes.ApplicationInstance]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init(
        applicationInstances: [PanoramaClientTypes.ApplicationInstance]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationInstances = applicationInstances
        self.nextToken = nextToken
    }
}

struct ListApplicationInstancesOutputBody: Swift.Equatable {
    let applicationInstances: [PanoramaClientTypes.ApplicationInstance]?
    let nextToken: Swift.String?
}

extension ListApplicationInstancesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationInstances = "ApplicationInstances"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationInstancesContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.ApplicationInstance?].self, forKey: .applicationInstances)
        var applicationInstancesDecoded0:[PanoramaClientTypes.ApplicationInstance]? = nil
        if let applicationInstancesContainer = applicationInstancesContainer {
            applicationInstancesDecoded0 = [PanoramaClientTypes.ApplicationInstance]()
            for structure0 in applicationInstancesContainer {
                if let structure0 = structure0 {
                    applicationInstancesDecoded0?.append(structure0)
                }
            }
        }
        applicationInstances = applicationInstancesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListApplicationInstancesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDevicesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nameFilter = nameFilter {
                let nameFilterQueryItem = ClientRuntime.URLQueryItem(name: "NameFilter".urlPercentEncoding(), value: Swift.String(nameFilter).urlPercentEncoding())
                items.append(nameFilterQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let sortBy = sortBy {
                let sortByQueryItem = ClientRuntime.URLQueryItem(name: "SortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
                items.append(sortByQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let sortOrder = sortOrder {
                let sortOrderQueryItem = ClientRuntime.URLQueryItem(name: "SortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
                items.append(sortOrderQueryItem)
            }
            if let deviceAggregatedStatusFilter = deviceAggregatedStatusFilter {
                let deviceAggregatedStatusFilterQueryItem = ClientRuntime.URLQueryItem(name: "DeviceAggregatedStatusFilter".urlPercentEncoding(), value: Swift.String(deviceAggregatedStatusFilter.rawValue).urlPercentEncoding())
                items.append(deviceAggregatedStatusFilterQueryItem)
            }
            return items
        }
    }
}

extension ListDevicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/devices"
    }
}

public struct ListDevicesInput: Swift.Equatable {
    /// Filter based on a device's status.
    public var deviceAggregatedStatusFilter: PanoramaClientTypes.DeviceAggregatedStatus?
    /// The maximum number of devices to return in one page of results.
    public var maxResults: Swift.Int
    /// Filter based on device's name. Prefixes supported.
    public var nameFilter: Swift.String?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The target column to be sorted on. Default column sort is CREATED_TIME.
    public var sortBy: PanoramaClientTypes.ListDevicesSortBy?
    /// The sorting order for the returned list. SortOrder is DESCENDING by default based on CREATED_TIME. Otherwise, SortOrder is ASCENDING.
    public var sortOrder: PanoramaClientTypes.SortOrder?

    public init(
        deviceAggregatedStatusFilter: PanoramaClientTypes.DeviceAggregatedStatus? = nil,
        maxResults: Swift.Int = 0,
        nameFilter: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sortBy: PanoramaClientTypes.ListDevicesSortBy? = nil,
        sortOrder: PanoramaClientTypes.SortOrder? = nil
    )
    {
        self.deviceAggregatedStatusFilter = deviceAggregatedStatusFilter
        self.maxResults = maxResults
        self.nameFilter = nameFilter
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

struct ListDevicesInputBody: Swift.Equatable {
}

extension ListDevicesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDevicesJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let deviceId = deviceId {
                let deviceIdQueryItem = ClientRuntime.URLQueryItem(name: "DeviceId".urlPercentEncoding(), value: Swift.String(deviceId).urlPercentEncoding())
                items.append(deviceIdQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDevicesJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/jobs"
    }
}

public struct ListDevicesJobsInput: Swift.Equatable {
    /// Filter results by the job's target device ID.
    public var deviceId: Swift.String?
    /// The maximum number of device jobs to return in one page of results.
    public var maxResults: Swift.Int
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        deviceId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDevicesJobsInputBody: Swift.Equatable {
}

extension ListDevicesJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDevicesJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDevicesJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.deviceJobs = output.deviceJobs
            self.nextToken = output.nextToken
        } else {
            self.deviceJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListDevicesJobsOutput: Swift.Equatable {
    /// A list of jobs.
    public var deviceJobs: [PanoramaClientTypes.DeviceJob]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init(
        deviceJobs: [PanoramaClientTypes.DeviceJob]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceJobs = deviceJobs
        self.nextToken = nextToken
    }
}

struct ListDevicesJobsOutputBody: Swift.Equatable {
    let deviceJobs: [PanoramaClientTypes.DeviceJob]?
    let nextToken: Swift.String?
}

extension ListDevicesJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceJobs = "DeviceJobs"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceJobsContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.DeviceJob?].self, forKey: .deviceJobs)
        var deviceJobsDecoded0:[PanoramaClientTypes.DeviceJob]? = nil
        if let deviceJobsContainer = deviceJobsContainer {
            deviceJobsDecoded0 = [PanoramaClientTypes.DeviceJob]()
            for structure0 in deviceJobsContainer {
                if let structure0 = structure0 {
                    deviceJobsDecoded0?.append(structure0)
                }
            }
        }
        deviceJobs = deviceJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDevicesJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDevicesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDevicesOutputBody = try responseDecoder.decode(responseBody: data)
            self.devices = output.devices
            self.nextToken = output.nextToken
        } else {
            self.devices = nil
            self.nextToken = nil
        }
    }
}

public struct ListDevicesOutput: Swift.Equatable {
    /// A list of devices.
    /// This member is required.
    public var devices: [PanoramaClientTypes.Device]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init(
        devices: [PanoramaClientTypes.Device]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.devices = devices
        self.nextToken = nextToken
    }
}

struct ListDevicesOutputBody: Swift.Equatable {
    let devices: [PanoramaClientTypes.Device]?
    let nextToken: Swift.String?
}

extension ListDevicesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devices = "Devices"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicesContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.Device?].self, forKey: .devices)
        var devicesDecoded0:[PanoramaClientTypes.Device]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [PanoramaClientTypes.Device]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDevicesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PanoramaClientTypes {
    public enum ListDevicesSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createdTime
        case deviceAggregatedStatus
        case deviceId
        case name
        case sdkUnknown(Swift.String)

        public static var allCases: [ListDevicesSortBy] {
            return [
                .createdTime,
                .deviceAggregatedStatus,
                .deviceId,
                .name,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createdTime: return "CREATED_TIME"
            case .deviceAggregatedStatus: return "DEVICE_AGGREGATED_STATUS"
            case .deviceId: return "DEVICE_ID"
            case .name: return "NAME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ListDevicesSortBy(rawValue: rawValue) ?? ListDevicesSortBy.sdkUnknown(rawValue)
        }
    }
}

extension ListNodeFromTemplateJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListNodeFromTemplateJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/packages/template-job"
    }
}

public struct ListNodeFromTemplateJobsInput: Swift.Equatable {
    /// The maximum number of node from template jobs to return in one page of results.
    public var maxResults: Swift.Int
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListNodeFromTemplateJobsInputBody: Swift.Equatable {
}

extension ListNodeFromTemplateJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListNodeFromTemplateJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListNodeFromTemplateJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.nodeFromTemplateJobs = output.nodeFromTemplateJobs
        } else {
            self.nextToken = nil
            self.nodeFromTemplateJobs = nil
        }
    }
}

public struct ListNodeFromTemplateJobsOutput: Swift.Equatable {
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of jobs.
    /// This member is required.
    public var nodeFromTemplateJobs: [PanoramaClientTypes.NodeFromTemplateJob]?

    public init(
        nextToken: Swift.String? = nil,
        nodeFromTemplateJobs: [PanoramaClientTypes.NodeFromTemplateJob]? = nil
    )
    {
        self.nextToken = nextToken
        self.nodeFromTemplateJobs = nodeFromTemplateJobs
    }
}

struct ListNodeFromTemplateJobsOutputBody: Swift.Equatable {
    let nodeFromTemplateJobs: [PanoramaClientTypes.NodeFromTemplateJob]?
    let nextToken: Swift.String?
}

extension ListNodeFromTemplateJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case nodeFromTemplateJobs = "NodeFromTemplateJobs"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeFromTemplateJobsContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.NodeFromTemplateJob?].self, forKey: .nodeFromTemplateJobs)
        var nodeFromTemplateJobsDecoded0:[PanoramaClientTypes.NodeFromTemplateJob]? = nil
        if let nodeFromTemplateJobsContainer = nodeFromTemplateJobsContainer {
            nodeFromTemplateJobsDecoded0 = [PanoramaClientTypes.NodeFromTemplateJob]()
            for structure0 in nodeFromTemplateJobsContainer {
                if let structure0 = structure0 {
                    nodeFromTemplateJobsDecoded0?.append(structure0)
                }
            }
        }
        nodeFromTemplateJobs = nodeFromTemplateJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListNodeFromTemplateJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListNodesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let patchVersion = patchVersion {
                let patchVersionQueryItem = ClientRuntime.URLQueryItem(name: "patchVersion".urlPercentEncoding(), value: Swift.String(patchVersion).urlPercentEncoding())
                items.append(patchVersionQueryItem)
            }
            if let category = category {
                let categoryQueryItem = ClientRuntime.URLQueryItem(name: "category".urlPercentEncoding(), value: Swift.String(category.rawValue).urlPercentEncoding())
                items.append(categoryQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let packageName = packageName {
                let packageNameQueryItem = ClientRuntime.URLQueryItem(name: "packageName".urlPercentEncoding(), value: Swift.String(packageName).urlPercentEncoding())
                items.append(packageNameQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let ownerAccount = ownerAccount {
                let ownerAccountQueryItem = ClientRuntime.URLQueryItem(name: "ownerAccount".urlPercentEncoding(), value: Swift.String(ownerAccount).urlPercentEncoding())
                items.append(ownerAccountQueryItem)
            }
            if let packageVersion = packageVersion {
                let packageVersionQueryItem = ClientRuntime.URLQueryItem(name: "packageVersion".urlPercentEncoding(), value: Swift.String(packageVersion).urlPercentEncoding())
                items.append(packageVersionQueryItem)
            }
            return items
        }
    }
}

extension ListNodesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/nodes"
    }
}

public struct ListNodesInput: Swift.Equatable {
    /// Search for nodes by category.
    public var category: PanoramaClientTypes.NodeCategory?
    /// The maximum number of nodes to return in one page of results.
    public var maxResults: Swift.Int
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// Search for nodes by the account ID of the nodes' owner.
    public var ownerAccount: Swift.String?
    /// Search for nodes by name.
    public var packageName: Swift.String?
    /// Search for nodes by version.
    public var packageVersion: Swift.String?
    /// Search for nodes by patch version.
    public var patchVersion: Swift.String?

    public init(
        category: PanoramaClientTypes.NodeCategory? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        ownerAccount: Swift.String? = nil,
        packageName: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        patchVersion: Swift.String? = nil
    )
    {
        self.category = category
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.ownerAccount = ownerAccount
        self.packageName = packageName
        self.packageVersion = packageVersion
        self.patchVersion = patchVersion
    }
}

struct ListNodesInputBody: Swift.Equatable {
}

extension ListNodesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListNodesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListNodesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.nodes = output.nodes
        } else {
            self.nextToken = nil
            self.nodes = nil
        }
    }
}

public struct ListNodesOutput: Swift.Equatable {
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of nodes.
    public var nodes: [PanoramaClientTypes.Node]?

    public init(
        nextToken: Swift.String? = nil,
        nodes: [PanoramaClientTypes.Node]? = nil
    )
    {
        self.nextToken = nextToken
        self.nodes = nodes
    }
}

struct ListNodesOutputBody: Swift.Equatable {
    let nodes: [PanoramaClientTypes.Node]?
    let nextToken: Swift.String?
}

extension ListNodesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case nodes = "Nodes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodesContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.Node?].self, forKey: .nodes)
        var nodesDecoded0:[PanoramaClientTypes.Node]? = nil
        if let nodesContainer = nodesContainer {
            nodesDecoded0 = [PanoramaClientTypes.Node]()
            for structure0 in nodesContainer {
                if let structure0 = structure0 {
                    nodesDecoded0?.append(structure0)
                }
            }
        }
        nodes = nodesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListNodesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPackageImportJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListPackageImportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/packages/import-jobs"
    }
}

public struct ListPackageImportJobsInput: Swift.Equatable {
    /// The maximum number of package import jobs to return in one page of results.
    public var maxResults: Swift.Int
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPackageImportJobsInputBody: Swift.Equatable {
}

extension ListPackageImportJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPackageImportJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPackageImportJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.packageImportJobs = output.packageImportJobs
        } else {
            self.nextToken = nil
            self.packageImportJobs = nil
        }
    }
}

public struct ListPackageImportJobsOutput: Swift.Equatable {
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of package import jobs.
    /// This member is required.
    public var packageImportJobs: [PanoramaClientTypes.PackageImportJob]?

    public init(
        nextToken: Swift.String? = nil,
        packageImportJobs: [PanoramaClientTypes.PackageImportJob]? = nil
    )
    {
        self.nextToken = nextToken
        self.packageImportJobs = packageImportJobs
    }
}

struct ListPackageImportJobsOutputBody: Swift.Equatable {
    let packageImportJobs: [PanoramaClientTypes.PackageImportJob]?
    let nextToken: Swift.String?
}

extension ListPackageImportJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case packageImportJobs = "PackageImportJobs"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageImportJobsContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.PackageImportJob?].self, forKey: .packageImportJobs)
        var packageImportJobsDecoded0:[PanoramaClientTypes.PackageImportJob]? = nil
        if let packageImportJobsContainer = packageImportJobsContainer {
            packageImportJobsDecoded0 = [PanoramaClientTypes.PackageImportJob]()
            for structure0 in packageImportJobsContainer {
                if let structure0 = structure0 {
                    packageImportJobsDecoded0?.append(structure0)
                }
            }
        }
        packageImportJobs = packageImportJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPackageImportJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPackagesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListPackagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/packages"
    }
}

public struct ListPackagesInput: Swift.Equatable {
    /// The maximum number of packages to return in one page of results.
    public var maxResults: Swift.Int
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPackagesInputBody: Swift.Equatable {
}

extension ListPackagesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPackagesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPackagesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.packages = output.packages
        } else {
            self.nextToken = nil
            self.packages = nil
        }
    }
}

public struct ListPackagesOutput: Swift.Equatable {
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of packages.
    public var packages: [PanoramaClientTypes.PackageListItem]?

    public init(
        nextToken: Swift.String? = nil,
        packages: [PanoramaClientTypes.PackageListItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.packages = packages
    }
}

struct ListPackagesOutputBody: Swift.Equatable {
    let packages: [PanoramaClientTypes.PackageListItem]?
    let nextToken: Swift.String?
}

extension ListPackagesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case packages = "Packages"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packagesContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.PackageListItem?].self, forKey: .packages)
        var packagesDecoded0:[PanoramaClientTypes.PackageListItem]? = nil
        if let packagesContainer = packagesContainer {
            packagesDecoded0 = [PanoramaClientTypes.PackageListItem]()
            for structure0 in packagesContainer {
                if let structure0 = structure0 {
                    packagesDecoded0?.append(structure0)
                }
            }
        }
        packages = packagesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPackagesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The resource's ARN.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A list of tags.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PanoramaClientTypes.ManifestOverridesPayload: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payloaddata = "PayloadData"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .payloaddata(payloaddata):
                try container.encode(payloaddata, forKey: .payloaddata)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let payloaddataDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .payloaddata)
        if let payloaddata = payloaddataDecoded {
            self = .payloaddata(payloaddata)
            return
        }
        self = .sdkUnknown("")
    }
}

extension PanoramaClientTypes {
    /// Parameter overrides for an application instance. This is a JSON document that has a single key (PayloadData) where the value is an escaped string representation of the overrides document.
    public enum ManifestOverridesPayload: Swift.Equatable {
        /// The overrides document.
        case payloaddata(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension PanoramaClientTypes.ManifestPayload: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payloaddata = "PayloadData"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .payloaddata(payloaddata):
                try container.encode(payloaddata, forKey: .payloaddata)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let payloaddataDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .payloaddata)
        if let payloaddata = payloaddataDecoded {
            self = .payloaddata(payloaddata)
            return
        }
        self = .sdkUnknown("")
    }
}

extension PanoramaClientTypes {
    /// A application verion's manifest file. This is a JSON document that has a single key (PayloadData) where the value is an escaped string representation of the application manifest (graph.json). This file is located in the graphs folder in your application source.
    public enum ManifestPayload: Swift.Equatable {
        /// The application manifest.
        case payloaddata(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension PanoramaClientTypes {
    public enum NetworkConnectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connected
        case connecting
        case notConnected
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkConnectionStatus] {
            return [
                .connected,
                .connecting,
                .notConnected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connected: return "CONNECTED"
            case .connecting: return "CONNECTING"
            case .notConnected: return "NOT_CONNECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkConnectionStatus(rawValue: rawValue) ?? NetworkConnectionStatus.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes.NetworkPayload: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ethernet0 = "Ethernet0"
        case ethernet1 = "Ethernet1"
        case ntp = "Ntp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ethernet0 = self.ethernet0 {
            try encodeContainer.encode(ethernet0, forKey: .ethernet0)
        }
        if let ethernet1 = self.ethernet1 {
            try encodeContainer.encode(ethernet1, forKey: .ethernet1)
        }
        if let ntp = self.ntp {
            try encodeContainer.encode(ntp, forKey: .ntp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ethernet0Decoded = try containerValues.decodeIfPresent(PanoramaClientTypes.EthernetPayload.self, forKey: .ethernet0)
        ethernet0 = ethernet0Decoded
        let ethernet1Decoded = try containerValues.decodeIfPresent(PanoramaClientTypes.EthernetPayload.self, forKey: .ethernet1)
        ethernet1 = ethernet1Decoded
        let ntpDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.NtpPayload.self, forKey: .ntp)
        ntp = ntpDecoded
    }
}

extension PanoramaClientTypes {
    /// The network configuration for a device.
    public struct NetworkPayload: Swift.Equatable {
        /// Settings for Ethernet port 0.
        public var ethernet0: PanoramaClientTypes.EthernetPayload?
        /// Settings for Ethernet port 1.
        public var ethernet1: PanoramaClientTypes.EthernetPayload?
        /// Network time protocol (NTP) server settings.
        public var ntp: PanoramaClientTypes.NtpPayload?

        public init(
            ethernet0: PanoramaClientTypes.EthernetPayload? = nil,
            ethernet1: PanoramaClientTypes.EthernetPayload? = nil,
            ntp: PanoramaClientTypes.NtpPayload? = nil
        )
        {
            self.ethernet0 = ethernet0
            self.ethernet1 = ethernet1
            self.ntp = ntp
        }
    }

}

extension PanoramaClientTypes.NetworkStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ethernet0Status = "Ethernet0Status"
        case ethernet1Status = "Ethernet1Status"
        case lastUpdatedTime = "LastUpdatedTime"
        case ntpStatus = "NtpStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ethernet0Status = self.ethernet0Status {
            try encodeContainer.encode(ethernet0Status, forKey: .ethernet0Status)
        }
        if let ethernet1Status = self.ethernet1Status {
            try encodeContainer.encode(ethernet1Status, forKey: .ethernet1Status)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let ntpStatus = self.ntpStatus {
            try encodeContainer.encode(ntpStatus, forKey: .ntpStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ethernet0StatusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.EthernetStatus.self, forKey: .ethernet0Status)
        ethernet0Status = ethernet0StatusDecoded
        let ethernet1StatusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.EthernetStatus.self, forKey: .ethernet1Status)
        ethernet1Status = ethernet1StatusDecoded
        let ntpStatusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.NtpStatus.self, forKey: .ntpStatus)
        ntpStatus = ntpStatusDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension PanoramaClientTypes {
    /// The network status of a device.
    public struct NetworkStatus: Swift.Equatable {
        /// The status of Ethernet port 0.
        public var ethernet0Status: PanoramaClientTypes.EthernetStatus?
        /// The status of Ethernet port 1.
        public var ethernet1Status: PanoramaClientTypes.EthernetStatus?
        /// When the network status changed.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// Details about a network time protocol (NTP) server connection.
        public var ntpStatus: PanoramaClientTypes.NtpStatus?

        public init(
            ethernet0Status: PanoramaClientTypes.EthernetStatus? = nil,
            ethernet1Status: PanoramaClientTypes.EthernetStatus? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            ntpStatus: PanoramaClientTypes.NtpStatus? = nil
        )
        {
            self.ethernet0Status = ethernet0Status
            self.ethernet1Status = ethernet1Status
            self.lastUpdatedTime = lastUpdatedTime
            self.ntpStatus = ntpStatus
        }
    }

}

extension PanoramaClientTypes.Node: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case category = "Category"
        case createdTime = "CreatedTime"
        case description = "Description"
        case name = "Name"
        case nodeId = "NodeId"
        case ownerAccount = "OwnerAccount"
        case packageArn = "PackageArn"
        case packageId = "PackageId"
        case packageName = "PackageName"
        case packageVersion = "PackageVersion"
        case patchVersion = "PatchVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = self.category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nodeId = self.nodeId {
            try encodeContainer.encode(nodeId, forKey: .nodeId)
        }
        if let ownerAccount = self.ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
        if let packageArn = self.packageArn {
            try encodeContainer.encode(packageArn, forKey: .packageArn)
        }
        if let packageId = self.packageId {
            try encodeContainer.encode(packageId, forKey: .packageId)
        }
        if let packageName = self.packageName {
            try encodeContainer.encode(packageName, forKey: .packageName)
        }
        if let packageVersion = self.packageVersion {
            try encodeContainer.encode(packageVersion, forKey: .packageVersion)
        }
        if let patchVersion = self.patchVersion {
            try encodeContainer.encode(patchVersion, forKey: .patchVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeId)
        nodeId = nodeIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.NodeCategory.self, forKey: .category)
        category = categoryDecoded
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let packageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageId)
        packageId = packageIdDecoded
        let packageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageArn)
        packageArn = packageArnDecoded
        let packageVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageVersion)
        packageVersion = packageVersionDecoded
        let patchVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchVersion)
        patchVersion = patchVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension PanoramaClientTypes {
    /// An application node that represents a camera stream, a model, code, or output.
    public struct Node: Swift.Equatable {
        /// The node's category.
        /// This member is required.
        public var category: PanoramaClientTypes.NodeCategory?
        /// When the node was created.
        /// This member is required.
        public var createdTime: ClientRuntime.Date?
        /// The node's description.
        public var description: Swift.String?
        /// The node's name.
        /// This member is required.
        public var name: Swift.String?
        /// The node's ID.
        /// This member is required.
        public var nodeId: Swift.String?
        /// The account ID of the node's owner.
        public var ownerAccount: Swift.String?
        /// The node's ARN.
        public var packageArn: Swift.String?
        /// The node's package ID.
        /// This member is required.
        public var packageId: Swift.String?
        /// The node's package name.
        /// This member is required.
        public var packageName: Swift.String?
        /// The node's package version.
        /// This member is required.
        public var packageVersion: Swift.String?
        /// The node's patch version.
        /// This member is required.
        public var patchVersion: Swift.String?

        public init(
            category: PanoramaClientTypes.NodeCategory? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            nodeId: Swift.String? = nil,
            ownerAccount: Swift.String? = nil,
            packageArn: Swift.String? = nil,
            packageId: Swift.String? = nil,
            packageName: Swift.String? = nil,
            packageVersion: Swift.String? = nil,
            patchVersion: Swift.String? = nil
        )
        {
            self.category = category
            self.createdTime = createdTime
            self.description = description
            self.name = name
            self.nodeId = nodeId
            self.ownerAccount = ownerAccount
            self.packageArn = packageArn
            self.packageId = packageId
            self.packageName = packageName
            self.packageVersion = packageVersion
            self.patchVersion = patchVersion
        }
    }

}

extension PanoramaClientTypes {
    public enum NodeCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case businessLogic
        case mediaSink
        case mediaSource
        case mlModel
        case sdkUnknown(Swift.String)

        public static var allCases: [NodeCategory] {
            return [
                .businessLogic,
                .mediaSink,
                .mediaSource,
                .mlModel,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .businessLogic: return "BUSINESS_LOGIC"
            case .mediaSink: return "MEDIA_SINK"
            case .mediaSource: return "MEDIA_SOURCE"
            case .mlModel: return "ML_MODEL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NodeCategory(rawValue: rawValue) ?? NodeCategory.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes.NodeFromTemplateJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case jobId = "JobId"
        case nodeName = "NodeName"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case templateType = "TemplateType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let nodeName = self.nodeName {
            try encodeContainer.encode(nodeName, forKey: .nodeName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let templateType = self.templateType {
            try encodeContainer.encode(templateType.rawValue, forKey: .templateType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let templateTypeDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.TemplateType.self, forKey: .templateType)
        templateType = templateTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.NodeFromTemplateJobStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let nodeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeName)
        nodeName = nodeNameDecoded
    }
}

extension PanoramaClientTypes {
    /// A job to create a camera stream node.
    public struct NodeFromTemplateJob: Swift.Equatable {
        /// When the job was created.
        public var createdTime: ClientRuntime.Date?
        /// The job's ID.
        public var jobId: Swift.String?
        /// The node's name.
        public var nodeName: Swift.String?
        /// The job's status.
        public var status: PanoramaClientTypes.NodeFromTemplateJobStatus?
        /// The job's status message.
        public var statusMessage: Swift.String?
        /// The job's template type.
        public var templateType: PanoramaClientTypes.TemplateType?

        public init(
            createdTime: ClientRuntime.Date? = nil,
            jobId: Swift.String? = nil,
            nodeName: Swift.String? = nil,
            status: PanoramaClientTypes.NodeFromTemplateJobStatus? = nil,
            statusMessage: Swift.String? = nil,
            templateType: PanoramaClientTypes.TemplateType? = nil
        )
        {
            self.createdTime = createdTime
            self.jobId = jobId
            self.nodeName = nodeName
            self.status = status
            self.statusMessage = statusMessage
            self.templateType = templateType
        }
    }

}

extension PanoramaClientTypes {
    public enum NodeFromTemplateJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case pending
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [NodeFromTemplateJobStatus] {
            return [
                .failed,
                .pending,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NodeFromTemplateJobStatus(rawValue: rawValue) ?? NodeFromTemplateJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes.NodeInputPort: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case description = "Description"
        case maxConnections = "MaxConnections"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if maxConnections != 0 {
            try encodeContainer.encode(maxConnections, forKey: .maxConnections)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.PortType.self, forKey: .type)
        type = typeDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let maxConnectionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxConnections) ?? 0
        maxConnections = maxConnectionsDecoded
    }
}

extension PanoramaClientTypes {
    /// A node input port.
    public struct NodeInputPort: Swift.Equatable {
        /// The input port's default value.
        public var defaultValue: Swift.String?
        /// The input port's description.
        public var description: Swift.String?
        /// The input port's max connections.
        public var maxConnections: Swift.Int
        /// The input port's name.
        public var name: Swift.String?
        /// The input port's type.
        public var type: PanoramaClientTypes.PortType?

        public init(
            defaultValue: Swift.String? = nil,
            description: Swift.String? = nil,
            maxConnections: Swift.Int = 0,
            name: Swift.String? = nil,
            type: PanoramaClientTypes.PortType? = nil
        )
        {
            self.defaultValue = defaultValue
            self.description = description
            self.maxConnections = maxConnections
            self.name = name
            self.type = type
        }
    }

}

extension PanoramaClientTypes.NodeInstance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentStatus = "CurrentStatus"
        case nodeId = "NodeId"
        case nodeInstanceId = "NodeInstanceId"
        case nodeName = "NodeName"
        case packageName = "PackageName"
        case packagePatchVersion = "PackagePatchVersion"
        case packageVersion = "PackageVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentStatus = self.currentStatus {
            try encodeContainer.encode(currentStatus.rawValue, forKey: .currentStatus)
        }
        if let nodeId = self.nodeId {
            try encodeContainer.encode(nodeId, forKey: .nodeId)
        }
        if let nodeInstanceId = self.nodeInstanceId {
            try encodeContainer.encode(nodeInstanceId, forKey: .nodeInstanceId)
        }
        if let nodeName = self.nodeName {
            try encodeContainer.encode(nodeName, forKey: .nodeName)
        }
        if let packageName = self.packageName {
            try encodeContainer.encode(packageName, forKey: .packageName)
        }
        if let packagePatchVersion = self.packagePatchVersion {
            try encodeContainer.encode(packagePatchVersion, forKey: .packagePatchVersion)
        }
        if let packageVersion = self.packageVersion {
            try encodeContainer.encode(packageVersion, forKey: .packageVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeInstanceId)
        nodeInstanceId = nodeInstanceIdDecoded
        let nodeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeId)
        nodeId = nodeIdDecoded
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let packageVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageVersion)
        packageVersion = packageVersionDecoded
        let packagePatchVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packagePatchVersion)
        packagePatchVersion = packagePatchVersionDecoded
        let nodeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeName)
        nodeName = nodeNameDecoded
        let currentStatusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.NodeInstanceStatus.self, forKey: .currentStatus)
        currentStatus = currentStatusDecoded
    }
}

extension PanoramaClientTypes {
    /// A node instance.
    public struct NodeInstance: Swift.Equatable {
        /// The instance's current status.
        /// This member is required.
        public var currentStatus: PanoramaClientTypes.NodeInstanceStatus?
        /// The node's ID.
        public var nodeId: Swift.String?
        /// The instance's ID.
        /// This member is required.
        public var nodeInstanceId: Swift.String?
        /// The instance's name.
        public var nodeName: Swift.String?
        /// The instance's package name.
        public var packageName: Swift.String?
        /// The instance's package patch version.
        public var packagePatchVersion: Swift.String?
        /// The instance's package version.
        public var packageVersion: Swift.String?

        public init(
            currentStatus: PanoramaClientTypes.NodeInstanceStatus? = nil,
            nodeId: Swift.String? = nil,
            nodeInstanceId: Swift.String? = nil,
            nodeName: Swift.String? = nil,
            packageName: Swift.String? = nil,
            packagePatchVersion: Swift.String? = nil,
            packageVersion: Swift.String? = nil
        )
        {
            self.currentStatus = currentStatus
            self.nodeId = nodeId
            self.nodeInstanceId = nodeInstanceId
            self.nodeName = nodeName
            self.packageName = packageName
            self.packagePatchVersion = packagePatchVersion
            self.packageVersion = packageVersion
        }
    }

}

extension PanoramaClientTypes {
    public enum NodeInstanceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case notAvailable
        case paused
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [NodeInstanceStatus] {
            return [
                .error,
                .notAvailable,
                .paused,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .notAvailable: return "NOT_AVAILABLE"
            case .paused: return "PAUSED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NodeInstanceStatus(rawValue: rawValue) ?? NodeInstanceStatus.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes.NodeInterface: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputs = "Inputs"
        case outputs = "Outputs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputs = inputs {
            var inputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputs)
            for nodeinputport0 in inputs {
                try inputsContainer.encode(nodeinputport0)
            }
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for nodeoutputport0 in outputs {
                try outputsContainer.encode(nodeoutputport0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputsContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.NodeInputPort?].self, forKey: .inputs)
        var inputsDecoded0:[PanoramaClientTypes.NodeInputPort]? = nil
        if let inputsContainer = inputsContainer {
            inputsDecoded0 = [PanoramaClientTypes.NodeInputPort]()
            for structure0 in inputsContainer {
                if let structure0 = structure0 {
                    inputsDecoded0?.append(structure0)
                }
            }
        }
        inputs = inputsDecoded0
        let outputsContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.NodeOutputPort?].self, forKey: .outputs)
        var outputsDecoded0:[PanoramaClientTypes.NodeOutputPort]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [PanoramaClientTypes.NodeOutputPort]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
    }
}

extension PanoramaClientTypes {
    /// A node interface.
    public struct NodeInterface: Swift.Equatable {
        /// The node interface's inputs.
        /// This member is required.
        public var inputs: [PanoramaClientTypes.NodeInputPort]?
        /// The node interface's outputs.
        /// This member is required.
        public var outputs: [PanoramaClientTypes.NodeOutputPort]?

        public init(
            inputs: [PanoramaClientTypes.NodeInputPort]? = nil,
            outputs: [PanoramaClientTypes.NodeOutputPort]? = nil
        )
        {
            self.inputs = inputs
            self.outputs = outputs
        }
    }

}

extension PanoramaClientTypes.NodeOutputPort: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.PortType.self, forKey: .type)
        type = typeDecoded
    }
}

extension PanoramaClientTypes {
    /// A node output port.
    public struct NodeOutputPort: Swift.Equatable {
        /// The output port's description.
        public var description: Swift.String?
        /// The output port's name.
        public var name: Swift.String?
        /// The output port's type.
        public var type: PanoramaClientTypes.PortType?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            type: PanoramaClientTypes.PortType? = nil
        )
        {
            self.description = description
            self.name = name
            self.type = type
        }
    }

}

extension PanoramaClientTypes.NodeSignal: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nodeInstanceId = "NodeInstanceId"
        case signal = "Signal"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nodeInstanceId = self.nodeInstanceId {
            try encodeContainer.encode(nodeInstanceId, forKey: .nodeInstanceId)
        }
        if let signal = self.signal {
            try encodeContainer.encode(signal.rawValue, forKey: .signal)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeInstanceId)
        nodeInstanceId = nodeInstanceIdDecoded
        let signalDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.NodeSignalValue.self, forKey: .signal)
        signal = signalDecoded
    }
}

extension PanoramaClientTypes {
    /// A signal to a camera node to start or stop processing video.
    public struct NodeSignal: Swift.Equatable {
        /// The camera node's name, from the application manifest.
        /// This member is required.
        public var nodeInstanceId: Swift.String?
        /// The signal value.
        /// This member is required.
        public var signal: PanoramaClientTypes.NodeSignalValue?

        public init(
            nodeInstanceId: Swift.String? = nil,
            signal: PanoramaClientTypes.NodeSignalValue? = nil
        )
        {
            self.nodeInstanceId = nodeInstanceId
            self.signal = signal
        }
    }

}

extension PanoramaClientTypes {
    public enum NodeSignalValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pause
        case resume
        case sdkUnknown(Swift.String)

        public static var allCases: [NodeSignalValue] {
            return [
                .pause,
                .resume,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pause: return "PAUSE"
            case .resume: return "RESUME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NodeSignalValue(rawValue: rawValue) ?? NodeSignalValue.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes.NtpPayload: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ntpServers = "NtpServers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ntpServers = ntpServers {
            var ntpServersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ntpServers)
            for ipaddressorservername0 in ntpServers {
                try ntpServersContainer.encode(ipaddressorservername0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ntpServersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ntpServers)
        var ntpServersDecoded0:[Swift.String]? = nil
        if let ntpServersContainer = ntpServersContainer {
            ntpServersDecoded0 = [Swift.String]()
            for string0 in ntpServersContainer {
                if let string0 = string0 {
                    ntpServersDecoded0?.append(string0)
                }
            }
        }
        ntpServers = ntpServersDecoded0
    }
}

extension PanoramaClientTypes {
    /// Network time protocol (NTP) server settings. Use this option to connect to local NTP servers instead of pool.ntp.org.
    public struct NtpPayload: Swift.Equatable {
        /// NTP servers to use, in order of preference.
        /// This member is required.
        public var ntpServers: [Swift.String]?

        public init(
            ntpServers: [Swift.String]? = nil
        )
        {
            self.ntpServers = ntpServers
        }
    }

}

extension PanoramaClientTypes.NtpStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionStatus = "ConnectionStatus"
        case ipAddress = "IpAddress"
        case ntpServerName = "NtpServerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionStatus = self.connectionStatus {
            try encodeContainer.encode(connectionStatus.rawValue, forKey: .connectionStatus)
        }
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let ntpServerName = self.ntpServerName {
            try encodeContainer.encode(ntpServerName, forKey: .ntpServerName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionStatusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.NetworkConnectionStatus.self, forKey: .connectionStatus)
        connectionStatus = connectionStatusDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let ntpServerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ntpServerName)
        ntpServerName = ntpServerNameDecoded
    }
}

extension PanoramaClientTypes {
    /// Details about an NTP server connection.
    public struct NtpStatus: Swift.Equatable {
        /// The connection's status.
        public var connectionStatus: PanoramaClientTypes.NetworkConnectionStatus?
        /// The IP address of the server.
        public var ipAddress: Swift.String?
        /// The domain name of the server.
        public var ntpServerName: Swift.String?

        public init(
            connectionStatus: PanoramaClientTypes.NetworkConnectionStatus? = nil,
            ipAddress: Swift.String? = nil,
            ntpServerName: Swift.String? = nil
        )
        {
            self.connectionStatus = connectionStatus
            self.ipAddress = ipAddress
            self.ntpServerName = ntpServerName
        }
    }

}

extension PanoramaClientTypes.OTAJobConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowMajorVersionUpdate = "AllowMajorVersionUpdate"
        case imageVersion = "ImageVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allowMajorVersionUpdate != false {
            try encodeContainer.encode(allowMajorVersionUpdate, forKey: .allowMajorVersionUpdate)
        }
        if let imageVersion = self.imageVersion {
            try encodeContainer.encode(imageVersion, forKey: .imageVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageVersion)
        imageVersion = imageVersionDecoded
        let allowMajorVersionUpdateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowMajorVersionUpdate) ?? false
        allowMajorVersionUpdate = allowMajorVersionUpdateDecoded
    }
}

extension PanoramaClientTypes {
    /// An over-the-air update (OTA) job configuration.
    public struct OTAJobConfig: Swift.Equatable {
        /// Whether to apply the update if it is a major version change.
        public var allowMajorVersionUpdate: Swift.Bool
        /// The target version of the device software.
        /// This member is required.
        public var imageVersion: Swift.String?

        public init(
            allowMajorVersionUpdate: Swift.Bool = false,
            imageVersion: Swift.String? = nil
        )
        {
            self.allowMajorVersionUpdate = allowMajorVersionUpdate
            self.imageVersion = imageVersion
        }
    }

}

extension PanoramaClientTypes.OutPutS3Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "BucketName"
        case objectKey = "ObjectKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let objectKey = self.objectKey {
            try encodeContainer.encode(objectKey, forKey: .objectKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let objectKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectKey)
        objectKey = objectKeyDecoded
    }
}

extension PanoramaClientTypes {
    /// The location of an output object in Amazon S3.
    public struct OutPutS3Location: Swift.Equatable {
        /// The object's bucket.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The object's key.
        /// This member is required.
        public var objectKey: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            objectKey: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.objectKey = objectKey
        }
    }

}

extension PanoramaClientTypes.PackageImportJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case jobId = "JobId"
        case jobType = "JobType"
        case lastUpdatedTime = "LastUpdatedTime"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobType = self.jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.PackageImportJobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.PackageImportJobStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension PanoramaClientTypes {
    /// A job to import a package version.
    public struct PackageImportJob: Swift.Equatable {
        /// When the job was created.
        public var createdTime: ClientRuntime.Date?
        /// The job's ID.
        public var jobId: Swift.String?
        /// The job's type.
        public var jobType: PanoramaClientTypes.PackageImportJobType?
        /// When the job was updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The job's status.
        public var status: PanoramaClientTypes.PackageImportJobStatus?
        /// The job's status message.
        public var statusMessage: Swift.String?

        public init(
            createdTime: ClientRuntime.Date? = nil,
            jobId: Swift.String? = nil,
            jobType: PanoramaClientTypes.PackageImportJobType? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            status: PanoramaClientTypes.PackageImportJobStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.createdTime = createdTime
            self.jobId = jobId
            self.jobType = jobType
            self.lastUpdatedTime = lastUpdatedTime
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension PanoramaClientTypes.PackageImportJobInputConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case packageVersionInputConfig = "PackageVersionInputConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let packageVersionInputConfig = self.packageVersionInputConfig {
            try encodeContainer.encode(packageVersionInputConfig, forKey: .packageVersionInputConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageVersionInputConfigDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.PackageVersionInputConfig.self, forKey: .packageVersionInputConfig)
        packageVersionInputConfig = packageVersionInputConfigDecoded
    }
}

extension PanoramaClientTypes {
    /// A configuration for a package import job.
    public struct PackageImportJobInputConfig: Swift.Equatable {
        /// The package version's input configuration.
        public var packageVersionInputConfig: PanoramaClientTypes.PackageVersionInputConfig?

        public init(
            packageVersionInputConfig: PanoramaClientTypes.PackageVersionInputConfig? = nil
        )
        {
            self.packageVersionInputConfig = packageVersionInputConfig
        }
    }

}

extension PanoramaClientTypes.PackageImportJobOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outputS3Location = "OutputS3Location"
        case packageId = "PackageId"
        case packageVersion = "PackageVersion"
        case patchVersion = "PatchVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputS3Location = self.outputS3Location {
            try encodeContainer.encode(outputS3Location, forKey: .outputS3Location)
        }
        if let packageId = self.packageId {
            try encodeContainer.encode(packageId, forKey: .packageId)
        }
        if let packageVersion = self.packageVersion {
            try encodeContainer.encode(packageVersion, forKey: .packageVersion)
        }
        if let patchVersion = self.patchVersion {
            try encodeContainer.encode(patchVersion, forKey: .patchVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageId)
        packageId = packageIdDecoded
        let packageVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageVersion)
        packageVersion = packageVersionDecoded
        let patchVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchVersion)
        patchVersion = patchVersionDecoded
        let outputS3LocationDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.OutPutS3Location.self, forKey: .outputS3Location)
        outputS3Location = outputS3LocationDecoded
    }
}

extension PanoramaClientTypes {
    /// Results of a package import job.
    public struct PackageImportJobOutput: Swift.Equatable {
        /// The package's output location.
        /// This member is required.
        public var outputS3Location: PanoramaClientTypes.OutPutS3Location?
        /// The package's ID.
        /// This member is required.
        public var packageId: Swift.String?
        /// The package's version.
        /// This member is required.
        public var packageVersion: Swift.String?
        /// The package's patch version.
        /// This member is required.
        public var patchVersion: Swift.String?

        public init(
            outputS3Location: PanoramaClientTypes.OutPutS3Location? = nil,
            packageId: Swift.String? = nil,
            packageVersion: Swift.String? = nil,
            patchVersion: Swift.String? = nil
        )
        {
            self.outputS3Location = outputS3Location
            self.packageId = packageId
            self.packageVersion = packageVersion
            self.patchVersion = patchVersion
        }
    }

}

extension PanoramaClientTypes.PackageImportJobOutputConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case packageVersionOutputConfig = "PackageVersionOutputConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let packageVersionOutputConfig = self.packageVersionOutputConfig {
            try encodeContainer.encode(packageVersionOutputConfig, forKey: .packageVersionOutputConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageVersionOutputConfigDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.PackageVersionOutputConfig.self, forKey: .packageVersionOutputConfig)
        packageVersionOutputConfig = packageVersionOutputConfigDecoded
    }
}

extension PanoramaClientTypes {
    /// An output configuration for a package import job.
    public struct PackageImportJobOutputConfig: Swift.Equatable {
        /// The package version's output configuration.
        public var packageVersionOutputConfig: PanoramaClientTypes.PackageVersionOutputConfig?

        public init(
            packageVersionOutputConfig: PanoramaClientTypes.PackageVersionOutputConfig? = nil
        )
        {
            self.packageVersionOutputConfig = packageVersionOutputConfig
        }
    }

}

extension PanoramaClientTypes {
    public enum PackageImportJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case pending
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageImportJobStatus] {
            return [
                .failed,
                .pending,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PackageImportJobStatus(rawValue: rawValue) ?? PackageImportJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes {
    public enum PackageImportJobType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case marketplaceNodePackageVersion
        case nodePackageVersion
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageImportJobType] {
            return [
                .marketplaceNodePackageVersion,
                .nodePackageVersion,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .marketplaceNodePackageVersion: return "MARKETPLACE_NODE_PACKAGE_VERSION"
            case .nodePackageVersion: return "NODE_PACKAGE_VERSION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PackageImportJobType(rawValue: rawValue) ?? PackageImportJobType.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes.PackageListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case packageId = "PackageId"
        case packageName = "PackageName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let packageId = self.packageId {
            try encodeContainer.encode(packageId, forKey: .packageId)
        }
        if let packageName = self.packageName {
            try encodeContainer.encode(packageName, forKey: .packageName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageId)
        packageId = packageIdDecoded
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PanoramaClientTypes {
    /// A package summary.
    public struct PackageListItem: Swift.Equatable {
        /// The package's ARN.
        public var arn: Swift.String?
        /// When the package was created.
        public var createdTime: ClientRuntime.Date?
        /// The package's ID.
        public var packageId: Swift.String?
        /// The package's name.
        public var packageName: Swift.String?
        /// The package's tags.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            packageId: Swift.String? = nil,
            packageName: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.packageId = packageId
            self.packageName = packageName
            self.tags = tags
        }
    }

}

extension PanoramaClientTypes.PackageObject: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case packageVersion = "PackageVersion"
        case patchVersion = "PatchVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let packageVersion = self.packageVersion {
            try encodeContainer.encode(packageVersion, forKey: .packageVersion)
        }
        if let patchVersion = self.patchVersion {
            try encodeContainer.encode(patchVersion, forKey: .patchVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let packageVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageVersion)
        packageVersion = packageVersionDecoded
        let patchVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .patchVersion)
        patchVersion = patchVersionDecoded
    }
}

extension PanoramaClientTypes {
    /// A package object.
    public struct PackageObject: Swift.Equatable {
        /// The object's name.
        /// This member is required.
        public var name: Swift.String?
        /// The object's package version.
        /// This member is required.
        public var packageVersion: Swift.String?
        /// The object's patch version.
        /// This member is required.
        public var patchVersion: Swift.String?

        public init(
            name: Swift.String? = nil,
            packageVersion: Swift.String? = nil,
            patchVersion: Swift.String? = nil
        )
        {
            self.name = name
            self.packageVersion = packageVersion
            self.patchVersion = patchVersion
        }
    }

}

extension PanoramaClientTypes.PackageVersionInputConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Location = "S3Location"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Location = self.s3Location {
            try encodeContainer.encode(s3Location, forKey: .s3Location)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LocationDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.S3Location.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
    }
}

extension PanoramaClientTypes {
    /// A package version input configuration.
    public struct PackageVersionInputConfig: Swift.Equatable {
        /// A location in Amazon S3.
        /// This member is required.
        public var s3Location: PanoramaClientTypes.S3Location?

        public init(
            s3Location: PanoramaClientTypes.S3Location? = nil
        )
        {
            self.s3Location = s3Location
        }
    }

}

extension PanoramaClientTypes.PackageVersionOutputConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case markLatest = "MarkLatest"
        case packageName = "PackageName"
        case packageVersion = "PackageVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if markLatest != false {
            try encodeContainer.encode(markLatest, forKey: .markLatest)
        }
        if let packageName = self.packageName {
            try encodeContainer.encode(packageName, forKey: .packageName)
        }
        if let packageVersion = self.packageVersion {
            try encodeContainer.encode(packageVersion, forKey: .packageVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let packageVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageVersion)
        packageVersion = packageVersionDecoded
        let markLatestDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .markLatest) ?? false
        markLatest = markLatestDecoded
    }
}

extension PanoramaClientTypes {
    /// A package version output configuration.
    public struct PackageVersionOutputConfig: Swift.Equatable {
        /// Indicates that the version is recommended for all users.
        public var markLatest: Swift.Bool
        /// The output's package name.
        /// This member is required.
        public var packageName: Swift.String?
        /// The output's package version.
        /// This member is required.
        public var packageVersion: Swift.String?

        public init(
            markLatest: Swift.Bool = false,
            packageName: Swift.String? = nil,
            packageVersion: Swift.String? = nil
        )
        {
            self.markLatest = markLatest
            self.packageName = packageName
            self.packageVersion = packageVersion
        }
    }

}

extension PanoramaClientTypes {
    public enum PackageVersionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleting
        case failed
        case registerCompleted
        case registerPending
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageVersionStatus] {
            return [
                .deleting,
                .failed,
                .registerCompleted,
                .registerPending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .registerCompleted: return "REGISTER_COMPLETED"
            case .registerPending: return "REGISTER_PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PackageVersionStatus(rawValue: rawValue) ?? PackageVersionStatus.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes {
    public enum PortType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case boolean
        case float32
        case int32
        case media
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [PortType] {
            return [
                .boolean,
                .float32,
                .int32,
                .media,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "BOOLEAN"
            case .float32: return "FLOAT32"
            case .int32: return "INT32"
            case .media: return "MEDIA"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PortType(rawValue: rawValue) ?? PortType.sdkUnknown(rawValue)
        }
    }
}

extension ProvisionDeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case networkingConfiguration = "NetworkingConfiguration"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkingConfiguration = self.networkingConfiguration {
            try encodeContainer.encode(networkingConfiguration, forKey: .networkingConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension ProvisionDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/devices"
    }
}

public struct ProvisionDeviceInput: Swift.Equatable {
    /// A description for the device.
    public var description: Swift.String?
    /// A name for the device.
    /// This member is required.
    public var name: Swift.String?
    /// A networking configuration for the device.
    public var networkingConfiguration: PanoramaClientTypes.NetworkPayload?
    /// Tags for the device.
    public var tags: [Swift.String:Swift.String]?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        networkingConfiguration: PanoramaClientTypes.NetworkPayload? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.name = name
        self.networkingConfiguration = networkingConfiguration
        self.tags = tags
    }
}

struct ProvisionDeviceInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let networkingConfiguration: PanoramaClientTypes.NetworkPayload?
}

extension ProvisionDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case networkingConfiguration = "NetworkingConfiguration"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let networkingConfigurationDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.NetworkPayload.self, forKey: .networkingConfiguration)
        networkingConfiguration = networkingConfigurationDecoded
    }
}

extension ProvisionDeviceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ProvisionDeviceOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.certificates = output.certificates
            self.deviceId = output.deviceId
            self.iotThingName = output.iotThingName
            self.status = output.status
        } else {
            self.arn = nil
            self.certificates = nil
            self.deviceId = nil
            self.iotThingName = nil
            self.status = nil
        }
    }
}

public struct ProvisionDeviceOutput: Swift.Equatable {
    /// The device's ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// The device's configuration bundle.
    public var certificates: ClientRuntime.Data?
    /// The device's ID.
    public var deviceId: Swift.String?
    /// The device's IoT thing name.
    public var iotThingName: Swift.String?
    /// The device's status.
    /// This member is required.
    public var status: PanoramaClientTypes.DeviceStatus?

    public init(
        arn: Swift.String? = nil,
        certificates: ClientRuntime.Data? = nil,
        deviceId: Swift.String? = nil,
        iotThingName: Swift.String? = nil,
        status: PanoramaClientTypes.DeviceStatus? = nil
    )
    {
        self.arn = arn
        self.certificates = certificates
        self.deviceId = deviceId
        self.iotThingName = iotThingName
        self.status = status
    }
}

struct ProvisionDeviceOutputBody: Swift.Equatable {
    let deviceId: Swift.String?
    let arn: Swift.String?
    let status: PanoramaClientTypes.DeviceStatus?
    let certificates: ClientRuntime.Data?
    let iotThingName: Swift.String?
}

extension ProvisionDeviceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case certificates = "Certificates"
        case deviceId = "DeviceId"
        case iotThingName = "IotThingName"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.DeviceStatus.self, forKey: .status)
        status = statusDecoded
        let certificatesDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .certificates)
        certificates = certificatesDecoded
        let iotThingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iotThingName)
        iotThingName = iotThingNameDecoded
    }
}

enum ProvisionDeviceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RegisterPackageVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case markLatest = "MarkLatest"
        case ownerAccount = "OwnerAccount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if markLatest != false {
            try encodeContainer.encode(markLatest, forKey: .markLatest)
        }
        if let ownerAccount = self.ownerAccount {
            try encodeContainer.encode(ownerAccount, forKey: .ownerAccount)
        }
    }
}

extension RegisterPackageVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let packageId = packageId else {
            return nil
        }
        guard let packageVersion = packageVersion else {
            return nil
        }
        guard let patchVersion = patchVersion else {
            return nil
        }
        return "/packages/\(packageId.urlPercentEncoding())/versions/\(packageVersion.urlPercentEncoding())/patch/\(patchVersion.urlPercentEncoding())"
    }
}

public struct RegisterPackageVersionInput: Swift.Equatable {
    /// Whether to mark the new version as the latest version.
    public var markLatest: Swift.Bool
    /// An owner account.
    public var ownerAccount: Swift.String?
    /// A package ID.
    /// This member is required.
    public var packageId: Swift.String?
    /// A package version.
    /// This member is required.
    public var packageVersion: Swift.String?
    /// A patch version.
    /// This member is required.
    public var patchVersion: Swift.String?

    public init(
        markLatest: Swift.Bool = false,
        ownerAccount: Swift.String? = nil,
        packageId: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        patchVersion: Swift.String? = nil
    )
    {
        self.markLatest = markLatest
        self.ownerAccount = ownerAccount
        self.packageId = packageId
        self.packageVersion = packageVersion
        self.patchVersion = patchVersion
    }
}

struct RegisterPackageVersionInputBody: Swift.Equatable {
    let ownerAccount: Swift.String?
    let markLatest: Swift.Bool
}

extension RegisterPackageVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case markLatest = "MarkLatest"
        case ownerAccount = "OwnerAccount"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let markLatestDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .markLatest) ?? false
        markLatest = markLatestDecoded
    }
}

extension RegisterPackageVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RegisterPackageVersionOutput: Swift.Equatable {

    public init() { }
}

enum RegisterPackageVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RemoveApplicationInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationInstanceId = applicationInstanceId else {
            return nil
        }
        return "/application-instances/\(applicationInstanceId.urlPercentEncoding())"
    }
}

public struct RemoveApplicationInstanceInput: Swift.Equatable {
    /// An application instance ID.
    /// This member is required.
    public var applicationInstanceId: Swift.String?

    public init(
        applicationInstanceId: Swift.String? = nil
    )
    {
        self.applicationInstanceId = applicationInstanceId
    }
}

struct RemoveApplicationInstanceInputBody: Swift.Equatable {
}

extension RemoveApplicationInstanceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension RemoveApplicationInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct RemoveApplicationInstanceOutput: Swift.Equatable {

    public init() { }
}

enum RemoveApplicationInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PanoramaClientTypes.ReportedRuntimeContextState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredState = "DesiredState"
        case deviceReportedStatus = "DeviceReportedStatus"
        case deviceReportedTime = "DeviceReportedTime"
        case runtimeContextName = "RuntimeContextName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let desiredState = self.desiredState {
            try encodeContainer.encode(desiredState.rawValue, forKey: .desiredState)
        }
        if let deviceReportedStatus = self.deviceReportedStatus {
            try encodeContainer.encode(deviceReportedStatus.rawValue, forKey: .deviceReportedStatus)
        }
        if let deviceReportedTime = self.deviceReportedTime {
            try encodeContainer.encodeTimestamp(deviceReportedTime, format: .epochSeconds, forKey: .deviceReportedTime)
        }
        if let runtimeContextName = self.runtimeContextName {
            try encodeContainer.encode(runtimeContextName, forKey: .runtimeContextName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let desiredStateDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.DesiredState.self, forKey: .desiredState)
        desiredState = desiredStateDecoded
        let runtimeContextNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runtimeContextName)
        runtimeContextName = runtimeContextNameDecoded
        let deviceReportedStatusDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.DeviceReportedStatus.self, forKey: .deviceReportedStatus)
        deviceReportedStatus = deviceReportedStatusDecoded
        let deviceReportedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .deviceReportedTime)
        deviceReportedTime = deviceReportedTimeDecoded
    }
}

extension PanoramaClientTypes {
    /// An application instance's state.
    public struct ReportedRuntimeContextState: Swift.Equatable {
        /// The application's desired state.
        /// This member is required.
        public var desiredState: PanoramaClientTypes.DesiredState?
        /// The application's reported status.
        /// This member is required.
        public var deviceReportedStatus: PanoramaClientTypes.DeviceReportedStatus?
        /// When the device reported the application's state.
        /// This member is required.
        public var deviceReportedTime: ClientRuntime.Date?
        /// The device's name.
        /// This member is required.
        public var runtimeContextName: Swift.String?

        public init(
            desiredState: PanoramaClientTypes.DesiredState? = nil,
            deviceReportedStatus: PanoramaClientTypes.DeviceReportedStatus? = nil,
            deviceReportedTime: ClientRuntime.Date? = nil,
            runtimeContextName: Swift.String? = nil
        )
        {
            self.desiredState = desiredState
            self.deviceReportedStatus = deviceReportedStatus
            self.deviceReportedTime = deviceReportedTime
            self.runtimeContextName = runtimeContextName
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The target resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The resource's ID.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource's type.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension PanoramaClientTypes.S3Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "BucketName"
        case objectKey = "ObjectKey"
        case region = "Region"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let objectKey = self.objectKey {
            try encodeContainer.encode(objectKey, forKey: .objectKey)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let objectKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectKey)
        objectKey = objectKeyDecoded
    }
}

extension PanoramaClientTypes {
    /// A location in Amazon S3.
    public struct S3Location: Swift.Equatable {
        /// A bucket name.
        /// This member is required.
        public var bucketName: Swift.String?
        /// An object key.
        /// This member is required.
        public var objectKey: Swift.String?
        /// The bucket's Region.
        public var region: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            objectKey: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.objectKey = objectKey
            self.region = region
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request would cause a limit to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The name of the limit.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The target resource's ID.
        public internal(set) var resourceId: Swift.String? = nil
        /// The target resource's type.
        public internal(set) var resourceType: Swift.String? = nil
        /// The name of the service.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let quotaCode: Swift.String?
    let serviceCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case quotaCode = "QuotaCode"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case serviceCode = "ServiceCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension SignalApplicationInstanceNodeInstancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nodeSignals = "NodeSignals"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nodeSignals = nodeSignals {
            var nodeSignalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodeSignals)
            for nodesignal0 in nodeSignals {
                try nodeSignalsContainer.encode(nodesignal0)
            }
        }
    }
}

extension SignalApplicationInstanceNodeInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationInstanceId = applicationInstanceId else {
            return nil
        }
        return "/application-instances/\(applicationInstanceId.urlPercentEncoding())/node-signals"
    }
}

public struct SignalApplicationInstanceNodeInstancesInput: Swift.Equatable {
    /// An application instance ID.
    /// This member is required.
    public var applicationInstanceId: Swift.String?
    /// A list of signals.
    /// This member is required.
    public var nodeSignals: [PanoramaClientTypes.NodeSignal]?

    public init(
        applicationInstanceId: Swift.String? = nil,
        nodeSignals: [PanoramaClientTypes.NodeSignal]? = nil
    )
    {
        self.applicationInstanceId = applicationInstanceId
        self.nodeSignals = nodeSignals
    }
}

struct SignalApplicationInstanceNodeInstancesInputBody: Swift.Equatable {
    let nodeSignals: [PanoramaClientTypes.NodeSignal]?
}

extension SignalApplicationInstanceNodeInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nodeSignals = "NodeSignals"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeSignalsContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.NodeSignal?].self, forKey: .nodeSignals)
        var nodeSignalsDecoded0:[PanoramaClientTypes.NodeSignal]? = nil
        if let nodeSignalsContainer = nodeSignalsContainer {
            nodeSignalsDecoded0 = [PanoramaClientTypes.NodeSignal]()
            for structure0 in nodeSignalsContainer {
                if let structure0 = structure0 {
                    nodeSignalsDecoded0?.append(structure0)
                }
            }
        }
        nodeSignals = nodeSignalsDecoded0
    }
}

extension SignalApplicationInstanceNodeInstancesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SignalApplicationInstanceNodeInstancesOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationInstanceId = output.applicationInstanceId
        } else {
            self.applicationInstanceId = nil
        }
    }
}

public struct SignalApplicationInstanceNodeInstancesOutput: Swift.Equatable {
    /// An application instance ID.
    /// This member is required.
    public var applicationInstanceId: Swift.String?

    public init(
        applicationInstanceId: Swift.String? = nil
    )
    {
        self.applicationInstanceId = applicationInstanceId
    }
}

struct SignalApplicationInstanceNodeInstancesOutputBody: Swift.Equatable {
    let applicationInstanceId: Swift.String?
}

extension SignalApplicationInstanceNodeInstancesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationInstanceId = "ApplicationInstanceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationInstanceId)
        applicationInstanceId = applicationInstanceIdDecoded
    }
}

enum SignalApplicationInstanceNodeInstancesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PanoramaClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes.StaticIpConnectionInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultGateway = "DefaultGateway"
        case dns = "Dns"
        case ipAddress = "IpAddress"
        case mask = "Mask"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultGateway = self.defaultGateway {
            try encodeContainer.encode(defaultGateway, forKey: .defaultGateway)
        }
        if let dns = dns {
            var dnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dns)
            for dns0 in dns {
                try dnsContainer.encode(dns0)
            }
        }
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let mask = self.mask {
            try encodeContainer.encode(mask, forKey: .mask)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let maskDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mask)
        mask = maskDecoded
        let dnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dns)
        var dnsDecoded0:[Swift.String]? = nil
        if let dnsContainer = dnsContainer {
            dnsDecoded0 = [Swift.String]()
            for string0 in dnsContainer {
                if let string0 = string0 {
                    dnsDecoded0?.append(string0)
                }
            }
        }
        dns = dnsDecoded0
        let defaultGatewayDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultGateway)
        defaultGateway = defaultGatewayDecoded
    }
}

extension PanoramaClientTypes {
    /// A static IP configuration.
    public struct StaticIpConnectionInfo: Swift.Equatable {
        /// The connection's default gateway.
        /// This member is required.
        public var defaultGateway: Swift.String?
        /// The connection's DNS address.
        /// This member is required.
        public var dns: [Swift.String]?
        /// The connection's IP address.
        /// This member is required.
        public var ipAddress: Swift.String?
        /// The connection's DNS mask.
        /// This member is required.
        public var mask: Swift.String?

        public init(
            defaultGateway: Swift.String? = nil,
            dns: [Swift.String]? = nil,
            ipAddress: Swift.String? = nil,
            mask: Swift.String? = nil
        )
        {
            self.defaultGateway = defaultGateway
            self.dns = dns
            self.ipAddress = ipAddress
            self.mask = mask
        }
    }

}

extension PanoramaClientTypes {
    public enum StatusFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deploymentError
        case deploymentFailed
        case deploymentSucceeded
        case processingDeployment
        case processingRemoval
        case removalFailed
        case removalSucceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [StatusFilter] {
            return [
                .deploymentError,
                .deploymentFailed,
                .deploymentSucceeded,
                .processingDeployment,
                .processingRemoval,
                .removalFailed,
                .removalSucceeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deploymentError: return "DEPLOYMENT_ERROR"
            case .deploymentFailed: return "DEPLOYMENT_FAILED"
            case .deploymentSucceeded: return "DEPLOYMENT_SUCCEEDED"
            case .processingDeployment: return "PROCESSING_DEPLOYMENT"
            case .processingRemoval: return "PROCESSING_REMOVAL"
            case .removalFailed: return "REMOVAL_FAILED"
            case .removalSucceeded: return "REMOVAL_SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StatusFilter(rawValue: rawValue) ?? StatusFilter.sdkUnknown(rawValue)
        }
    }
}

extension PanoramaClientTypes.StorageLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case binaryPrefixLocation = "BinaryPrefixLocation"
        case bucket = "Bucket"
        case generatedPrefixLocation = "GeneratedPrefixLocation"
        case manifestPrefixLocation = "ManifestPrefixLocation"
        case repoPrefixLocation = "RepoPrefixLocation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let binaryPrefixLocation = self.binaryPrefixLocation {
            try encodeContainer.encode(binaryPrefixLocation, forKey: .binaryPrefixLocation)
        }
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let generatedPrefixLocation = self.generatedPrefixLocation {
            try encodeContainer.encode(generatedPrefixLocation, forKey: .generatedPrefixLocation)
        }
        if let manifestPrefixLocation = self.manifestPrefixLocation {
            try encodeContainer.encode(manifestPrefixLocation, forKey: .manifestPrefixLocation)
        }
        if let repoPrefixLocation = self.repoPrefixLocation {
            try encodeContainer.encode(repoPrefixLocation, forKey: .repoPrefixLocation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let repoPrefixLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repoPrefixLocation)
        repoPrefixLocation = repoPrefixLocationDecoded
        let generatedPrefixLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedPrefixLocation)
        generatedPrefixLocation = generatedPrefixLocationDecoded
        let binaryPrefixLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .binaryPrefixLocation)
        binaryPrefixLocation = binaryPrefixLocationDecoded
        let manifestPrefixLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestPrefixLocation)
        manifestPrefixLocation = manifestPrefixLocationDecoded
    }
}

extension PanoramaClientTypes {
    /// A storage location.
    public struct StorageLocation: Swift.Equatable {
        /// The location's binary prefix.
        /// This member is required.
        public var binaryPrefixLocation: Swift.String?
        /// The location's bucket.
        /// This member is required.
        public var bucket: Swift.String?
        /// The location's generated prefix.
        /// This member is required.
        public var generatedPrefixLocation: Swift.String?
        /// The location's manifest prefix.
        /// This member is required.
        public var manifestPrefixLocation: Swift.String?
        /// The location's repo prefix.
        /// This member is required.
        public var repoPrefixLocation: Swift.String?

        public init(
            binaryPrefixLocation: Swift.String? = nil,
            bucket: Swift.String? = nil,
            generatedPrefixLocation: Swift.String? = nil,
            manifestPrefixLocation: Swift.String? = nil,
            repoPrefixLocation: Swift.String? = nil
        )
        {
            self.binaryPrefixLocation = binaryPrefixLocation
            self.bucket = bucket
            self.generatedPrefixLocation = generatedPrefixLocation
            self.manifestPrefixLocation = manifestPrefixLocation
            self.repoPrefixLocation = repoPrefixLocation
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The resource's ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tags for the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PanoramaClientTypes {
    public enum TemplateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case rtspCameraStream
        case sdkUnknown(Swift.String)

        public static var allCases: [TemplateType] {
            return [
                .rtspCameraStream,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .rtspCameraStream: return "RTSP_CAMERA_STREAM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TemplateType(rawValue: rawValue) ?? TemplateType.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The resource's ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tag keys to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDeviceMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateDeviceMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let deviceId = deviceId else {
            return nil
        }
        return "/devices/\(deviceId.urlPercentEncoding())"
    }
}

public struct UpdateDeviceMetadataInput: Swift.Equatable {
    /// A description for the device.
    public var description: Swift.String?
    /// The device's ID.
    /// This member is required.
    public var deviceId: Swift.String?

    public init(
        description: Swift.String? = nil,
        deviceId: Swift.String? = nil
    )
    {
        self.description = description
        self.deviceId = deviceId
    }
}

struct UpdateDeviceMetadataInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension UpdateDeviceMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateDeviceMetadataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateDeviceMetadataOutputBody = try responseDecoder.decode(responseBody: data)
            self.deviceId = output.deviceId
        } else {
            self.deviceId = nil
        }
    }
}

public struct UpdateDeviceMetadataOutput: Swift.Equatable {
    /// The device's ID.
    public var deviceId: Swift.String?

    public init(
        deviceId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
    }
}

struct UpdateDeviceMetadataOutputBody: Swift.Equatable {
    let deviceId: Swift.String?
}

extension UpdateDeviceMetadataOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
    }
}

enum UpdateDeviceMetadataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PanoramaClientTypes {
    public enum UpdateProgress: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case downloading
        case failed
        case inProgress
        case pending
        case rebooting
        case verifying
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateProgress] {
            return [
                .completed,
                .downloading,
                .failed,
                .inProgress,
                .pending,
                .rebooting,
                .verifying,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .downloading: return "DOWNLOADING"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case .rebooting: return "REBOOTING"
            case .verifying: return "VERIFYING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateProgress(rawValue: rawValue) ?? UpdateProgress.sdkUnknown(rawValue)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorArguments = output.errorArguments
            self.properties.errorId = output.errorId
            self.properties.fields = output.fields
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.errorArguments = nil
            self.properties.errorId = nil
            self.properties.fields = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request contains an invalid parameter value.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A list of attributes that led to the exception and their values.
        public internal(set) var errorArguments: [PanoramaClientTypes.ValidationExceptionErrorArgument]? = nil
        /// A unique ID for the error.
        public internal(set) var errorId: Swift.String? = nil
        /// A list of request parameters that failed validation.
        public internal(set) var fields: [PanoramaClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason that validation failed.
        public internal(set) var reason: PanoramaClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorArguments: [PanoramaClientTypes.ValidationExceptionErrorArgument]? = nil,
        errorId: Swift.String? = nil,
        fields: [PanoramaClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: PanoramaClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.errorArguments = errorArguments
        self.properties.errorId = errorId
        self.properties.fields = fields
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: PanoramaClientTypes.ValidationExceptionReason?
    let errorId: Swift.String?
    let errorArguments: [PanoramaClientTypes.ValidationExceptionErrorArgument]?
    let fields: [PanoramaClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorArguments = "ErrorArguments"
        case errorId = "ErrorId"
        case fields = "Fields"
        case message = "Message"
        case reason = "Reason"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(PanoramaClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let errorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorId)
        errorId = errorIdDecoded
        let errorArgumentsContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.ValidationExceptionErrorArgument?].self, forKey: .errorArguments)
        var errorArgumentsDecoded0:[PanoramaClientTypes.ValidationExceptionErrorArgument]? = nil
        if let errorArgumentsContainer = errorArgumentsContainer {
            errorArgumentsDecoded0 = [PanoramaClientTypes.ValidationExceptionErrorArgument]()
            for structure0 in errorArgumentsContainer {
                if let structure0 = structure0 {
                    errorArgumentsDecoded0?.append(structure0)
                }
            }
        }
        errorArguments = errorArgumentsDecoded0
        let fieldsContainer = try containerValues.decodeIfPresent([PanoramaClientTypes.ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[PanoramaClientTypes.ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [PanoramaClientTypes.ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension PanoramaClientTypes.ValidationExceptionErrorArgument: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension PanoramaClientTypes {
    /// A validation exception error argument.
    public struct ValidationExceptionErrorArgument: Swift.Equatable {
        /// The argument's name.
        /// This member is required.
        public var name: Swift.String?
        /// The argument's value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension PanoramaClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PanoramaClientTypes {
    /// A validation exception field.
    public struct ValidationExceptionField: Swift.Equatable {
        /// The field's message.
        /// This member is required.
        public var message: Swift.String?
        /// The field's name.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension PanoramaClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
