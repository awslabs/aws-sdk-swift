// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient permissions to perform this action. Check the error message and try again.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VoiceIDClientTypes.AuthenticationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptanceThreshold = "AcceptanceThreshold"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptanceThreshold = self.acceptanceThreshold {
            try encodeContainer.encode(acceptanceThreshold, forKey: .acceptanceThreshold)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptanceThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .acceptanceThreshold)
        acceptanceThreshold = acceptanceThresholdDecoded
    }
}

extension VoiceIDClientTypes {
    /// The configuration used to authenticate a speaker during a session.
    public struct AuthenticationConfiguration: Swift.Equatable {
        /// The minimum threshold needed to successfully authenticate a speaker.
        /// This member is required.
        public var acceptanceThreshold: Swift.Int?

        public init (
            acceptanceThreshold: Swift.Int? = nil
        )
        {
            self.acceptanceThreshold = acceptanceThreshold
        }
    }

}

extension VoiceIDClientTypes {
    public enum AuthenticationDecision: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accept
        case notEnoughSpeech
        case reject
        case speakerExpired
        case speakerIdNotProvided
        case speakerNotEnrolled
        case speakerOptedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationDecision] {
            return [
                .accept,
                .notEnoughSpeech,
                .reject,
                .speakerExpired,
                .speakerIdNotProvided,
                .speakerNotEnrolled,
                .speakerOptedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accept: return "ACCEPT"
            case .notEnoughSpeech: return "NOT_ENOUGH_SPEECH"
            case .reject: return "REJECT"
            case .speakerExpired: return "SPEAKER_EXPIRED"
            case .speakerIdNotProvided: return "SPEAKER_ID_NOT_PROVIDED"
            case .speakerNotEnrolled: return "SPEAKER_NOT_ENROLLED"
            case .speakerOptedOut: return "SPEAKER_OPTED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthenticationDecision(rawValue: rawValue) ?? AuthenticationDecision.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIDClientTypes.AuthenticationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioAggregationEndedAt = "AudioAggregationEndedAt"
        case audioAggregationStartedAt = "AudioAggregationStartedAt"
        case authenticationResultId = "AuthenticationResultId"
        case configuration = "Configuration"
        case customerSpeakerId = "CustomerSpeakerId"
        case decision = "Decision"
        case generatedSpeakerId = "GeneratedSpeakerId"
        case score = "Score"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioAggregationEndedAt = self.audioAggregationEndedAt {
            try encodeContainer.encodeTimestamp(audioAggregationEndedAt, format: .epochSeconds, forKey: .audioAggregationEndedAt)
        }
        if let audioAggregationStartedAt = self.audioAggregationStartedAt {
            try encodeContainer.encodeTimestamp(audioAggregationStartedAt, format: .epochSeconds, forKey: .audioAggregationStartedAt)
        }
        if let authenticationResultId = self.authenticationResultId {
            try encodeContainer.encode(authenticationResultId, forKey: .authenticationResultId)
        }
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let customerSpeakerId = self.customerSpeakerId {
            try encodeContainer.encode(customerSpeakerId, forKey: .customerSpeakerId)
        }
        if let decision = self.decision {
            try encodeContainer.encode(decision.rawValue, forKey: .decision)
        }
        if let generatedSpeakerId = self.generatedSpeakerId {
            try encodeContainer.encode(generatedSpeakerId, forKey: .generatedSpeakerId)
        }
        if let score = self.score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationResultIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authenticationResultId)
        authenticationResultId = authenticationResultIdDecoded
        let audioAggregationStartedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .audioAggregationStartedAt)
        audioAggregationStartedAt = audioAggregationStartedAtDecoded
        let audioAggregationEndedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .audioAggregationEndedAt)
        audioAggregationEndedAt = audioAggregationEndedAtDecoded
        let customerSpeakerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerSpeakerId)
        customerSpeakerId = customerSpeakerIdDecoded
        let generatedSpeakerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedSpeakerId)
        generatedSpeakerId = generatedSpeakerIdDecoded
        let decisionDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.AuthenticationDecision.self, forKey: .decision)
        decision = decisionDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .score)
        score = scoreDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.AuthenticationConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension VoiceIDClientTypes.AuthenticationResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AuthenticationResult(audioAggregationEndedAt: \(Swift.String(describing: audioAggregationEndedAt)), audioAggregationStartedAt: \(Swift.String(describing: audioAggregationStartedAt)), authenticationResultId: \(Swift.String(describing: authenticationResultId)), configuration: \(Swift.String(describing: configuration)), decision: \(Swift.String(describing: decision)), generatedSpeakerId: \(Swift.String(describing: generatedSpeakerId)), score: \(Swift.String(describing: score)), customerSpeakerId: \"CONTENT_REDACTED\")"}
}

extension VoiceIDClientTypes {
    /// The authentication result produced by Voice ID, processed against the current session state and streamed audio of the speaker.
    public struct AuthenticationResult: Swift.Equatable {
        /// A timestamp indicating when audio aggregation ended for this authentication result.
        public var audioAggregationEndedAt: ClientRuntime.Date?
        /// A timestamp indicating when audio aggregation started for this authentication result.
        public var audioAggregationStartedAt: ClientRuntime.Date?
        /// The unique identifier for this authentication result. Because there can be multiple authentications for a given session, this field helps to identify if the returned result is from a previous streaming activity or a new result. Note that in absence of any new streaming activity, AcceptanceThreshold changes, or SpeakerId changes, Voice ID always returns cached Authentication Result for this API.
        public var authenticationResultId: Swift.String?
        /// The AuthenticationConfiguration used to generate this authentication result.
        public var configuration: VoiceIDClientTypes.AuthenticationConfiguration?
        /// The client-provided identifier for the speaker whose authentication result is produced. Only present if a SpeakerId is provided for the session.
        public var customerSpeakerId: Swift.String?
        /// The authentication decision produced by Voice ID, processed against the current session state and streamed audio of the speaker.
        public var decision: VoiceIDClientTypes.AuthenticationDecision?
        /// The service-generated identifier for the speaker whose authentication result is produced.
        public var generatedSpeakerId: Swift.String?
        /// The authentication score for the speaker whose authentication result is produced. This value is only present if the authentication decision is either ACCEPT or REJECT.
        public var score: Swift.Int?

        public init (
            audioAggregationEndedAt: ClientRuntime.Date? = nil,
            audioAggregationStartedAt: ClientRuntime.Date? = nil,
            authenticationResultId: Swift.String? = nil,
            configuration: VoiceIDClientTypes.AuthenticationConfiguration? = nil,
            customerSpeakerId: Swift.String? = nil,
            decision: VoiceIDClientTypes.AuthenticationDecision? = nil,
            generatedSpeakerId: Swift.String? = nil,
            score: Swift.Int? = nil
        )
        {
            self.audioAggregationEndedAt = audioAggregationEndedAt
            self.audioAggregationStartedAt = audioAggregationStartedAt
            self.authenticationResultId = authenticationResultId
            self.configuration = configuration
            self.customerSpeakerId = customerSpeakerId
            self.decision = decision
            self.generatedSpeakerId = generatedSpeakerId
            self.score = score
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.conflictType = output.conflictType
            self.message = output.message
        } else {
            self.conflictType = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request failed due to a conflict. Check the ConflictType and error message for more details.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The type of conflict which caused a ConflictException. Possible types and the corresponding error messages are as follows:
    ///
    /// * DOMAIN_NOT_ACTIVE: The domain is not active.
    ///
    /// * CANNOT_CHANGE_SPEAKER_AFTER_ENROLLMENT: You cannot change the speaker ID after an enrollment has been requested.
    ///
    /// * ENROLLMENT_ALREADY_EXISTS: There is already an enrollment for this session.
    ///
    /// * SPEAKER_NOT_SET: You must set the speaker ID before requesting an enrollment.
    ///
    /// * SPEAKER_OPTED_OUT: You cannot request an enrollment for an opted out speaker.
    ///
    /// * CONCURRENT_CHANGES: The request could not be processed as the resource was modified by another request during execution.
    public var conflictType: VoiceIDClientTypes.ConflictType?
    public var message: Swift.String?

    public init (
        conflictType: VoiceIDClientTypes.ConflictType? = nil,
        message: Swift.String? = nil
    )
    {
        self.conflictType = conflictType
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let conflictType: VoiceIDClientTypes.ConflictType?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictType = "ConflictType"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let conflictTypeDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.ConflictType.self, forKey: .conflictType)
        conflictType = conflictTypeDecoded
    }
}

extension VoiceIDClientTypes {
    public enum ConflictType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case anotherActiveStream
        case cannotChangeSpeakerAfterEnrollment
        case concurrentChanges
        case domainLockedFromEncryptionUpdates
        case domainNotActive
        case enrollmentAlreadyExists
        case speakerNotSet
        case speakerOptedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictType] {
            return [
                .anotherActiveStream,
                .cannotChangeSpeakerAfterEnrollment,
                .concurrentChanges,
                .domainLockedFromEncryptionUpdates,
                .domainNotActive,
                .enrollmentAlreadyExists,
                .speakerNotSet,
                .speakerOptedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .anotherActiveStream: return "ANOTHER_ACTIVE_STREAM"
            case .cannotChangeSpeakerAfterEnrollment: return "CANNOT_CHANGE_SPEAKER_AFTER_ENROLLMENT"
            case .concurrentChanges: return "CONCURRENT_CHANGES"
            case .domainLockedFromEncryptionUpdates: return "DOMAIN_LOCKED_FROM_ENCRYPTION_UPDATES"
            case .domainNotActive: return "DOMAIN_NOT_ACTIVE"
            case .enrollmentAlreadyExists: return "ENROLLMENT_ALREADY_EXISTS"
            case .speakerNotSet: return "SPEAKER_NOT_SET"
            case .speakerOptedOut: return "SPEAKER_OPTED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConflictType(rawValue: rawValue) ?? ConflictType.sdkUnknown(rawValue)
        }
    }
}

extension CreateDomainInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDomainInput(clientToken: \(Swift.String(describing: clientToken)), serverSideEncryptionConfiguration: \(Swift.String(describing: serverSideEncryptionConfiguration)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case name = "Name"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverSideEncryptionConfiguration = self.serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDomainInput: Swift.Equatable {
    /// The idempotency token for creating a new domain. If not provided, Amazon Web Services SDK populates this field.
    public var clientToken: Swift.String?
    /// A brief description of the domain.
    public var description: Swift.String?
    /// The name of the domain.
    /// This member is required.
    public var name: Swift.String?
    /// The configuration, containing the KMS key identifier, to be used by Voice ID for the server-side encryption of your data. Refer to [ Amazon Connect Voice ID encryption at rest](https://docs.aws.amazon.com/connect/latest/adminguide/encryption-at-rest.html#encryption-at-rest-voiceid) for more details on how the KMS key is used.
    /// This member is required.
    public var serverSideEncryptionConfiguration: VoiceIDClientTypes.ServerSideEncryptionConfiguration?
    /// A list of tags you want added to the domain.
    public var tags: [VoiceIDClientTypes.Tag]?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        serverSideEncryptionConfiguration: VoiceIDClientTypes.ServerSideEncryptionConfiguration? = nil,
        tags: [VoiceIDClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
        self.tags = tags
    }
}

struct CreateDomainInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let serverSideEncryptionConfiguration: VoiceIDClientTypes.ServerSideEncryptionConfiguration?
    let clientToken: Swift.String?
    let tags: [VoiceIDClientTypes.Tag]?
}

extension CreateDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case name = "Name"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([VoiceIDClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[VoiceIDClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [VoiceIDClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDomainOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domain = output.domain
        } else {
            self.domain = nil
        }
    }
}

public struct CreateDomainOutputResponse: Swift.Equatable {
    /// Information about the newly created domain.
    public var domain: VoiceIDClientTypes.Domain?

    public init (
        domain: VoiceIDClientTypes.Domain? = nil
    )
    {
        self.domain = domain
    }
}

struct CreateDomainOutputResponseBody: Swift.Equatable {
    let domain: VoiceIDClientTypes.Domain?
}

extension CreateDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension DeleteDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
    }
}

extension DeleteDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDomainInput: Swift.Equatable {
    /// The identifier of the domain you want to delete.
    /// This member is required.
    public var domainId: Swift.String?

    public init (
        domainId: Swift.String? = nil
    )
    {
        self.domainId = domainId
    }
}

struct DeleteDomainInputBody: Swift.Equatable {
    let domainId: Swift.String?
}

extension DeleteDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
    }
}

extension DeleteDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDomainOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDomainOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteFraudsterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFraudsterInput(domainId: \(Swift.String(describing: domainId)), fraudsterId: \"CONTENT_REDACTED\")"}
}

extension DeleteFraudsterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case fraudsterId = "FraudsterId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let fraudsterId = self.fraudsterId {
            try encodeContainer.encode(fraudsterId, forKey: .fraudsterId)
        }
    }
}

extension DeleteFraudsterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteFraudsterInput: Swift.Equatable {
    /// The identifier of the domain containing the fraudster.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the fraudster you want to delete.
    /// This member is required.
    public var fraudsterId: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        fraudsterId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.fraudsterId = fraudsterId
    }
}

struct DeleteFraudsterInputBody: Swift.Equatable {
    let domainId: Swift.String?
    let fraudsterId: Swift.String?
}

extension DeleteFraudsterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case fraudsterId = "FraudsterId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let fraudsterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fraudsterId)
        fraudsterId = fraudsterIdDecoded
    }
}

extension DeleteFraudsterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFraudsterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteFraudsterOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFraudsterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFraudsterOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteSpeakerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSpeakerInput(domainId: \(Swift.String(describing: domainId)), speakerId: \"CONTENT_REDACTED\")"}
}

extension DeleteSpeakerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case speakerId = "SpeakerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let speakerId = self.speakerId {
            try encodeContainer.encode(speakerId, forKey: .speakerId)
        }
    }
}

extension DeleteSpeakerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSpeakerInput: Swift.Equatable {
    /// The identifier of the domain containing the speaker.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the speaker you want to delete.
    /// This member is required.
    public var speakerId: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        speakerId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.speakerId = speakerId
    }
}

struct DeleteSpeakerInputBody: Swift.Equatable {
    let domainId: Swift.String?
    let speakerId: Swift.String?
}

extension DeleteSpeakerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case speakerId = "SpeakerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let speakerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .speakerId)
        speakerId = speakerIdDecoded
    }
}

extension DeleteSpeakerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSpeakerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSpeakerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSpeakerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSpeakerOutputResponse: Swift.Equatable {

    public init () { }
}

extension DescribeDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
    }
}

extension DescribeDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDomainInput: Swift.Equatable {
    /// The identifier of the domain you are describing.
    /// This member is required.
    public var domainId: Swift.String?

    public init (
        domainId: Swift.String? = nil
    )
    {
        self.domainId = domainId
    }
}

struct DescribeDomainInputBody: Swift.Equatable {
    let domainId: Swift.String?
}

extension DescribeDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
    }
}

extension DescribeDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDomainOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domain = output.domain
        } else {
            self.domain = nil
        }
    }
}

public struct DescribeDomainOutputResponse: Swift.Equatable {
    /// Information about the specified domain.
    public var domain: VoiceIDClientTypes.Domain?

    public init (
        domain: VoiceIDClientTypes.Domain? = nil
    )
    {
        self.domain = domain
    }
}

struct DescribeDomainOutputResponseBody: Swift.Equatable {
    let domain: VoiceIDClientTypes.Domain?
}

extension DescribeDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension DescribeFraudsterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFraudsterInput(domainId: \(Swift.String(describing: domainId)), fraudsterId: \"CONTENT_REDACTED\")"}
}

extension DescribeFraudsterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case fraudsterId = "FraudsterId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let fraudsterId = self.fraudsterId {
            try encodeContainer.encode(fraudsterId, forKey: .fraudsterId)
        }
    }
}

extension DescribeFraudsterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeFraudsterInput: Swift.Equatable {
    /// The identifier of the domain containing the fraudster.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the fraudster you are describing.
    /// This member is required.
    public var fraudsterId: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        fraudsterId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.fraudsterId = fraudsterId
    }
}

struct DescribeFraudsterInputBody: Swift.Equatable {
    let domainId: Swift.String?
    let fraudsterId: Swift.String?
}

extension DescribeFraudsterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case fraudsterId = "FraudsterId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let fraudsterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fraudsterId)
        fraudsterId = fraudsterIdDecoded
    }
}

extension DescribeFraudsterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFraudsterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeFraudsterOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFraudsterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeFraudsterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fraudster = output.fraudster
        } else {
            self.fraudster = nil
        }
    }
}

public struct DescribeFraudsterOutputResponse: Swift.Equatable {
    /// Information about the specified fraudster.
    public var fraudster: VoiceIDClientTypes.Fraudster?

    public init (
        fraudster: VoiceIDClientTypes.Fraudster? = nil
    )
    {
        self.fraudster = fraudster
    }
}

struct DescribeFraudsterOutputResponseBody: Swift.Equatable {
    let fraudster: VoiceIDClientTypes.Fraudster?
}

extension DescribeFraudsterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fraudster = "Fraudster"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fraudsterDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.Fraudster.self, forKey: .fraudster)
        fraudster = fraudsterDecoded
    }
}

extension DescribeFraudsterRegistrationJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension DescribeFraudsterRegistrationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeFraudsterRegistrationJobInput: Swift.Equatable {
    /// The identifier for the domain containing the fraudster registration job.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier for the fraudster registration job you are describing.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.jobId = jobId
    }
}

struct DescribeFraudsterRegistrationJobInputBody: Swift.Equatable {
    let domainId: Swift.String?
    let jobId: Swift.String?
}

extension DescribeFraudsterRegistrationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeFraudsterRegistrationJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFraudsterRegistrationJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeFraudsterRegistrationJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFraudsterRegistrationJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeFraudsterRegistrationJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct DescribeFraudsterRegistrationJobOutputResponse: Swift.Equatable {
    /// Contains details about the specified fraudster registration job.
    public var job: VoiceIDClientTypes.FraudsterRegistrationJob?

    public init (
        job: VoiceIDClientTypes.FraudsterRegistrationJob? = nil
    )
    {
        self.job = job
    }
}

struct DescribeFraudsterRegistrationJobOutputResponseBody: Swift.Equatable {
    let job: VoiceIDClientTypes.FraudsterRegistrationJob?
}

extension DescribeFraudsterRegistrationJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job = "Job"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.FraudsterRegistrationJob.self, forKey: .job)
        job = jobDecoded
    }
}

extension DescribeSpeakerEnrollmentJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension DescribeSpeakerEnrollmentJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeSpeakerEnrollmentJobInput: Swift.Equatable {
    /// The identifier of the domain containing the speaker enrollment job.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the speaker enrollment job you are describing.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.jobId = jobId
    }
}

struct DescribeSpeakerEnrollmentJobInputBody: Swift.Equatable {
    let domainId: Swift.String?
    let jobId: Swift.String?
}

extension DescribeSpeakerEnrollmentJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeSpeakerEnrollmentJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSpeakerEnrollmentJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeSpeakerEnrollmentJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSpeakerEnrollmentJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeSpeakerEnrollmentJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct DescribeSpeakerEnrollmentJobOutputResponse: Swift.Equatable {
    /// Contains details about the specified speaker enrollment job.
    public var job: VoiceIDClientTypes.SpeakerEnrollmentJob?

    public init (
        job: VoiceIDClientTypes.SpeakerEnrollmentJob? = nil
    )
    {
        self.job = job
    }
}

struct DescribeSpeakerEnrollmentJobOutputResponseBody: Swift.Equatable {
    let job: VoiceIDClientTypes.SpeakerEnrollmentJob?
}

extension DescribeSpeakerEnrollmentJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job = "Job"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.SpeakerEnrollmentJob.self, forKey: .job)
        job = jobDecoded
    }
}

extension DescribeSpeakerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSpeakerInput(domainId: \(Swift.String(describing: domainId)), speakerId: \"CONTENT_REDACTED\")"}
}

extension DescribeSpeakerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case speakerId = "SpeakerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let speakerId = self.speakerId {
            try encodeContainer.encode(speakerId, forKey: .speakerId)
        }
    }
}

extension DescribeSpeakerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeSpeakerInput: Swift.Equatable {
    /// The identifier of the domain that contains the speaker.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the speaker you are describing.
    /// This member is required.
    public var speakerId: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        speakerId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.speakerId = speakerId
    }
}

struct DescribeSpeakerInputBody: Swift.Equatable {
    let domainId: Swift.String?
    let speakerId: Swift.String?
}

extension DescribeSpeakerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case speakerId = "SpeakerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let speakerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .speakerId)
        speakerId = speakerIdDecoded
    }
}

extension DescribeSpeakerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSpeakerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeSpeakerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSpeakerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeSpeakerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.speaker = output.speaker
        } else {
            self.speaker = nil
        }
    }
}

public struct DescribeSpeakerOutputResponse: Swift.Equatable {
    /// Information about the specified speaker.
    public var speaker: VoiceIDClientTypes.Speaker?

    public init (
        speaker: VoiceIDClientTypes.Speaker? = nil
    )
    {
        self.speaker = speaker
    }
}

struct DescribeSpeakerOutputResponseBody: Swift.Equatable {
    let speaker: VoiceIDClientTypes.Speaker?
}

extension DescribeSpeakerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case speaker = "Speaker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let speakerDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.Speaker.self, forKey: .speaker)
        speaker = speakerDecoded
    }
}

extension VoiceIDClientTypes.Domain: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case description = "Description"
        case domainId = "DomainId"
        case domainStatus = "DomainStatus"
        case name = "Name"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
        case serverSideEncryptionUpdateDetails = "ServerSideEncryptionUpdateDetails"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let domainStatus = self.domainStatus {
            try encodeContainer.encode(domainStatus.rawValue, forKey: .domainStatus)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverSideEncryptionConfiguration = self.serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let serverSideEncryptionUpdateDetails = self.serverSideEncryptionUpdateDetails {
            try encodeContainer.encode(serverSideEncryptionUpdateDetails, forKey: .serverSideEncryptionUpdateDetails)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let domainStatusDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.DomainStatus.self, forKey: .domainStatus)
        domainStatus = domainStatusDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let serverSideEncryptionUpdateDetailsDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.ServerSideEncryptionUpdateDetails.self, forKey: .serverSideEncryptionUpdateDetails)
        serverSideEncryptionUpdateDetails = serverSideEncryptionUpdateDetailsDecoded
    }
}

extension VoiceIDClientTypes.Domain: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Domain(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), domainStatus: \(Swift.String(describing: domainStatus)), serverSideEncryptionConfiguration: \(Swift.String(describing: serverSideEncryptionConfiguration)), serverSideEncryptionUpdateDetails: \(Swift.String(describing: serverSideEncryptionUpdateDetails)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension VoiceIDClientTypes {
    /// Contains all the information about a domain.
    public struct Domain: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the domain.
        public var arn: Swift.String?
        /// The timestamp at which the domain is created.
        public var createdAt: ClientRuntime.Date?
        /// The client-provided description of the domain.
        public var description: Swift.String?
        /// The service-generated identifier for the domain.
        public var domainId: Swift.String?
        /// The current status of the domain.
        public var domainStatus: VoiceIDClientTypes.DomainStatus?
        /// The client-provided name for the domain.
        public var name: Swift.String?
        /// The server-side encryption configuration containing the KMS key identifier you want Voice ID to use to encrypt your data.
        public var serverSideEncryptionConfiguration: VoiceIDClientTypes.ServerSideEncryptionConfiguration?
        /// Details about the most recent server-side encryption configuration update. When the server-side encryption configuration is changed, dependency on the old KMS key is removed through an asynchronous process. When this update is complete, the domain's data can only be accessed using the new KMS key.
        public var serverSideEncryptionUpdateDetails: VoiceIDClientTypes.ServerSideEncryptionUpdateDetails?
        /// The timestamp showing the domain's last update.
        public var updatedAt: ClientRuntime.Date?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            domainStatus: VoiceIDClientTypes.DomainStatus? = nil,
            name: Swift.String? = nil,
            serverSideEncryptionConfiguration: VoiceIDClientTypes.ServerSideEncryptionConfiguration? = nil,
            serverSideEncryptionUpdateDetails: VoiceIDClientTypes.ServerSideEncryptionUpdateDetails? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.domainId = domainId
            self.domainStatus = domainStatus
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.serverSideEncryptionUpdateDetails = serverSideEncryptionUpdateDetails
            self.updatedAt = updatedAt
        }
    }

}

extension VoiceIDClientTypes {
    public enum DomainStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case pending
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainStatus] {
            return [
                .active,
                .pending,
                .suspended,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .pending: return "PENDING"
            case .suspended: return "SUSPENDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DomainStatus(rawValue: rawValue) ?? DomainStatus.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIDClientTypes.DomainSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case description = "Description"
        case domainId = "DomainId"
        case domainStatus = "DomainStatus"
        case name = "Name"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
        case serverSideEncryptionUpdateDetails = "ServerSideEncryptionUpdateDetails"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let domainStatus = self.domainStatus {
            try encodeContainer.encode(domainStatus.rawValue, forKey: .domainStatus)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverSideEncryptionConfiguration = self.serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let serverSideEncryptionUpdateDetails = self.serverSideEncryptionUpdateDetails {
            try encodeContainer.encode(serverSideEncryptionUpdateDetails, forKey: .serverSideEncryptionUpdateDetails)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let domainStatusDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.DomainStatus.self, forKey: .domainStatus)
        domainStatus = domainStatusDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let serverSideEncryptionUpdateDetailsDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.ServerSideEncryptionUpdateDetails.self, forKey: .serverSideEncryptionUpdateDetails)
        serverSideEncryptionUpdateDetails = serverSideEncryptionUpdateDetailsDecoded
    }
}

extension VoiceIDClientTypes.DomainSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DomainSummary(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), domainStatus: \(Swift.String(describing: domainStatus)), serverSideEncryptionConfiguration: \(Swift.String(describing: serverSideEncryptionConfiguration)), serverSideEncryptionUpdateDetails: \(Swift.String(describing: serverSideEncryptionUpdateDetails)), updatedAt: \(Swift.String(describing: updatedAt)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension VoiceIDClientTypes {
    /// Contains a summary of information about a domain.
    public struct DomainSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the domain.
        public var arn: Swift.String?
        /// The timestamp showing when the domain is created.
        public var createdAt: ClientRuntime.Date?
        /// The client-provided description of the domain.
        public var description: Swift.String?
        /// The service-generated identifier for the domain.
        public var domainId: Swift.String?
        /// The current status of the domain.
        public var domainStatus: VoiceIDClientTypes.DomainStatus?
        /// The client-provided name for the domain.
        public var name: Swift.String?
        /// The server-side encryption configuration containing the KMS key identifier you want Voice ID to use to encrypt your data.
        public var serverSideEncryptionConfiguration: VoiceIDClientTypes.ServerSideEncryptionConfiguration?
        /// Details about the most recent server-side encryption configuration update. When the server-side encryption configuration is changed, dependency on the old KMS key is removed through an asynchronous process. When this update is complete, the domain's data can only be accessed using the new KMS key.
        public var serverSideEncryptionUpdateDetails: VoiceIDClientTypes.ServerSideEncryptionUpdateDetails?
        /// The timestamp showing the domain's last update.
        public var updatedAt: ClientRuntime.Date?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            domainStatus: VoiceIDClientTypes.DomainStatus? = nil,
            name: Swift.String? = nil,
            serverSideEncryptionConfiguration: VoiceIDClientTypes.ServerSideEncryptionConfiguration? = nil,
            serverSideEncryptionUpdateDetails: VoiceIDClientTypes.ServerSideEncryptionUpdateDetails? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.domainId = domainId
            self.domainStatus = domainStatus
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.serverSideEncryptionUpdateDetails = serverSideEncryptionUpdateDetails
            self.updatedAt = updatedAt
        }
    }

}

extension VoiceIDClientTypes {
    public enum DuplicateRegistrationAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case registerAsNew
        case skip
        case sdkUnknown(Swift.String)

        public static var allCases: [DuplicateRegistrationAction] {
            return [
                .registerAsNew,
                .skip,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .registerAsNew: return "REGISTER_AS_NEW"
            case .skip: return "SKIP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DuplicateRegistrationAction(rawValue: rawValue) ?? DuplicateRegistrationAction.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIDClientTypes.EnrollmentConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case existingEnrollmentAction = "ExistingEnrollmentAction"
        case fraudDetectionConfig = "FraudDetectionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let existingEnrollmentAction = self.existingEnrollmentAction {
            try encodeContainer.encode(existingEnrollmentAction.rawValue, forKey: .existingEnrollmentAction)
        }
        if let fraudDetectionConfig = self.fraudDetectionConfig {
            try encodeContainer.encode(fraudDetectionConfig, forKey: .fraudDetectionConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let existingEnrollmentActionDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.ExistingEnrollmentAction.self, forKey: .existingEnrollmentAction)
        existingEnrollmentAction = existingEnrollmentActionDecoded
        let fraudDetectionConfigDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.EnrollmentJobFraudDetectionConfig.self, forKey: .fraudDetectionConfig)
        fraudDetectionConfig = fraudDetectionConfigDecoded
    }
}

extension VoiceIDClientTypes {
    /// Contains configurations defining enrollment behavior for the batch job.
    public struct EnrollmentConfig: Swift.Equatable {
        /// The action to take when the specified speaker is already enrolled in the specified domain. The default value is SKIP, which skips the enrollment for the existing speaker. Setting the value to OVERWRITE replaces the existing voice prints and enrollment audio stored for that speaker with new data generated from the latest audio.
        public var existingEnrollmentAction: VoiceIDClientTypes.ExistingEnrollmentAction?
        /// The fraud detection configuration to use for the speaker enrollment job.
        public var fraudDetectionConfig: VoiceIDClientTypes.EnrollmentJobFraudDetectionConfig?

        public init (
            existingEnrollmentAction: VoiceIDClientTypes.ExistingEnrollmentAction? = nil,
            fraudDetectionConfig: VoiceIDClientTypes.EnrollmentJobFraudDetectionConfig? = nil
        )
        {
            self.existingEnrollmentAction = existingEnrollmentAction
            self.fraudDetectionConfig = fraudDetectionConfig
        }
    }

}

extension VoiceIDClientTypes.EnrollmentJobFraudDetectionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fraudDetectionAction = "FraudDetectionAction"
        case riskThreshold = "RiskThreshold"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fraudDetectionAction = self.fraudDetectionAction {
            try encodeContainer.encode(fraudDetectionAction.rawValue, forKey: .fraudDetectionAction)
        }
        if let riskThreshold = self.riskThreshold {
            try encodeContainer.encode(riskThreshold, forKey: .riskThreshold)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fraudDetectionActionDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.FraudDetectionAction.self, forKey: .fraudDetectionAction)
        fraudDetectionAction = fraudDetectionActionDecoded
        let riskThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .riskThreshold)
        riskThreshold = riskThresholdDecoded
    }
}

extension VoiceIDClientTypes {
    /// The configuration defining the action to take when a speaker is flagged by the fraud detection system during a batch speaker enrollment job, and the risk threshold to use for identification.
    public struct EnrollmentJobFraudDetectionConfig: Swift.Equatable {
        /// The action to take when the given speaker is flagged by the fraud detection system. The default value is FAIL, which fails the speaker enrollment. Changing this value to IGNORE results in the speaker being enrolled even if they are flagged by the fraud detection system.
        public var fraudDetectionAction: VoiceIDClientTypes.FraudDetectionAction?
        /// Threshold value for determining whether the speaker is a high risk to be fraudulent. If the detected risk score calculated by Voice ID is greater than or equal to the threshold, the speaker is considered a fraudster.
        public var riskThreshold: Swift.Int?

        public init (
            fraudDetectionAction: VoiceIDClientTypes.FraudDetectionAction? = nil,
            riskThreshold: Swift.Int? = nil
        )
        {
            self.fraudDetectionAction = fraudDetectionAction
            self.riskThreshold = riskThreshold
        }
    }

}

extension EvaluateSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case sessionNameOrId = "SessionNameOrId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let sessionNameOrId = self.sessionNameOrId {
            try encodeContainer.encode(sessionNameOrId, forKey: .sessionNameOrId)
        }
    }
}

extension EvaluateSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct EvaluateSessionInput: Swift.Equatable {
    /// The identifier of the domain where the session started.
    /// This member is required.
    public var domainId: Swift.String?
    /// The session identifier, or name of the session, that you want to evaluate. In Voice ID integration, this is the Contact-Id.
    /// This member is required.
    public var sessionNameOrId: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        sessionNameOrId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.sessionNameOrId = sessionNameOrId
    }
}

struct EvaluateSessionInputBody: Swift.Equatable {
    let domainId: Swift.String?
    let sessionNameOrId: Swift.String?
}

extension EvaluateSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case sessionNameOrId = "SessionNameOrId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let sessionNameOrIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionNameOrId)
        sessionNameOrId = sessionNameOrIdDecoded
    }
}

extension EvaluateSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EvaluateSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum EvaluateSessionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EvaluateSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: EvaluateSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.authenticationResult = output.authenticationResult
            self.domainId = output.domainId
            self.fraudDetectionResult = output.fraudDetectionResult
            self.sessionId = output.sessionId
            self.sessionName = output.sessionName
            self.streamingStatus = output.streamingStatus
        } else {
            self.authenticationResult = nil
            self.domainId = nil
            self.fraudDetectionResult = nil
            self.sessionId = nil
            self.sessionName = nil
            self.streamingStatus = nil
        }
    }
}

public struct EvaluateSessionOutputResponse: Swift.Equatable {
    /// Details resulting from the authentication process, such as authentication decision and authentication score.
    public var authenticationResult: VoiceIDClientTypes.AuthenticationResult?
    /// The identifier of the domain containing the session.
    public var domainId: Swift.String?
    /// Details resulting from the fraud detection process, such as fraud detection decision and risk score.
    public var fraudDetectionResult: VoiceIDClientTypes.FraudDetectionResult?
    /// The service-generated identifier of the session.
    public var sessionId: Swift.String?
    /// The client-provided name of the session.
    public var sessionName: Swift.String?
    /// The current status of audio streaming for this session. This field is useful to infer next steps when the Authentication or Fraud Detection results are empty or the decision is NOT_ENOUGH_SPEECH. In this situation, if the StreamingStatus is ONGOING/PENDING_CONFIGURATION, it can mean that the client should call the API again later, after Voice ID has enough audio to produce a result. If the decision remains NOT_ENOUGH_SPEECH even after StreamingStatus is ENDED, it means that the previously streamed session did not have enough speech to perform evaluation, and a new streaming session is needed to try again.
    public var streamingStatus: VoiceIDClientTypes.StreamingStatus?

    public init (
        authenticationResult: VoiceIDClientTypes.AuthenticationResult? = nil,
        domainId: Swift.String? = nil,
        fraudDetectionResult: VoiceIDClientTypes.FraudDetectionResult? = nil,
        sessionId: Swift.String? = nil,
        sessionName: Swift.String? = nil,
        streamingStatus: VoiceIDClientTypes.StreamingStatus? = nil
    )
    {
        self.authenticationResult = authenticationResult
        self.domainId = domainId
        self.fraudDetectionResult = fraudDetectionResult
        self.sessionId = sessionId
        self.sessionName = sessionName
        self.streamingStatus = streamingStatus
    }
}

struct EvaluateSessionOutputResponseBody: Swift.Equatable {
    let domainId: Swift.String?
    let sessionId: Swift.String?
    let sessionName: Swift.String?
    let streamingStatus: VoiceIDClientTypes.StreamingStatus?
    let authenticationResult: VoiceIDClientTypes.AuthenticationResult?
    let fraudDetectionResult: VoiceIDClientTypes.FraudDetectionResult?
}

extension EvaluateSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationResult = "AuthenticationResult"
        case domainId = "DomainId"
        case fraudDetectionResult = "FraudDetectionResult"
        case sessionId = "SessionId"
        case sessionName = "SessionName"
        case streamingStatus = "StreamingStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let sessionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionName)
        sessionName = sessionNameDecoded
        let streamingStatusDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.StreamingStatus.self, forKey: .streamingStatus)
        streamingStatus = streamingStatusDecoded
        let authenticationResultDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.AuthenticationResult.self, forKey: .authenticationResult)
        authenticationResult = authenticationResultDecoded
        let fraudDetectionResultDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.FraudDetectionResult.self, forKey: .fraudDetectionResult)
        fraudDetectionResult = fraudDetectionResultDecoded
    }
}

extension VoiceIDClientTypes {
    public enum ExistingEnrollmentAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case overwrite
        case skip
        case sdkUnknown(Swift.String)

        public static var allCases: [ExistingEnrollmentAction] {
            return [
                .overwrite,
                .skip,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .overwrite: return "OVERWRITE"
            case .skip: return "SKIP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExistingEnrollmentAction(rawValue: rawValue) ?? ExistingEnrollmentAction.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIDClientTypes.FailureDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case statusCode = "StatusCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode, forKey: .statusCode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VoiceIDClientTypes {
    /// Contains error details for a failed batch job.
    public struct FailureDetails: Swift.Equatable {
        /// A description of the error that caused the batch job failure.
        public var message: Swift.String?
        /// An HTTP status code representing the nature of the error.
        public var statusCode: Swift.Int?

        public init (
            message: Swift.String? = nil,
            statusCode: Swift.Int? = nil
        )
        {
            self.message = message
            self.statusCode = statusCode
        }
    }

}

extension VoiceIDClientTypes {
    public enum FraudDetectionAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fail
        case ignore
        case sdkUnknown(Swift.String)

        public static var allCases: [FraudDetectionAction] {
            return [
                .fail,
                .ignore,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fail: return "FAIL"
            case .ignore: return "IGNORE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FraudDetectionAction(rawValue: rawValue) ?? FraudDetectionAction.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIDClientTypes.FraudDetectionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case riskThreshold = "RiskThreshold"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let riskThreshold = self.riskThreshold {
            try encodeContainer.encode(riskThreshold, forKey: .riskThreshold)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let riskThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .riskThreshold)
        riskThreshold = riskThresholdDecoded
    }
}

extension VoiceIDClientTypes {
    /// The configuration used for performing fraud detection over a speaker during a session.
    public struct FraudDetectionConfiguration: Swift.Equatable {
        /// Threshold value for determining whether the speaker is a fraudster. If the detected risk score calculated by Voice ID is higher than the threshold, the speaker is considered a fraudster.
        /// This member is required.
        public var riskThreshold: Swift.Int?

        public init (
            riskThreshold: Swift.Int? = nil
        )
        {
            self.riskThreshold = riskThreshold
        }
    }

}

extension VoiceIDClientTypes {
    public enum FraudDetectionDecision: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case highRisk
        case lowRisk
        case notEnoughSpeech
        case sdkUnknown(Swift.String)

        public static var allCases: [FraudDetectionDecision] {
            return [
                .highRisk,
                .lowRisk,
                .notEnoughSpeech,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .highRisk: return "HIGH_RISK"
            case .lowRisk: return "LOW_RISK"
            case .notEnoughSpeech: return "NOT_ENOUGH_SPEECH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FraudDetectionDecision(rawValue: rawValue) ?? FraudDetectionDecision.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIDClientTypes {
    public enum FraudDetectionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case knownFraudster
        case voiceSpoofing
        case sdkUnknown(Swift.String)

        public static var allCases: [FraudDetectionReason] {
            return [
                .knownFraudster,
                .voiceSpoofing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .knownFraudster: return "KNOWN_FRAUDSTER"
            case .voiceSpoofing: return "VOICE_SPOOFING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FraudDetectionReason(rawValue: rawValue) ?? FraudDetectionReason.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIDClientTypes.FraudDetectionResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioAggregationEndedAt = "AudioAggregationEndedAt"
        case audioAggregationStartedAt = "AudioAggregationStartedAt"
        case configuration = "Configuration"
        case decision = "Decision"
        case fraudDetectionResultId = "FraudDetectionResultId"
        case reasons = "Reasons"
        case riskDetails = "RiskDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioAggregationEndedAt = self.audioAggregationEndedAt {
            try encodeContainer.encodeTimestamp(audioAggregationEndedAt, format: .epochSeconds, forKey: .audioAggregationEndedAt)
        }
        if let audioAggregationStartedAt = self.audioAggregationStartedAt {
            try encodeContainer.encodeTimestamp(audioAggregationStartedAt, format: .epochSeconds, forKey: .audioAggregationStartedAt)
        }
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let decision = self.decision {
            try encodeContainer.encode(decision.rawValue, forKey: .decision)
        }
        if let fraudDetectionResultId = self.fraudDetectionResultId {
            try encodeContainer.encode(fraudDetectionResultId, forKey: .fraudDetectionResultId)
        }
        if let reasons = reasons {
            var reasonsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reasons)
            for frauddetectionreason0 in reasons {
                try reasonsContainer.encode(frauddetectionreason0.rawValue)
            }
        }
        if let riskDetails = self.riskDetails {
            try encodeContainer.encode(riskDetails, forKey: .riskDetails)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fraudDetectionResultIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fraudDetectionResultId)
        fraudDetectionResultId = fraudDetectionResultIdDecoded
        let audioAggregationStartedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .audioAggregationStartedAt)
        audioAggregationStartedAt = audioAggregationStartedAtDecoded
        let audioAggregationEndedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .audioAggregationEndedAt)
        audioAggregationEndedAt = audioAggregationEndedAtDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.FraudDetectionConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let decisionDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.FraudDetectionDecision.self, forKey: .decision)
        decision = decisionDecoded
        let reasonsContainer = try containerValues.decodeIfPresent([VoiceIDClientTypes.FraudDetectionReason?].self, forKey: .reasons)
        var reasonsDecoded0:[VoiceIDClientTypes.FraudDetectionReason]? = nil
        if let reasonsContainer = reasonsContainer {
            reasonsDecoded0 = [VoiceIDClientTypes.FraudDetectionReason]()
            for string0 in reasonsContainer {
                if let string0 = string0 {
                    reasonsDecoded0?.append(string0)
                }
            }
        }
        reasons = reasonsDecoded0
        let riskDetailsDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.FraudRiskDetails.self, forKey: .riskDetails)
        riskDetails = riskDetailsDecoded
    }
}

extension VoiceIDClientTypes {
    /// The fraud detection result produced by Voice ID, processed against the current session state and streamed audio of the speaker.
    public struct FraudDetectionResult: Swift.Equatable {
        /// A timestamp indicating when audio aggregation ended for this fraud detection result.
        public var audioAggregationEndedAt: ClientRuntime.Date?
        /// A timestamp indicating when audio aggregation started for this fraud detection result.
        public var audioAggregationStartedAt: ClientRuntime.Date?
        /// The FraudDetectionConfiguration used to generate this fraud detection result.
        public var configuration: VoiceIDClientTypes.FraudDetectionConfiguration?
        /// The fraud detection decision produced by Voice ID, processed against the current session state and streamed audio of the speaker.
        public var decision: VoiceIDClientTypes.FraudDetectionDecision?
        /// The unique identifier for this fraud detection result. Given there can be multiple fraud detections for a given session, this field helps in identifying if the returned result is from previous streaming activity or a new result. Note that in the absence of any new streaming activity or risk threshold changes, Voice ID always returns cached Fraud Detection result for this API.
        public var fraudDetectionResultId: Swift.String?
        /// The reason speaker was flagged by the fraud detection system. This is only be populated if fraud detection Decision is HIGH_RISK, and the following possible values: KNOWN_FRAUDSTER and VOICE_SPOOFING.
        public var reasons: [VoiceIDClientTypes.FraudDetectionReason]?
        /// Details about each risk analyzed for this speaker. Currently, this contains KnownFraudsterRisk and VoiceSpoofingRisk details.
        public var riskDetails: VoiceIDClientTypes.FraudRiskDetails?

        public init (
            audioAggregationEndedAt: ClientRuntime.Date? = nil,
            audioAggregationStartedAt: ClientRuntime.Date? = nil,
            configuration: VoiceIDClientTypes.FraudDetectionConfiguration? = nil,
            decision: VoiceIDClientTypes.FraudDetectionDecision? = nil,
            fraudDetectionResultId: Swift.String? = nil,
            reasons: [VoiceIDClientTypes.FraudDetectionReason]? = nil,
            riskDetails: VoiceIDClientTypes.FraudRiskDetails? = nil
        )
        {
            self.audioAggregationEndedAt = audioAggregationEndedAt
            self.audioAggregationStartedAt = audioAggregationStartedAt
            self.configuration = configuration
            self.decision = decision
            self.fraudDetectionResultId = fraudDetectionResultId
            self.reasons = reasons
            self.riskDetails = riskDetails
        }
    }

}

extension VoiceIDClientTypes.FraudRiskDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knownFraudsterRisk = "KnownFraudsterRisk"
        case voiceSpoofingRisk = "VoiceSpoofingRisk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let knownFraudsterRisk = self.knownFraudsterRisk {
            try encodeContainer.encode(knownFraudsterRisk, forKey: .knownFraudsterRisk)
        }
        if let voiceSpoofingRisk = self.voiceSpoofingRisk {
            try encodeContainer.encode(voiceSpoofingRisk, forKey: .voiceSpoofingRisk)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knownFraudsterRiskDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.KnownFraudsterRisk.self, forKey: .knownFraudsterRisk)
        knownFraudsterRisk = knownFraudsterRiskDecoded
        let voiceSpoofingRiskDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.VoiceSpoofingRisk.self, forKey: .voiceSpoofingRisk)
        voiceSpoofingRisk = voiceSpoofingRiskDecoded
    }
}

extension VoiceIDClientTypes {
    /// Details regarding various fraud risk analyses performed against the current session state and streamed audio of the speaker.
    public struct FraudRiskDetails: Swift.Equatable {
        /// The details resulting from 'Known Fraudster Risk' analysis of the speaker.
        /// This member is required.
        public var knownFraudsterRisk: VoiceIDClientTypes.KnownFraudsterRisk?
        /// The details resulting from 'Voice Spoofing Risk' analysis of the speaker.
        /// This member is required.
        public var voiceSpoofingRisk: VoiceIDClientTypes.VoiceSpoofingRisk?

        public init (
            knownFraudsterRisk: VoiceIDClientTypes.KnownFraudsterRisk? = nil,
            voiceSpoofingRisk: VoiceIDClientTypes.VoiceSpoofingRisk? = nil
        )
        {
            self.knownFraudsterRisk = knownFraudsterRisk
            self.voiceSpoofingRisk = voiceSpoofingRisk
        }
    }

}

extension VoiceIDClientTypes.Fraudster: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case domainId = "DomainId"
        case generatedFraudsterId = "GeneratedFraudsterId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let generatedFraudsterId = self.generatedFraudsterId {
            try encodeContainer.encode(generatedFraudsterId, forKey: .generatedFraudsterId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let generatedFraudsterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedFraudsterId)
        generatedFraudsterId = generatedFraudsterIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension VoiceIDClientTypes {
    /// Contains all the information about a fraudster.
    public struct Fraudster: Swift.Equatable {
        /// The timestamp when Voice ID identified the fraudster.
        public var createdAt: ClientRuntime.Date?
        /// The identifier for the domain containing the fraudster.
        public var domainId: Swift.String?
        /// The service-generated identifier for the fraudster.
        public var generatedFraudsterId: Swift.String?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            domainId: Swift.String? = nil,
            generatedFraudsterId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.domainId = domainId
            self.generatedFraudsterId = generatedFraudsterId
        }
    }

}

extension VoiceIDClientTypes.FraudsterRegistrationJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case domainId = "DomainId"
        case endedAt = "EndedAt"
        case failureDetails = "FailureDetails"
        case inputDataConfig = "InputDataConfig"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobProgress = "JobProgress"
        case jobStatus = "JobStatus"
        case outputDataConfig = "OutputDataConfig"
        case registrationConfig = "RegistrationConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let dataAccessRoleArn = self.dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let endedAt = self.endedAt {
            try encodeContainer.encodeTimestamp(endedAt, format: .epochSeconds, forKey: .endedAt)
        }
        if let failureDetails = self.failureDetails {
            try encodeContainer.encode(failureDetails, forKey: .failureDetails)
        }
        if let inputDataConfig = self.inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobProgress = self.jobProgress {
            try encodeContainer.encode(jobProgress, forKey: .jobProgress)
        }
        if let jobStatus = self.jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let outputDataConfig = self.outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let registrationConfig = self.registrationConfig {
            try encodeContainer.encode(registrationConfig, forKey: .registrationConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.FraudsterRegistrationJobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let registrationConfigDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.RegistrationConfig.self, forKey: .registrationConfig)
        registrationConfig = registrationConfigDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let endedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endedAt)
        endedAt = endedAtDecoded
        let failureDetailsDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.FailureDetails.self, forKey: .failureDetails)
        failureDetails = failureDetailsDecoded
        let jobProgressDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.JobProgress.self, forKey: .jobProgress)
        jobProgress = jobProgressDecoded
    }
}

extension VoiceIDClientTypes.FraudsterRegistrationJob: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FraudsterRegistrationJob(createdAt: \(Swift.String(describing: createdAt)), dataAccessRoleArn: \(Swift.String(describing: dataAccessRoleArn)), domainId: \(Swift.String(describing: domainId)), endedAt: \(Swift.String(describing: endedAt)), failureDetails: \(Swift.String(describing: failureDetails)), inputDataConfig: \(Swift.String(describing: inputDataConfig)), jobId: \(Swift.String(describing: jobId)), jobProgress: \(Swift.String(describing: jobProgress)), jobStatus: \(Swift.String(describing: jobStatus)), outputDataConfig: \(Swift.String(describing: outputDataConfig)), registrationConfig: \(Swift.String(describing: registrationConfig)), jobName: \"CONTENT_REDACTED\")"}
}

extension VoiceIDClientTypes {
    /// Contains all the information about a fraudster registration job.
    public struct FraudsterRegistrationJob: Swift.Equatable {
        /// A timestamp showing the creation time of the fraudster registration job.
        public var createdAt: ClientRuntime.Date?
        /// The IAM role Amazon Resource Name (ARN) that grants Voice ID permissions to access customer's buckets to read the input manifest file and write the job output file.
        public var dataAccessRoleArn: Swift.String?
        /// The identifier of the domain containing the fraudster registration job.
        public var domainId: Swift.String?
        /// A timestamp showing when the fraudster registration job ended.
        public var endedAt: ClientRuntime.Date?
        /// Contains details that are populated when an entire batch job fails. In cases of individual registration job failures, the batch job as a whole doesn't fail; it is completed with a JobStatus of COMPLETED_WITH_ERRORS. You can use the job output file to identify the individual registration requests that failed.
        public var failureDetails: VoiceIDClientTypes.FailureDetails?
        /// The input data config containing an S3 URI for the input manifest file that contains the list of fraudster registration job requests.
        public var inputDataConfig: VoiceIDClientTypes.InputDataConfig?
        /// The service-generated identifier for the fraudster registration job.
        public var jobId: Swift.String?
        /// The client-provided name for the fraudster registration job.
        public var jobName: Swift.String?
        /// Shows the completed percentage of registration requests listed in the input file.
        public var jobProgress: VoiceIDClientTypes.JobProgress?
        /// The current status of the fraudster registration job.
        public var jobStatus: VoiceIDClientTypes.FraudsterRegistrationJobStatus?
        /// The output data config containing the S3 location where you want Voice ID to write your job output file; you must also include a KMS key ID in order to encrypt the file.
        public var outputDataConfig: VoiceIDClientTypes.OutputDataConfig?
        /// The registration config containing details such as the action to take when a duplicate fraudster is detected, and the similarity threshold to use for detecting a duplicate fraudster.
        public var registrationConfig: VoiceIDClientTypes.RegistrationConfig?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            dataAccessRoleArn: Swift.String? = nil,
            domainId: Swift.String? = nil,
            endedAt: ClientRuntime.Date? = nil,
            failureDetails: VoiceIDClientTypes.FailureDetails? = nil,
            inputDataConfig: VoiceIDClientTypes.InputDataConfig? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobProgress: VoiceIDClientTypes.JobProgress? = nil,
            jobStatus: VoiceIDClientTypes.FraudsterRegistrationJobStatus? = nil,
            outputDataConfig: VoiceIDClientTypes.OutputDataConfig? = nil,
            registrationConfig: VoiceIDClientTypes.RegistrationConfig? = nil
        )
        {
            self.createdAt = createdAt
            self.dataAccessRoleArn = dataAccessRoleArn
            self.domainId = domainId
            self.endedAt = endedAt
            self.failureDetails = failureDetails
            self.inputDataConfig = inputDataConfig
            self.jobId = jobId
            self.jobName = jobName
            self.jobProgress = jobProgress
            self.jobStatus = jobStatus
            self.outputDataConfig = outputDataConfig
            self.registrationConfig = registrationConfig
        }
    }

}

extension VoiceIDClientTypes {
    public enum FraudsterRegistrationJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case completedWithErrors
        case failed
        case inProgress
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [FraudsterRegistrationJobStatus] {
            return [
                .completed,
                .completedWithErrors,
                .failed,
                .inProgress,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .completedWithErrors: return "COMPLETED_WITH_ERRORS"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FraudsterRegistrationJobStatus(rawValue: rawValue) ?? FraudsterRegistrationJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIDClientTypes.FraudsterRegistrationJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case domainId = "DomainId"
        case endedAt = "EndedAt"
        case failureDetails = "FailureDetails"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobProgress = "JobProgress"
        case jobStatus = "JobStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let endedAt = self.endedAt {
            try encodeContainer.encodeTimestamp(endedAt, format: .epochSeconds, forKey: .endedAt)
        }
        if let failureDetails = self.failureDetails {
            try encodeContainer.encode(failureDetails, forKey: .failureDetails)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobProgress = self.jobProgress {
            try encodeContainer.encode(jobProgress, forKey: .jobProgress)
        }
        if let jobStatus = self.jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.FraudsterRegistrationJobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let endedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endedAt)
        endedAt = endedAtDecoded
        let failureDetailsDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.FailureDetails.self, forKey: .failureDetails)
        failureDetails = failureDetailsDecoded
        let jobProgressDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.JobProgress.self, forKey: .jobProgress)
        jobProgress = jobProgressDecoded
    }
}

extension VoiceIDClientTypes.FraudsterRegistrationJobSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FraudsterRegistrationJobSummary(createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), endedAt: \(Swift.String(describing: endedAt)), failureDetails: \(Swift.String(describing: failureDetails)), jobId: \(Swift.String(describing: jobId)), jobProgress: \(Swift.String(describing: jobProgress)), jobStatus: \(Swift.String(describing: jobStatus)), jobName: \"CONTENT_REDACTED\")"}
}

extension VoiceIDClientTypes {
    /// Contains a summary of information about a fraudster registration job.
    public struct FraudsterRegistrationJobSummary: Swift.Equatable {
        /// A timestamp showing when the fraudster registration job is created.
        public var createdAt: ClientRuntime.Date?
        /// The identifier of the domain containing the fraudster registration job.
        public var domainId: Swift.String?
        /// A timestamp showing when the fraudster registration job ended.
        public var endedAt: ClientRuntime.Date?
        /// Contains details that are populated when an entire batch job fails. In cases of individual registration job failures, the batch job as a whole doesn't fail; it is completed with a JobStatus of COMPLETED_WITH_ERRORS. You can use the job output file to identify the individual registration requests that failed.
        public var failureDetails: VoiceIDClientTypes.FailureDetails?
        /// The service-generated identifier for the fraudster registration job.
        public var jobId: Swift.String?
        /// The client-provided name for the fraudster registration job.
        public var jobName: Swift.String?
        /// Shows the completed percentage of registration requests listed in the input file.
        public var jobProgress: VoiceIDClientTypes.JobProgress?
        /// The current status of the fraudster registration job.
        public var jobStatus: VoiceIDClientTypes.FraudsterRegistrationJobStatus?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            domainId: Swift.String? = nil,
            endedAt: ClientRuntime.Date? = nil,
            failureDetails: VoiceIDClientTypes.FailureDetails? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobProgress: VoiceIDClientTypes.JobProgress? = nil,
            jobStatus: VoiceIDClientTypes.FraudsterRegistrationJobStatus? = nil
        )
        {
            self.createdAt = createdAt
            self.domainId = domainId
            self.endedAt = endedAt
            self.failureDetails = failureDetails
            self.jobId = jobId
            self.jobName = jobName
            self.jobProgress = jobProgress
            self.jobStatus = jobStatus
        }
    }

}

extension VoiceIDClientTypes.InputDataConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Uri = "S3Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Uri = self.s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
    }
}

extension VoiceIDClientTypes {
    /// The configuration containing input file information for a batch job.
    public struct InputDataConfig: Swift.Equatable {
        /// The S3 location for the input manifest file that contains the list of individual enrollment or registration job requests.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init (
            s3Uri: Swift.String? = nil
        )
        {
            self.s3Uri = s3Uri
        }
    }

}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request failed due to an unknown error on the server side.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VoiceIDClientTypes.JobProgress: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case percentComplete = "PercentComplete"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let percentComplete = self.percentComplete {
            try encodeContainer.encode(percentComplete, forKey: .percentComplete)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let percentCompleteDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .percentComplete)
        percentComplete = percentCompleteDecoded
    }
}

extension VoiceIDClientTypes {
    /// Indicates the completion progress for a batch job.
    public struct JobProgress: Swift.Equatable {
        /// Shows the completed percentage of enrollment or registration requests listed in the input file.
        public var percentComplete: Swift.Int?

        public init (
            percentComplete: Swift.Int? = nil
        )
        {
            self.percentComplete = percentComplete
        }
    }

}

extension VoiceIDClientTypes.KnownFraudsterRisk: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generatedFraudsterId = "GeneratedFraudsterId"
        case riskScore = "RiskScore"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let generatedFraudsterId = self.generatedFraudsterId {
            try encodeContainer.encode(generatedFraudsterId, forKey: .generatedFraudsterId)
        }
        if let riskScore = self.riskScore {
            try encodeContainer.encode(riskScore, forKey: .riskScore)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let riskScoreDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .riskScore)
        riskScore = riskScoreDecoded
        let generatedFraudsterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedFraudsterId)
        generatedFraudsterId = generatedFraudsterIdDecoded
    }
}

extension VoiceIDClientTypes {
    /// Contains details produced as a result of performing known fraudster risk analysis on a speaker.
    public struct KnownFraudsterRisk: Swift.Equatable {
        /// The identifier of the fraudster that is the closest match to the speaker. If there are no fraudsters registered in a given domain, or if there are no fraudsters with a non-zero RiskScore, this value is null.
        public var generatedFraudsterId: Swift.String?
        /// The score indicating the likelihood the speaker is a known fraudster.
        /// This member is required.
        public var riskScore: Swift.Int?

        public init (
            generatedFraudsterId: Swift.String? = nil,
            riskScore: Swift.Int? = nil
        )
        {
            self.generatedFraudsterId = generatedFraudsterId
            self.riskScore = riskScore
        }
    }

}

extension ListDomainsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDomainsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDomainsInput: Swift.Equatable {
    /// The maximum number of domains to list per API call.
    public var maxResults: Swift.Int?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDomainsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListDomainsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDomainsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDomainsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDomainsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDomainsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDomainsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domainSummaries = output.domainSummaries
            self.nextToken = output.nextToken
        } else {
            self.domainSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListDomainsOutputResponse: Swift.Equatable {
    /// A list containing details about each domain in the Amazon Web Services account.
    public var domainSummaries: [VoiceIDClientTypes.DomainSummary]?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?

    public init (
        domainSummaries: [VoiceIDClientTypes.DomainSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainSummaries = domainSummaries
        self.nextToken = nextToken
    }
}

struct ListDomainsOutputResponseBody: Swift.Equatable {
    let domainSummaries: [VoiceIDClientTypes.DomainSummary]?
    let nextToken: Swift.String?
}

extension ListDomainsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainSummaries = "DomainSummaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainSummariesContainer = try containerValues.decodeIfPresent([VoiceIDClientTypes.DomainSummary?].self, forKey: .domainSummaries)
        var domainSummariesDecoded0:[VoiceIDClientTypes.DomainSummary]? = nil
        if let domainSummariesContainer = domainSummariesContainer {
            domainSummariesDecoded0 = [VoiceIDClientTypes.DomainSummary]()
            for structure0 in domainSummariesContainer {
                if let structure0 = structure0 {
                    domainSummariesDecoded0?.append(structure0)
                }
            }
        }
        domainSummaries = domainSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFraudsterRegistrationJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case jobStatus = "JobStatus"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let jobStatus = self.jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListFraudsterRegistrationJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListFraudsterRegistrationJobsInput: Swift.Equatable {
    /// The identifier of the domain containing the fraudster registration Jobs.
    /// This member is required.
    public var domainId: Swift.String?
    /// Provides the status of your fraudster registration job.
    public var jobStatus: VoiceIDClientTypes.FraudsterRegistrationJobStatus?
    /// The maximum number of results that are returned per call. You can use NextToken to obtain further pages of results. The default is 100; the maximum allowed page size is also 100.
    public var maxResults: Swift.Int?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        jobStatus: VoiceIDClientTypes.FraudsterRegistrationJobStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.jobStatus = jobStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFraudsterRegistrationJobsInputBody: Swift.Equatable {
    let domainId: Swift.String?
    let jobStatus: VoiceIDClientTypes.FraudsterRegistrationJobStatus?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListFraudsterRegistrationJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case jobStatus = "JobStatus"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.FraudsterRegistrationJobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFraudsterRegistrationJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFraudsterRegistrationJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListFraudsterRegistrationJobsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFraudsterRegistrationJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListFraudsterRegistrationJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobSummaries = output.jobSummaries
            self.nextToken = output.nextToken
        } else {
            self.jobSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListFraudsterRegistrationJobsOutputResponse: Swift.Equatable {
    /// A list containing details about each specified fraudster registration job.
    public var jobSummaries: [VoiceIDClientTypes.FraudsterRegistrationJobSummary]?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?

    public init (
        jobSummaries: [VoiceIDClientTypes.FraudsterRegistrationJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobSummaries = jobSummaries
        self.nextToken = nextToken
    }
}

struct ListFraudsterRegistrationJobsOutputResponseBody: Swift.Equatable {
    let jobSummaries: [VoiceIDClientTypes.FraudsterRegistrationJobSummary]?
    let nextToken: Swift.String?
}

extension ListFraudsterRegistrationJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobSummaries = "JobSummaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobSummariesContainer = try containerValues.decodeIfPresent([VoiceIDClientTypes.FraudsterRegistrationJobSummary?].self, forKey: .jobSummaries)
        var jobSummariesDecoded0:[VoiceIDClientTypes.FraudsterRegistrationJobSummary]? = nil
        if let jobSummariesContainer = jobSummariesContainer {
            jobSummariesDecoded0 = [VoiceIDClientTypes.FraudsterRegistrationJobSummary]()
            for structure0 in jobSummariesContainer {
                if let structure0 = structure0 {
                    jobSummariesDecoded0?.append(structure0)
                }
            }
        }
        jobSummaries = jobSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSpeakerEnrollmentJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case jobStatus = "JobStatus"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let jobStatus = self.jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSpeakerEnrollmentJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSpeakerEnrollmentJobsInput: Swift.Equatable {
    /// The identifier of the domain containing the speaker enrollment jobs.
    /// This member is required.
    public var domainId: Swift.String?
    /// Provides the status of your speaker enrollment Job.
    public var jobStatus: VoiceIDClientTypes.SpeakerEnrollmentJobStatus?
    /// The maximum number of results that are returned per call. You can use NextToken to obtain further pages of results. The default is 100; the maximum allowed page size is also 100.
    public var maxResults: Swift.Int?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        jobStatus: VoiceIDClientTypes.SpeakerEnrollmentJobStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.jobStatus = jobStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSpeakerEnrollmentJobsInputBody: Swift.Equatable {
    let domainId: Swift.String?
    let jobStatus: VoiceIDClientTypes.SpeakerEnrollmentJobStatus?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListSpeakerEnrollmentJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case jobStatus = "JobStatus"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.SpeakerEnrollmentJobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSpeakerEnrollmentJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSpeakerEnrollmentJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSpeakerEnrollmentJobsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSpeakerEnrollmentJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSpeakerEnrollmentJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobSummaries = output.jobSummaries
            self.nextToken = output.nextToken
        } else {
            self.jobSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListSpeakerEnrollmentJobsOutputResponse: Swift.Equatable {
    /// A list containing details about each specified speaker enrollment job.
    public var jobSummaries: [VoiceIDClientTypes.SpeakerEnrollmentJobSummary]?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?

    public init (
        jobSummaries: [VoiceIDClientTypes.SpeakerEnrollmentJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobSummaries = jobSummaries
        self.nextToken = nextToken
    }
}

struct ListSpeakerEnrollmentJobsOutputResponseBody: Swift.Equatable {
    let jobSummaries: [VoiceIDClientTypes.SpeakerEnrollmentJobSummary]?
    let nextToken: Swift.String?
}

extension ListSpeakerEnrollmentJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobSummaries = "JobSummaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobSummariesContainer = try containerValues.decodeIfPresent([VoiceIDClientTypes.SpeakerEnrollmentJobSummary?].self, forKey: .jobSummaries)
        var jobSummariesDecoded0:[VoiceIDClientTypes.SpeakerEnrollmentJobSummary]? = nil
        if let jobSummariesContainer = jobSummariesContainer {
            jobSummariesDecoded0 = [VoiceIDClientTypes.SpeakerEnrollmentJobSummary]()
            for structure0 in jobSummariesContainer {
                if let structure0 = structure0 {
                    jobSummariesDecoded0?.append(structure0)
                }
            }
        }
        jobSummaries = jobSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSpeakersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSpeakersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSpeakersInput: Swift.Equatable {
    /// The identifier of the domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The maximum number of results that are returned per call. You can use NextToken to obtain further pages of results. The default is 100; the maximum allowed page size is also 100.
    public var maxResults: Swift.Int?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSpeakersInputBody: Swift.Equatable {
    let domainId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListSpeakersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSpeakersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSpeakersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSpeakersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSpeakersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSpeakersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.speakerSummaries = output.speakerSummaries
        } else {
            self.nextToken = nil
            self.speakerSummaries = nil
        }
    }
}

public struct ListSpeakersOutputResponse: Swift.Equatable {
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?
    /// A list containing details about each speaker in the Amazon Web Services account.
    public var speakerSummaries: [VoiceIDClientTypes.SpeakerSummary]?

    public init (
        nextToken: Swift.String? = nil,
        speakerSummaries: [VoiceIDClientTypes.SpeakerSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.speakerSummaries = speakerSummaries
    }
}

struct ListSpeakersOutputResponseBody: Swift.Equatable {
    let speakerSummaries: [VoiceIDClientTypes.SpeakerSummary]?
    let nextToken: Swift.String?
}

extension ListSpeakersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case speakerSummaries = "SpeakerSummaries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let speakerSummariesContainer = try containerValues.decodeIfPresent([VoiceIDClientTypes.SpeakerSummary?].self, forKey: .speakerSummaries)
        var speakerSummariesDecoded0:[VoiceIDClientTypes.SpeakerSummary]? = nil
        if let speakerSummariesContainer = speakerSummariesContainer {
            speakerSummariesDecoded0 = [VoiceIDClientTypes.SpeakerSummary]()
            for structure0 in speakerSummariesContainer {
                if let structure0 = structure0 {
                    speakerSummariesDecoded0?.append(structure0)
                }
            }
        }
        speakerSummaries = speakerSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Voice ID resource for which you want to list the tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The list of tags associated with the specified resource.
    public var tags: [VoiceIDClientTypes.Tag]?

    public init (
        tags: [VoiceIDClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [VoiceIDClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([VoiceIDClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[VoiceIDClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [VoiceIDClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension OptOutSpeakerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OptOutSpeakerInput(domainId: \(Swift.String(describing: domainId)), speakerId: \"CONTENT_REDACTED\")"}
}

extension OptOutSpeakerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case speakerId = "SpeakerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let speakerId = self.speakerId {
            try encodeContainer.encode(speakerId, forKey: .speakerId)
        }
    }
}

extension OptOutSpeakerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct OptOutSpeakerInput: Swift.Equatable {
    /// The identifier of the domain containing the speaker.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the speaker you want opted-out.
    /// This member is required.
    public var speakerId: Swift.String?

    public init (
        domainId: Swift.String? = nil,
        speakerId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.speakerId = speakerId
    }
}

struct OptOutSpeakerInputBody: Swift.Equatable {
    let domainId: Swift.String?
    let speakerId: Swift.String?
}

extension OptOutSpeakerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case speakerId = "SpeakerId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let speakerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .speakerId)
        speakerId = speakerIdDecoded
    }
}

extension OptOutSpeakerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension OptOutSpeakerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum OptOutSpeakerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension OptOutSpeakerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: OptOutSpeakerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.speaker = output.speaker
        } else {
            self.speaker = nil
        }
    }
}

public struct OptOutSpeakerOutputResponse: Swift.Equatable {
    /// Details about the opted-out speaker.
    public var speaker: VoiceIDClientTypes.Speaker?

    public init (
        speaker: VoiceIDClientTypes.Speaker? = nil
    )
    {
        self.speaker = speaker
    }
}

struct OptOutSpeakerOutputResponseBody: Swift.Equatable {
    let speaker: VoiceIDClientTypes.Speaker?
}

extension OptOutSpeakerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case speaker = "Speaker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let speakerDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.Speaker.self, forKey: .speaker)
        speaker = speakerDecoded
    }
}

extension VoiceIDClientTypes.OutputDataConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId = "KmsKeyId"
        case s3Uri = "S3Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let s3Uri = self.s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension VoiceIDClientTypes {
    /// The configuration containing output file information for a batch job.
    public struct OutputDataConfig: Swift.Equatable {
        /// The identifier of the KMS key you want Voice ID to use to encrypt the output file of a speaker enrollment job/fraudster registration job.
        public var kmsKeyId: Swift.String?
        /// The S3 path of the folder where Voice ID writes the job output file. It has a *.out extension. For example, if the input file name is input-file.json and the output folder path is s3://output-bucket/output-folder, the full output file path is s3://output-bucket/output-folder/job-Id/input-file.json.out.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init (
            kmsKeyId: Swift.String? = nil,
            s3Uri: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.s3Uri = s3Uri
        }
    }

}

extension VoiceIDClientTypes.RegistrationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case duplicateRegistrationAction = "DuplicateRegistrationAction"
        case fraudsterSimilarityThreshold = "FraudsterSimilarityThreshold"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let duplicateRegistrationAction = self.duplicateRegistrationAction {
            try encodeContainer.encode(duplicateRegistrationAction.rawValue, forKey: .duplicateRegistrationAction)
        }
        if let fraudsterSimilarityThreshold = self.fraudsterSimilarityThreshold {
            try encodeContainer.encode(fraudsterSimilarityThreshold, forKey: .fraudsterSimilarityThreshold)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let duplicateRegistrationActionDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.DuplicateRegistrationAction.self, forKey: .duplicateRegistrationAction)
        duplicateRegistrationAction = duplicateRegistrationActionDecoded
        let fraudsterSimilarityThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fraudsterSimilarityThreshold)
        fraudsterSimilarityThreshold = fraudsterSimilarityThresholdDecoded
    }
}

extension VoiceIDClientTypes {
    /// The configuration defining the action to take when a duplicate fraudster is detected, and the similarity threshold to use for detecting a duplicate fraudster during a batch fraudster registration job.
    public struct RegistrationConfig: Swift.Equatable {
        /// The action to take when a fraudster is identified as a duplicate. The default action is SKIP, which skips registering the duplicate fraudster. Setting the value to REGISTER_AS_NEW always registers a new fraudster into the specified domain.
        public var duplicateRegistrationAction: VoiceIDClientTypes.DuplicateRegistrationAction?
        /// The minimum similarity score between the new and old fraudsters in order to consider the new fraudster a duplicate.
        public var fraudsterSimilarityThreshold: Swift.Int?

        public init (
            duplicateRegistrationAction: VoiceIDClientTypes.DuplicateRegistrationAction? = nil,
            fraudsterSimilarityThreshold: Swift.Int? = nil
        )
        {
            self.duplicateRegistrationAction = duplicateRegistrationAction
            self.fraudsterSimilarityThreshold = fraudsterSimilarityThreshold
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource cannot be found. Check the ResourceType and error message for more details.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The type of resource which cannot not be found. Possible types are BATCH_JOB, COMPLIANCE_CONSENT, DOMAIN, FRAUDSTER, SESSION and SPEAKER.
    public var resourceType: VoiceIDClientTypes.ResourceType?

    public init (
        message: Swift.String? = nil,
        resourceType: VoiceIDClientTypes.ResourceType? = nil
    )
    {
        self.message = message
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: VoiceIDClientTypes.ResourceType?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension VoiceIDClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case batchJob
        case complianceConsent
        case domain
        case fraudster
        case session
        case speaker
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .batchJob,
                .complianceConsent,
                .domain,
                .fraudster,
                .session,
                .speaker,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .batchJob: return "BATCH_JOB"
            case .complianceConsent: return "COMPLIANCE_CONSENT"
            case .domain: return "DOMAIN"
            case .fraudster: return "FRAUDSTER"
            case .session: return "SESSION"
            case .speaker: return "SPEAKER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIDClientTypes.ServerSideEncryptionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId = "KmsKeyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension VoiceIDClientTypes {
    /// The configuration containing information about the customer managed key used for encrypting customer data.
    public struct ServerSideEncryptionConfiguration: Swift.Equatable {
        /// The identifier of the KMS key to use to encrypt data stored by Voice ID. Voice ID doesn't support asymmetric customer managed keys.
        /// This member is required.
        public var kmsKeyId: Swift.String?

        public init (
            kmsKeyId: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
        }
    }

}

extension VoiceIDClientTypes.ServerSideEncryptionUpdateDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case oldKmsKeyId = "OldKmsKeyId"
        case updateStatus = "UpdateStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let oldKmsKeyId = self.oldKmsKeyId {
            try encodeContainer.encode(oldKmsKeyId, forKey: .oldKmsKeyId)
        }
        if let updateStatus = self.updateStatus {
            try encodeContainer.encode(updateStatus.rawValue, forKey: .updateStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oldKmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .oldKmsKeyId)
        oldKmsKeyId = oldKmsKeyIdDecoded
        let updateStatusDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.ServerSideEncryptionUpdateStatus.self, forKey: .updateStatus)
        updateStatus = updateStatusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VoiceIDClientTypes {
    /// Details about the most recent server-side encryption configuration update. When the server-side encryption configuration is changed, dependency on the old KMS key is removed through an asynchronous process. When this update is complete, the domain’s data can only be accessed using the new KMS key.
    public struct ServerSideEncryptionUpdateDetails: Swift.Equatable {
        /// Message explaining the current UpdateStatus. When the UpdateStatus is FAILED, this message explains the cause of the failure.
        public var message: Swift.String?
        /// The previous KMS key ID the domain was encrypted with, before ServerSideEncryptionConfiguration was updated to a new KMS key ID.
        public var oldKmsKeyId: Swift.String?
        /// Status of the server-side encryption update. During an update, if there is an issue with the domain's current or old KMS key ID, such as an inaccessible or disabled key, then the status is FAILED. In order to resolve this, the key needs to be made accessible, and then an UpdateDomain call with the existing server-side encryption configuration will re-attempt this update process.
        public var updateStatus: VoiceIDClientTypes.ServerSideEncryptionUpdateStatus?

        public init (
            message: Swift.String? = nil,
            oldKmsKeyId: Swift.String? = nil,
            updateStatus: VoiceIDClientTypes.ServerSideEncryptionUpdateStatus? = nil
        )
        {
            self.message = message
            self.oldKmsKeyId = oldKmsKeyId
            self.updateStatus = updateStatus
        }
    }

}

extension VoiceIDClientTypes {
    public enum ServerSideEncryptionUpdateStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ServerSideEncryptionUpdateStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServerSideEncryptionUpdateStatus(rawValue: rawValue) ?? ServerSideEncryptionUpdateStatus.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request exceeded the service quota. Refer to [Voice ID Service Quotas](https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html#voiceid-quotas) and try your request again.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VoiceIDClientTypes.Speaker: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case customerSpeakerId = "CustomerSpeakerId"
        case domainId = "DomainId"
        case generatedSpeakerId = "GeneratedSpeakerId"
        case lastAccessedAt = "LastAccessedAt"
        case status = "Status"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let customerSpeakerId = self.customerSpeakerId {
            try encodeContainer.encode(customerSpeakerId, forKey: .customerSpeakerId)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let generatedSpeakerId = self.generatedSpeakerId {
            try encodeContainer.encode(generatedSpeakerId, forKey: .generatedSpeakerId)
        }
        if let lastAccessedAt = self.lastAccessedAt {
            try encodeContainer.encodeTimestamp(lastAccessedAt, format: .epochSeconds, forKey: .lastAccessedAt)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let customerSpeakerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerSpeakerId)
        customerSpeakerId = customerSpeakerIdDecoded
        let generatedSpeakerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedSpeakerId)
        generatedSpeakerId = generatedSpeakerIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.SpeakerStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let lastAccessedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastAccessedAt)
        lastAccessedAt = lastAccessedAtDecoded
    }
}

extension VoiceIDClientTypes.Speaker: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Speaker(createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), generatedSpeakerId: \(Swift.String(describing: generatedSpeakerId)), lastAccessedAt: \(Swift.String(describing: lastAccessedAt)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), customerSpeakerId: \"CONTENT_REDACTED\")"}
}

extension VoiceIDClientTypes {
    /// Contains all the information about a speaker.
    public struct Speaker: Swift.Equatable {
        /// A timestamp showing when the speaker is created.
        public var createdAt: ClientRuntime.Date?
        /// The client-provided identifier for the speaker.
        public var customerSpeakerId: Swift.String?
        /// The identifier of the domain that contains the speaker.
        public var domainId: Swift.String?
        /// The service-generated identifier for the speaker.
        public var generatedSpeakerId: Swift.String?
        /// The timestamp when the speaker was last accessed for enrollment, re-enrollment or a successful authentication. This timestamp is accurate to one hour.
        public var lastAccessedAt: ClientRuntime.Date?
        /// The current status of the speaker.
        public var status: VoiceIDClientTypes.SpeakerStatus?
        /// A timestamp showing the speaker's last update.
        public var updatedAt: ClientRuntime.Date?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            customerSpeakerId: Swift.String? = nil,
            domainId: Swift.String? = nil,
            generatedSpeakerId: Swift.String? = nil,
            lastAccessedAt: ClientRuntime.Date? = nil,
            status: VoiceIDClientTypes.SpeakerStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.customerSpeakerId = customerSpeakerId
            self.domainId = domainId
            self.generatedSpeakerId = generatedSpeakerId
            self.lastAccessedAt = lastAccessedAt
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension VoiceIDClientTypes.SpeakerEnrollmentJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case domainId = "DomainId"
        case endedAt = "EndedAt"
        case enrollmentConfig = "EnrollmentConfig"
        case failureDetails = "FailureDetails"
        case inputDataConfig = "InputDataConfig"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobProgress = "JobProgress"
        case jobStatus = "JobStatus"
        case outputDataConfig = "OutputDataConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let dataAccessRoleArn = self.dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let endedAt = self.endedAt {
            try encodeContainer.encodeTimestamp(endedAt, format: .epochSeconds, forKey: .endedAt)
        }
        if let enrollmentConfig = self.enrollmentConfig {
            try encodeContainer.encode(enrollmentConfig, forKey: .enrollmentConfig)
        }
        if let failureDetails = self.failureDetails {
            try encodeContainer.encode(failureDetails, forKey: .failureDetails)
        }
        if let inputDataConfig = self.inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobProgress = self.jobProgress {
            try encodeContainer.encode(jobProgress, forKey: .jobProgress)
        }
        if let jobStatus = self.jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let outputDataConfig = self.outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.SpeakerEnrollmentJobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let enrollmentConfigDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.EnrollmentConfig.self, forKey: .enrollmentConfig)
        enrollmentConfig = enrollmentConfigDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let endedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endedAt)
        endedAt = endedAtDecoded
        let failureDetailsDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.FailureDetails.self, forKey: .failureDetails)
        failureDetails = failureDetailsDecoded
        let jobProgressDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.JobProgress.self, forKey: .jobProgress)
        jobProgress = jobProgressDecoded
    }
}

extension VoiceIDClientTypes.SpeakerEnrollmentJob: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SpeakerEnrollmentJob(createdAt: \(Swift.String(describing: createdAt)), dataAccessRoleArn: \(Swift.String(describing: dataAccessRoleArn)), domainId: \(Swift.String(describing: domainId)), endedAt: \(Swift.String(describing: endedAt)), enrollmentConfig: \(Swift.String(describing: enrollmentConfig)), failureDetails: \(Swift.String(describing: failureDetails)), inputDataConfig: \(Swift.String(describing: inputDataConfig)), jobId: \(Swift.String(describing: jobId)), jobProgress: \(Swift.String(describing: jobProgress)), jobStatus: \(Swift.String(describing: jobStatus)), outputDataConfig: \(Swift.String(describing: outputDataConfig)), jobName: \"CONTENT_REDACTED\")"}
}

extension VoiceIDClientTypes {
    /// Contains all the information about a speaker enrollment job.
    public struct SpeakerEnrollmentJob: Swift.Equatable {
        /// A timestamp showing the creation of the speaker enrollment job.
        public var createdAt: ClientRuntime.Date?
        /// The IAM role Amazon Resource Name (ARN) that grants Voice ID permissions to access customer's buckets to read the input manifest file and write the job output file.
        public var dataAccessRoleArn: Swift.String?
        /// The identifier of the domain that contains the speaker enrollment job.
        public var domainId: Swift.String?
        /// A timestamp showing when the speaker enrollment job ended.
        public var endedAt: ClientRuntime.Date?
        /// The configuration that defines the action to take when the speaker is already enrolled in Voice ID, and the FraudDetectionConfig to use.
        public var enrollmentConfig: VoiceIDClientTypes.EnrollmentConfig?
        /// Contains details that are populated when an entire batch job fails. In cases of individual registration job failures, the batch job as a whole doesn't fail; it is completed with a JobStatus of COMPLETED_WITH_ERRORS. You can use the job output file to identify the individual registration requests that failed.
        public var failureDetails: VoiceIDClientTypes.FailureDetails?
        /// The input data config containing an S3 URI for the input manifest file that contains the list of speaker enrollment job requests.
        public var inputDataConfig: VoiceIDClientTypes.InputDataConfig?
        /// The service-generated identifier for the speaker enrollment job.
        public var jobId: Swift.String?
        /// The client-provided name for the speaker enrollment job.
        public var jobName: Swift.String?
        /// Provides details on job progress. This field shows the completed percentage of registration requests listed in the input file.
        public var jobProgress: VoiceIDClientTypes.JobProgress?
        /// The current status of the speaker enrollment job.
        public var jobStatus: VoiceIDClientTypes.SpeakerEnrollmentJobStatus?
        /// The output data config containing the S3 location where Voice ID writes the job output file; you must also include a KMS key ID to encrypt the file.
        public var outputDataConfig: VoiceIDClientTypes.OutputDataConfig?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            dataAccessRoleArn: Swift.String? = nil,
            domainId: Swift.String? = nil,
            endedAt: ClientRuntime.Date? = nil,
            enrollmentConfig: VoiceIDClientTypes.EnrollmentConfig? = nil,
            failureDetails: VoiceIDClientTypes.FailureDetails? = nil,
            inputDataConfig: VoiceIDClientTypes.InputDataConfig? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobProgress: VoiceIDClientTypes.JobProgress? = nil,
            jobStatus: VoiceIDClientTypes.SpeakerEnrollmentJobStatus? = nil,
            outputDataConfig: VoiceIDClientTypes.OutputDataConfig? = nil
        )
        {
            self.createdAt = createdAt
            self.dataAccessRoleArn = dataAccessRoleArn
            self.domainId = domainId
            self.endedAt = endedAt
            self.enrollmentConfig = enrollmentConfig
            self.failureDetails = failureDetails
            self.inputDataConfig = inputDataConfig
            self.jobId = jobId
            self.jobName = jobName
            self.jobProgress = jobProgress
            self.jobStatus = jobStatus
            self.outputDataConfig = outputDataConfig
        }
    }

}

extension VoiceIDClientTypes {
    public enum SpeakerEnrollmentJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case completedWithErrors
        case failed
        case inProgress
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [SpeakerEnrollmentJobStatus] {
            return [
                .completed,
                .completedWithErrors,
                .failed,
                .inProgress,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .completedWithErrors: return "COMPLETED_WITH_ERRORS"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SpeakerEnrollmentJobStatus(rawValue: rawValue) ?? SpeakerEnrollmentJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIDClientTypes.SpeakerEnrollmentJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case domainId = "DomainId"
        case endedAt = "EndedAt"
        case failureDetails = "FailureDetails"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobProgress = "JobProgress"
        case jobStatus = "JobStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let endedAt = self.endedAt {
            try encodeContainer.encodeTimestamp(endedAt, format: .epochSeconds, forKey: .endedAt)
        }
        if let failureDetails = self.failureDetails {
            try encodeContainer.encode(failureDetails, forKey: .failureDetails)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobProgress = self.jobProgress {
            try encodeContainer.encode(jobProgress, forKey: .jobProgress)
        }
        if let jobStatus = self.jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.SpeakerEnrollmentJobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let endedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endedAt)
        endedAt = endedAtDecoded
        let failureDetailsDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.FailureDetails.self, forKey: .failureDetails)
        failureDetails = failureDetailsDecoded
        let jobProgressDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.JobProgress.self, forKey: .jobProgress)
        jobProgress = jobProgressDecoded
    }
}

extension VoiceIDClientTypes.SpeakerEnrollmentJobSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SpeakerEnrollmentJobSummary(createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), endedAt: \(Swift.String(describing: endedAt)), failureDetails: \(Swift.String(describing: failureDetails)), jobId: \(Swift.String(describing: jobId)), jobProgress: \(Swift.String(describing: jobProgress)), jobStatus: \(Swift.String(describing: jobStatus)), jobName: \"CONTENT_REDACTED\")"}
}

extension VoiceIDClientTypes {
    /// Contains a summary of information about a speaker enrollment job.
    public struct SpeakerEnrollmentJobSummary: Swift.Equatable {
        /// A timestamp showing the creation time of the speaker enrollment job.
        public var createdAt: ClientRuntime.Date?
        /// The identifier of the domain that contains the speaker enrollment job.
        public var domainId: Swift.String?
        /// A timestamp showing when the speaker enrollment job ended.
        public var endedAt: ClientRuntime.Date?
        /// Contains details that are populated when an entire batch job fails. In cases of individual registration job failures, the batch job as a whole doesn't fail; it is completed with a JobStatus of COMPLETED_WITH_ERRORS. You can use the job output file to identify the individual registration requests that failed.
        public var failureDetails: VoiceIDClientTypes.FailureDetails?
        /// The service-generated identifier for the speaker enrollment job.
        public var jobId: Swift.String?
        /// The client-provided name for the speaker enrollment job.
        public var jobName: Swift.String?
        /// Provides details regarding job progress. This field shows the completed percentage of enrollment requests listed in the input file.
        public var jobProgress: VoiceIDClientTypes.JobProgress?
        /// The current status of the speaker enrollment job.
        public var jobStatus: VoiceIDClientTypes.SpeakerEnrollmentJobStatus?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            domainId: Swift.String? = nil,
            endedAt: ClientRuntime.Date? = nil,
            failureDetails: VoiceIDClientTypes.FailureDetails? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobProgress: VoiceIDClientTypes.JobProgress? = nil,
            jobStatus: VoiceIDClientTypes.SpeakerEnrollmentJobStatus? = nil
        )
        {
            self.createdAt = createdAt
            self.domainId = domainId
            self.endedAt = endedAt
            self.failureDetails = failureDetails
            self.jobId = jobId
            self.jobName = jobName
            self.jobProgress = jobProgress
            self.jobStatus = jobStatus
        }
    }

}

extension VoiceIDClientTypes {
    public enum SpeakerStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enrolled
        case expired
        case optedOut
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [SpeakerStatus] {
            return [
                .enrolled,
                .expired,
                .optedOut,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enrolled: return "ENROLLED"
            case .expired: return "EXPIRED"
            case .optedOut: return "OPTED_OUT"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SpeakerStatus(rawValue: rawValue) ?? SpeakerStatus.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIDClientTypes.SpeakerSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case customerSpeakerId = "CustomerSpeakerId"
        case domainId = "DomainId"
        case generatedSpeakerId = "GeneratedSpeakerId"
        case lastAccessedAt = "LastAccessedAt"
        case status = "Status"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let customerSpeakerId = self.customerSpeakerId {
            try encodeContainer.encode(customerSpeakerId, forKey: .customerSpeakerId)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let generatedSpeakerId = self.generatedSpeakerId {
            try encodeContainer.encode(generatedSpeakerId, forKey: .generatedSpeakerId)
        }
        if let lastAccessedAt = self.lastAccessedAt {
            try encodeContainer.encodeTimestamp(lastAccessedAt, format: .epochSeconds, forKey: .lastAccessedAt)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let customerSpeakerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerSpeakerId)
        customerSpeakerId = customerSpeakerIdDecoded
        let generatedSpeakerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedSpeakerId)
        generatedSpeakerId = generatedSpeakerIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.SpeakerStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let lastAccessedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastAccessedAt)
        lastAccessedAt = lastAccessedAtDecoded
    }
}

extension VoiceIDClientTypes.SpeakerSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SpeakerSummary(createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), generatedSpeakerId: \(Swift.String(describing: generatedSpeakerId)), lastAccessedAt: \(Swift.String(describing: lastAccessedAt)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), customerSpeakerId: \"CONTENT_REDACTED\")"}
}

extension VoiceIDClientTypes {
    /// Contains a summary of information about a speaker.
    public struct SpeakerSummary: Swift.Equatable {
        /// A timestamp showing the speaker's creation time.
        public var createdAt: ClientRuntime.Date?
        /// The client-provided identifier for the speaker.
        public var customerSpeakerId: Swift.String?
        /// The identifier of the domain that contains the speaker.
        public var domainId: Swift.String?
        /// The service-generated identifier for the speaker.
        public var generatedSpeakerId: Swift.String?
        /// The timestamp when the speaker was last accessed for enrollment, re-enrollment or a successful authentication. This timestamp is accurate to one hour.
        public var lastAccessedAt: ClientRuntime.Date?
        /// The current status of the speaker.
        public var status: VoiceIDClientTypes.SpeakerStatus?
        /// A timestamp showing the speaker's last update.
        public var updatedAt: ClientRuntime.Date?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            customerSpeakerId: Swift.String? = nil,
            domainId: Swift.String? = nil,
            generatedSpeakerId: Swift.String? = nil,
            lastAccessedAt: ClientRuntime.Date? = nil,
            status: VoiceIDClientTypes.SpeakerStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.customerSpeakerId = customerSpeakerId
            self.domainId = domainId
            self.generatedSpeakerId = generatedSpeakerId
            self.lastAccessedAt = lastAccessedAt
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension StartFraudsterRegistrationJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartFraudsterRegistrationJobInput(clientToken: \(Swift.String(describing: clientToken)), dataAccessRoleArn: \(Swift.String(describing: dataAccessRoleArn)), domainId: \(Swift.String(describing: domainId)), inputDataConfig: \(Swift.String(describing: inputDataConfig)), outputDataConfig: \(Swift.String(describing: outputDataConfig)), registrationConfig: \(Swift.String(describing: registrationConfig)), jobName: \"CONTENT_REDACTED\")"}
}

extension StartFraudsterRegistrationJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case domainId = "DomainId"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case outputDataConfig = "OutputDataConfig"
        case registrationConfig = "RegistrationConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dataAccessRoleArn = self.dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let inputDataConfig = self.inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let outputDataConfig = self.outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let registrationConfig = self.registrationConfig {
            try encodeContainer.encode(registrationConfig, forKey: .registrationConfig)
        }
    }
}

extension StartFraudsterRegistrationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartFraudsterRegistrationJobInput: Swift.Equatable {
    /// The idempotency token for starting a new fraudster registration job. If not provided, Amazon Web Services SDK populates this field.
    public var clientToken: Swift.String?
    /// The IAM role Amazon Resource Name (ARN) that grants Voice ID permissions to access customer's buckets to read the input manifest file and write the Job output file. Refer to the [Create and edit a fraudster watchlist](https://docs.aws.amazon.com/connect/latest/adminguide/voiceid-fraudster-watchlist.html) documentation for the permissions needed in this role.
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// The identifier of the domain containing the fraudster registration job and in which the fraudsters are registered.
    /// This member is required.
    public var domainId: Swift.String?
    /// The input data config containing an S3 URI for the input manifest file that contains the list of fraudster registration requests.
    /// This member is required.
    public var inputDataConfig: VoiceIDClientTypes.InputDataConfig?
    /// The name of the new fraudster registration job.
    public var jobName: Swift.String?
    /// The output data config containing the S3 location where Voice ID writes the job output file; you must also include a KMS key ID to encrypt the file.
    /// This member is required.
    public var outputDataConfig: VoiceIDClientTypes.OutputDataConfig?
    /// The registration config containing details such as the action to take when a duplicate fraudster is detected, and the similarity threshold to use for detecting a duplicate fraudster.
    public var registrationConfig: VoiceIDClientTypes.RegistrationConfig?

    public init (
        clientToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        domainId: Swift.String? = nil,
        inputDataConfig: VoiceIDClientTypes.InputDataConfig? = nil,
        jobName: Swift.String? = nil,
        outputDataConfig: VoiceIDClientTypes.OutputDataConfig? = nil,
        registrationConfig: VoiceIDClientTypes.RegistrationConfig? = nil
    )
    {
        self.clientToken = clientToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.domainId = domainId
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.outputDataConfig = outputDataConfig
        self.registrationConfig = registrationConfig
    }
}

struct StartFraudsterRegistrationJobInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let jobName: Swift.String?
    let domainId: Swift.String?
    let dataAccessRoleArn: Swift.String?
    let registrationConfig: VoiceIDClientTypes.RegistrationConfig?
    let inputDataConfig: VoiceIDClientTypes.InputDataConfig?
    let outputDataConfig: VoiceIDClientTypes.OutputDataConfig?
}

extension StartFraudsterRegistrationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case domainId = "DomainId"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case outputDataConfig = "OutputDataConfig"
        case registrationConfig = "RegistrationConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let registrationConfigDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.RegistrationConfig.self, forKey: .registrationConfig)
        registrationConfig = registrationConfigDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
    }
}

extension StartFraudsterRegistrationJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartFraudsterRegistrationJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartFraudsterRegistrationJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartFraudsterRegistrationJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartFraudsterRegistrationJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct StartFraudsterRegistrationJobOutputResponse: Swift.Equatable {
    /// Details about the started fraudster registration job.
    public var job: VoiceIDClientTypes.FraudsterRegistrationJob?

    public init (
        job: VoiceIDClientTypes.FraudsterRegistrationJob? = nil
    )
    {
        self.job = job
    }
}

struct StartFraudsterRegistrationJobOutputResponseBody: Swift.Equatable {
    let job: VoiceIDClientTypes.FraudsterRegistrationJob?
}

extension StartFraudsterRegistrationJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job = "Job"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.FraudsterRegistrationJob.self, forKey: .job)
        job = jobDecoded
    }
}

extension StartSpeakerEnrollmentJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartSpeakerEnrollmentJobInput(clientToken: \(Swift.String(describing: clientToken)), dataAccessRoleArn: \(Swift.String(describing: dataAccessRoleArn)), domainId: \(Swift.String(describing: domainId)), enrollmentConfig: \(Swift.String(describing: enrollmentConfig)), inputDataConfig: \(Swift.String(describing: inputDataConfig)), outputDataConfig: \(Swift.String(describing: outputDataConfig)), jobName: \"CONTENT_REDACTED\")"}
}

extension StartSpeakerEnrollmentJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case domainId = "DomainId"
        case enrollmentConfig = "EnrollmentConfig"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case outputDataConfig = "OutputDataConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dataAccessRoleArn = self.dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let enrollmentConfig = self.enrollmentConfig {
            try encodeContainer.encode(enrollmentConfig, forKey: .enrollmentConfig)
        }
        if let inputDataConfig = self.inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let outputDataConfig = self.outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
    }
}

extension StartSpeakerEnrollmentJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartSpeakerEnrollmentJobInput: Swift.Equatable {
    /// The idempotency token for starting a new speaker enrollment Job. If not provided, Amazon Web Services SDK populates this field.
    public var clientToken: Swift.String?
    /// The IAM role Amazon Resource Name (ARN) that grants Voice ID permissions to access customer's buckets to read the input manifest file and write the job output file. Refer to [Batch enrollment using audio data from prior calls](https://docs.aws.amazon.com/connect/latest/adminguide/voiceid-batch-enrollment.html) for the permissions needed in this role.
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// The identifier of the domain that contains the speaker enrollment job and in which the speakers are enrolled.
    /// This member is required.
    public var domainId: Swift.String?
    /// The enrollment config that contains details such as the action to take when a speaker is already enrolled in Voice ID or when a speaker is identified as a fraudster.
    public var enrollmentConfig: VoiceIDClientTypes.EnrollmentConfig?
    /// The input data config containing the S3 location for the input manifest file that contains the list of speaker enrollment requests.
    /// This member is required.
    public var inputDataConfig: VoiceIDClientTypes.InputDataConfig?
    /// A name for your speaker enrollment job.
    public var jobName: Swift.String?
    /// The output data config containing the S3 location where Voice ID writes the job output file; you must also include a KMS key ID to encrypt the file.
    /// This member is required.
    public var outputDataConfig: VoiceIDClientTypes.OutputDataConfig?

    public init (
        clientToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        domainId: Swift.String? = nil,
        enrollmentConfig: VoiceIDClientTypes.EnrollmentConfig? = nil,
        inputDataConfig: VoiceIDClientTypes.InputDataConfig? = nil,
        jobName: Swift.String? = nil,
        outputDataConfig: VoiceIDClientTypes.OutputDataConfig? = nil
    )
    {
        self.clientToken = clientToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.domainId = domainId
        self.enrollmentConfig = enrollmentConfig
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.outputDataConfig = outputDataConfig
    }
}

struct StartSpeakerEnrollmentJobInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let jobName: Swift.String?
    let domainId: Swift.String?
    let dataAccessRoleArn: Swift.String?
    let enrollmentConfig: VoiceIDClientTypes.EnrollmentConfig?
    let inputDataConfig: VoiceIDClientTypes.InputDataConfig?
    let outputDataConfig: VoiceIDClientTypes.OutputDataConfig?
}

extension StartSpeakerEnrollmentJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case domainId = "DomainId"
        case enrollmentConfig = "EnrollmentConfig"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case outputDataConfig = "OutputDataConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let enrollmentConfigDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.EnrollmentConfig.self, forKey: .enrollmentConfig)
        enrollmentConfig = enrollmentConfigDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
    }
}

extension StartSpeakerEnrollmentJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartSpeakerEnrollmentJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartSpeakerEnrollmentJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartSpeakerEnrollmentJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartSpeakerEnrollmentJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct StartSpeakerEnrollmentJobOutputResponse: Swift.Equatable {
    /// Details about the started speaker enrollment job.
    public var job: VoiceIDClientTypes.SpeakerEnrollmentJob?

    public init (
        job: VoiceIDClientTypes.SpeakerEnrollmentJob? = nil
    )
    {
        self.job = job
    }
}

struct StartSpeakerEnrollmentJobOutputResponseBody: Swift.Equatable {
    let job: VoiceIDClientTypes.SpeakerEnrollmentJob?
}

extension StartSpeakerEnrollmentJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job = "Job"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.SpeakerEnrollmentJob.self, forKey: .job)
        job = jobDecoded
    }
}

extension VoiceIDClientTypes {
    public enum StreamingStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ended
        case ongoing
        case pendingConfiguration
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingStatus] {
            return [
                .ended,
                .ongoing,
                .pendingConfiguration,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ended: return "ENDED"
            case .ongoing: return "ONGOING"
            case .pendingConfiguration: return "PENDING_CONFIGURATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamingStatus(rawValue: rawValue) ?? StreamingStatus.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIDClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension VoiceIDClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \"CONTENT_REDACTED\", value: \"CONTENT_REDACTED\")"}
}

extension VoiceIDClientTypes {
    /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    public struct Tag: Swift.Equatable {
        /// The first part of a key:value pair that forms a tag associated with a given resource. For example, in the tag 'Department':'Sales', the key is 'Department'.
        /// This member is required.
        public var key: Swift.String?
        /// The second part of a key:value pair that forms a tag associated with a given resource. For example, in the tag 'Department':'Sales', the value is 'Sales'.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Voice ID resource you want to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tags to assign to the specified resource.
    /// This member is required.
    public var tags: [VoiceIDClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [VoiceIDClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [VoiceIDClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([VoiceIDClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[VoiceIDClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [VoiceIDClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling. Please slow down your request rate. Refer to [ Amazon Connect Voice ID Service API throttling quotas ](https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html##voiceid-api-quotas) and try your request again.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Voice ID resource you want to remove tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys you want to remove from the specified resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateDomainInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDomainInput(domainId: \(Swift.String(describing: domainId)), serverSideEncryptionConfiguration: \(Swift.String(describing: serverSideEncryptionConfiguration)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case domainId = "DomainId"
        case name = "Name"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverSideEncryptionConfiguration = self.serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
    }
}

extension UpdateDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateDomainInput: Swift.Equatable {
    /// A brief description of the domain.
    public var description: Swift.String?
    /// The identifier of the domain to be updated.
    /// This member is required.
    public var domainId: Swift.String?
    /// The name of the domain.
    /// This member is required.
    public var name: Swift.String?
    /// The configuration, containing the KMS key identifier, to be used by Voice ID for the server-side encryption of your data. Changing the domain's associated KMS key immediately triggers an asynchronous process to remove dependency on the old KMS key, such that the domain's data can only be accessed using the new KMS key. The domain's ServerSideEncryptionUpdateDetails contains the details for this process.
    /// This member is required.
    public var serverSideEncryptionConfiguration: VoiceIDClientTypes.ServerSideEncryptionConfiguration?

    public init (
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        name: Swift.String? = nil,
        serverSideEncryptionConfiguration: VoiceIDClientTypes.ServerSideEncryptionConfiguration? = nil
    )
    {
        self.description = description
        self.domainId = domainId
        self.name = name
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
    }
}

struct UpdateDomainInputBody: Swift.Equatable {
    let domainId: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let serverSideEncryptionConfiguration: VoiceIDClientTypes.ServerSideEncryptionConfiguration?
}

extension UpdateDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case domainId = "DomainId"
        case name = "Name"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
    }
}

extension UpdateDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDomainOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.domain = output.domain
        } else {
            self.domain = nil
        }
    }
}

public struct UpdateDomainOutputResponse: Swift.Equatable {
    /// Details about the updated domain
    public var domain: VoiceIDClientTypes.Domain?

    public init (
        domain: VoiceIDClientTypes.Domain? = nil
    )
    {
        self.domain = domain
    }
}

struct UpdateDomainOutputResponseBody: Swift.Equatable {
    let domain: VoiceIDClientTypes.Domain?
}

extension UpdateDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request failed one or more validations; check the error message for more details.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VoiceIDClientTypes.VoiceSpoofingRisk: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case riskScore = "RiskScore"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let riskScore = self.riskScore {
            try encodeContainer.encode(riskScore, forKey: .riskScore)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let riskScoreDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .riskScore)
        riskScore = riskScoreDecoded
    }
}

extension VoiceIDClientTypes {
    /// The details resulting from 'Voice Spoofing Risk' analysis of the speaker.
    public struct VoiceSpoofingRisk: Swift.Equatable {
        /// The score indicating the likelihood of speaker’s voice being spoofed.
        /// This member is required.
        public var riskScore: Swift.Int?

        public init (
            riskScore: Swift.Int? = nil
        )
        {
            self.riskScore = riskScore
        }
    }

}
