// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient permissions to perform this action. Check the error message and try again.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AssociateFraudsterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateFraudsterInput(domainId: \(Swift.String(describing: domainId)), watchlistId: \(Swift.String(describing: watchlistId)), fraudsterId: \"CONTENT_REDACTED\")"}
}

extension AssociateFraudsterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case fraudsterId = "FraudsterId"
        case watchlistId = "WatchlistId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let fraudsterId = self.fraudsterId {
            try encodeContainer.encode(fraudsterId, forKey: .fraudsterId)
        }
        if let watchlistId = self.watchlistId {
            try encodeContainer.encode(watchlistId, forKey: .watchlistId)
        }
    }
}

extension AssociateFraudsterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateFraudsterInput: Swift.Equatable {
    /// The identifier of the domain that contains the fraudster.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the fraudster to be associated with the watchlist.
    /// This member is required.
    public var fraudsterId: Swift.String?
    /// The identifier of the watchlist you want to associate with the fraudster.
    /// This member is required.
    public var watchlistId: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        fraudsterId: Swift.String? = nil,
        watchlistId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.fraudsterId = fraudsterId
        self.watchlistId = watchlistId
    }
}

struct AssociateFraudsterInputBody: Swift.Equatable {
    let domainId: Swift.String?
    let watchlistId: Swift.String?
    let fraudsterId: Swift.String?
}

extension AssociateFraudsterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case fraudsterId = "FraudsterId"
        case watchlistId = "WatchlistId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let watchlistIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .watchlistId)
        watchlistId = watchlistIdDecoded
        let fraudsterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fraudsterId)
        fraudsterId = fraudsterIdDecoded
    }
}

extension AssociateFraudsterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateFraudsterOutputBody = try responseDecoder.decode(responseBody: data)
            self.fraudster = output.fraudster
        } else {
            self.fraudster = nil
        }
    }
}

public struct AssociateFraudsterOutput: Swift.Equatable {
    /// Contains all the information about a fraudster.
    public var fraudster: VoiceIDClientTypes.Fraudster?

    public init(
        fraudster: VoiceIDClientTypes.Fraudster? = nil
    )
    {
        self.fraudster = fraudster
    }
}

struct AssociateFraudsterOutputBody: Swift.Equatable {
    let fraudster: VoiceIDClientTypes.Fraudster?
}

extension AssociateFraudsterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fraudster = "Fraudster"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fraudsterDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.Fraudster.self, forKey: .fraudster)
        fraudster = fraudsterDecoded
    }
}

enum AssociateFraudsterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension VoiceIDClientTypes.AuthenticationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptanceThreshold = "AcceptanceThreshold"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptanceThreshold = self.acceptanceThreshold {
            try encodeContainer.encode(acceptanceThreshold, forKey: .acceptanceThreshold)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptanceThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .acceptanceThreshold)
        acceptanceThreshold = acceptanceThresholdDecoded
    }
}

extension VoiceIDClientTypes {
    /// The configuration used to authenticate a speaker during a session.
    public struct AuthenticationConfiguration: Swift.Equatable {
        /// The minimum threshold needed to successfully authenticate a speaker.
        /// This member is required.
        public var acceptanceThreshold: Swift.Int?

        public init(
            acceptanceThreshold: Swift.Int? = nil
        )
        {
            self.acceptanceThreshold = acceptanceThreshold
        }
    }

}

extension VoiceIDClientTypes {
    public enum AuthenticationDecision: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accept
        case notEnoughSpeech
        case reject
        case speakerExpired
        case speakerIdNotProvided
        case speakerNotEnrolled
        case speakerOptedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationDecision] {
            return [
                .accept,
                .notEnoughSpeech,
                .reject,
                .speakerExpired,
                .speakerIdNotProvided,
                .speakerNotEnrolled,
                .speakerOptedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accept: return "ACCEPT"
            case .notEnoughSpeech: return "NOT_ENOUGH_SPEECH"
            case .reject: return "REJECT"
            case .speakerExpired: return "SPEAKER_EXPIRED"
            case .speakerIdNotProvided: return "SPEAKER_ID_NOT_PROVIDED"
            case .speakerNotEnrolled: return "SPEAKER_NOT_ENROLLED"
            case .speakerOptedOut: return "SPEAKER_OPTED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthenticationDecision(rawValue: rawValue) ?? AuthenticationDecision.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIDClientTypes.AuthenticationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioAggregationEndedAt = "AudioAggregationEndedAt"
        case audioAggregationStartedAt = "AudioAggregationStartedAt"
        case authenticationResultId = "AuthenticationResultId"
        case configuration = "Configuration"
        case customerSpeakerId = "CustomerSpeakerId"
        case decision = "Decision"
        case generatedSpeakerId = "GeneratedSpeakerId"
        case score = "Score"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioAggregationEndedAt = self.audioAggregationEndedAt {
            try encodeContainer.encodeTimestamp(audioAggregationEndedAt, format: .epochSeconds, forKey: .audioAggregationEndedAt)
        }
        if let audioAggregationStartedAt = self.audioAggregationStartedAt {
            try encodeContainer.encodeTimestamp(audioAggregationStartedAt, format: .epochSeconds, forKey: .audioAggregationStartedAt)
        }
        if let authenticationResultId = self.authenticationResultId {
            try encodeContainer.encode(authenticationResultId, forKey: .authenticationResultId)
        }
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let customerSpeakerId = self.customerSpeakerId {
            try encodeContainer.encode(customerSpeakerId, forKey: .customerSpeakerId)
        }
        if let decision = self.decision {
            try encodeContainer.encode(decision.rawValue, forKey: .decision)
        }
        if let generatedSpeakerId = self.generatedSpeakerId {
            try encodeContainer.encode(generatedSpeakerId, forKey: .generatedSpeakerId)
        }
        if let score = self.score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationResultIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authenticationResultId)
        authenticationResultId = authenticationResultIdDecoded
        let audioAggregationStartedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .audioAggregationStartedAt)
        audioAggregationStartedAt = audioAggregationStartedAtDecoded
        let audioAggregationEndedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .audioAggregationEndedAt)
        audioAggregationEndedAt = audioAggregationEndedAtDecoded
        let customerSpeakerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerSpeakerId)
        customerSpeakerId = customerSpeakerIdDecoded
        let generatedSpeakerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedSpeakerId)
        generatedSpeakerId = generatedSpeakerIdDecoded
        let decisionDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.AuthenticationDecision.self, forKey: .decision)
        decision = decisionDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .score)
        score = scoreDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.AuthenticationConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension VoiceIDClientTypes.AuthenticationResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AuthenticationResult(audioAggregationEndedAt: \(Swift.String(describing: audioAggregationEndedAt)), audioAggregationStartedAt: \(Swift.String(describing: audioAggregationStartedAt)), authenticationResultId: \(Swift.String(describing: authenticationResultId)), configuration: \(Swift.String(describing: configuration)), decision: \(Swift.String(describing: decision)), generatedSpeakerId: \(Swift.String(describing: generatedSpeakerId)), score: \(Swift.String(describing: score)), customerSpeakerId: \"CONTENT_REDACTED\")"}
}

extension VoiceIDClientTypes {
    /// The authentication result produced by Voice ID, processed against the current session state and streamed audio of the speaker.
    public struct AuthenticationResult: Swift.Equatable {
        /// A timestamp of when audio aggregation ended for this authentication result.
        public var audioAggregationEndedAt: ClientRuntime.Date?
        /// A timestamp of when audio aggregation started for this authentication result.
        public var audioAggregationStartedAt: ClientRuntime.Date?
        /// The unique identifier for this authentication result. Because there can be multiple authentications for a given session, this field helps to identify if the returned result is from a previous streaming activity or a new result. Note that in absence of any new streaming activity, AcceptanceThreshold changes, or SpeakerId changes, Voice ID always returns cached Authentication Result for this API.
        public var authenticationResultId: Swift.String?
        /// The AuthenticationConfiguration used to generate this authentication result.
        public var configuration: VoiceIDClientTypes.AuthenticationConfiguration?
        /// The client-provided identifier for the speaker whose authentication result is produced. Only present if a SpeakerId is provided for the session.
        public var customerSpeakerId: Swift.String?
        /// The authentication decision produced by Voice ID, processed against the current session state and streamed audio of the speaker.
        public var decision: VoiceIDClientTypes.AuthenticationDecision?
        /// The service-generated identifier for the speaker whose authentication result is produced.
        public var generatedSpeakerId: Swift.String?
        /// The authentication score for the speaker whose authentication result is produced. This value is only present if the authentication decision is either ACCEPT or REJECT.
        public var score: Swift.Int?

        public init(
            audioAggregationEndedAt: ClientRuntime.Date? = nil,
            audioAggregationStartedAt: ClientRuntime.Date? = nil,
            authenticationResultId: Swift.String? = nil,
            configuration: VoiceIDClientTypes.AuthenticationConfiguration? = nil,
            customerSpeakerId: Swift.String? = nil,
            decision: VoiceIDClientTypes.AuthenticationDecision? = nil,
            generatedSpeakerId: Swift.String? = nil,
            score: Swift.Int? = nil
        )
        {
            self.audioAggregationEndedAt = audioAggregationEndedAt
            self.audioAggregationStartedAt = audioAggregationStartedAt
            self.authenticationResultId = authenticationResultId
            self.configuration = configuration
            self.customerSpeakerId = customerSpeakerId
            self.decision = decision
            self.generatedSpeakerId = generatedSpeakerId
            self.score = score
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.conflictType = output.conflictType
            self.properties.message = output.message
        } else {
            self.properties.conflictType = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request failed due to a conflict. Check the ConflictType and error message for more details.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The type of conflict which caused a ConflictException. Possible types and the corresponding error messages are as follows:
        ///
        /// * DOMAIN_NOT_ACTIVE: The domain is not active.
        ///
        /// * CANNOT_CHANGE_SPEAKER_AFTER_ENROLLMENT: You cannot change the speaker ID after an enrollment has been requested.
        ///
        /// * ENROLLMENT_ALREADY_EXISTS: There is already an enrollment for this session.
        ///
        /// * SPEAKER_NOT_SET: You must set the speaker ID before requesting an enrollment.
        ///
        /// * SPEAKER_OPTED_OUT: You cannot request an enrollment for an opted out speaker.
        ///
        /// * CONCURRENT_CHANGES: The request could not be processed as the resource was modified by another request during execution.
        public internal(set) var conflictType: VoiceIDClientTypes.ConflictType? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        conflictType: VoiceIDClientTypes.ConflictType? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.conflictType = conflictType
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let conflictType: VoiceIDClientTypes.ConflictType?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictType = "ConflictType"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let conflictTypeDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.ConflictType.self, forKey: .conflictType)
        conflictType = conflictTypeDecoded
    }
}

extension VoiceIDClientTypes {
    public enum ConflictType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case anotherActiveStream
        case cannotChangeSpeakerAfterEnrollment
        case cannotDeleteNonEmptyWatchlist
        case concurrentChanges
        case domainLockedFromEncryptionUpdates
        case domainNotActive
        case enrollmentAlreadyExists
        case fraudsterMustBelongToAtLeastOneWatchlist
        case speakerNotSet
        case speakerOptedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictType] {
            return [
                .anotherActiveStream,
                .cannotChangeSpeakerAfterEnrollment,
                .cannotDeleteNonEmptyWatchlist,
                .concurrentChanges,
                .domainLockedFromEncryptionUpdates,
                .domainNotActive,
                .enrollmentAlreadyExists,
                .fraudsterMustBelongToAtLeastOneWatchlist,
                .speakerNotSet,
                .speakerOptedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .anotherActiveStream: return "ANOTHER_ACTIVE_STREAM"
            case .cannotChangeSpeakerAfterEnrollment: return "CANNOT_CHANGE_SPEAKER_AFTER_ENROLLMENT"
            case .cannotDeleteNonEmptyWatchlist: return "CANNOT_DELETE_NON_EMPTY_WATCHLIST"
            case .concurrentChanges: return "CONCURRENT_CHANGES"
            case .domainLockedFromEncryptionUpdates: return "DOMAIN_LOCKED_FROM_ENCRYPTION_UPDATES"
            case .domainNotActive: return "DOMAIN_NOT_ACTIVE"
            case .enrollmentAlreadyExists: return "ENROLLMENT_ALREADY_EXISTS"
            case .fraudsterMustBelongToAtLeastOneWatchlist: return "FRAUDSTER_MUST_BELONG_TO_AT_LEAST_ONE_WATCHLIST"
            case .speakerNotSet: return "SPEAKER_NOT_SET"
            case .speakerOptedOut: return "SPEAKER_OPTED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConflictType(rawValue: rawValue) ?? ConflictType.sdkUnknown(rawValue)
        }
    }
}

extension CreateDomainInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDomainInput(clientToken: \(Swift.String(describing: clientToken)), serverSideEncryptionConfiguration: \(Swift.String(describing: serverSideEncryptionConfiguration)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case name = "Name"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverSideEncryptionConfiguration = self.serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDomainInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// A brief description of this domain.
    public var description: Swift.String?
    /// The name of the domain.
    /// This member is required.
    public var name: Swift.String?
    /// The configuration, containing the KMS key identifier, to be used by Voice ID for the server-side encryption of your data. Refer to [ Amazon Connect Voice ID encryption at rest](https://docs.aws.amazon.com/connect/latest/adminguide/encryption-at-rest.html#encryption-at-rest-voiceid) for more details on how the KMS key is used.
    /// This member is required.
    public var serverSideEncryptionConfiguration: VoiceIDClientTypes.ServerSideEncryptionConfiguration?
    /// A list of tags you want added to the domain.
    public var tags: [VoiceIDClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        serverSideEncryptionConfiguration: VoiceIDClientTypes.ServerSideEncryptionConfiguration? = nil,
        tags: [VoiceIDClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
        self.tags = tags
    }
}

struct CreateDomainInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let serverSideEncryptionConfiguration: VoiceIDClientTypes.ServerSideEncryptionConfiguration?
    let clientToken: Swift.String?
    let tags: [VoiceIDClientTypes.Tag]?
}

extension CreateDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case name = "Name"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([VoiceIDClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[VoiceIDClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [VoiceIDClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDomainOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDomainOutputBody = try responseDecoder.decode(responseBody: data)
            self.domain = output.domain
        } else {
            self.domain = nil
        }
    }
}

public struct CreateDomainOutput: Swift.Equatable {
    /// Information about the newly created domain.
    public var domain: VoiceIDClientTypes.Domain?

    public init(
        domain: VoiceIDClientTypes.Domain? = nil
    )
    {
        self.domain = domain
    }
}

struct CreateDomainOutputBody: Swift.Equatable {
    let domain: VoiceIDClientTypes.Domain?
}

extension CreateDomainOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
    }
}

enum CreateDomainOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateWatchlistInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWatchlistInput(clientToken: \(Swift.String(describing: clientToken)), domainId: \(Swift.String(describing: domainId)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateWatchlistInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case domainId = "DomainId"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension CreateWatchlistInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateWatchlistInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// A brief description of this watchlist.
    public var description: Swift.String?
    /// The identifier of the domain that contains the watchlist.
    /// This member is required.
    public var domainId: Swift.String?
    /// The name of the watchlist.
    /// This member is required.
    public var name: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.domainId = domainId
        self.name = name
    }
}

struct CreateWatchlistInputBody: Swift.Equatable {
    let domainId: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let clientToken: Swift.String?
}

extension CreateWatchlistInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case domainId = "DomainId"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateWatchlistOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateWatchlistOutputBody = try responseDecoder.decode(responseBody: data)
            self.watchlist = output.watchlist
        } else {
            self.watchlist = nil
        }
    }
}

public struct CreateWatchlistOutput: Swift.Equatable {
    /// Information about the newly created watchlist.
    public var watchlist: VoiceIDClientTypes.Watchlist?

    public init(
        watchlist: VoiceIDClientTypes.Watchlist? = nil
    )
    {
        self.watchlist = watchlist
    }
}

struct CreateWatchlistOutputBody: Swift.Equatable {
    let watchlist: VoiceIDClientTypes.Watchlist?
}

extension CreateWatchlistOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case watchlist = "Watchlist"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let watchlistDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.Watchlist.self, forKey: .watchlist)
        watchlist = watchlistDecoded
    }
}

enum CreateWatchlistOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
    }
}

extension DeleteDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDomainInput: Swift.Equatable {
    /// The identifier of the domain you want to delete.
    /// This member is required.
    public var domainId: Swift.String?

    public init(
        domainId: Swift.String? = nil
    )
    {
        self.domainId = domainId
    }
}

struct DeleteDomainInputBody: Swift.Equatable {
    let domainId: Swift.String?
}

extension DeleteDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
    }
}

extension DeleteDomainOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDomainOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDomainOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteFraudsterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFraudsterInput(domainId: \(Swift.String(describing: domainId)), fraudsterId: \"CONTENT_REDACTED\")"}
}

extension DeleteFraudsterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case fraudsterId = "FraudsterId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let fraudsterId = self.fraudsterId {
            try encodeContainer.encode(fraudsterId, forKey: .fraudsterId)
        }
    }
}

extension DeleteFraudsterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteFraudsterInput: Swift.Equatable {
    /// The identifier of the domain that contains the fraudster.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the fraudster you want to delete.
    /// This member is required.
    public var fraudsterId: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        fraudsterId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.fraudsterId = fraudsterId
    }
}

struct DeleteFraudsterInputBody: Swift.Equatable {
    let domainId: Swift.String?
    let fraudsterId: Swift.String?
}

extension DeleteFraudsterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case fraudsterId = "FraudsterId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let fraudsterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fraudsterId)
        fraudsterId = fraudsterIdDecoded
    }
}

extension DeleteFraudsterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteFraudsterOutput: Swift.Equatable {

    public init() { }
}

enum DeleteFraudsterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSpeakerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSpeakerInput(domainId: \(Swift.String(describing: domainId)), speakerId: \"CONTENT_REDACTED\")"}
}

extension DeleteSpeakerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case speakerId = "SpeakerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let speakerId = self.speakerId {
            try encodeContainer.encode(speakerId, forKey: .speakerId)
        }
    }
}

extension DeleteSpeakerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSpeakerInput: Swift.Equatable {
    /// The identifier of the domain that contains the speaker.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the speaker you want to delete.
    /// This member is required.
    public var speakerId: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        speakerId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.speakerId = speakerId
    }
}

struct DeleteSpeakerInputBody: Swift.Equatable {
    let domainId: Swift.String?
    let speakerId: Swift.String?
}

extension DeleteSpeakerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case speakerId = "SpeakerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let speakerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .speakerId)
        speakerId = speakerIdDecoded
    }
}

extension DeleteSpeakerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSpeakerOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSpeakerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteWatchlistInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case watchlistId = "WatchlistId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let watchlistId = self.watchlistId {
            try encodeContainer.encode(watchlistId, forKey: .watchlistId)
        }
    }
}

extension DeleteWatchlistInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteWatchlistInput: Swift.Equatable {
    /// The identifier of the domain that contains the watchlist.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the watchlist to be deleted.
    /// This member is required.
    public var watchlistId: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        watchlistId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.watchlistId = watchlistId
    }
}

struct DeleteWatchlistInputBody: Swift.Equatable {
    let domainId: Swift.String?
    let watchlistId: Swift.String?
}

extension DeleteWatchlistInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case watchlistId = "WatchlistId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let watchlistIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .watchlistId)
        watchlistId = watchlistIdDecoded
    }
}

extension DeleteWatchlistOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteWatchlistOutput: Swift.Equatable {

    public init() { }
}

enum DeleteWatchlistOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
    }
}

extension DescribeDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDomainInput: Swift.Equatable {
    /// The identifier of the domain that you are describing.
    /// This member is required.
    public var domainId: Swift.String?

    public init(
        domainId: Swift.String? = nil
    )
    {
        self.domainId = domainId
    }
}

struct DescribeDomainInputBody: Swift.Equatable {
    let domainId: Swift.String?
}

extension DescribeDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
    }
}

extension DescribeDomainOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeDomainOutputBody = try responseDecoder.decode(responseBody: data)
            self.domain = output.domain
        } else {
            self.domain = nil
        }
    }
}

public struct DescribeDomainOutput: Swift.Equatable {
    /// Information about the specified domain.
    public var domain: VoiceIDClientTypes.Domain?

    public init(
        domain: VoiceIDClientTypes.Domain? = nil
    )
    {
        self.domain = domain
    }
}

struct DescribeDomainOutputBody: Swift.Equatable {
    let domain: VoiceIDClientTypes.Domain?
}

extension DescribeDomainOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
    }
}

enum DescribeDomainOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeFraudsterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFraudsterInput(domainId: \(Swift.String(describing: domainId)), fraudsterId: \"CONTENT_REDACTED\")"}
}

extension DescribeFraudsterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case fraudsterId = "FraudsterId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let fraudsterId = self.fraudsterId {
            try encodeContainer.encode(fraudsterId, forKey: .fraudsterId)
        }
    }
}

extension DescribeFraudsterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeFraudsterInput: Swift.Equatable {
    /// The identifier of the domain that contains the fraudster.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the fraudster you are describing.
    /// This member is required.
    public var fraudsterId: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        fraudsterId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.fraudsterId = fraudsterId
    }
}

struct DescribeFraudsterInputBody: Swift.Equatable {
    let domainId: Swift.String?
    let fraudsterId: Swift.String?
}

extension DescribeFraudsterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case fraudsterId = "FraudsterId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let fraudsterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fraudsterId)
        fraudsterId = fraudsterIdDecoded
    }
}

extension DescribeFraudsterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeFraudsterOutputBody = try responseDecoder.decode(responseBody: data)
            self.fraudster = output.fraudster
        } else {
            self.fraudster = nil
        }
    }
}

public struct DescribeFraudsterOutput: Swift.Equatable {
    /// Information about the specified fraudster.
    public var fraudster: VoiceIDClientTypes.Fraudster?

    public init(
        fraudster: VoiceIDClientTypes.Fraudster? = nil
    )
    {
        self.fraudster = fraudster
    }
}

struct DescribeFraudsterOutputBody: Swift.Equatable {
    let fraudster: VoiceIDClientTypes.Fraudster?
}

extension DescribeFraudsterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fraudster = "Fraudster"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fraudsterDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.Fraudster.self, forKey: .fraudster)
        fraudster = fraudsterDecoded
    }
}

enum DescribeFraudsterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeFraudsterRegistrationJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension DescribeFraudsterRegistrationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeFraudsterRegistrationJobInput: Swift.Equatable {
    /// The identifier of the domain that contains the fraudster registration job.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the fraudster registration job you are describing.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.jobId = jobId
    }
}

struct DescribeFraudsterRegistrationJobInputBody: Swift.Equatable {
    let domainId: Swift.String?
    let jobId: Swift.String?
}

extension DescribeFraudsterRegistrationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeFraudsterRegistrationJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeFraudsterRegistrationJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct DescribeFraudsterRegistrationJobOutput: Swift.Equatable {
    /// Contains details about the specified fraudster registration job.
    public var job: VoiceIDClientTypes.FraudsterRegistrationJob?

    public init(
        job: VoiceIDClientTypes.FraudsterRegistrationJob? = nil
    )
    {
        self.job = job
    }
}

struct DescribeFraudsterRegistrationJobOutputBody: Swift.Equatable {
    let job: VoiceIDClientTypes.FraudsterRegistrationJob?
}

extension DescribeFraudsterRegistrationJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job = "Job"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.FraudsterRegistrationJob.self, forKey: .job)
        job = jobDecoded
    }
}

enum DescribeFraudsterRegistrationJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeSpeakerEnrollmentJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension DescribeSpeakerEnrollmentJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeSpeakerEnrollmentJobInput: Swift.Equatable {
    /// The identifier of the domain that contains the speaker enrollment job.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the speaker enrollment job you are describing.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.jobId = jobId
    }
}

struct DescribeSpeakerEnrollmentJobInputBody: Swift.Equatable {
    let domainId: Swift.String?
    let jobId: Swift.String?
}

extension DescribeSpeakerEnrollmentJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeSpeakerEnrollmentJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSpeakerEnrollmentJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct DescribeSpeakerEnrollmentJobOutput: Swift.Equatable {
    /// Contains details about the specified speaker enrollment job.
    public var job: VoiceIDClientTypes.SpeakerEnrollmentJob?

    public init(
        job: VoiceIDClientTypes.SpeakerEnrollmentJob? = nil
    )
    {
        self.job = job
    }
}

struct DescribeSpeakerEnrollmentJobOutputBody: Swift.Equatable {
    let job: VoiceIDClientTypes.SpeakerEnrollmentJob?
}

extension DescribeSpeakerEnrollmentJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job = "Job"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.SpeakerEnrollmentJob.self, forKey: .job)
        job = jobDecoded
    }
}

enum DescribeSpeakerEnrollmentJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeSpeakerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSpeakerInput(domainId: \(Swift.String(describing: domainId)), speakerId: \"CONTENT_REDACTED\")"}
}

extension DescribeSpeakerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case speakerId = "SpeakerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let speakerId = self.speakerId {
            try encodeContainer.encode(speakerId, forKey: .speakerId)
        }
    }
}

extension DescribeSpeakerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeSpeakerInput: Swift.Equatable {
    /// The identifier of the domain that contains the speaker.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the speaker you are describing.
    /// This member is required.
    public var speakerId: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        speakerId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.speakerId = speakerId
    }
}

struct DescribeSpeakerInputBody: Swift.Equatable {
    let domainId: Swift.String?
    let speakerId: Swift.String?
}

extension DescribeSpeakerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case speakerId = "SpeakerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let speakerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .speakerId)
        speakerId = speakerIdDecoded
    }
}

extension DescribeSpeakerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSpeakerOutputBody = try responseDecoder.decode(responseBody: data)
            self.speaker = output.speaker
        } else {
            self.speaker = nil
        }
    }
}

public struct DescribeSpeakerOutput: Swift.Equatable {
    /// Information about the specified speaker.
    public var speaker: VoiceIDClientTypes.Speaker?

    public init(
        speaker: VoiceIDClientTypes.Speaker? = nil
    )
    {
        self.speaker = speaker
    }
}

struct DescribeSpeakerOutputBody: Swift.Equatable {
    let speaker: VoiceIDClientTypes.Speaker?
}

extension DescribeSpeakerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case speaker = "Speaker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let speakerDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.Speaker.self, forKey: .speaker)
        speaker = speakerDecoded
    }
}

enum DescribeSpeakerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeWatchlistInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case watchlistId = "WatchlistId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let watchlistId = self.watchlistId {
            try encodeContainer.encode(watchlistId, forKey: .watchlistId)
        }
    }
}

extension DescribeWatchlistInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeWatchlistInput: Swift.Equatable {
    /// The identifier of the domain that contains the watchlist.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the watchlist that you are describing.
    /// This member is required.
    public var watchlistId: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        watchlistId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.watchlistId = watchlistId
    }
}

struct DescribeWatchlistInputBody: Swift.Equatable {
    let domainId: Swift.String?
    let watchlistId: Swift.String?
}

extension DescribeWatchlistInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case watchlistId = "WatchlistId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let watchlistIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .watchlistId)
        watchlistId = watchlistIdDecoded
    }
}

extension DescribeWatchlistOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeWatchlistOutputBody = try responseDecoder.decode(responseBody: data)
            self.watchlist = output.watchlist
        } else {
            self.watchlist = nil
        }
    }
}

public struct DescribeWatchlistOutput: Swift.Equatable {
    /// Information about the specified watchlist.
    public var watchlist: VoiceIDClientTypes.Watchlist?

    public init(
        watchlist: VoiceIDClientTypes.Watchlist? = nil
    )
    {
        self.watchlist = watchlist
    }
}

struct DescribeWatchlistOutputBody: Swift.Equatable {
    let watchlist: VoiceIDClientTypes.Watchlist?
}

extension DescribeWatchlistOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case watchlist = "Watchlist"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let watchlistDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.Watchlist.self, forKey: .watchlist)
        watchlist = watchlistDecoded
    }
}

enum DescribeWatchlistOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateFraudsterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateFraudsterInput(domainId: \(Swift.String(describing: domainId)), watchlistId: \(Swift.String(describing: watchlistId)), fraudsterId: \"CONTENT_REDACTED\")"}
}

extension DisassociateFraudsterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case fraudsterId = "FraudsterId"
        case watchlistId = "WatchlistId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let fraudsterId = self.fraudsterId {
            try encodeContainer.encode(fraudsterId, forKey: .fraudsterId)
        }
        if let watchlistId = self.watchlistId {
            try encodeContainer.encode(watchlistId, forKey: .watchlistId)
        }
    }
}

extension DisassociateFraudsterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateFraudsterInput: Swift.Equatable {
    /// The identifier of the domain that contains the fraudster.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the fraudster to be disassociated from the watchlist.
    /// This member is required.
    public var fraudsterId: Swift.String?
    /// The identifier of the watchlist that you want to disassociate from the fraudster.
    /// This member is required.
    public var watchlistId: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        fraudsterId: Swift.String? = nil,
        watchlistId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.fraudsterId = fraudsterId
        self.watchlistId = watchlistId
    }
}

struct DisassociateFraudsterInputBody: Swift.Equatable {
    let domainId: Swift.String?
    let watchlistId: Swift.String?
    let fraudsterId: Swift.String?
}

extension DisassociateFraudsterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case fraudsterId = "FraudsterId"
        case watchlistId = "WatchlistId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let watchlistIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .watchlistId)
        watchlistId = watchlistIdDecoded
        let fraudsterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fraudsterId)
        fraudsterId = fraudsterIdDecoded
    }
}

extension DisassociateFraudsterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisassociateFraudsterOutputBody = try responseDecoder.decode(responseBody: data)
            self.fraudster = output.fraudster
        } else {
            self.fraudster = nil
        }
    }
}

public struct DisassociateFraudsterOutput: Swift.Equatable {
    /// Contains all the information about a fraudster.
    public var fraudster: VoiceIDClientTypes.Fraudster?

    public init(
        fraudster: VoiceIDClientTypes.Fraudster? = nil
    )
    {
        self.fraudster = fraudster
    }
}

struct DisassociateFraudsterOutputBody: Swift.Equatable {
    let fraudster: VoiceIDClientTypes.Fraudster?
}

extension DisassociateFraudsterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fraudster = "Fraudster"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fraudsterDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.Fraudster.self, forKey: .fraudster)
        fraudster = fraudsterDecoded
    }
}

enum DisassociateFraudsterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension VoiceIDClientTypes.Domain: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case description = "Description"
        case domainId = "DomainId"
        case domainStatus = "DomainStatus"
        case name = "Name"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
        case serverSideEncryptionUpdateDetails = "ServerSideEncryptionUpdateDetails"
        case updatedAt = "UpdatedAt"
        case watchlistDetails = "WatchlistDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let domainStatus = self.domainStatus {
            try encodeContainer.encode(domainStatus.rawValue, forKey: .domainStatus)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverSideEncryptionConfiguration = self.serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let serverSideEncryptionUpdateDetails = self.serverSideEncryptionUpdateDetails {
            try encodeContainer.encode(serverSideEncryptionUpdateDetails, forKey: .serverSideEncryptionUpdateDetails)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
        if let watchlistDetails = self.watchlistDetails {
            try encodeContainer.encode(watchlistDetails, forKey: .watchlistDetails)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let domainStatusDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.DomainStatus.self, forKey: .domainStatus)
        domainStatus = domainStatusDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let serverSideEncryptionUpdateDetailsDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.ServerSideEncryptionUpdateDetails.self, forKey: .serverSideEncryptionUpdateDetails)
        serverSideEncryptionUpdateDetails = serverSideEncryptionUpdateDetailsDecoded
        let watchlistDetailsDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.WatchlistDetails.self, forKey: .watchlistDetails)
        watchlistDetails = watchlistDetailsDecoded
    }
}

extension VoiceIDClientTypes.Domain: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Domain(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), domainStatus: \(Swift.String(describing: domainStatus)), serverSideEncryptionConfiguration: \(Swift.String(describing: serverSideEncryptionConfiguration)), serverSideEncryptionUpdateDetails: \(Swift.String(describing: serverSideEncryptionUpdateDetails)), updatedAt: \(Swift.String(describing: updatedAt)), watchlistDetails: \(Swift.String(describing: watchlistDetails)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension VoiceIDClientTypes {
    /// Contains all the information about a domain.
    public struct Domain: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the domain.
        public var arn: Swift.String?
        /// The timestamp of when the domain was created.
        public var createdAt: ClientRuntime.Date?
        /// The description of the domain.
        public var description: Swift.String?
        /// The identifier of the domain.
        public var domainId: Swift.String?
        /// The current status of the domain.
        public var domainStatus: VoiceIDClientTypes.DomainStatus?
        /// The name for the domain.
        public var name: Swift.String?
        /// The server-side encryption configuration containing the KMS key identifier you want Voice ID to use to encrypt your data.
        public var serverSideEncryptionConfiguration: VoiceIDClientTypes.ServerSideEncryptionConfiguration?
        /// Details about the most recent server-side encryption configuration update. When the server-side encryption configuration is changed, dependency on the old KMS key is removed through an asynchronous process. When this update is complete, the domain's data can only be accessed using the new KMS key.
        public var serverSideEncryptionUpdateDetails: VoiceIDClientTypes.ServerSideEncryptionUpdateDetails?
        /// The timestamp of when the domain was last update.
        public var updatedAt: ClientRuntime.Date?
        /// The watchlist details of a domain. Contains the default watchlist ID of the domain.
        public var watchlistDetails: VoiceIDClientTypes.WatchlistDetails?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            domainStatus: VoiceIDClientTypes.DomainStatus? = nil,
            name: Swift.String? = nil,
            serverSideEncryptionConfiguration: VoiceIDClientTypes.ServerSideEncryptionConfiguration? = nil,
            serverSideEncryptionUpdateDetails: VoiceIDClientTypes.ServerSideEncryptionUpdateDetails? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            watchlistDetails: VoiceIDClientTypes.WatchlistDetails? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.domainId = domainId
            self.domainStatus = domainStatus
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.serverSideEncryptionUpdateDetails = serverSideEncryptionUpdateDetails
            self.updatedAt = updatedAt
            self.watchlistDetails = watchlistDetails
        }
    }

}

extension VoiceIDClientTypes {
    public enum DomainStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case pending
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainStatus] {
            return [
                .active,
                .pending,
                .suspended,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .pending: return "PENDING"
            case .suspended: return "SUSPENDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DomainStatus(rawValue: rawValue) ?? DomainStatus.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIDClientTypes.DomainSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case description = "Description"
        case domainId = "DomainId"
        case domainStatus = "DomainStatus"
        case name = "Name"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
        case serverSideEncryptionUpdateDetails = "ServerSideEncryptionUpdateDetails"
        case updatedAt = "UpdatedAt"
        case watchlistDetails = "WatchlistDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let domainStatus = self.domainStatus {
            try encodeContainer.encode(domainStatus.rawValue, forKey: .domainStatus)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverSideEncryptionConfiguration = self.serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let serverSideEncryptionUpdateDetails = self.serverSideEncryptionUpdateDetails {
            try encodeContainer.encode(serverSideEncryptionUpdateDetails, forKey: .serverSideEncryptionUpdateDetails)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
        if let watchlistDetails = self.watchlistDetails {
            try encodeContainer.encode(watchlistDetails, forKey: .watchlistDetails)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let domainStatusDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.DomainStatus.self, forKey: .domainStatus)
        domainStatus = domainStatusDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let serverSideEncryptionUpdateDetailsDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.ServerSideEncryptionUpdateDetails.self, forKey: .serverSideEncryptionUpdateDetails)
        serverSideEncryptionUpdateDetails = serverSideEncryptionUpdateDetailsDecoded
        let watchlistDetailsDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.WatchlistDetails.self, forKey: .watchlistDetails)
        watchlistDetails = watchlistDetailsDecoded
    }
}

extension VoiceIDClientTypes.DomainSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DomainSummary(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), domainStatus: \(Swift.String(describing: domainStatus)), serverSideEncryptionConfiguration: \(Swift.String(describing: serverSideEncryptionConfiguration)), serverSideEncryptionUpdateDetails: \(Swift.String(describing: serverSideEncryptionUpdateDetails)), updatedAt: \(Swift.String(describing: updatedAt)), watchlistDetails: \(Swift.String(describing: watchlistDetails)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension VoiceIDClientTypes {
    /// Contains a summary of information about a domain.
    public struct DomainSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the domain.
        public var arn: Swift.String?
        /// The timestamp of when the domain was created.
        public var createdAt: ClientRuntime.Date?
        /// The description of the domain.
        public var description: Swift.String?
        /// The identifier of the domain.
        public var domainId: Swift.String?
        /// The current status of the domain.
        public var domainStatus: VoiceIDClientTypes.DomainStatus?
        /// The client-provided name for the domain.
        public var name: Swift.String?
        /// The server-side encryption configuration containing the KMS key identifier you want Voice ID to use to encrypt your data.
        public var serverSideEncryptionConfiguration: VoiceIDClientTypes.ServerSideEncryptionConfiguration?
        /// Details about the most recent server-side encryption configuration update. When the server-side encryption configuration is changed, dependency on the old KMS key is removed through an asynchronous process. When this update is complete, the domain's data can only be accessed using the new KMS key.
        public var serverSideEncryptionUpdateDetails: VoiceIDClientTypes.ServerSideEncryptionUpdateDetails?
        /// The timestamp of when the domain was last updated.
        public var updatedAt: ClientRuntime.Date?
        /// Provides information about watchlistDetails and DefaultWatchlistID.
        public var watchlistDetails: VoiceIDClientTypes.WatchlistDetails?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            domainStatus: VoiceIDClientTypes.DomainStatus? = nil,
            name: Swift.String? = nil,
            serverSideEncryptionConfiguration: VoiceIDClientTypes.ServerSideEncryptionConfiguration? = nil,
            serverSideEncryptionUpdateDetails: VoiceIDClientTypes.ServerSideEncryptionUpdateDetails? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            watchlistDetails: VoiceIDClientTypes.WatchlistDetails? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.domainId = domainId
            self.domainStatus = domainStatus
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.serverSideEncryptionUpdateDetails = serverSideEncryptionUpdateDetails
            self.updatedAt = updatedAt
            self.watchlistDetails = watchlistDetails
        }
    }

}

extension VoiceIDClientTypes {
    public enum DuplicateRegistrationAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case registerAsNew
        case skip
        case sdkUnknown(Swift.String)

        public static var allCases: [DuplicateRegistrationAction] {
            return [
                .registerAsNew,
                .skip,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .registerAsNew: return "REGISTER_AS_NEW"
            case .skip: return "SKIP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DuplicateRegistrationAction(rawValue: rawValue) ?? DuplicateRegistrationAction.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIDClientTypes.EnrollmentConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case existingEnrollmentAction = "ExistingEnrollmentAction"
        case fraudDetectionConfig = "FraudDetectionConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let existingEnrollmentAction = self.existingEnrollmentAction {
            try encodeContainer.encode(existingEnrollmentAction.rawValue, forKey: .existingEnrollmentAction)
        }
        if let fraudDetectionConfig = self.fraudDetectionConfig {
            try encodeContainer.encode(fraudDetectionConfig, forKey: .fraudDetectionConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let existingEnrollmentActionDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.ExistingEnrollmentAction.self, forKey: .existingEnrollmentAction)
        existingEnrollmentAction = existingEnrollmentActionDecoded
        let fraudDetectionConfigDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.EnrollmentJobFraudDetectionConfig.self, forKey: .fraudDetectionConfig)
        fraudDetectionConfig = fraudDetectionConfigDecoded
    }
}

extension VoiceIDClientTypes {
    /// Contains configurations defining enrollment behavior for the batch job.
    public struct EnrollmentConfig: Swift.Equatable {
        /// The action to take when the specified speaker is already enrolled in the specified domain. The default value is SKIP, which skips the enrollment for the existing speaker. Setting the value to OVERWRITE replaces the existing voice prints and enrollment audio stored for that speaker with new data generated from the latest audio.
        public var existingEnrollmentAction: VoiceIDClientTypes.ExistingEnrollmentAction?
        /// The fraud detection configuration to use for the speaker enrollment job.
        public var fraudDetectionConfig: VoiceIDClientTypes.EnrollmentJobFraudDetectionConfig?

        public init(
            existingEnrollmentAction: VoiceIDClientTypes.ExistingEnrollmentAction? = nil,
            fraudDetectionConfig: VoiceIDClientTypes.EnrollmentJobFraudDetectionConfig? = nil
        )
        {
            self.existingEnrollmentAction = existingEnrollmentAction
            self.fraudDetectionConfig = fraudDetectionConfig
        }
    }

}

extension VoiceIDClientTypes.EnrollmentJobFraudDetectionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fraudDetectionAction = "FraudDetectionAction"
        case riskThreshold = "RiskThreshold"
        case watchlistIds = "WatchlistIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fraudDetectionAction = self.fraudDetectionAction {
            try encodeContainer.encode(fraudDetectionAction.rawValue, forKey: .fraudDetectionAction)
        }
        if let riskThreshold = self.riskThreshold {
            try encodeContainer.encode(riskThreshold, forKey: .riskThreshold)
        }
        if let watchlistIds = watchlistIds {
            var watchlistIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .watchlistIds)
            for watchlistid0 in watchlistIds {
                try watchlistIdsContainer.encode(watchlistid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fraudDetectionActionDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.FraudDetectionAction.self, forKey: .fraudDetectionAction)
        fraudDetectionAction = fraudDetectionActionDecoded
        let riskThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .riskThreshold)
        riskThreshold = riskThresholdDecoded
        let watchlistIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .watchlistIds)
        var watchlistIdsDecoded0:[Swift.String]? = nil
        if let watchlistIdsContainer = watchlistIdsContainer {
            watchlistIdsDecoded0 = [Swift.String]()
            for string0 in watchlistIdsContainer {
                if let string0 = string0 {
                    watchlistIdsDecoded0?.append(string0)
                }
            }
        }
        watchlistIds = watchlistIdsDecoded0
    }
}

extension VoiceIDClientTypes {
    /// The fraud detection configuration to be used during the batch speaker enrollment job.
    public struct EnrollmentJobFraudDetectionConfig: Swift.Equatable {
        /// The action to take when the given speaker is flagged by the fraud detection system. The default value is FAIL, which fails the speaker enrollment. Changing this value to IGNORE results in the speaker being enrolled even if they are flagged by the fraud detection system.
        public var fraudDetectionAction: VoiceIDClientTypes.FraudDetectionAction?
        /// Threshold value for determining whether the speaker is a high risk to be fraudulent. If the detected risk score calculated by Voice ID is greater than or equal to the threshold, the speaker is considered a fraudster.
        public var riskThreshold: Swift.Int?
        /// The identifier of watchlists against which fraud detection is performed.
        public var watchlistIds: [Swift.String]?

        public init(
            fraudDetectionAction: VoiceIDClientTypes.FraudDetectionAction? = nil,
            riskThreshold: Swift.Int? = nil,
            watchlistIds: [Swift.String]? = nil
        )
        {
            self.fraudDetectionAction = fraudDetectionAction
            self.riskThreshold = riskThreshold
            self.watchlistIds = watchlistIds
        }
    }

}

extension EvaluateSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case sessionNameOrId = "SessionNameOrId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let sessionNameOrId = self.sessionNameOrId {
            try encodeContainer.encode(sessionNameOrId, forKey: .sessionNameOrId)
        }
    }
}

extension EvaluateSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct EvaluateSessionInput: Swift.Equatable {
    /// The identifier of the domain where the session started.
    /// This member is required.
    public var domainId: Swift.String?
    /// The session identifier, or name of the session, that you want to evaluate. In Voice ID integration, this is the Contact-Id.
    /// This member is required.
    public var sessionNameOrId: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        sessionNameOrId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.sessionNameOrId = sessionNameOrId
    }
}

struct EvaluateSessionInputBody: Swift.Equatable {
    let domainId: Swift.String?
    let sessionNameOrId: Swift.String?
}

extension EvaluateSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case sessionNameOrId = "SessionNameOrId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let sessionNameOrIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionNameOrId)
        sessionNameOrId = sessionNameOrIdDecoded
    }
}

extension EvaluateSessionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EvaluateSessionOutputBody = try responseDecoder.decode(responseBody: data)
            self.authenticationResult = output.authenticationResult
            self.domainId = output.domainId
            self.fraudDetectionResult = output.fraudDetectionResult
            self.sessionId = output.sessionId
            self.sessionName = output.sessionName
            self.streamingStatus = output.streamingStatus
        } else {
            self.authenticationResult = nil
            self.domainId = nil
            self.fraudDetectionResult = nil
            self.sessionId = nil
            self.sessionName = nil
            self.streamingStatus = nil
        }
    }
}

public struct EvaluateSessionOutput: Swift.Equatable {
    /// Details resulting from the authentication process, such as authentication decision and authentication score.
    public var authenticationResult: VoiceIDClientTypes.AuthenticationResult?
    /// The identifier of the domain that contains the session.
    public var domainId: Swift.String?
    /// Details resulting from the fraud detection process, such as fraud detection decision and risk score.
    public var fraudDetectionResult: VoiceIDClientTypes.FraudDetectionResult?
    /// The service-generated identifier of the session.
    public var sessionId: Swift.String?
    /// The client-provided name of the session.
    public var sessionName: Swift.String?
    /// The current status of audio streaming for this session. This field is useful to infer next steps when the Authentication or Fraud Detection results are empty or the decision is NOT_ENOUGH_SPEECH. In this situation, if the StreamingStatus is ONGOING/PENDING_CONFIGURATION, it can mean that the client should call the API again later, after Voice ID has enough audio to produce a result. If the decision remains NOT_ENOUGH_SPEECH even after StreamingStatus is ENDED, it means that the previously streamed session did not have enough speech to perform evaluation, and a new streaming session is needed to try again.
    public var streamingStatus: VoiceIDClientTypes.StreamingStatus?

    public init(
        authenticationResult: VoiceIDClientTypes.AuthenticationResult? = nil,
        domainId: Swift.String? = nil,
        fraudDetectionResult: VoiceIDClientTypes.FraudDetectionResult? = nil,
        sessionId: Swift.String? = nil,
        sessionName: Swift.String? = nil,
        streamingStatus: VoiceIDClientTypes.StreamingStatus? = nil
    )
    {
        self.authenticationResult = authenticationResult
        self.domainId = domainId
        self.fraudDetectionResult = fraudDetectionResult
        self.sessionId = sessionId
        self.sessionName = sessionName
        self.streamingStatus = streamingStatus
    }
}

struct EvaluateSessionOutputBody: Swift.Equatable {
    let domainId: Swift.String?
    let sessionId: Swift.String?
    let sessionName: Swift.String?
    let streamingStatus: VoiceIDClientTypes.StreamingStatus?
    let authenticationResult: VoiceIDClientTypes.AuthenticationResult?
    let fraudDetectionResult: VoiceIDClientTypes.FraudDetectionResult?
}

extension EvaluateSessionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationResult = "AuthenticationResult"
        case domainId = "DomainId"
        case fraudDetectionResult = "FraudDetectionResult"
        case sessionId = "SessionId"
        case sessionName = "SessionName"
        case streamingStatus = "StreamingStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let sessionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionName)
        sessionName = sessionNameDecoded
        let streamingStatusDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.StreamingStatus.self, forKey: .streamingStatus)
        streamingStatus = streamingStatusDecoded
        let authenticationResultDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.AuthenticationResult.self, forKey: .authenticationResult)
        authenticationResult = authenticationResultDecoded
        let fraudDetectionResultDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.FraudDetectionResult.self, forKey: .fraudDetectionResult)
        fraudDetectionResult = fraudDetectionResultDecoded
    }
}

enum EvaluateSessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension VoiceIDClientTypes {
    public enum ExistingEnrollmentAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case overwrite
        case skip
        case sdkUnknown(Swift.String)

        public static var allCases: [ExistingEnrollmentAction] {
            return [
                .overwrite,
                .skip,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .overwrite: return "OVERWRITE"
            case .skip: return "SKIP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExistingEnrollmentAction(rawValue: rawValue) ?? ExistingEnrollmentAction.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIDClientTypes.FailureDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case statusCode = "StatusCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode, forKey: .statusCode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VoiceIDClientTypes {
    /// Contains error details for a failed batch job.
    public struct FailureDetails: Swift.Equatable {
        /// A description of the error that caused the batch job failure.
        public var message: Swift.String?
        /// An HTTP status code representing the nature of the error.
        public var statusCode: Swift.Int?

        public init(
            message: Swift.String? = nil,
            statusCode: Swift.Int? = nil
        )
        {
            self.message = message
            self.statusCode = statusCode
        }
    }

}

extension VoiceIDClientTypes {
    public enum FraudDetectionAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fail
        case ignore
        case sdkUnknown(Swift.String)

        public static var allCases: [FraudDetectionAction] {
            return [
                .fail,
                .ignore,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fail: return "FAIL"
            case .ignore: return "IGNORE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FraudDetectionAction(rawValue: rawValue) ?? FraudDetectionAction.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIDClientTypes.FraudDetectionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case riskThreshold = "RiskThreshold"
        case watchlistId = "WatchlistId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let riskThreshold = self.riskThreshold {
            try encodeContainer.encode(riskThreshold, forKey: .riskThreshold)
        }
        if let watchlistId = self.watchlistId {
            try encodeContainer.encode(watchlistId, forKey: .watchlistId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let riskThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .riskThreshold)
        riskThreshold = riskThresholdDecoded
        let watchlistIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .watchlistId)
        watchlistId = watchlistIdDecoded
    }
}

extension VoiceIDClientTypes {
    /// The configuration used for performing fraud detection over a speaker during a session.
    public struct FraudDetectionConfiguration: Swift.Equatable {
        /// Threshold value for determining whether the speaker is a fraudster. If the detected risk score calculated by Voice ID is higher than the threshold, the speaker is considered a fraudster.
        public var riskThreshold: Swift.Int?
        /// The identifier of the watchlist against which fraud detection is performed.
        public var watchlistId: Swift.String?

        public init(
            riskThreshold: Swift.Int? = nil,
            watchlistId: Swift.String? = nil
        )
        {
            self.riskThreshold = riskThreshold
            self.watchlistId = watchlistId
        }
    }

}

extension VoiceIDClientTypes {
    public enum FraudDetectionDecision: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case highRisk
        case lowRisk
        case notEnoughSpeech
        case sdkUnknown(Swift.String)

        public static var allCases: [FraudDetectionDecision] {
            return [
                .highRisk,
                .lowRisk,
                .notEnoughSpeech,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .highRisk: return "HIGH_RISK"
            case .lowRisk: return "LOW_RISK"
            case .notEnoughSpeech: return "NOT_ENOUGH_SPEECH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FraudDetectionDecision(rawValue: rawValue) ?? FraudDetectionDecision.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIDClientTypes {
    public enum FraudDetectionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case knownFraudster
        case voiceSpoofing
        case sdkUnknown(Swift.String)

        public static var allCases: [FraudDetectionReason] {
            return [
                .knownFraudster,
                .voiceSpoofing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .knownFraudster: return "KNOWN_FRAUDSTER"
            case .voiceSpoofing: return "VOICE_SPOOFING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FraudDetectionReason(rawValue: rawValue) ?? FraudDetectionReason.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIDClientTypes.FraudDetectionResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioAggregationEndedAt = "AudioAggregationEndedAt"
        case audioAggregationStartedAt = "AudioAggregationStartedAt"
        case configuration = "Configuration"
        case decision = "Decision"
        case fraudDetectionResultId = "FraudDetectionResultId"
        case reasons = "Reasons"
        case riskDetails = "RiskDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioAggregationEndedAt = self.audioAggregationEndedAt {
            try encodeContainer.encodeTimestamp(audioAggregationEndedAt, format: .epochSeconds, forKey: .audioAggregationEndedAt)
        }
        if let audioAggregationStartedAt = self.audioAggregationStartedAt {
            try encodeContainer.encodeTimestamp(audioAggregationStartedAt, format: .epochSeconds, forKey: .audioAggregationStartedAt)
        }
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let decision = self.decision {
            try encodeContainer.encode(decision.rawValue, forKey: .decision)
        }
        if let fraudDetectionResultId = self.fraudDetectionResultId {
            try encodeContainer.encode(fraudDetectionResultId, forKey: .fraudDetectionResultId)
        }
        if let reasons = reasons {
            var reasonsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reasons)
            for frauddetectionreason0 in reasons {
                try reasonsContainer.encode(frauddetectionreason0.rawValue)
            }
        }
        if let riskDetails = self.riskDetails {
            try encodeContainer.encode(riskDetails, forKey: .riskDetails)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fraudDetectionResultIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fraudDetectionResultId)
        fraudDetectionResultId = fraudDetectionResultIdDecoded
        let audioAggregationStartedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .audioAggregationStartedAt)
        audioAggregationStartedAt = audioAggregationStartedAtDecoded
        let audioAggregationEndedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .audioAggregationEndedAt)
        audioAggregationEndedAt = audioAggregationEndedAtDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.FraudDetectionConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let decisionDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.FraudDetectionDecision.self, forKey: .decision)
        decision = decisionDecoded
        let reasonsContainer = try containerValues.decodeIfPresent([VoiceIDClientTypes.FraudDetectionReason?].self, forKey: .reasons)
        var reasonsDecoded0:[VoiceIDClientTypes.FraudDetectionReason]? = nil
        if let reasonsContainer = reasonsContainer {
            reasonsDecoded0 = [VoiceIDClientTypes.FraudDetectionReason]()
            for string0 in reasonsContainer {
                if let string0 = string0 {
                    reasonsDecoded0?.append(string0)
                }
            }
        }
        reasons = reasonsDecoded0
        let riskDetailsDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.FraudRiskDetails.self, forKey: .riskDetails)
        riskDetails = riskDetailsDecoded
    }
}

extension VoiceIDClientTypes {
    /// The fraud detection result produced by Voice ID, processed against the current session state and streamed audio of the speaker.
    public struct FraudDetectionResult: Swift.Equatable {
        /// A timestamp of when audio aggregation ended for this fraud detection result.
        public var audioAggregationEndedAt: ClientRuntime.Date?
        /// A timestamp of when audio aggregation started for this fraud detection result.
        public var audioAggregationStartedAt: ClientRuntime.Date?
        /// The FraudDetectionConfiguration used to generate this fraud detection result.
        public var configuration: VoiceIDClientTypes.FraudDetectionConfiguration?
        /// The fraud detection decision produced by Voice ID, processed against the current session state and streamed audio of the speaker.
        public var decision: VoiceIDClientTypes.FraudDetectionDecision?
        /// The unique identifier for this fraud detection result. Given there can be multiple fraud detections for a given session, this field helps in identifying if the returned result is from previous streaming activity or a new result. Note that in the absence of any new streaming activity or risk threshold changes, Voice ID always returns cached Fraud Detection result for this API.
        public var fraudDetectionResultId: Swift.String?
        /// The reason speaker was flagged by the fraud detection system. This is only be populated if fraud detection Decision is HIGH_RISK, and the following possible values: KNOWN_FRAUDSTER and VOICE_SPOOFING.
        public var reasons: [VoiceIDClientTypes.FraudDetectionReason]?
        /// Details about each risk analyzed for this speaker. Currently, this contains KnownFraudsterRisk and VoiceSpoofingRisk details.
        public var riskDetails: VoiceIDClientTypes.FraudRiskDetails?

        public init(
            audioAggregationEndedAt: ClientRuntime.Date? = nil,
            audioAggregationStartedAt: ClientRuntime.Date? = nil,
            configuration: VoiceIDClientTypes.FraudDetectionConfiguration? = nil,
            decision: VoiceIDClientTypes.FraudDetectionDecision? = nil,
            fraudDetectionResultId: Swift.String? = nil,
            reasons: [VoiceIDClientTypes.FraudDetectionReason]? = nil,
            riskDetails: VoiceIDClientTypes.FraudRiskDetails? = nil
        )
        {
            self.audioAggregationEndedAt = audioAggregationEndedAt
            self.audioAggregationStartedAt = audioAggregationStartedAt
            self.configuration = configuration
            self.decision = decision
            self.fraudDetectionResultId = fraudDetectionResultId
            self.reasons = reasons
            self.riskDetails = riskDetails
        }
    }

}

extension VoiceIDClientTypes.FraudRiskDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knownFraudsterRisk = "KnownFraudsterRisk"
        case voiceSpoofingRisk = "VoiceSpoofingRisk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let knownFraudsterRisk = self.knownFraudsterRisk {
            try encodeContainer.encode(knownFraudsterRisk, forKey: .knownFraudsterRisk)
        }
        if let voiceSpoofingRisk = self.voiceSpoofingRisk {
            try encodeContainer.encode(voiceSpoofingRisk, forKey: .voiceSpoofingRisk)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knownFraudsterRiskDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.KnownFraudsterRisk.self, forKey: .knownFraudsterRisk)
        knownFraudsterRisk = knownFraudsterRiskDecoded
        let voiceSpoofingRiskDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.VoiceSpoofingRisk.self, forKey: .voiceSpoofingRisk)
        voiceSpoofingRisk = voiceSpoofingRiskDecoded
    }
}

extension VoiceIDClientTypes {
    /// Details regarding various fraud risk analyses performed against the current session state and streamed audio of the speaker.
    public struct FraudRiskDetails: Swift.Equatable {
        /// The details resulting from 'Known Fraudster Risk' analysis of the speaker.
        /// This member is required.
        public var knownFraudsterRisk: VoiceIDClientTypes.KnownFraudsterRisk?
        /// The details resulting from 'Voice Spoofing Risk' analysis of the speaker.
        /// This member is required.
        public var voiceSpoofingRisk: VoiceIDClientTypes.VoiceSpoofingRisk?

        public init(
            knownFraudsterRisk: VoiceIDClientTypes.KnownFraudsterRisk? = nil,
            voiceSpoofingRisk: VoiceIDClientTypes.VoiceSpoofingRisk? = nil
        )
        {
            self.knownFraudsterRisk = knownFraudsterRisk
            self.voiceSpoofingRisk = voiceSpoofingRisk
        }
    }

}

extension VoiceIDClientTypes.Fraudster: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case domainId = "DomainId"
        case generatedFraudsterId = "GeneratedFraudsterId"
        case watchlistIds = "WatchlistIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let generatedFraudsterId = self.generatedFraudsterId {
            try encodeContainer.encode(generatedFraudsterId, forKey: .generatedFraudsterId)
        }
        if let watchlistIds = watchlistIds {
            var watchlistIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .watchlistIds)
            for watchlistid0 in watchlistIds {
                try watchlistIdsContainer.encode(watchlistid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let generatedFraudsterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedFraudsterId)
        generatedFraudsterId = generatedFraudsterIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let watchlistIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .watchlistIds)
        var watchlistIdsDecoded0:[Swift.String]? = nil
        if let watchlistIdsContainer = watchlistIdsContainer {
            watchlistIdsDecoded0 = [Swift.String]()
            for string0 in watchlistIdsContainer {
                if let string0 = string0 {
                    watchlistIdsDecoded0?.append(string0)
                }
            }
        }
        watchlistIds = watchlistIdsDecoded0
    }
}

extension VoiceIDClientTypes {
    /// Contains all the information about a fraudster.
    public struct Fraudster: Swift.Equatable {
        /// The timestamp of when Voice ID identified the fraudster.
        public var createdAt: ClientRuntime.Date?
        /// The identifier of the domain that contains the fraudster.
        public var domainId: Swift.String?
        /// The service-generated identifier for the fraudster.
        public var generatedFraudsterId: Swift.String?
        /// The identifier of the watchlists the fraudster is a part of.
        public var watchlistIds: [Swift.String]?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            domainId: Swift.String? = nil,
            generatedFraudsterId: Swift.String? = nil,
            watchlistIds: [Swift.String]? = nil
        )
        {
            self.createdAt = createdAt
            self.domainId = domainId
            self.generatedFraudsterId = generatedFraudsterId
            self.watchlistIds = watchlistIds
        }
    }

}

extension VoiceIDClientTypes.FraudsterRegistrationJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case domainId = "DomainId"
        case endedAt = "EndedAt"
        case failureDetails = "FailureDetails"
        case inputDataConfig = "InputDataConfig"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobProgress = "JobProgress"
        case jobStatus = "JobStatus"
        case outputDataConfig = "OutputDataConfig"
        case registrationConfig = "RegistrationConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let dataAccessRoleArn = self.dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let endedAt = self.endedAt {
            try encodeContainer.encodeTimestamp(endedAt, format: .epochSeconds, forKey: .endedAt)
        }
        if let failureDetails = self.failureDetails {
            try encodeContainer.encode(failureDetails, forKey: .failureDetails)
        }
        if let inputDataConfig = self.inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobProgress = self.jobProgress {
            try encodeContainer.encode(jobProgress, forKey: .jobProgress)
        }
        if let jobStatus = self.jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let outputDataConfig = self.outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let registrationConfig = self.registrationConfig {
            try encodeContainer.encode(registrationConfig, forKey: .registrationConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.FraudsterRegistrationJobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let registrationConfigDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.RegistrationConfig.self, forKey: .registrationConfig)
        registrationConfig = registrationConfigDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let endedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endedAt)
        endedAt = endedAtDecoded
        let failureDetailsDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.FailureDetails.self, forKey: .failureDetails)
        failureDetails = failureDetailsDecoded
        let jobProgressDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.JobProgress.self, forKey: .jobProgress)
        jobProgress = jobProgressDecoded
    }
}

extension VoiceIDClientTypes.FraudsterRegistrationJob: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FraudsterRegistrationJob(createdAt: \(Swift.String(describing: createdAt)), dataAccessRoleArn: \(Swift.String(describing: dataAccessRoleArn)), domainId: \(Swift.String(describing: domainId)), endedAt: \(Swift.String(describing: endedAt)), failureDetails: \(Swift.String(describing: failureDetails)), inputDataConfig: \(Swift.String(describing: inputDataConfig)), jobId: \(Swift.String(describing: jobId)), jobProgress: \(Swift.String(describing: jobProgress)), jobStatus: \(Swift.String(describing: jobStatus)), outputDataConfig: \(Swift.String(describing: outputDataConfig)), registrationConfig: \(Swift.String(describing: registrationConfig)), jobName: \"CONTENT_REDACTED\")"}
}

extension VoiceIDClientTypes {
    /// Contains all the information about a fraudster registration job.
    public struct FraudsterRegistrationJob: Swift.Equatable {
        /// A timestamp of when the fraudster registration job was created.
        public var createdAt: ClientRuntime.Date?
        /// The IAM role Amazon Resource Name (ARN) that grants Voice ID permissions to access customer's buckets to read the input manifest file and write the job output file.
        public var dataAccessRoleArn: Swift.String?
        /// The identifier of the domain that contains the fraudster registration job.
        public var domainId: Swift.String?
        /// A timestamp of when the fraudster registration job ended.
        public var endedAt: ClientRuntime.Date?
        /// Contains details that are populated when an entire batch job fails. In cases of individual registration job failures, the batch job as a whole doesn't fail; it is completed with a JobStatus of COMPLETED_WITH_ERRORS. You can use the job output file to identify the individual registration requests that failed.
        public var failureDetails: VoiceIDClientTypes.FailureDetails?
        /// The input data config containing an S3 URI for the input manifest file that contains the list of fraudster registration job requests.
        public var inputDataConfig: VoiceIDClientTypes.InputDataConfig?
        /// The service-generated identifier for the fraudster registration job.
        public var jobId: Swift.String?
        /// The client-provided name for the fraudster registration job.
        public var jobName: Swift.String?
        /// Shows the completed percentage of registration requests listed in the input file.
        public var jobProgress: VoiceIDClientTypes.JobProgress?
        /// The current status of the fraudster registration job.
        public var jobStatus: VoiceIDClientTypes.FraudsterRegistrationJobStatus?
        /// The output data config containing the S3 location where you want Voice ID to write your job output file; you must also include a KMS key ID in order to encrypt the file.
        public var outputDataConfig: VoiceIDClientTypes.OutputDataConfig?
        /// The registration config containing details such as the action to take when a duplicate fraudster is detected, and the similarity threshold to use for detecting a duplicate fraudster.
        public var registrationConfig: VoiceIDClientTypes.RegistrationConfig?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            dataAccessRoleArn: Swift.String? = nil,
            domainId: Swift.String? = nil,
            endedAt: ClientRuntime.Date? = nil,
            failureDetails: VoiceIDClientTypes.FailureDetails? = nil,
            inputDataConfig: VoiceIDClientTypes.InputDataConfig? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobProgress: VoiceIDClientTypes.JobProgress? = nil,
            jobStatus: VoiceIDClientTypes.FraudsterRegistrationJobStatus? = nil,
            outputDataConfig: VoiceIDClientTypes.OutputDataConfig? = nil,
            registrationConfig: VoiceIDClientTypes.RegistrationConfig? = nil
        )
        {
            self.createdAt = createdAt
            self.dataAccessRoleArn = dataAccessRoleArn
            self.domainId = domainId
            self.endedAt = endedAt
            self.failureDetails = failureDetails
            self.inputDataConfig = inputDataConfig
            self.jobId = jobId
            self.jobName = jobName
            self.jobProgress = jobProgress
            self.jobStatus = jobStatus
            self.outputDataConfig = outputDataConfig
            self.registrationConfig = registrationConfig
        }
    }

}

extension VoiceIDClientTypes {
    public enum FraudsterRegistrationJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case completedWithErrors
        case failed
        case inProgress
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [FraudsterRegistrationJobStatus] {
            return [
                .completed,
                .completedWithErrors,
                .failed,
                .inProgress,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .completedWithErrors: return "COMPLETED_WITH_ERRORS"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FraudsterRegistrationJobStatus(rawValue: rawValue) ?? FraudsterRegistrationJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIDClientTypes.FraudsterRegistrationJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case domainId = "DomainId"
        case endedAt = "EndedAt"
        case failureDetails = "FailureDetails"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobProgress = "JobProgress"
        case jobStatus = "JobStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let endedAt = self.endedAt {
            try encodeContainer.encodeTimestamp(endedAt, format: .epochSeconds, forKey: .endedAt)
        }
        if let failureDetails = self.failureDetails {
            try encodeContainer.encode(failureDetails, forKey: .failureDetails)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobProgress = self.jobProgress {
            try encodeContainer.encode(jobProgress, forKey: .jobProgress)
        }
        if let jobStatus = self.jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.FraudsterRegistrationJobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let endedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endedAt)
        endedAt = endedAtDecoded
        let failureDetailsDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.FailureDetails.self, forKey: .failureDetails)
        failureDetails = failureDetailsDecoded
        let jobProgressDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.JobProgress.self, forKey: .jobProgress)
        jobProgress = jobProgressDecoded
    }
}

extension VoiceIDClientTypes.FraudsterRegistrationJobSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FraudsterRegistrationJobSummary(createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), endedAt: \(Swift.String(describing: endedAt)), failureDetails: \(Swift.String(describing: failureDetails)), jobId: \(Swift.String(describing: jobId)), jobProgress: \(Swift.String(describing: jobProgress)), jobStatus: \(Swift.String(describing: jobStatus)), jobName: \"CONTENT_REDACTED\")"}
}

extension VoiceIDClientTypes {
    /// Contains a summary of information about a fraudster registration job.
    public struct FraudsterRegistrationJobSummary: Swift.Equatable {
        /// A timestamp of when the fraudster registration job was created.
        public var createdAt: ClientRuntime.Date?
        /// The identifier of the domain that contains the fraudster registration job.
        public var domainId: Swift.String?
        /// A timestamp of when the fraudster registration job ended.
        public var endedAt: ClientRuntime.Date?
        /// Contains details that are populated when an entire batch job fails. In cases of individual registration job failures, the batch job as a whole doesn't fail; it is completed with a JobStatus of COMPLETED_WITH_ERRORS. You can use the job output file to identify the individual registration requests that failed.
        public var failureDetails: VoiceIDClientTypes.FailureDetails?
        /// The service-generated identifier for the fraudster registration job.
        public var jobId: Swift.String?
        /// The client-provided name for the fraudster registration job.
        public var jobName: Swift.String?
        /// Shows the completed percentage of registration requests listed in the input file.
        public var jobProgress: VoiceIDClientTypes.JobProgress?
        /// The current status of the fraudster registration job.
        public var jobStatus: VoiceIDClientTypes.FraudsterRegistrationJobStatus?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            domainId: Swift.String? = nil,
            endedAt: ClientRuntime.Date? = nil,
            failureDetails: VoiceIDClientTypes.FailureDetails? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobProgress: VoiceIDClientTypes.JobProgress? = nil,
            jobStatus: VoiceIDClientTypes.FraudsterRegistrationJobStatus? = nil
        )
        {
            self.createdAt = createdAt
            self.domainId = domainId
            self.endedAt = endedAt
            self.failureDetails = failureDetails
            self.jobId = jobId
            self.jobName = jobName
            self.jobProgress = jobProgress
            self.jobStatus = jobStatus
        }
    }

}

extension VoiceIDClientTypes.FraudsterSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case domainId = "DomainId"
        case generatedFraudsterId = "GeneratedFraudsterId"
        case watchlistIds = "WatchlistIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let generatedFraudsterId = self.generatedFraudsterId {
            try encodeContainer.encode(generatedFraudsterId, forKey: .generatedFraudsterId)
        }
        if let watchlistIds = watchlistIds {
            var watchlistIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .watchlistIds)
            for watchlistid0 in watchlistIds {
                try watchlistIdsContainer.encode(watchlistid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let generatedFraudsterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedFraudsterId)
        generatedFraudsterId = generatedFraudsterIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let watchlistIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .watchlistIds)
        var watchlistIdsDecoded0:[Swift.String]? = nil
        if let watchlistIdsContainer = watchlistIdsContainer {
            watchlistIdsDecoded0 = [Swift.String]()
            for string0 in watchlistIdsContainer {
                if let string0 = string0 {
                    watchlistIdsDecoded0?.append(string0)
                }
            }
        }
        watchlistIds = watchlistIdsDecoded0
    }
}

extension VoiceIDClientTypes {
    /// Contains a summary of information about a fraudster.
    public struct FraudsterSummary: Swift.Equatable {
        /// The timestamp of when the fraudster summary was created.
        public var createdAt: ClientRuntime.Date?
        /// The identifier of the domain that contains the fraudster summary.
        public var domainId: Swift.String?
        /// The service-generated identifier for the fraudster.
        public var generatedFraudsterId: Swift.String?
        /// The identifier of the watchlists the fraudster is a part of.
        public var watchlistIds: [Swift.String]?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            domainId: Swift.String? = nil,
            generatedFraudsterId: Swift.String? = nil,
            watchlistIds: [Swift.String]? = nil
        )
        {
            self.createdAt = createdAt
            self.domainId = domainId
            self.generatedFraudsterId = generatedFraudsterId
            self.watchlistIds = watchlistIds
        }
    }

}

extension VoiceIDClientTypes.InputDataConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Uri = "S3Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Uri = self.s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
    }
}

extension VoiceIDClientTypes {
    /// The configuration containing input file information for a batch job.
    public struct InputDataConfig: Swift.Equatable {
        /// The S3 location for the input manifest file that contains the list of individual enrollment or registration job requests.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            s3Uri: Swift.String? = nil
        )
        {
            self.s3Uri = s3Uri
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request failed due to an unknown error on the server side.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VoiceIDClientTypes.JobProgress: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case percentComplete = "PercentComplete"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let percentComplete = self.percentComplete {
            try encodeContainer.encode(percentComplete, forKey: .percentComplete)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let percentCompleteDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .percentComplete)
        percentComplete = percentCompleteDecoded
    }
}

extension VoiceIDClientTypes {
    /// Indicates the completion progress for a batch job.
    public struct JobProgress: Swift.Equatable {
        /// Shows the completed percentage of enrollment or registration requests listed in the input file.
        public var percentComplete: Swift.Int?

        public init(
            percentComplete: Swift.Int? = nil
        )
        {
            self.percentComplete = percentComplete
        }
    }

}

extension VoiceIDClientTypes.KnownFraudsterRisk: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generatedFraudsterId = "GeneratedFraudsterId"
        case riskScore = "RiskScore"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let generatedFraudsterId = self.generatedFraudsterId {
            try encodeContainer.encode(generatedFraudsterId, forKey: .generatedFraudsterId)
        }
        if let riskScore = self.riskScore {
            try encodeContainer.encode(riskScore, forKey: .riskScore)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let riskScoreDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .riskScore)
        riskScore = riskScoreDecoded
        let generatedFraudsterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedFraudsterId)
        generatedFraudsterId = generatedFraudsterIdDecoded
    }
}

extension VoiceIDClientTypes {
    /// Contains details produced as a result of performing known fraudster risk analysis on a speaker.
    public struct KnownFraudsterRisk: Swift.Equatable {
        /// The identifier of the fraudster that is the closest match to the speaker. If there are no fraudsters registered in a given domain, or if there are no fraudsters with a non-zero RiskScore, this value is null.
        public var generatedFraudsterId: Swift.String?
        /// The score indicating the likelihood the speaker is a known fraudster.
        /// This member is required.
        public var riskScore: Swift.Int?

        public init(
            generatedFraudsterId: Swift.String? = nil,
            riskScore: Swift.Int? = nil
        )
        {
            self.generatedFraudsterId = generatedFraudsterId
            self.riskScore = riskScore
        }
    }

}

extension ListDomainsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDomainsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDomainsInput: Swift.Equatable {
    /// The maximum number of results that are returned per call. You can use NextToken to obtain more pages of results. The default is 100; the maximum allowed page size is also 100.
    public var maxResults: Swift.Int?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDomainsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListDomainsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDomainsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDomainsOutputBody = try responseDecoder.decode(responseBody: data)
            self.domainSummaries = output.domainSummaries
            self.nextToken = output.nextToken
        } else {
            self.domainSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListDomainsOutput: Swift.Equatable {
    /// A list containing details about each domain in the Amazon Web Services account.
    public var domainSummaries: [VoiceIDClientTypes.DomainSummary]?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?

    public init(
        domainSummaries: [VoiceIDClientTypes.DomainSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainSummaries = domainSummaries
        self.nextToken = nextToken
    }
}

struct ListDomainsOutputBody: Swift.Equatable {
    let domainSummaries: [VoiceIDClientTypes.DomainSummary]?
    let nextToken: Swift.String?
}

extension ListDomainsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainSummaries = "DomainSummaries"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainSummariesContainer = try containerValues.decodeIfPresent([VoiceIDClientTypes.DomainSummary?].self, forKey: .domainSummaries)
        var domainSummariesDecoded0:[VoiceIDClientTypes.DomainSummary]? = nil
        if let domainSummariesContainer = domainSummariesContainer {
            domainSummariesDecoded0 = [VoiceIDClientTypes.DomainSummary]()
            for structure0 in domainSummariesContainer {
                if let structure0 = structure0 {
                    domainSummariesDecoded0?.append(structure0)
                }
            }
        }
        domainSummaries = domainSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDomainsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFraudsterRegistrationJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case jobStatus = "JobStatus"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let jobStatus = self.jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListFraudsterRegistrationJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListFraudsterRegistrationJobsInput: Swift.Equatable {
    /// The identifier of the domain that contains the fraudster registration Jobs.
    /// This member is required.
    public var domainId: Swift.String?
    /// Provides the status of your fraudster registration job.
    public var jobStatus: VoiceIDClientTypes.FraudsterRegistrationJobStatus?
    /// The maximum number of results that are returned per call. You can use NextToken to obtain more pages of results. The default is 100; the maximum allowed page size is also 100.
    public var maxResults: Swift.Int?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        jobStatus: VoiceIDClientTypes.FraudsterRegistrationJobStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.jobStatus = jobStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFraudsterRegistrationJobsInputBody: Swift.Equatable {
    let domainId: Swift.String?
    let jobStatus: VoiceIDClientTypes.FraudsterRegistrationJobStatus?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListFraudsterRegistrationJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case jobStatus = "JobStatus"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.FraudsterRegistrationJobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFraudsterRegistrationJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFraudsterRegistrationJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobSummaries = output.jobSummaries
            self.nextToken = output.nextToken
        } else {
            self.jobSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListFraudsterRegistrationJobsOutput: Swift.Equatable {
    /// A list containing details about each specified fraudster registration job.
    public var jobSummaries: [VoiceIDClientTypes.FraudsterRegistrationJobSummary]?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?

    public init(
        jobSummaries: [VoiceIDClientTypes.FraudsterRegistrationJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobSummaries = jobSummaries
        self.nextToken = nextToken
    }
}

struct ListFraudsterRegistrationJobsOutputBody: Swift.Equatable {
    let jobSummaries: [VoiceIDClientTypes.FraudsterRegistrationJobSummary]?
    let nextToken: Swift.String?
}

extension ListFraudsterRegistrationJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobSummaries = "JobSummaries"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobSummariesContainer = try containerValues.decodeIfPresent([VoiceIDClientTypes.FraudsterRegistrationJobSummary?].self, forKey: .jobSummaries)
        var jobSummariesDecoded0:[VoiceIDClientTypes.FraudsterRegistrationJobSummary]? = nil
        if let jobSummariesContainer = jobSummariesContainer {
            jobSummariesDecoded0 = [VoiceIDClientTypes.FraudsterRegistrationJobSummary]()
            for structure0 in jobSummariesContainer {
                if let structure0 = structure0 {
                    jobSummariesDecoded0?.append(structure0)
                }
            }
        }
        jobSummaries = jobSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListFraudsterRegistrationJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFraudstersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case watchlistId = "WatchlistId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let watchlistId = self.watchlistId {
            try encodeContainer.encode(watchlistId, forKey: .watchlistId)
        }
    }
}

extension ListFraudstersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListFraudstersInput: Swift.Equatable {
    /// The identifier of the domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The maximum number of results that are returned per call. You can use NextToken to obtain more pages of results. The default is 100; the maximum allowed page size is also 100.
    public var maxResults: Swift.Int?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?
    /// The identifier of the watchlist. If provided, all fraudsters in the watchlist are listed. If not provided, all fraudsters in the domain are listed.
    public var watchlistId: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        watchlistId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.watchlistId = watchlistId
    }
}

struct ListFraudstersInputBody: Swift.Equatable {
    let domainId: Swift.String?
    let watchlistId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListFraudstersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case watchlistId = "WatchlistId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let watchlistIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .watchlistId)
        watchlistId = watchlistIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFraudstersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFraudstersOutputBody = try responseDecoder.decode(responseBody: data)
            self.fraudsterSummaries = output.fraudsterSummaries
            self.nextToken = output.nextToken
        } else {
            self.fraudsterSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListFraudstersOutput: Swift.Equatable {
    /// A list that contains details about each fraudster in the Amazon Web Services account.
    public var fraudsterSummaries: [VoiceIDClientTypes.FraudsterSummary]?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?

    public init(
        fraudsterSummaries: [VoiceIDClientTypes.FraudsterSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fraudsterSummaries = fraudsterSummaries
        self.nextToken = nextToken
    }
}

struct ListFraudstersOutputBody: Swift.Equatable {
    let fraudsterSummaries: [VoiceIDClientTypes.FraudsterSummary]?
    let nextToken: Swift.String?
}

extension ListFraudstersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fraudsterSummaries = "FraudsterSummaries"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fraudsterSummariesContainer = try containerValues.decodeIfPresent([VoiceIDClientTypes.FraudsterSummary?].self, forKey: .fraudsterSummaries)
        var fraudsterSummariesDecoded0:[VoiceIDClientTypes.FraudsterSummary]? = nil
        if let fraudsterSummariesContainer = fraudsterSummariesContainer {
            fraudsterSummariesDecoded0 = [VoiceIDClientTypes.FraudsterSummary]()
            for structure0 in fraudsterSummariesContainer {
                if let structure0 = structure0 {
                    fraudsterSummariesDecoded0?.append(structure0)
                }
            }
        }
        fraudsterSummaries = fraudsterSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListFraudstersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSpeakerEnrollmentJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case jobStatus = "JobStatus"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let jobStatus = self.jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSpeakerEnrollmentJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSpeakerEnrollmentJobsInput: Swift.Equatable {
    /// The identifier of the domain that contains the speaker enrollment jobs.
    /// This member is required.
    public var domainId: Swift.String?
    /// Provides the status of your speaker enrollment Job.
    public var jobStatus: VoiceIDClientTypes.SpeakerEnrollmentJobStatus?
    /// The maximum number of results that are returned per call. You can use NextToken to obtain more pages of results. The default is 100; the maximum allowed page size is also 100.
    public var maxResults: Swift.Int?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        jobStatus: VoiceIDClientTypes.SpeakerEnrollmentJobStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.jobStatus = jobStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSpeakerEnrollmentJobsInputBody: Swift.Equatable {
    let domainId: Swift.String?
    let jobStatus: VoiceIDClientTypes.SpeakerEnrollmentJobStatus?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListSpeakerEnrollmentJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case jobStatus = "JobStatus"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.SpeakerEnrollmentJobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSpeakerEnrollmentJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSpeakerEnrollmentJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobSummaries = output.jobSummaries
            self.nextToken = output.nextToken
        } else {
            self.jobSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListSpeakerEnrollmentJobsOutput: Swift.Equatable {
    /// A list containing details about each specified speaker enrollment job.
    public var jobSummaries: [VoiceIDClientTypes.SpeakerEnrollmentJobSummary]?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?

    public init(
        jobSummaries: [VoiceIDClientTypes.SpeakerEnrollmentJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobSummaries = jobSummaries
        self.nextToken = nextToken
    }
}

struct ListSpeakerEnrollmentJobsOutputBody: Swift.Equatable {
    let jobSummaries: [VoiceIDClientTypes.SpeakerEnrollmentJobSummary]?
    let nextToken: Swift.String?
}

extension ListSpeakerEnrollmentJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobSummaries = "JobSummaries"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobSummariesContainer = try containerValues.decodeIfPresent([VoiceIDClientTypes.SpeakerEnrollmentJobSummary?].self, forKey: .jobSummaries)
        var jobSummariesDecoded0:[VoiceIDClientTypes.SpeakerEnrollmentJobSummary]? = nil
        if let jobSummariesContainer = jobSummariesContainer {
            jobSummariesDecoded0 = [VoiceIDClientTypes.SpeakerEnrollmentJobSummary]()
            for structure0 in jobSummariesContainer {
                if let structure0 = structure0 {
                    jobSummariesDecoded0?.append(structure0)
                }
            }
        }
        jobSummaries = jobSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSpeakerEnrollmentJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSpeakersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSpeakersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSpeakersInput: Swift.Equatable {
    /// The identifier of the domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The maximum number of results that are returned per call. You can use NextToken to obtain more pages of results. The default is 100; the maximum allowed page size is also 100.
    public var maxResults: Swift.Int?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSpeakersInputBody: Swift.Equatable {
    let domainId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListSpeakersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSpeakersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSpeakersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.speakerSummaries = output.speakerSummaries
        } else {
            self.nextToken = nil
            self.speakerSummaries = nil
        }
    }
}

public struct ListSpeakersOutput: Swift.Equatable {
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?
    /// A list containing details about each speaker in the Amazon Web Services account.
    public var speakerSummaries: [VoiceIDClientTypes.SpeakerSummary]?

    public init(
        nextToken: Swift.String? = nil,
        speakerSummaries: [VoiceIDClientTypes.SpeakerSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.speakerSummaries = speakerSummaries
    }
}

struct ListSpeakersOutputBody: Swift.Equatable {
    let speakerSummaries: [VoiceIDClientTypes.SpeakerSummary]?
    let nextToken: Swift.String?
}

extension ListSpeakersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case speakerSummaries = "SpeakerSummaries"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let speakerSummariesContainer = try containerValues.decodeIfPresent([VoiceIDClientTypes.SpeakerSummary?].self, forKey: .speakerSummaries)
        var speakerSummariesDecoded0:[VoiceIDClientTypes.SpeakerSummary]? = nil
        if let speakerSummariesContainer = speakerSummariesContainer {
            speakerSummariesDecoded0 = [VoiceIDClientTypes.SpeakerSummary]()
            for structure0 in speakerSummariesContainer {
                if let structure0 = structure0 {
                    speakerSummariesDecoded0?.append(structure0)
                }
            }
        }
        speakerSummaries = speakerSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSpeakersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Voice ID resource for which you want to list the tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The list of tags associated with the specified resource.
    public var tags: [VoiceIDClientTypes.Tag]?

    public init(
        tags: [VoiceIDClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [VoiceIDClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([VoiceIDClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[VoiceIDClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [VoiceIDClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListWatchlistsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListWatchlistsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListWatchlistsInput: Swift.Equatable {
    /// The identifier of the domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The maximum number of results that are returned per call. You can use NextToken to obtain more pages of results. The default is 100; the maximum allowed page size is also 100.
    public var maxResults: Swift.Int?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWatchlistsInputBody: Swift.Equatable {
    let domainId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListWatchlistsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListWatchlistsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListWatchlistsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.watchlistSummaries = output.watchlistSummaries
        } else {
            self.nextToken = nil
            self.watchlistSummaries = nil
        }
    }
}

public struct ListWatchlistsOutput: Swift.Equatable {
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?
    /// A list that contains details about each watchlist in the Amazon Web Services account.
    public var watchlistSummaries: [VoiceIDClientTypes.WatchlistSummary]?

    public init(
        nextToken: Swift.String? = nil,
        watchlistSummaries: [VoiceIDClientTypes.WatchlistSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.watchlistSummaries = watchlistSummaries
    }
}

struct ListWatchlistsOutputBody: Swift.Equatable {
    let watchlistSummaries: [VoiceIDClientTypes.WatchlistSummary]?
    let nextToken: Swift.String?
}

extension ListWatchlistsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case watchlistSummaries = "WatchlistSummaries"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let watchlistSummariesContainer = try containerValues.decodeIfPresent([VoiceIDClientTypes.WatchlistSummary?].self, forKey: .watchlistSummaries)
        var watchlistSummariesDecoded0:[VoiceIDClientTypes.WatchlistSummary]? = nil
        if let watchlistSummariesContainer = watchlistSummariesContainer {
            watchlistSummariesDecoded0 = [VoiceIDClientTypes.WatchlistSummary]()
            for structure0 in watchlistSummariesContainer {
                if let structure0 = structure0 {
                    watchlistSummariesDecoded0?.append(structure0)
                }
            }
        }
        watchlistSummaries = watchlistSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListWatchlistsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OptOutSpeakerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OptOutSpeakerInput(domainId: \(Swift.String(describing: domainId)), speakerId: \"CONTENT_REDACTED\")"}
}

extension OptOutSpeakerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case speakerId = "SpeakerId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let speakerId = self.speakerId {
            try encodeContainer.encode(speakerId, forKey: .speakerId)
        }
    }
}

extension OptOutSpeakerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct OptOutSpeakerInput: Swift.Equatable {
    /// The identifier of the domain that contains the speaker.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the speaker you want opted-out.
    /// This member is required.
    public var speakerId: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        speakerId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.speakerId = speakerId
    }
}

struct OptOutSpeakerInputBody: Swift.Equatable {
    let domainId: Swift.String?
    let speakerId: Swift.String?
}

extension OptOutSpeakerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainId = "DomainId"
        case speakerId = "SpeakerId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let speakerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .speakerId)
        speakerId = speakerIdDecoded
    }
}

extension OptOutSpeakerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: OptOutSpeakerOutputBody = try responseDecoder.decode(responseBody: data)
            self.speaker = output.speaker
        } else {
            self.speaker = nil
        }
    }
}

public struct OptOutSpeakerOutput: Swift.Equatable {
    /// Details about the opted-out speaker.
    public var speaker: VoiceIDClientTypes.Speaker?

    public init(
        speaker: VoiceIDClientTypes.Speaker? = nil
    )
    {
        self.speaker = speaker
    }
}

struct OptOutSpeakerOutputBody: Swift.Equatable {
    let speaker: VoiceIDClientTypes.Speaker?
}

extension OptOutSpeakerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case speaker = "Speaker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let speakerDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.Speaker.self, forKey: .speaker)
        speaker = speakerDecoded
    }
}

enum OptOutSpeakerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension VoiceIDClientTypes.OutputDataConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId = "KmsKeyId"
        case s3Uri = "S3Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let s3Uri = self.s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension VoiceIDClientTypes {
    /// The configuration containing output file information for a batch job.
    public struct OutputDataConfig: Swift.Equatable {
        /// The identifier of the KMS key you want Voice ID to use to encrypt the output file of a speaker enrollment job/fraudster registration job.
        public var kmsKeyId: Swift.String?
        /// The S3 path of the folder where Voice ID writes the job output file. It has a *.out extension. For example, if the input file name is input-file.json and the output folder path is s3://output-bucket/output-folder, the full output file path is s3://output-bucket/output-folder/job-Id/input-file.json.out.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            kmsKeyId: Swift.String? = nil,
            s3Uri: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.s3Uri = s3Uri
        }
    }

}

extension VoiceIDClientTypes.RegistrationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case duplicateRegistrationAction = "DuplicateRegistrationAction"
        case fraudsterSimilarityThreshold = "FraudsterSimilarityThreshold"
        case watchlistIds = "WatchlistIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let duplicateRegistrationAction = self.duplicateRegistrationAction {
            try encodeContainer.encode(duplicateRegistrationAction.rawValue, forKey: .duplicateRegistrationAction)
        }
        if let fraudsterSimilarityThreshold = self.fraudsterSimilarityThreshold {
            try encodeContainer.encode(fraudsterSimilarityThreshold, forKey: .fraudsterSimilarityThreshold)
        }
        if let watchlistIds = watchlistIds {
            var watchlistIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .watchlistIds)
            for watchlistid0 in watchlistIds {
                try watchlistIdsContainer.encode(watchlistid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let duplicateRegistrationActionDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.DuplicateRegistrationAction.self, forKey: .duplicateRegistrationAction)
        duplicateRegistrationAction = duplicateRegistrationActionDecoded
        let fraudsterSimilarityThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fraudsterSimilarityThreshold)
        fraudsterSimilarityThreshold = fraudsterSimilarityThresholdDecoded
        let watchlistIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .watchlistIds)
        var watchlistIdsDecoded0:[Swift.String]? = nil
        if let watchlistIdsContainer = watchlistIdsContainer {
            watchlistIdsDecoded0 = [Swift.String]()
            for string0 in watchlistIdsContainer {
                if let string0 = string0 {
                    watchlistIdsDecoded0?.append(string0)
                }
            }
        }
        watchlistIds = watchlistIdsDecoded0
    }
}

extension VoiceIDClientTypes {
    /// The registration configuration to be used during the batch fraudster registration job.
    public struct RegistrationConfig: Swift.Equatable {
        /// The action to take when a fraudster is identified as a duplicate. The default action is SKIP, which skips registering the duplicate fraudster. Setting the value to REGISTER_AS_NEW always registers a new fraudster into the specified domain.
        public var duplicateRegistrationAction: VoiceIDClientTypes.DuplicateRegistrationAction?
        /// The minimum similarity score between the new and old fraudsters in order to consider the new fraudster a duplicate.
        public var fraudsterSimilarityThreshold: Swift.Int?
        /// The identifiers of watchlists that a fraudster is registered to. If a watchlist isn't provided, the fraudsters are registered to the default watchlist.
        public var watchlistIds: [Swift.String]?

        public init(
            duplicateRegistrationAction: VoiceIDClientTypes.DuplicateRegistrationAction? = nil,
            fraudsterSimilarityThreshold: Swift.Int? = nil,
            watchlistIds: [Swift.String]? = nil
        )
        {
            self.duplicateRegistrationAction = duplicateRegistrationAction
            self.fraudsterSimilarityThreshold = fraudsterSimilarityThreshold
            self.watchlistIds = watchlistIds
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource cannot be found. Check the ResourceType and error message for more details.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The type of resource which cannot not be found. Possible types are BATCH_JOB, COMPLIANCE_CONSENT, DOMAIN, FRAUDSTER, SESSION and SPEAKER.
        public internal(set) var resourceType: VoiceIDClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceType: VoiceIDClientTypes.ResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: VoiceIDClientTypes.ResourceType?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension VoiceIDClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case batchJob
        case complianceConsent
        case domain
        case fraudster
        case session
        case speaker
        case watchlist
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .batchJob,
                .complianceConsent,
                .domain,
                .fraudster,
                .session,
                .speaker,
                .watchlist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .batchJob: return "BATCH_JOB"
            case .complianceConsent: return "COMPLIANCE_CONSENT"
            case .domain: return "DOMAIN"
            case .fraudster: return "FRAUDSTER"
            case .session: return "SESSION"
            case .speaker: return "SPEAKER"
            case .watchlist: return "WATCHLIST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIDClientTypes.ServerSideEncryptionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId = "KmsKeyId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension VoiceIDClientTypes {
    /// The configuration containing information about the customer managed key used for encrypting customer data.
    public struct ServerSideEncryptionConfiguration: Swift.Equatable {
        /// The identifier of the KMS key to use to encrypt data stored by Voice ID. Voice ID doesn't support asymmetric customer managed keys.
        /// This member is required.
        public var kmsKeyId: Swift.String?

        public init(
            kmsKeyId: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
        }
    }

}

extension VoiceIDClientTypes.ServerSideEncryptionUpdateDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case oldKmsKeyId = "OldKmsKeyId"
        case updateStatus = "UpdateStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let oldKmsKeyId = self.oldKmsKeyId {
            try encodeContainer.encode(oldKmsKeyId, forKey: .oldKmsKeyId)
        }
        if let updateStatus = self.updateStatus {
            try encodeContainer.encode(updateStatus.rawValue, forKey: .updateStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oldKmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .oldKmsKeyId)
        oldKmsKeyId = oldKmsKeyIdDecoded
        let updateStatusDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.ServerSideEncryptionUpdateStatus.self, forKey: .updateStatus)
        updateStatus = updateStatusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VoiceIDClientTypes {
    /// Details about the most recent server-side encryption configuration update. When the server-side encryption configuration is changed, dependency on the old KMS key is removed through an asynchronous process. When this update is complete, the domains data can only be accessed using the new KMS key.
    public struct ServerSideEncryptionUpdateDetails: Swift.Equatable {
        /// Message explaining the current UpdateStatus. When the UpdateStatus is FAILED, this message explains the cause of the failure.
        public var message: Swift.String?
        /// The previous KMS key ID the domain was encrypted with, before ServerSideEncryptionConfiguration was updated to a new KMS key ID.
        public var oldKmsKeyId: Swift.String?
        /// Status of the server-side encryption update. During an update, if there is an issue with the domain's current or old KMS key ID, such as an inaccessible or disabled key, then the status is FAILED. In order to resolve this, the key needs to be made accessible, and then an UpdateDomain call with the existing server-side encryption configuration will re-attempt this update process.
        public var updateStatus: VoiceIDClientTypes.ServerSideEncryptionUpdateStatus?

        public init(
            message: Swift.String? = nil,
            oldKmsKeyId: Swift.String? = nil,
            updateStatus: VoiceIDClientTypes.ServerSideEncryptionUpdateStatus? = nil
        )
        {
            self.message = message
            self.oldKmsKeyId = oldKmsKeyId
            self.updateStatus = updateStatus
        }
    }

}

extension VoiceIDClientTypes {
    public enum ServerSideEncryptionUpdateStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ServerSideEncryptionUpdateStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServerSideEncryptionUpdateStatus(rawValue: rawValue) ?? ServerSideEncryptionUpdateStatus.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request exceeded the service quota. Refer to [Voice ID Service Quotas](https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html#voiceid-quotas) and try your request again.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VoiceIDClientTypes.Speaker: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case customerSpeakerId = "CustomerSpeakerId"
        case domainId = "DomainId"
        case generatedSpeakerId = "GeneratedSpeakerId"
        case lastAccessedAt = "LastAccessedAt"
        case status = "Status"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let customerSpeakerId = self.customerSpeakerId {
            try encodeContainer.encode(customerSpeakerId, forKey: .customerSpeakerId)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let generatedSpeakerId = self.generatedSpeakerId {
            try encodeContainer.encode(generatedSpeakerId, forKey: .generatedSpeakerId)
        }
        if let lastAccessedAt = self.lastAccessedAt {
            try encodeContainer.encodeTimestamp(lastAccessedAt, format: .epochSeconds, forKey: .lastAccessedAt)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let customerSpeakerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerSpeakerId)
        customerSpeakerId = customerSpeakerIdDecoded
        let generatedSpeakerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedSpeakerId)
        generatedSpeakerId = generatedSpeakerIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.SpeakerStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let lastAccessedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastAccessedAt)
        lastAccessedAt = lastAccessedAtDecoded
    }
}

extension VoiceIDClientTypes.Speaker: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Speaker(createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), generatedSpeakerId: \(Swift.String(describing: generatedSpeakerId)), lastAccessedAt: \(Swift.String(describing: lastAccessedAt)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), customerSpeakerId: \"CONTENT_REDACTED\")"}
}

extension VoiceIDClientTypes {
    /// Contains all the information about a speaker.
    public struct Speaker: Swift.Equatable {
        /// A timestamp of when the speaker was created.
        public var createdAt: ClientRuntime.Date?
        /// The client-provided identifier for the speaker.
        public var customerSpeakerId: Swift.String?
        /// The identifier of the domain that contains the speaker.
        public var domainId: Swift.String?
        /// The service-generated identifier for the speaker.
        public var generatedSpeakerId: Swift.String?
        /// The timestamp of when the speaker was last accessed for enrollment, re-enrollment or a successful authentication. This timestamp is accurate to one hour.
        public var lastAccessedAt: ClientRuntime.Date?
        /// The current status of the speaker.
        public var status: VoiceIDClientTypes.SpeakerStatus?
        /// A timestamp of the speaker's last update.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            customerSpeakerId: Swift.String? = nil,
            domainId: Swift.String? = nil,
            generatedSpeakerId: Swift.String? = nil,
            lastAccessedAt: ClientRuntime.Date? = nil,
            status: VoiceIDClientTypes.SpeakerStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.customerSpeakerId = customerSpeakerId
            self.domainId = domainId
            self.generatedSpeakerId = generatedSpeakerId
            self.lastAccessedAt = lastAccessedAt
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension VoiceIDClientTypes.SpeakerEnrollmentJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case domainId = "DomainId"
        case endedAt = "EndedAt"
        case enrollmentConfig = "EnrollmentConfig"
        case failureDetails = "FailureDetails"
        case inputDataConfig = "InputDataConfig"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobProgress = "JobProgress"
        case jobStatus = "JobStatus"
        case outputDataConfig = "OutputDataConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let dataAccessRoleArn = self.dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let endedAt = self.endedAt {
            try encodeContainer.encodeTimestamp(endedAt, format: .epochSeconds, forKey: .endedAt)
        }
        if let enrollmentConfig = self.enrollmentConfig {
            try encodeContainer.encode(enrollmentConfig, forKey: .enrollmentConfig)
        }
        if let failureDetails = self.failureDetails {
            try encodeContainer.encode(failureDetails, forKey: .failureDetails)
        }
        if let inputDataConfig = self.inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobProgress = self.jobProgress {
            try encodeContainer.encode(jobProgress, forKey: .jobProgress)
        }
        if let jobStatus = self.jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let outputDataConfig = self.outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.SpeakerEnrollmentJobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let enrollmentConfigDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.EnrollmentConfig.self, forKey: .enrollmentConfig)
        enrollmentConfig = enrollmentConfigDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let endedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endedAt)
        endedAt = endedAtDecoded
        let failureDetailsDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.FailureDetails.self, forKey: .failureDetails)
        failureDetails = failureDetailsDecoded
        let jobProgressDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.JobProgress.self, forKey: .jobProgress)
        jobProgress = jobProgressDecoded
    }
}

extension VoiceIDClientTypes.SpeakerEnrollmentJob: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SpeakerEnrollmentJob(createdAt: \(Swift.String(describing: createdAt)), dataAccessRoleArn: \(Swift.String(describing: dataAccessRoleArn)), domainId: \(Swift.String(describing: domainId)), endedAt: \(Swift.String(describing: endedAt)), enrollmentConfig: \(Swift.String(describing: enrollmentConfig)), failureDetails: \(Swift.String(describing: failureDetails)), inputDataConfig: \(Swift.String(describing: inputDataConfig)), jobId: \(Swift.String(describing: jobId)), jobProgress: \(Swift.String(describing: jobProgress)), jobStatus: \(Swift.String(describing: jobStatus)), outputDataConfig: \(Swift.String(describing: outputDataConfig)), jobName: \"CONTENT_REDACTED\")"}
}

extension VoiceIDClientTypes {
    /// Contains all the information about a speaker enrollment job.
    public struct SpeakerEnrollmentJob: Swift.Equatable {
        /// A timestamp of when the speaker enrollment job was created.
        public var createdAt: ClientRuntime.Date?
        /// The IAM role Amazon Resource Name (ARN) that grants Voice ID permissions to access customer's buckets to read the input manifest file and write the job output file.
        public var dataAccessRoleArn: Swift.String?
        /// The identifier of the domain that contains the speaker enrollment job.
        public var domainId: Swift.String?
        /// A timestamp of when the speaker enrollment job ended.
        public var endedAt: ClientRuntime.Date?
        /// The configuration that defines the action to take when the speaker is already enrolled in Voice ID, and the FraudDetectionConfig to use.
        public var enrollmentConfig: VoiceIDClientTypes.EnrollmentConfig?
        /// Contains details that are populated when an entire batch job fails. In cases of individual registration job failures, the batch job as a whole doesn't fail; it is completed with a JobStatus of COMPLETED_WITH_ERRORS. You can use the job output file to identify the individual registration requests that failed.
        public var failureDetails: VoiceIDClientTypes.FailureDetails?
        /// The input data config containing an S3 URI for the input manifest file that contains the list of speaker enrollment job requests.
        public var inputDataConfig: VoiceIDClientTypes.InputDataConfig?
        /// The service-generated identifier for the speaker enrollment job.
        public var jobId: Swift.String?
        /// The client-provided name for the speaker enrollment job.
        public var jobName: Swift.String?
        /// Provides details on job progress. This field shows the completed percentage of registration requests listed in the input file.
        public var jobProgress: VoiceIDClientTypes.JobProgress?
        /// The current status of the speaker enrollment job.
        public var jobStatus: VoiceIDClientTypes.SpeakerEnrollmentJobStatus?
        /// The output data config containing the S3 location where Voice ID writes the job output file; you must also include a KMS key ID to encrypt the file.
        public var outputDataConfig: VoiceIDClientTypes.OutputDataConfig?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            dataAccessRoleArn: Swift.String? = nil,
            domainId: Swift.String? = nil,
            endedAt: ClientRuntime.Date? = nil,
            enrollmentConfig: VoiceIDClientTypes.EnrollmentConfig? = nil,
            failureDetails: VoiceIDClientTypes.FailureDetails? = nil,
            inputDataConfig: VoiceIDClientTypes.InputDataConfig? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobProgress: VoiceIDClientTypes.JobProgress? = nil,
            jobStatus: VoiceIDClientTypes.SpeakerEnrollmentJobStatus? = nil,
            outputDataConfig: VoiceIDClientTypes.OutputDataConfig? = nil
        )
        {
            self.createdAt = createdAt
            self.dataAccessRoleArn = dataAccessRoleArn
            self.domainId = domainId
            self.endedAt = endedAt
            self.enrollmentConfig = enrollmentConfig
            self.failureDetails = failureDetails
            self.inputDataConfig = inputDataConfig
            self.jobId = jobId
            self.jobName = jobName
            self.jobProgress = jobProgress
            self.jobStatus = jobStatus
            self.outputDataConfig = outputDataConfig
        }
    }

}

extension VoiceIDClientTypes {
    public enum SpeakerEnrollmentJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case completedWithErrors
        case failed
        case inProgress
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [SpeakerEnrollmentJobStatus] {
            return [
                .completed,
                .completedWithErrors,
                .failed,
                .inProgress,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .completedWithErrors: return "COMPLETED_WITH_ERRORS"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SpeakerEnrollmentJobStatus(rawValue: rawValue) ?? SpeakerEnrollmentJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIDClientTypes.SpeakerEnrollmentJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case domainId = "DomainId"
        case endedAt = "EndedAt"
        case failureDetails = "FailureDetails"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobProgress = "JobProgress"
        case jobStatus = "JobStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let endedAt = self.endedAt {
            try encodeContainer.encodeTimestamp(endedAt, format: .epochSeconds, forKey: .endedAt)
        }
        if let failureDetails = self.failureDetails {
            try encodeContainer.encode(failureDetails, forKey: .failureDetails)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobProgress = self.jobProgress {
            try encodeContainer.encode(jobProgress, forKey: .jobProgress)
        }
        if let jobStatus = self.jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.SpeakerEnrollmentJobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let endedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endedAt)
        endedAt = endedAtDecoded
        let failureDetailsDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.FailureDetails.self, forKey: .failureDetails)
        failureDetails = failureDetailsDecoded
        let jobProgressDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.JobProgress.self, forKey: .jobProgress)
        jobProgress = jobProgressDecoded
    }
}

extension VoiceIDClientTypes.SpeakerEnrollmentJobSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SpeakerEnrollmentJobSummary(createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), endedAt: \(Swift.String(describing: endedAt)), failureDetails: \(Swift.String(describing: failureDetails)), jobId: \(Swift.String(describing: jobId)), jobProgress: \(Swift.String(describing: jobProgress)), jobStatus: \(Swift.String(describing: jobStatus)), jobName: \"CONTENT_REDACTED\")"}
}

extension VoiceIDClientTypes {
    /// Contains a summary of information about a speaker enrollment job.
    public struct SpeakerEnrollmentJobSummary: Swift.Equatable {
        /// A timestamp of when of the speaker enrollment job was created.
        public var createdAt: ClientRuntime.Date?
        /// The identifier of the domain that contains the speaker enrollment job.
        public var domainId: Swift.String?
        /// A timestamp of when the speaker enrollment job ended.
        public var endedAt: ClientRuntime.Date?
        /// Contains details that are populated when an entire batch job fails. In cases of individual registration job failures, the batch job as a whole doesn't fail; it is completed with a JobStatus of COMPLETED_WITH_ERRORS. You can use the job output file to identify the individual registration requests that failed.
        public var failureDetails: VoiceIDClientTypes.FailureDetails?
        /// The service-generated identifier for the speaker enrollment job.
        public var jobId: Swift.String?
        /// The client-provided name for the speaker enrollment job.
        public var jobName: Swift.String?
        /// Provides details regarding job progress. This field shows the completed percentage of enrollment requests listed in the input file.
        public var jobProgress: VoiceIDClientTypes.JobProgress?
        /// The current status of the speaker enrollment job.
        public var jobStatus: VoiceIDClientTypes.SpeakerEnrollmentJobStatus?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            domainId: Swift.String? = nil,
            endedAt: ClientRuntime.Date? = nil,
            failureDetails: VoiceIDClientTypes.FailureDetails? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobProgress: VoiceIDClientTypes.JobProgress? = nil,
            jobStatus: VoiceIDClientTypes.SpeakerEnrollmentJobStatus? = nil
        )
        {
            self.createdAt = createdAt
            self.domainId = domainId
            self.endedAt = endedAt
            self.failureDetails = failureDetails
            self.jobId = jobId
            self.jobName = jobName
            self.jobProgress = jobProgress
            self.jobStatus = jobStatus
        }
    }

}

extension VoiceIDClientTypes {
    public enum SpeakerStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enrolled
        case expired
        case optedOut
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [SpeakerStatus] {
            return [
                .enrolled,
                .expired,
                .optedOut,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enrolled: return "ENROLLED"
            case .expired: return "EXPIRED"
            case .optedOut: return "OPTED_OUT"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SpeakerStatus(rawValue: rawValue) ?? SpeakerStatus.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIDClientTypes.SpeakerSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case customerSpeakerId = "CustomerSpeakerId"
        case domainId = "DomainId"
        case generatedSpeakerId = "GeneratedSpeakerId"
        case lastAccessedAt = "LastAccessedAt"
        case status = "Status"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let customerSpeakerId = self.customerSpeakerId {
            try encodeContainer.encode(customerSpeakerId, forKey: .customerSpeakerId)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let generatedSpeakerId = self.generatedSpeakerId {
            try encodeContainer.encode(generatedSpeakerId, forKey: .generatedSpeakerId)
        }
        if let lastAccessedAt = self.lastAccessedAt {
            try encodeContainer.encodeTimestamp(lastAccessedAt, format: .epochSeconds, forKey: .lastAccessedAt)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let customerSpeakerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerSpeakerId)
        customerSpeakerId = customerSpeakerIdDecoded
        let generatedSpeakerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedSpeakerId)
        generatedSpeakerId = generatedSpeakerIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.SpeakerStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let lastAccessedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastAccessedAt)
        lastAccessedAt = lastAccessedAtDecoded
    }
}

extension VoiceIDClientTypes.SpeakerSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SpeakerSummary(createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), generatedSpeakerId: \(Swift.String(describing: generatedSpeakerId)), lastAccessedAt: \(Swift.String(describing: lastAccessedAt)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), customerSpeakerId: \"CONTENT_REDACTED\")"}
}

extension VoiceIDClientTypes {
    /// Contains a summary of information about a speaker.
    public struct SpeakerSummary: Swift.Equatable {
        /// A timestamp showing the speaker's creation time.
        public var createdAt: ClientRuntime.Date?
        /// The client-provided identifier for the speaker.
        public var customerSpeakerId: Swift.String?
        /// The identifier of the domain that contains the speaker.
        public var domainId: Swift.String?
        /// The service-generated identifier for the speaker.
        public var generatedSpeakerId: Swift.String?
        /// The timestamp when the speaker was last accessed for enrollment, re-enrollment or a successful authentication. This timestamp is accurate to one hour.
        public var lastAccessedAt: ClientRuntime.Date?
        /// The current status of the speaker.
        public var status: VoiceIDClientTypes.SpeakerStatus?
        /// A timestamp showing the speaker's last update.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            customerSpeakerId: Swift.String? = nil,
            domainId: Swift.String? = nil,
            generatedSpeakerId: Swift.String? = nil,
            lastAccessedAt: ClientRuntime.Date? = nil,
            status: VoiceIDClientTypes.SpeakerStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.customerSpeakerId = customerSpeakerId
            self.domainId = domainId
            self.generatedSpeakerId = generatedSpeakerId
            self.lastAccessedAt = lastAccessedAt
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension StartFraudsterRegistrationJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartFraudsterRegistrationJobInput(clientToken: \(Swift.String(describing: clientToken)), dataAccessRoleArn: \(Swift.String(describing: dataAccessRoleArn)), domainId: \(Swift.String(describing: domainId)), inputDataConfig: \(Swift.String(describing: inputDataConfig)), outputDataConfig: \(Swift.String(describing: outputDataConfig)), registrationConfig: \(Swift.String(describing: registrationConfig)), jobName: \"CONTENT_REDACTED\")"}
}

extension StartFraudsterRegistrationJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case domainId = "DomainId"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case outputDataConfig = "OutputDataConfig"
        case registrationConfig = "RegistrationConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dataAccessRoleArn = self.dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let inputDataConfig = self.inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let outputDataConfig = self.outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let registrationConfig = self.registrationConfig {
            try encodeContainer.encode(registrationConfig, forKey: .registrationConfig)
        }
    }
}

extension StartFraudsterRegistrationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartFraudsterRegistrationJobInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The IAM role Amazon Resource Name (ARN) that grants Voice ID permissions to access customer's buckets to read the input manifest file and write the Job output file. Refer to the [Create and edit a fraudster watchlist](https://docs.aws.amazon.com/connect/latest/adminguide/voiceid-fraudster-watchlist.html) documentation for the permissions needed in this role.
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// The identifier of the domain that contains the fraudster registration job and in which the fraudsters are registered.
    /// This member is required.
    public var domainId: Swift.String?
    /// The input data config containing an S3 URI for the input manifest file that contains the list of fraudster registration requests.
    /// This member is required.
    public var inputDataConfig: VoiceIDClientTypes.InputDataConfig?
    /// The name of the new fraudster registration job.
    public var jobName: Swift.String?
    /// The output data config containing the S3 location where Voice ID writes the job output file; you must also include a KMS key ID to encrypt the file.
    /// This member is required.
    public var outputDataConfig: VoiceIDClientTypes.OutputDataConfig?
    /// The registration config containing details such as the action to take when a duplicate fraudster is detected, and the similarity threshold to use for detecting a duplicate fraudster.
    public var registrationConfig: VoiceIDClientTypes.RegistrationConfig?

    public init(
        clientToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        domainId: Swift.String? = nil,
        inputDataConfig: VoiceIDClientTypes.InputDataConfig? = nil,
        jobName: Swift.String? = nil,
        outputDataConfig: VoiceIDClientTypes.OutputDataConfig? = nil,
        registrationConfig: VoiceIDClientTypes.RegistrationConfig? = nil
    )
    {
        self.clientToken = clientToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.domainId = domainId
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.outputDataConfig = outputDataConfig
        self.registrationConfig = registrationConfig
    }
}

struct StartFraudsterRegistrationJobInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let jobName: Swift.String?
    let domainId: Swift.String?
    let dataAccessRoleArn: Swift.String?
    let registrationConfig: VoiceIDClientTypes.RegistrationConfig?
    let inputDataConfig: VoiceIDClientTypes.InputDataConfig?
    let outputDataConfig: VoiceIDClientTypes.OutputDataConfig?
}

extension StartFraudsterRegistrationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case domainId = "DomainId"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case outputDataConfig = "OutputDataConfig"
        case registrationConfig = "RegistrationConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let registrationConfigDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.RegistrationConfig.self, forKey: .registrationConfig)
        registrationConfig = registrationConfigDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
    }
}

extension StartFraudsterRegistrationJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartFraudsterRegistrationJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct StartFraudsterRegistrationJobOutput: Swift.Equatable {
    /// Details about the started fraudster registration job.
    public var job: VoiceIDClientTypes.FraudsterRegistrationJob?

    public init(
        job: VoiceIDClientTypes.FraudsterRegistrationJob? = nil
    )
    {
        self.job = job
    }
}

struct StartFraudsterRegistrationJobOutputBody: Swift.Equatable {
    let job: VoiceIDClientTypes.FraudsterRegistrationJob?
}

extension StartFraudsterRegistrationJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job = "Job"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.FraudsterRegistrationJob.self, forKey: .job)
        job = jobDecoded
    }
}

enum StartFraudsterRegistrationJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartSpeakerEnrollmentJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartSpeakerEnrollmentJobInput(clientToken: \(Swift.String(describing: clientToken)), dataAccessRoleArn: \(Swift.String(describing: dataAccessRoleArn)), domainId: \(Swift.String(describing: domainId)), enrollmentConfig: \(Swift.String(describing: enrollmentConfig)), inputDataConfig: \(Swift.String(describing: inputDataConfig)), outputDataConfig: \(Swift.String(describing: outputDataConfig)), jobName: \"CONTENT_REDACTED\")"}
}

extension StartSpeakerEnrollmentJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case domainId = "DomainId"
        case enrollmentConfig = "EnrollmentConfig"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case outputDataConfig = "OutputDataConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dataAccessRoleArn = self.dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let enrollmentConfig = self.enrollmentConfig {
            try encodeContainer.encode(enrollmentConfig, forKey: .enrollmentConfig)
        }
        if let inputDataConfig = self.inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let outputDataConfig = self.outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
    }
}

extension StartSpeakerEnrollmentJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartSpeakerEnrollmentJobInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The IAM role Amazon Resource Name (ARN) that grants Voice ID permissions to access customer's buckets to read the input manifest file and write the job output file. Refer to [Batch enrollment using audio data from prior calls](https://docs.aws.amazon.com/connect/latest/adminguide/voiceid-batch-enrollment.html) for the permissions needed in this role.
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// The identifier of the domain that contains the speaker enrollment job and in which the speakers are enrolled.
    /// This member is required.
    public var domainId: Swift.String?
    /// The enrollment config that contains details such as the action to take when a speaker is already enrolled in Voice ID or when a speaker is identified as a fraudster.
    public var enrollmentConfig: VoiceIDClientTypes.EnrollmentConfig?
    /// The input data config containing the S3 location for the input manifest file that contains the list of speaker enrollment requests.
    /// This member is required.
    public var inputDataConfig: VoiceIDClientTypes.InputDataConfig?
    /// A name for your speaker enrollment job.
    public var jobName: Swift.String?
    /// The output data config containing the S3 location where Voice ID writes the job output file; you must also include a KMS key ID to encrypt the file.
    /// This member is required.
    public var outputDataConfig: VoiceIDClientTypes.OutputDataConfig?

    public init(
        clientToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        domainId: Swift.String? = nil,
        enrollmentConfig: VoiceIDClientTypes.EnrollmentConfig? = nil,
        inputDataConfig: VoiceIDClientTypes.InputDataConfig? = nil,
        jobName: Swift.String? = nil,
        outputDataConfig: VoiceIDClientTypes.OutputDataConfig? = nil
    )
    {
        self.clientToken = clientToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.domainId = domainId
        self.enrollmentConfig = enrollmentConfig
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.outputDataConfig = outputDataConfig
    }
}

struct StartSpeakerEnrollmentJobInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let jobName: Swift.String?
    let domainId: Swift.String?
    let dataAccessRoleArn: Swift.String?
    let enrollmentConfig: VoiceIDClientTypes.EnrollmentConfig?
    let inputDataConfig: VoiceIDClientTypes.InputDataConfig?
    let outputDataConfig: VoiceIDClientTypes.OutputDataConfig?
}

extension StartSpeakerEnrollmentJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case domainId = "DomainId"
        case enrollmentConfig = "EnrollmentConfig"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case outputDataConfig = "OutputDataConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let enrollmentConfigDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.EnrollmentConfig.self, forKey: .enrollmentConfig)
        enrollmentConfig = enrollmentConfigDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
    }
}

extension StartSpeakerEnrollmentJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartSpeakerEnrollmentJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct StartSpeakerEnrollmentJobOutput: Swift.Equatable {
    /// Details about the started speaker enrollment job.
    public var job: VoiceIDClientTypes.SpeakerEnrollmentJob?

    public init(
        job: VoiceIDClientTypes.SpeakerEnrollmentJob? = nil
    )
    {
        self.job = job
    }
}

struct StartSpeakerEnrollmentJobOutputBody: Swift.Equatable {
    let job: VoiceIDClientTypes.SpeakerEnrollmentJob?
}

extension StartSpeakerEnrollmentJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job = "Job"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.SpeakerEnrollmentJob.self, forKey: .job)
        job = jobDecoded
    }
}

enum StartSpeakerEnrollmentJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension VoiceIDClientTypes {
    public enum StreamingStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ended
        case ongoing
        case pendingConfiguration
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingStatus] {
            return [
                .ended,
                .ongoing,
                .pendingConfiguration,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ended: return "ENDED"
            case .ongoing: return "ONGOING"
            case .pendingConfiguration: return "PENDING_CONFIGURATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamingStatus(rawValue: rawValue) ?? StreamingStatus.sdkUnknown(rawValue)
        }
    }
}

extension VoiceIDClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension VoiceIDClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \"CONTENT_REDACTED\", value: \"CONTENT_REDACTED\")"}
}

extension VoiceIDClientTypes {
    /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    public struct Tag: Swift.Equatable {
        /// The first part of a key:value pair that forms a tag associated with a given resource. For example, in the tag 'Department':'Sales', the key is 'Department'.
        /// This member is required.
        public var key: Swift.String?
        /// The second part of a key:value pair that forms a tag associated with a given resource. For example, in the tag 'Department':'Sales', the value is 'Sales'.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Voice ID resource you want to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tags to assign to the specified resource.
    /// This member is required.
    public var tags: [VoiceIDClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [VoiceIDClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [VoiceIDClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([VoiceIDClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[VoiceIDClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [VoiceIDClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling. Please slow down your request rate. Refer to [ Amazon Connect Voice ID Service API throttling quotas ](https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html##voiceid-api-quotas) and try your request again.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Voice ID resource you want to remove tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys you want to remove from the specified resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDomainInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDomainInput(domainId: \(Swift.String(describing: domainId)), serverSideEncryptionConfiguration: \(Swift.String(describing: serverSideEncryptionConfiguration)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case domainId = "DomainId"
        case name = "Name"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverSideEncryptionConfiguration = self.serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
    }
}

extension UpdateDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateDomainInput: Swift.Equatable {
    /// A brief description about this domain.
    public var description: Swift.String?
    /// The identifier of the domain to be updated.
    /// This member is required.
    public var domainId: Swift.String?
    /// The name of the domain.
    /// This member is required.
    public var name: Swift.String?
    /// The configuration, containing the KMS key identifier, to be used by Voice ID for the server-side encryption of your data. Changing the domain's associated KMS key immediately triggers an asynchronous process to remove dependency on the old KMS key, such that the domain's data can only be accessed using the new KMS key. The domain's ServerSideEncryptionUpdateDetails contains the details for this process.
    /// This member is required.
    public var serverSideEncryptionConfiguration: VoiceIDClientTypes.ServerSideEncryptionConfiguration?

    public init(
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        name: Swift.String? = nil,
        serverSideEncryptionConfiguration: VoiceIDClientTypes.ServerSideEncryptionConfiguration? = nil
    )
    {
        self.description = description
        self.domainId = domainId
        self.name = name
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
    }
}

struct UpdateDomainInputBody: Swift.Equatable {
    let domainId: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let serverSideEncryptionConfiguration: VoiceIDClientTypes.ServerSideEncryptionConfiguration?
}

extension UpdateDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case domainId = "DomainId"
        case name = "Name"
        case serverSideEncryptionConfiguration = "ServerSideEncryptionConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
    }
}

extension UpdateDomainOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateDomainOutputBody = try responseDecoder.decode(responseBody: data)
            self.domain = output.domain
        } else {
            self.domain = nil
        }
    }
}

public struct UpdateDomainOutput: Swift.Equatable {
    /// Details about the updated domain
    public var domain: VoiceIDClientTypes.Domain?

    public init(
        domain: VoiceIDClientTypes.Domain? = nil
    )
    {
        self.domain = domain
    }
}

struct UpdateDomainOutputBody: Swift.Equatable {
    let domain: VoiceIDClientTypes.Domain?
}

extension UpdateDomainOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "Domain"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.Domain.self, forKey: .domain)
        domain = domainDecoded
    }
}

enum UpdateDomainOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateWatchlistInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateWatchlistInput(domainId: \(Swift.String(describing: domainId)), watchlistId: \(Swift.String(describing: watchlistId)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateWatchlistInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case domainId = "DomainId"
        case name = "Name"
        case watchlistId = "WatchlistId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let watchlistId = self.watchlistId {
            try encodeContainer.encode(watchlistId, forKey: .watchlistId)
        }
    }
}

extension UpdateWatchlistInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateWatchlistInput: Swift.Equatable {
    /// A brief description about this watchlist.
    public var description: Swift.String?
    /// The identifier of the domain that contains the watchlist.
    /// This member is required.
    public var domainId: Swift.String?
    /// The name of the watchlist.
    public var name: Swift.String?
    /// The identifier of the watchlist to be updated.
    /// This member is required.
    public var watchlistId: Swift.String?

    public init(
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        name: Swift.String? = nil,
        watchlistId: Swift.String? = nil
    )
    {
        self.description = description
        self.domainId = domainId
        self.name = name
        self.watchlistId = watchlistId
    }
}

struct UpdateWatchlistInputBody: Swift.Equatable {
    let domainId: Swift.String?
    let watchlistId: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdateWatchlistInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case domainId = "DomainId"
        case name = "Name"
        case watchlistId = "WatchlistId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let watchlistIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .watchlistId)
        watchlistId = watchlistIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateWatchlistOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateWatchlistOutputBody = try responseDecoder.decode(responseBody: data)
            self.watchlist = output.watchlist
        } else {
            self.watchlist = nil
        }
    }
}

public struct UpdateWatchlistOutput: Swift.Equatable {
    /// Details about the updated watchlist.
    public var watchlist: VoiceIDClientTypes.Watchlist?

    public init(
        watchlist: VoiceIDClientTypes.Watchlist? = nil
    )
    {
        self.watchlist = watchlist
    }
}

struct UpdateWatchlistOutputBody: Swift.Equatable {
    let watchlist: VoiceIDClientTypes.Watchlist?
}

extension UpdateWatchlistOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case watchlist = "Watchlist"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let watchlistDecoded = try containerValues.decodeIfPresent(VoiceIDClientTypes.Watchlist.self, forKey: .watchlist)
        watchlist = watchlistDecoded
    }
}

enum UpdateWatchlistOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request failed one or more validations; check the error message for more details.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VoiceIDClientTypes.VoiceSpoofingRisk: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case riskScore = "RiskScore"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let riskScore = self.riskScore {
            try encodeContainer.encode(riskScore, forKey: .riskScore)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let riskScoreDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .riskScore)
        riskScore = riskScoreDecoded
    }
}

extension VoiceIDClientTypes {
    /// The details resulting from 'Voice Spoofing Risk' analysis of the speaker.
    public struct VoiceSpoofingRisk: Swift.Equatable {
        /// The score indicating the likelihood of speakers voice being spoofed.
        /// This member is required.
        public var riskScore: Swift.Int?

        public init(
            riskScore: Swift.Int? = nil
        )
        {
            self.riskScore = riskScore
        }
    }

}

extension VoiceIDClientTypes.Watchlist: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case defaultWatchlist = "DefaultWatchlist"
        case description = "Description"
        case domainId = "DomainId"
        case name = "Name"
        case updatedAt = "UpdatedAt"
        case watchlistId = "WatchlistId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if defaultWatchlist != false {
            try encodeContainer.encode(defaultWatchlist, forKey: .defaultWatchlist)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
        if let watchlistId = self.watchlistId {
            try encodeContainer.encode(watchlistId, forKey: .watchlistId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let watchlistIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .watchlistId)
        watchlistId = watchlistIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let defaultWatchlistDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .defaultWatchlist) ?? false
        defaultWatchlist = defaultWatchlistDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension VoiceIDClientTypes.Watchlist: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Watchlist(createdAt: \(Swift.String(describing: createdAt)), defaultWatchlist: \(Swift.String(describing: defaultWatchlist)), domainId: \(Swift.String(describing: domainId)), updatedAt: \(Swift.String(describing: updatedAt)), watchlistId: \(Swift.String(describing: watchlistId)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension VoiceIDClientTypes {
    /// Contains all the information about a watchlist.
    public struct Watchlist: Swift.Equatable {
        /// The timestamp of when the watchlist was created.
        public var createdAt: ClientRuntime.Date?
        /// Whether the specified watchlist is the default watchlist of a domain.
        public var defaultWatchlist: Swift.Bool
        /// The description of the watchlist.
        public var description: Swift.String?
        /// The identifier of the domain that contains the watchlist.
        public var domainId: Swift.String?
        /// The name for the watchlist.
        public var name: Swift.String?
        /// The timestamp of when the watchlist was updated.
        public var updatedAt: ClientRuntime.Date?
        /// The identifier of the watchlist.
        public var watchlistId: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            defaultWatchlist: Swift.Bool = false,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            name: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            watchlistId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.defaultWatchlist = defaultWatchlist
            self.description = description
            self.domainId = domainId
            self.name = name
            self.updatedAt = updatedAt
            self.watchlistId = watchlistId
        }
    }

}

extension VoiceIDClientTypes.WatchlistDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultWatchlistId = "DefaultWatchlistId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultWatchlistId = self.defaultWatchlistId {
            try encodeContainer.encode(defaultWatchlistId, forKey: .defaultWatchlistId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultWatchlistIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultWatchlistId)
        defaultWatchlistId = defaultWatchlistIdDecoded
    }
}

extension VoiceIDClientTypes {
    /// Details of the watchlists in a domain.
    public struct WatchlistDetails: Swift.Equatable {
        /// The identifier of the default watchlist.
        /// This member is required.
        public var defaultWatchlistId: Swift.String?

        public init(
            defaultWatchlistId: Swift.String? = nil
        )
        {
            self.defaultWatchlistId = defaultWatchlistId
        }
    }

}

extension VoiceIDClientTypes.WatchlistSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case defaultWatchlist = "DefaultWatchlist"
        case description = "Description"
        case domainId = "DomainId"
        case name = "Name"
        case updatedAt = "UpdatedAt"
        case watchlistId = "WatchlistId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if defaultWatchlist != false {
            try encodeContainer.encode(defaultWatchlist, forKey: .defaultWatchlist)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domainId = self.domainId {
            try encodeContainer.encode(domainId, forKey: .domainId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
        if let watchlistId = self.watchlistId {
            try encodeContainer.encode(watchlistId, forKey: .watchlistId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainId)
        domainId = domainIdDecoded
        let watchlistIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .watchlistId)
        watchlistId = watchlistIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let defaultWatchlistDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .defaultWatchlist) ?? false
        defaultWatchlist = defaultWatchlistDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension VoiceIDClientTypes.WatchlistSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WatchlistSummary(createdAt: \(Swift.String(describing: createdAt)), defaultWatchlist: \(Swift.String(describing: defaultWatchlist)), domainId: \(Swift.String(describing: domainId)), updatedAt: \(Swift.String(describing: updatedAt)), watchlistId: \(Swift.String(describing: watchlistId)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension VoiceIDClientTypes {
    /// Contains a summary of information about a watchlist.
    public struct WatchlistSummary: Swift.Equatable {
        /// The timestamp of when the watchlist was created.
        public var createdAt: ClientRuntime.Date?
        /// Whether the specified watchlist is the default watchlist of a domain.
        public var defaultWatchlist: Swift.Bool
        /// The description of the watchlist.
        public var description: Swift.String?
        /// The identifier of the domain that contains the watchlist.
        public var domainId: Swift.String?
        /// The name for the watchlist.
        public var name: Swift.String?
        /// The timestamp of when the watchlist was last updated.
        public var updatedAt: ClientRuntime.Date?
        /// The identifier of the watchlist.
        public var watchlistId: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            defaultWatchlist: Swift.Bool = false,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            name: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            watchlistId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.defaultWatchlist = defaultWatchlist
            self.description = description
            self.domainId = domainId
            self.name = name
            self.updatedAt = updatedAt
            self.watchlistId = watchlistId
        }
    }

}
