// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AcceptResourceShareInvitationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShareInvitationArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let resourceShareInvitationArn = self.resourceShareInvitationArn {
            try encodeContainer.encode(resourceShareInvitationArn, forKey: .resourceShareInvitationArn)
        }
    }
}

extension AcceptResourceShareInvitationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/acceptresourceshareinvitation"
    }
}

public struct AcceptResourceShareInvitationInput: Swift.Equatable {
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value.](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// The [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the invitation that you want to accept.
    /// This member is required.
    public var resourceShareInvitationArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        resourceShareInvitationArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShareInvitationArn = resourceShareInvitationArn
    }
}

struct AcceptResourceShareInvitationInputBody: Swift.Equatable {
    let resourceShareInvitationArn: Swift.String?
    let clientToken: Swift.String?
}

extension AcceptResourceShareInvitationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShareInvitationArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareInvitationArn)
        resourceShareInvitationArn = resourceShareInvitationArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public enum AcceptResourceShareInvitationOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "IdempotentParameterMismatch": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidClientToken": return try await InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArn.Malformed": return try await MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceShareInvitationArn.AlreadyAccepted": return try await ResourceShareInvitationAlreadyAcceptedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceShareInvitationArn.AlreadyRejected": return try await ResourceShareInvitationAlreadyRejectedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceShareInvitationArn.NotFound": return try await ResourceShareInvitationArnNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceShareInvitationArn.Expired": return try await ResourceShareInvitationExpiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "Unavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AcceptResourceShareInvitationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AcceptResourceShareInvitationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.resourceShareInvitation = output.resourceShareInvitation
        } else {
            self.clientToken = nil
            self.resourceShareInvitation = nil
        }
    }
}

public struct AcceptResourceShareInvitationOutputResponse: Swift.Equatable {
    /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other parameters must also have the same values that you used in the first call.
    public var clientToken: Swift.String?
    /// An object that contains information about the specified invitation.
    public var resourceShareInvitation: RAMClientTypes.ResourceShareInvitation?

    public init(
        clientToken: Swift.String? = nil,
        resourceShareInvitation: RAMClientTypes.ResourceShareInvitation? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShareInvitation = resourceShareInvitation
    }
}

struct AcceptResourceShareInvitationOutputResponseBody: Swift.Equatable {
    let resourceShareInvitation: RAMClientTypes.ResourceShareInvitation?
    let clientToken: Swift.String?
}

extension AcceptResourceShareInvitationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShareInvitation
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceShareInvitation.self, forKey: .resourceShareInvitation)
        resourceShareInvitation = resourceShareInvitationDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension AssociateResourceShareInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case principals
        case resourceArns
        case resourceShareArn
        case sources
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for string0 in principals {
                try principalsContainer.encode(string0)
            }
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for string0 in resourceArns {
                try resourceArnsContainer.encode(string0)
            }
        }
        if let resourceShareArn = self.resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for string0 in sources {
                try sourcesContainer.encode(string0)
            }
        }
    }
}

extension AssociateResourceShareInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/associateresourceshare"
    }
}

public struct AssociateResourceShareInput: Swift.Equatable {
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value.](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// Specifies a list of principals to whom you want to the resource share. This can be null if you want to add only resources. What the principals can do with the resources in the share is determined by the RAM permissions that you associate with the resource share. See [AssociateResourceSharePermission]. You can include the following values:
    ///
    /// * An Amazon Web Services account ID, for example: 123456789012
    ///
    /// * An [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of an organization in Organizations, for example: organizations::123456789012:organization/o-exampleorgid
    ///
    /// * An ARN of an organizational unit (OU) in Organizations, for example: organizations::123456789012:ou/o-exampleorgid/ou-examplerootid-exampleouid123
    ///
    /// * An ARN of an IAM role, for example: iam::123456789012:role/rolename
    ///
    /// * An ARN of an IAM user, for example: iam::123456789012user/username
    ///
    ///
    /// Not all resource types can be shared with IAM roles and users. For more information, see [Sharing with IAM roles and users](https://docs.aws.amazon.com/ram/latest/userguide/permissions.html#permissions-rbp-supported-resource-types) in the Resource Access Manager User Guide.
    public var principals: [Swift.String]?
    /// Specifies a list of [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resources that you want to share. This can be null if you want to add only principals.
    public var resourceArns: [Swift.String]?
    /// Specifies the [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource share that you want to add principals or resources to.
    /// This member is required.
    public var resourceShareArn: Swift.String?
    /// Specifies from which source accounts the service principal has access to the resources in this resource share.
    public var sources: [Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        principals: [Swift.String]? = nil,
        resourceArns: [Swift.String]? = nil,
        resourceShareArn: Swift.String? = nil,
        sources: [Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.principals = principals
        self.resourceArns = resourceArns
        self.resourceShareArn = resourceShareArn
        self.sources = sources
    }
}

struct AssociateResourceShareInputBody: Swift.Equatable {
    let resourceShareArn: Swift.String?
    let resourceArns: [Swift.String]?
    let principals: [Swift.String]?
    let clientToken: Swift.String?
    let sources: [Swift.String]?
}

extension AssociateResourceShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case principals
        case resourceArns
        case resourceShareArn
        case sources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let principalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .principals)
        var principalsDecoded0:[Swift.String]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [Swift.String]()
            for string0 in principalsContainer {
                if let string0 = string0 {
                    principalsDecoded0?.append(string0)
                }
            }
        }
        principals = principalsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sources)
        var sourcesDecoded0:[Swift.String]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [Swift.String]()
            for string0 in sourcesContainer {
                if let string0 = string0 {
                    sourcesDecoded0?.append(string0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

public enum AssociateResourceShareOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "IdempotentParameterMismatch": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidClientToken": return try await InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidStateTransitionException.Unknown": return try await InvalidStateTransitionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArn.Malformed": return try await MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceShareLimitExceeded": return try await ResourceShareLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "Unavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceShareArn.NotFound": return try await UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateResourceShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateResourceShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.resourceShareAssociations = output.resourceShareAssociations
        } else {
            self.clientToken = nil
            self.resourceShareAssociations = nil
        }
    }
}

public struct AssociateResourceShareOutputResponse: Swift.Equatable {
    /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other parameters must also have the same values that you used in the first call.
    public var clientToken: Swift.String?
    /// An array of objects that contain information about the associations.
    public var resourceShareAssociations: [RAMClientTypes.ResourceShareAssociation]?

    public init(
        clientToken: Swift.String? = nil,
        resourceShareAssociations: [RAMClientTypes.ResourceShareAssociation]? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShareAssociations = resourceShareAssociations
    }
}

struct AssociateResourceShareOutputResponseBody: Swift.Equatable {
    let resourceShareAssociations: [RAMClientTypes.ResourceShareAssociation]?
    let clientToken: Swift.String?
}

extension AssociateResourceShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShareAssociations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareAssociationsContainer = try containerValues.decodeIfPresent([RAMClientTypes.ResourceShareAssociation?].self, forKey: .resourceShareAssociations)
        var resourceShareAssociationsDecoded0:[RAMClientTypes.ResourceShareAssociation]? = nil
        if let resourceShareAssociationsContainer = resourceShareAssociationsContainer {
            resourceShareAssociationsDecoded0 = [RAMClientTypes.ResourceShareAssociation]()
            for structure0 in resourceShareAssociationsContainer {
                if let structure0 = structure0 {
                    resourceShareAssociationsDecoded0?.append(structure0)
                }
            }
        }
        resourceShareAssociations = resourceShareAssociationsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension AssociateResourceSharePermissionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case permissionArn
        case permissionVersion
        case replace
        case resourceShareArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let permissionArn = self.permissionArn {
            try encodeContainer.encode(permissionArn, forKey: .permissionArn)
        }
        if let permissionVersion = self.permissionVersion {
            try encodeContainer.encode(permissionVersion, forKey: .permissionVersion)
        }
        if let replace = self.replace {
            try encodeContainer.encode(replace, forKey: .replace)
        }
        if let resourceShareArn = self.resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
    }
}

extension AssociateResourceSharePermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/associateresourcesharepermission"
    }
}

public struct AssociateResourceSharePermissionInput: Swift.Equatable {
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value.](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// Specifies the [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the RAM permission to associate with the resource share. To find the ARN for a permission, use either the [ListPermissions] operation or go to the [Permissions library](https://console.aws.amazon.com/ram/home#Permissions:) page in the RAM console and then choose the name of the permission. The ARN is displayed on the detail page.
    /// This member is required.
    public var permissionArn: Swift.String?
    /// Specifies the version of the RAM permission to associate with the resource share. You can specify only the version that is currently set as the default version for the permission. If you also set the replace pararameter to true, then this operation updates an outdated version of the permission to the current default version. You don't need to specify this parameter because the default behavior is to use the version that is currently set as the default version for the permission. This parameter is supported for backwards compatibility.
    public var permissionVersion: Swift.Int?
    /// Specifies whether the specified permission should replace the existing permission associated with the resource share. Use true to replace the current permissions. Use false to add the permission to a resource share that currently doesn't have a permission. The default value is false. A resource share can have only one permission per resource type. If a resource share already has a permission for the specified resource type and you don't set replace to true then the operation returns an error. This helps prevent accidental overwriting of a permission.
    public var replace: Swift.Bool?
    /// Specifies the [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource share to which you want to add or replace permissions.
    /// This member is required.
    public var resourceShareArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        permissionArn: Swift.String? = nil,
        permissionVersion: Swift.Int? = nil,
        replace: Swift.Bool? = nil,
        resourceShareArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.permissionArn = permissionArn
        self.permissionVersion = permissionVersion
        self.replace = replace
        self.resourceShareArn = resourceShareArn
    }
}

struct AssociateResourceSharePermissionInputBody: Swift.Equatable {
    let resourceShareArn: Swift.String?
    let permissionArn: Swift.String?
    let replace: Swift.Bool?
    let clientToken: Swift.String?
    let permissionVersion: Swift.Int?
}

extension AssociateResourceSharePermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case permissionArn
        case permissionVersion
        case replace
        case resourceShareArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let permissionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionArn)
        permissionArn = permissionArnDecoded
        let replaceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .replace)
        replace = replaceDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let permissionVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .permissionVersion)
        permissionVersion = permissionVersionDecoded
    }
}

public enum AssociateResourceSharePermissionOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidClientToken": return try await InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArn.Malformed": return try await MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "Unavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceShareArn.NotFound": return try await UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateResourceSharePermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateResourceSharePermissionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.returnValue = output.returnValue
        } else {
            self.clientToken = nil
            self.returnValue = nil
        }
    }
}

public struct AssociateResourceSharePermissionOutputResponse: Swift.Equatable {
    /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other parameters must also have the same values that you used in the first call.
    public var clientToken: Swift.String?
    /// A return value of true indicates that the request succeeded. A value of false indicates that the request failed.
    public var returnValue: Swift.Bool?

    public init(
        clientToken: Swift.String? = nil,
        returnValue: Swift.Bool? = nil
    )
    {
        self.clientToken = clientToken
        self.returnValue = returnValue
    }
}

struct AssociateResourceSharePermissionOutputResponseBody: Swift.Equatable {
    let returnValue: Swift.Bool?
    let clientToken: Swift.String?
}

extension AssociateResourceSharePermissionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case returnValue
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnValue)
        returnValue = returnValueDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension RAMClientTypes.AssociatedPermission: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case defaultVersion
        case featureSet
        case lastUpdatedTime
        case permissionVersion
        case resourceShareArn
        case resourceType
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let defaultVersion = self.defaultVersion {
            try encodeContainer.encode(defaultVersion, forKey: .defaultVersion)
        }
        if let featureSet = self.featureSet {
            try encodeContainer.encode(featureSet.rawValue, forKey: .featureSet)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let permissionVersion = self.permissionVersion {
            try encodeContainer.encode(permissionVersion, forKey: .permissionVersion)
        }
        if let resourceShareArn = self.resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let permissionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionVersion)
        permissionVersion = permissionVersionDecoded
        let defaultVersionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .defaultVersion)
        defaultVersion = defaultVersionDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let featureSetDecoded = try containerValues.decodeIfPresent(RAMClientTypes.PermissionFeatureSet.self, forKey: .featureSet)
        featureSet = featureSetDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
    }
}

extension RAMClientTypes {
    /// An object that describes a managed permission associated with a resource share.
    public struct AssociatedPermission: Swift.Equatable {
        /// The [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the associated managed permission.
        public var arn: Swift.String?
        /// Indicates whether the associated resource share is using the default version of the permission.
        public var defaultVersion: Swift.Bool?
        /// Indicates what features are available for this resource share. This parameter can have one of the following values:
        ///
        /// * STANDARD – A resource share that supports all functionality. These resource shares are visible to all principals you share the resource share with. You can modify these resource shares in RAM using the console or APIs. This resource share might have been created by RAM, or it might have been CREATED_FROM_POLICY and then promoted.
        ///
        /// * CREATED_FROM_POLICY – The customer manually shared a resource by attaching a resource-based policy. That policy did not match any existing managed permissions, so RAM created this customer managed permission automatically on the customer's behalf based on the attached policy document. This type of resource share is visible only to the Amazon Web Services account that created it. You can't modify it in RAM unless you promote it. For more information, see [PromoteResourceShareCreatedFromPolicy].
        ///
        /// * PROMOTING_TO_STANDARD – This resource share was originally CREATED_FROM_POLICY, but the customer ran the [PromoteResourceShareCreatedFromPolicy] and that operation is still in progress. This value changes to STANDARD when complete.
        public var featureSet: RAMClientTypes.PermissionFeatureSet?
        /// The date and time when the association between the permission and the resource share was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The version of the permission currently associated with the resource share.
        public var permissionVersion: Swift.String?
        /// The [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of a resource share associated with this permission.
        public var resourceShareArn: Swift.String?
        /// The resource type to which this permission applies.
        public var resourceType: Swift.String?
        /// The current status of the association between the permission and the resource share. The following are the possible values:
        ///
        /// * ATTACHABLE – This permission or version can be associated with resource shares.
        ///
        /// * UNATTACHABLE – This permission or version can't currently be associated with resource shares.
        ///
        /// * DELETING – This permission or version is in the process of being deleted.
        ///
        /// * DELETED – This permission or version is deleted.
        public var status: Swift.String?

        public init(
            arn: Swift.String? = nil,
            defaultVersion: Swift.Bool? = nil,
            featureSet: RAMClientTypes.PermissionFeatureSet? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            permissionVersion: Swift.String? = nil,
            resourceShareArn: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.arn = arn
            self.defaultVersion = defaultVersion
            self.featureSet = featureSet
            self.lastUpdatedTime = lastUpdatedTime
            self.permissionVersion = permissionVersion
            self.resourceShareArn = resourceShareArn
            self.resourceType = resourceType
            self.status = status
        }
    }

}

extension CreatePermissionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case name
        case policyTemplate
        case resourceType
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policyTemplate = self.policyTemplate {
            try encodeContainer.encode(policyTemplate, forKey: .policyTemplate)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreatePermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createpermission"
    }
}

public struct CreatePermissionInput: Swift.Equatable {
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value.](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// Specifies the name of the customer managed permission. The name must be unique within the Amazon Web Services Region.
    /// This member is required.
    public var name: Swift.String?
    /// A string in JSON format string that contains the following elements of a resource-based policy:
    ///
    /// * Effect: must be set to ALLOW.
    ///
    /// * Action: specifies the actions that are allowed by this customer managed permission. The list must contain only actions that are supported by the specified resource type. For a list of all actions supported by each resource type, see [Actions, resources, and condition keys for Amazon Web Services services](https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html) in the Identity and Access Management User Guide.
    ///
    /// * Condition: (optional) specifies conditional parameters that must evaluate to true when a user attempts an action for that action to be allowed. For more information about the Condition element, see [IAM policies: Condition element](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_condition.html) in the Identity and Access Management User Guide.
    ///
    ///
    /// This template can't include either the Resource or Principal elements. Those are both filled in by RAM when it instantiates the resource-based policy on each resource shared using this managed permission. The Resource comes from the ARN of the specific resource that you are sharing. The Principal comes from the list of identities added to the resource share.
    /// This member is required.
    public var policyTemplate: Swift.String?
    /// Specifies the name of the resource type that this customer managed permission applies to. The format is  :  and is not case sensitive. For example, to specify an Amazon EC2 Subnet, you can use the string ec2:subnet. To see the list of valid values for this parameter, query the [ListResourceTypes] operation.
    /// This member is required.
    public var resourceType: Swift.String?
    /// Specifies a list of one or more tag key and value pairs to attach to the permission.
    public var tags: [RAMClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        policyTemplate: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        tags: [RAMClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.name = name
        self.policyTemplate = policyTemplate
        self.resourceType = resourceType
        self.tags = tags
    }
}

struct CreatePermissionInputBody: Swift.Equatable {
    let name: Swift.String?
    let resourceType: Swift.String?
    let policyTemplate: Swift.String?
    let clientToken: Swift.String?
    let tags: [RAMClientTypes.Tag]?
}

extension CreatePermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case name
        case policyTemplate
        case resourceType
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let policyTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyTemplate)
        policyTemplate = policyTemplateDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([RAMClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RAMClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RAMClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public enum CreatePermissionOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "IdempotentParameterMismatch": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidClientToken": return try await InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPolicy": return try await InvalidPolicyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MalformedPolicyTemplateException": return try await MalformedPolicyTemplateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PermissionAlreadyExistsException": return try await PermissionAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PermissionLimitExceededException": return try await PermissionLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "Unavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePermissionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.permission = output.permission
        } else {
            self.clientToken = nil
            self.permission = nil
        }
    }
}

public struct CreatePermissionOutputResponse: Swift.Equatable {
    /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other parameters must also have the same values that you used in the first call.
    public var clientToken: Swift.String?
    /// A structure with information about this customer managed permission.
    public var permission: RAMClientTypes.ResourceSharePermissionSummary?

    public init(
        clientToken: Swift.String? = nil,
        permission: RAMClientTypes.ResourceSharePermissionSummary? = nil
    )
    {
        self.clientToken = clientToken
        self.permission = permission
    }
}

struct CreatePermissionOutputResponseBody: Swift.Equatable {
    let permission: RAMClientTypes.ResourceSharePermissionSummary?
    let clientToken: Swift.String?
}

extension CreatePermissionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case permission
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceSharePermissionSummary.self, forKey: .permission)
        permission = permissionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreatePermissionVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case permissionArn
        case policyTemplate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let permissionArn = self.permissionArn {
            try encodeContainer.encode(permissionArn, forKey: .permissionArn)
        }
        if let policyTemplate = self.policyTemplate {
            try encodeContainer.encode(policyTemplate, forKey: .policyTemplate)
        }
    }
}

extension CreatePermissionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createpermissionversion"
    }
}

public struct CreatePermissionVersionInput: Swift.Equatable {
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value.](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// Specifies the [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the customer managed permission you're creating a new version for.
    /// This member is required.
    public var permissionArn: Swift.String?
    /// A string in JSON format string that contains the following elements of a resource-based policy:
    ///
    /// * Effect: must be set to ALLOW.
    ///
    /// * Action: specifies the actions that are allowed by this customer managed permission. The list must contain only actions that are supported by the specified resource type. For a list of all actions supported by each resource type, see [Actions, resources, and condition keys for Amazon Web Services services](https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html) in the Identity and Access Management User Guide.
    ///
    /// * Condition: (optional) specifies conditional parameters that must evaluate to true when a user attempts an action for that action to be allowed. For more information about the Condition element, see [IAM policies: Condition element](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_condition.html) in the Identity and Access Management User Guide.
    ///
    ///
    /// This template can't include either the Resource or Principal elements. Those are both filled in by RAM when it instantiates the resource-based policy on each resource shared using this managed permission. The Resource comes from the ARN of the specific resource that you are sharing. The Principal comes from the list of identities added to the resource share.
    /// This member is required.
    public var policyTemplate: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        permissionArn: Swift.String? = nil,
        policyTemplate: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.permissionArn = permissionArn
        self.policyTemplate = policyTemplate
    }
}

struct CreatePermissionVersionInputBody: Swift.Equatable {
    let permissionArn: Swift.String?
    let policyTemplate: Swift.String?
    let clientToken: Swift.String?
}

extension CreatePermissionVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case permissionArn
        case policyTemplate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionArn)
        permissionArn = permissionArnDecoded
        let policyTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyTemplate)
        policyTemplate = policyTemplateDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public enum CreatePermissionVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "IdempotentParameterMismatch": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidClientToken": return try await InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPolicy": return try await InvalidPolicyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArn.Malformed": return try await MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MalformedPolicyTemplateException": return try await MalformedPolicyTemplateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PermissionVersionsLimitExceededException": return try await PermissionVersionsLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "Unavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceShareArn.NotFound": return try await UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePermissionVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePermissionVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.permission = output.permission
        } else {
            self.clientToken = nil
            self.permission = nil
        }
    }
}

public struct CreatePermissionVersionOutputResponse: Swift.Equatable {
    /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other parameters must also have the same values that you used in the first call.
    public var clientToken: Swift.String?
    /// Information about a RAM managed permission.
    public var permission: RAMClientTypes.ResourceSharePermissionDetail?

    public init(
        clientToken: Swift.String? = nil,
        permission: RAMClientTypes.ResourceSharePermissionDetail? = nil
    )
    {
        self.clientToken = clientToken
        self.permission = permission
    }
}

struct CreatePermissionVersionOutputResponseBody: Swift.Equatable {
    let permission: RAMClientTypes.ResourceSharePermissionDetail?
    let clientToken: Swift.String?
}

extension CreatePermissionVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case permission
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceSharePermissionDetail.self, forKey: .permission)
        permission = permissionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateResourceShareInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowExternalPrincipals
        case clientToken
        case name
        case permissionArns
        case principals
        case resourceArns
        case sources
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowExternalPrincipals = self.allowExternalPrincipals {
            try encodeContainer.encode(allowExternalPrincipals, forKey: .allowExternalPrincipals)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permissionArns = permissionArns {
            var permissionArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissionArns)
            for string0 in permissionArns {
                try permissionArnsContainer.encode(string0)
            }
        }
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for string0 in principals {
                try principalsContainer.encode(string0)
            }
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for string0 in resourceArns {
                try resourceArnsContainer.encode(string0)
            }
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for string0 in sources {
                try sourcesContainer.encode(string0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateResourceShareInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createresourceshare"
    }
}

public struct CreateResourceShareInput: Swift.Equatable {
    /// Specifies whether principals outside your organization in Organizations can be associated with a resource share. A value of true lets you share with individual Amazon Web Services accounts that are not in your organization. A value of false only has meaning if your account is a member of an Amazon Web Services Organization. The default value is true.
    public var allowExternalPrincipals: Swift.Bool?
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value.](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// Specifies the name of the resource share.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the RAM permission to associate with the resource share. If you do not specify an ARN for the permission, RAM automatically attaches the default version of the permission for each resource type. You can associate only one permission with each resource type included in the resource share.
    public var permissionArns: [Swift.String]?
    /// Specifies a list of one or more principals to associate with the resource share. You can include the following values:
    ///
    /// * An Amazon Web Services account ID, for example: 123456789012
    ///
    /// * An [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of an organization in Organizations, for example: organizations::123456789012:organization/o-exampleorgid
    ///
    /// * An ARN of an organizational unit (OU) in Organizations, for example: organizations::123456789012:ou/o-exampleorgid/ou-examplerootid-exampleouid123
    ///
    /// * An ARN of an IAM role, for example: iam::123456789012:role/rolename
    ///
    /// * An ARN of an IAM user, for example: iam::123456789012user/username
    ///
    ///
    /// Not all resource types can be shared with IAM roles and users. For more information, see [Sharing with IAM roles and users](https://docs.aws.amazon.com/ram/latest/userguide/permissions.html#permissions-rbp-supported-resource-types) in the Resource Access Manager User Guide.
    public var principals: [Swift.String]?
    /// Specifies a list of one or more ARNs of the resources to associate with the resource share.
    public var resourceArns: [Swift.String]?
    /// Specifies from which source accounts the service principal has access to the resources in this resource share.
    public var sources: [Swift.String]?
    /// Specifies one or more tags to attach to the resource share itself. It doesn't attach the tags to the resources associated with the resource share.
    public var tags: [RAMClientTypes.Tag]?

    public init(
        allowExternalPrincipals: Swift.Bool? = nil,
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        permissionArns: [Swift.String]? = nil,
        principals: [Swift.String]? = nil,
        resourceArns: [Swift.String]? = nil,
        sources: [Swift.String]? = nil,
        tags: [RAMClientTypes.Tag]? = nil
    )
    {
        self.allowExternalPrincipals = allowExternalPrincipals
        self.clientToken = clientToken
        self.name = name
        self.permissionArns = permissionArns
        self.principals = principals
        self.resourceArns = resourceArns
        self.sources = sources
        self.tags = tags
    }
}

struct CreateResourceShareInputBody: Swift.Equatable {
    let name: Swift.String?
    let resourceArns: [Swift.String]?
    let principals: [Swift.String]?
    let tags: [RAMClientTypes.Tag]?
    let allowExternalPrincipals: Swift.Bool?
    let clientToken: Swift.String?
    let permissionArns: [Swift.String]?
    let sources: [Swift.String]?
}

extension CreateResourceShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowExternalPrincipals
        case clientToken
        case name
        case permissionArns
        case principals
        case resourceArns
        case sources
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let principalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .principals)
        var principalsDecoded0:[Swift.String]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [Swift.String]()
            for string0 in principalsContainer {
                if let string0 = string0 {
                    principalsDecoded0?.append(string0)
                }
            }
        }
        principals = principalsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([RAMClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RAMClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RAMClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let allowExternalPrincipalsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowExternalPrincipals)
        allowExternalPrincipals = allowExternalPrincipalsDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let permissionArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .permissionArns)
        var permissionArnsDecoded0:[Swift.String]? = nil
        if let permissionArnsContainer = permissionArnsContainer {
            permissionArnsDecoded0 = [Swift.String]()
            for string0 in permissionArnsContainer {
                if let string0 = string0 {
                    permissionArnsDecoded0?.append(string0)
                }
            }
        }
        permissionArns = permissionArnsDecoded0
        let sourcesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sources)
        var sourcesDecoded0:[Swift.String]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [Swift.String]()
            for string0 in sourcesContainer {
                if let string0 = string0 {
                    sourcesDecoded0?.append(string0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

public enum CreateResourceShareOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "IdempotentParameterMismatch": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidClientToken": return try await InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidStateTransitionException.Unknown": return try await InvalidStateTransitionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArn.Malformed": return try await MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceShareLimitExceeded": return try await ResourceShareLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "Unavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagLimitExceeded": return try await TagLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagPolicyViolation": return try await TagPolicyViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceShareArn.NotFound": return try await UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateResourceShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateResourceShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.resourceShare = output.resourceShare
        } else {
            self.clientToken = nil
            self.resourceShare = nil
        }
    }
}

public struct CreateResourceShareOutputResponse: Swift.Equatable {
    /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other parameters must also have the same values that you used in the first call.
    public var clientToken: Swift.String?
    /// An object with information about the new resource share.
    public var resourceShare: RAMClientTypes.ResourceShare?

    public init(
        clientToken: Swift.String? = nil,
        resourceShare: RAMClientTypes.ResourceShare? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShare = resourceShare
    }
}

struct CreateResourceShareOutputResponseBody: Swift.Equatable {
    let resourceShare: RAMClientTypes.ResourceShare?
    let clientToken: Swift.String?
}

extension CreateResourceShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShare
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceShare.self, forKey: .resourceShare)
        resourceShare = resourceShareDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeletePermissionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            guard let permissionArn = permissionArn else {
                let message = "Creating a URL Query Item failed. permissionArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let permissionArnQueryItem = ClientRuntime.URLQueryItem(name: "permissionArn".urlPercentEncoding(), value: Swift.String(permissionArn).urlPercentEncoding())
            items.append(permissionArnQueryItem)
            return items
        }
    }
}

extension DeletePermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deletepermission"
    }
}

public struct DeletePermissionInput: Swift.Equatable {
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value.](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// Specifies the [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the customer managed permission that you want to delete.
    /// This member is required.
    public var permissionArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        permissionArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.permissionArn = permissionArn
    }
}

struct DeletePermissionInputBody: Swift.Equatable {
}

extension DeletePermissionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum DeletePermissionOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "IdempotentParameterMismatch": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidClientToken": return try await InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArn.Malformed": return try await MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "Unavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceShareArn.NotFound": return try await UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeletePermissionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.permissionStatus = output.permissionStatus
            self.returnValue = output.returnValue
        } else {
            self.clientToken = nil
            self.permissionStatus = nil
            self.returnValue = nil
        }
    }
}

public struct DeletePermissionOutputResponse: Swift.Equatable {
    /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other parameters must also have the same values that you used in the first call.
    public var clientToken: Swift.String?
    /// This operation is performed asynchronously, and this response parameter indicates the current status.
    public var permissionStatus: RAMClientTypes.PermissionStatus?
    /// A boolean that indicates whether the delete operations succeeded.
    public var returnValue: Swift.Bool?

    public init(
        clientToken: Swift.String? = nil,
        permissionStatus: RAMClientTypes.PermissionStatus? = nil,
        returnValue: Swift.Bool? = nil
    )
    {
        self.clientToken = clientToken
        self.permissionStatus = permissionStatus
        self.returnValue = returnValue
    }
}

struct DeletePermissionOutputResponseBody: Swift.Equatable {
    let returnValue: Swift.Bool?
    let clientToken: Swift.String?
    let permissionStatus: RAMClientTypes.PermissionStatus?
}

extension DeletePermissionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case permissionStatus
        case returnValue
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnValue)
        returnValue = returnValueDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let permissionStatusDecoded = try containerValues.decodeIfPresent(RAMClientTypes.PermissionStatus.self, forKey: .permissionStatus)
        permissionStatus = permissionStatusDecoded
    }
}

extension DeletePermissionVersionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            guard let permissionArn = permissionArn else {
                let message = "Creating a URL Query Item failed. permissionArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let permissionArnQueryItem = ClientRuntime.URLQueryItem(name: "permissionArn".urlPercentEncoding(), value: Swift.String(permissionArn).urlPercentEncoding())
            items.append(permissionArnQueryItem)
            guard let permissionVersion = permissionVersion else {
                let message = "Creating a URL Query Item failed. permissionVersion is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let permissionVersionQueryItem = ClientRuntime.URLQueryItem(name: "permissionVersion".urlPercentEncoding(), value: Swift.String(permissionVersion).urlPercentEncoding())
            items.append(permissionVersionQueryItem)
            return items
        }
    }
}

extension DeletePermissionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deletepermissionversion"
    }
}

public struct DeletePermissionVersionInput: Swift.Equatable {
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value.](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// Specifies the [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the permission with the version you want to delete.
    /// This member is required.
    public var permissionArn: Swift.String?
    /// Specifies the version number to delete. You can't delete the default version for a customer managed permission. You can't delete a version if it's the only version of the permission. You must either first create another version, or delete the permission completely. You can't delete a version if it is attached to any resource shares. If the version is the default, you must first use [SetDefaultPermissionVersion] to set a different version as the default for the customer managed permission, and then use [AssociateResourceSharePermission] to update your resource shares to use the new default version.
    /// This member is required.
    public var permissionVersion: Swift.Int?

    public init(
        clientToken: Swift.String? = nil,
        permissionArn: Swift.String? = nil,
        permissionVersion: Swift.Int? = nil
    )
    {
        self.clientToken = clientToken
        self.permissionArn = permissionArn
        self.permissionVersion = permissionVersion
    }
}

struct DeletePermissionVersionInputBody: Swift.Equatable {
}

extension DeletePermissionVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum DeletePermissionVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "IdempotentParameterMismatch": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidClientToken": return try await InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArn.Malformed": return try await MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "Unavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceShareArn.NotFound": return try await UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePermissionVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeletePermissionVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.permissionStatus = output.permissionStatus
            self.returnValue = output.returnValue
        } else {
            self.clientToken = nil
            self.permissionStatus = nil
            self.returnValue = nil
        }
    }
}

public struct DeletePermissionVersionOutputResponse: Swift.Equatable {
    /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other parameters must also have the same values that you used in the first call.
    public var clientToken: Swift.String?
    /// This operation is performed asynchronously, and this response parameter indicates the current status.
    public var permissionStatus: RAMClientTypes.PermissionStatus?
    /// A boolean value that indicates whether the operation is successful.
    public var returnValue: Swift.Bool?

    public init(
        clientToken: Swift.String? = nil,
        permissionStatus: RAMClientTypes.PermissionStatus? = nil,
        returnValue: Swift.Bool? = nil
    )
    {
        self.clientToken = clientToken
        self.permissionStatus = permissionStatus
        self.returnValue = returnValue
    }
}

struct DeletePermissionVersionOutputResponseBody: Swift.Equatable {
    let returnValue: Swift.Bool?
    let clientToken: Swift.String?
    let permissionStatus: RAMClientTypes.PermissionStatus?
}

extension DeletePermissionVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case permissionStatus
        case returnValue
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnValue)
        returnValue = returnValueDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let permissionStatusDecoded = try containerValues.decodeIfPresent(RAMClientTypes.PermissionStatus.self, forKey: .permissionStatus)
        permissionStatus = permissionStatusDecoded
    }
}

extension DeleteResourceShareInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceShareArn = resourceShareArn else {
                let message = "Creating a URL Query Item failed. resourceShareArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceShareArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceShareArn".urlPercentEncoding(), value: Swift.String(resourceShareArn).urlPercentEncoding())
            items.append(resourceShareArnQueryItem)
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension DeleteResourceShareInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteresourceshare"
    }
}

public struct DeleteResourceShareInput: Swift.Equatable {
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value.](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// Specifies the [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource share to delete.
    /// This member is required.
    public var resourceShareArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        resourceShareArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShareArn = resourceShareArn
    }
}

struct DeleteResourceShareInputBody: Swift.Equatable {
}

extension DeleteResourceShareInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum DeleteResourceShareOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "IdempotentParameterMismatch": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidClientToken": return try await InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidStateTransitionException.Unknown": return try await InvalidStateTransitionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArn.Malformed": return try await MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "Unavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceShareArn.NotFound": return try await UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteResourceShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteResourceShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.returnValue = output.returnValue
        } else {
            self.clientToken = nil
            self.returnValue = nil
        }
    }
}

public struct DeleteResourceShareOutputResponse: Swift.Equatable {
    /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other parameters must also have the same values that you used in the first call.
    public var clientToken: Swift.String?
    /// A return value of true indicates that the request succeeded. A value of false indicates that the request failed.
    public var returnValue: Swift.Bool?

    public init(
        clientToken: Swift.String? = nil,
        returnValue: Swift.Bool? = nil
    )
    {
        self.clientToken = clientToken
        self.returnValue = returnValue
    }
}

struct DeleteResourceShareOutputResponseBody: Swift.Equatable {
    let returnValue: Swift.Bool?
    let clientToken: Swift.String?
}

extension DeleteResourceShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case returnValue
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnValue)
        returnValue = returnValueDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DisassociateResourceShareInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case principals
        case resourceArns
        case resourceShareArn
        case sources
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for string0 in principals {
                try principalsContainer.encode(string0)
            }
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for string0 in resourceArns {
                try resourceArnsContainer.encode(string0)
            }
        }
        if let resourceShareArn = self.resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for string0 in sources {
                try sourcesContainer.encode(string0)
            }
        }
    }
}

extension DisassociateResourceShareInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/disassociateresourceshare"
    }
}

public struct DisassociateResourceShareInput: Swift.Equatable {
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value.](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// Specifies a list of one or more principals that no longer are to have access to the resources in this resource share. You can include the following values:
    ///
    /// * An Amazon Web Services account ID, for example: 123456789012
    ///
    /// * An [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of an organization in Organizations, for example: organizations::123456789012:organization/o-exampleorgid
    ///
    /// * An ARN of an organizational unit (OU) in Organizations, for example: organizations::123456789012:ou/o-exampleorgid/ou-examplerootid-exampleouid123
    ///
    /// * An ARN of an IAM role, for example: iam::123456789012:role/rolename
    ///
    /// * An ARN of an IAM user, for example: iam::123456789012user/username
    ///
    ///
    /// Not all resource types can be shared with IAM roles and users. For more information, see [Sharing with IAM roles and users](https://docs.aws.amazon.com/ram/latest/userguide/permissions.html#permissions-rbp-supported-resource-types) in the Resource Access Manager User Guide.
    public var principals: [Swift.String]?
    /// Specifies a list of [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) for one or more resources that you want to remove from the resource share. After the operation runs, these resources are no longer shared with principals associated with the resource share.
    public var resourceArns: [Swift.String]?
    /// Specifies [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource share that you want to remove resources or principals from.
    /// This member is required.
    public var resourceShareArn: Swift.String?
    /// Specifies from which source accounts the service principal no longer has access to the resources in this resource share.
    public var sources: [Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        principals: [Swift.String]? = nil,
        resourceArns: [Swift.String]? = nil,
        resourceShareArn: Swift.String? = nil,
        sources: [Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.principals = principals
        self.resourceArns = resourceArns
        self.resourceShareArn = resourceShareArn
        self.sources = sources
    }
}

struct DisassociateResourceShareInputBody: Swift.Equatable {
    let resourceShareArn: Swift.String?
    let resourceArns: [Swift.String]?
    let principals: [Swift.String]?
    let clientToken: Swift.String?
    let sources: [Swift.String]?
}

extension DisassociateResourceShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case principals
        case resourceArns
        case resourceShareArn
        case sources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let principalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .principals)
        var principalsDecoded0:[Swift.String]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [Swift.String]()
            for string0 in principalsContainer {
                if let string0 = string0 {
                    principalsDecoded0?.append(string0)
                }
            }
        }
        principals = principalsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sources)
        var sourcesDecoded0:[Swift.String]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [Swift.String]()
            for string0 in sourcesContainer {
                if let string0 = string0 {
                    sourcesDecoded0?.append(string0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

public enum DisassociateResourceShareOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "IdempotentParameterMismatch": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidClientToken": return try await InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidStateTransitionException.Unknown": return try await InvalidStateTransitionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArn.Malformed": return try await MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceShareLimitExceeded": return try await ResourceShareLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "Unavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceShareArn.NotFound": return try await UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateResourceShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisassociateResourceShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.resourceShareAssociations = output.resourceShareAssociations
        } else {
            self.clientToken = nil
            self.resourceShareAssociations = nil
        }
    }
}

public struct DisassociateResourceShareOutputResponse: Swift.Equatable {
    /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other parameters must also have the same values that you used in the first call.
    public var clientToken: Swift.String?
    /// An array of objects with information about the updated associations for this resource share.
    public var resourceShareAssociations: [RAMClientTypes.ResourceShareAssociation]?

    public init(
        clientToken: Swift.String? = nil,
        resourceShareAssociations: [RAMClientTypes.ResourceShareAssociation]? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShareAssociations = resourceShareAssociations
    }
}

struct DisassociateResourceShareOutputResponseBody: Swift.Equatable {
    let resourceShareAssociations: [RAMClientTypes.ResourceShareAssociation]?
    let clientToken: Swift.String?
}

extension DisassociateResourceShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShareAssociations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareAssociationsContainer = try containerValues.decodeIfPresent([RAMClientTypes.ResourceShareAssociation?].self, forKey: .resourceShareAssociations)
        var resourceShareAssociationsDecoded0:[RAMClientTypes.ResourceShareAssociation]? = nil
        if let resourceShareAssociationsContainer = resourceShareAssociationsContainer {
            resourceShareAssociationsDecoded0 = [RAMClientTypes.ResourceShareAssociation]()
            for structure0 in resourceShareAssociationsContainer {
                if let structure0 = structure0 {
                    resourceShareAssociationsDecoded0?.append(structure0)
                }
            }
        }
        resourceShareAssociations = resourceShareAssociationsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DisassociateResourceSharePermissionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case permissionArn
        case resourceShareArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let permissionArn = self.permissionArn {
            try encodeContainer.encode(permissionArn, forKey: .permissionArn)
        }
        if let resourceShareArn = self.resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
    }
}

extension DisassociateResourceSharePermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/disassociateresourcesharepermission"
    }
}

public struct DisassociateResourceSharePermissionInput: Swift.Equatable {
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value.](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// The [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the managed permission to disassociate from the resource share. Changes to permissions take effect immediately.
    /// This member is required.
    public var permissionArn: Swift.String?
    /// The [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource share that you want to remove the managed permission from.
    /// This member is required.
    public var resourceShareArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        permissionArn: Swift.String? = nil,
        resourceShareArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.permissionArn = permissionArn
        self.resourceShareArn = resourceShareArn
    }
}

struct DisassociateResourceSharePermissionInputBody: Swift.Equatable {
    let resourceShareArn: Swift.String?
    let permissionArn: Swift.String?
    let clientToken: Swift.String?
}

extension DisassociateResourceSharePermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case permissionArn
        case resourceShareArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let permissionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionArn)
        permissionArn = permissionArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public enum DisassociateResourceSharePermissionOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidClientToken": return try await InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidStateTransitionException.Unknown": return try await InvalidStateTransitionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArn.Malformed": return try await MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "Unavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceShareArn.NotFound": return try await UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateResourceSharePermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisassociateResourceSharePermissionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.returnValue = output.returnValue
        } else {
            self.clientToken = nil
            self.returnValue = nil
        }
    }
}

public struct DisassociateResourceSharePermissionOutputResponse: Swift.Equatable {
    /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other parameters must also have the same values that you used in the first call.
    public var clientToken: Swift.String?
    /// A return value of true indicates that the request succeeded. A value of false indicates that the request failed.
    public var returnValue: Swift.Bool?

    public init(
        clientToken: Swift.String? = nil,
        returnValue: Swift.Bool? = nil
    )
    {
        self.clientToken = clientToken
        self.returnValue = returnValue
    }
}

struct DisassociateResourceSharePermissionOutputResponseBody: Swift.Equatable {
    let returnValue: Swift.Bool?
    let clientToken: Swift.String?
}

extension DisassociateResourceSharePermissionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case returnValue
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnValue)
        returnValue = returnValueDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension EnableSharingWithAwsOrganizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/enablesharingwithawsorganization"
    }
}

public struct EnableSharingWithAwsOrganizationInput: Swift.Equatable {

    public init() { }
}

struct EnableSharingWithAwsOrganizationInputBody: Swift.Equatable {
}

extension EnableSharingWithAwsOrganizationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum EnableSharingWithAwsOrganizationOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "Unavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EnableSharingWithAwsOrganizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EnableSharingWithAwsOrganizationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.returnValue = output.returnValue
        } else {
            self.returnValue = nil
        }
    }
}

public struct EnableSharingWithAwsOrganizationOutputResponse: Swift.Equatable {
    /// A return value of true indicates that the request succeeded. A value of false indicates that the request failed.
    public var returnValue: Swift.Bool?

    public init(
        returnValue: Swift.Bool? = nil
    )
    {
        self.returnValue = returnValue
    }
}

struct EnableSharingWithAwsOrganizationOutputResponseBody: Swift.Equatable {
    let returnValue: Swift.Bool?
}

extension EnableSharingWithAwsOrganizationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case returnValue
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnValue)
        returnValue = returnValueDecoded
    }
}

extension GetPermissionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionArn
        case permissionVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let permissionArn = self.permissionArn {
            try encodeContainer.encode(permissionArn, forKey: .permissionArn)
        }
        if let permissionVersion = self.permissionVersion {
            try encodeContainer.encode(permissionVersion, forKey: .permissionVersion)
        }
    }
}

extension GetPermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/getpermission"
    }
}

public struct GetPermissionInput: Swift.Equatable {
    /// Specifies the [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the permission whose contents you want to retrieve. To find the ARN for a permission, use either the [ListPermissions] operation or go to the [Permissions library](https://console.aws.amazon.com/ram/home#Permissions:) page in the RAM console and then choose the name of the permission. The ARN is displayed on the detail page.
    /// This member is required.
    public var permissionArn: Swift.String?
    /// Specifies the version number of the RAM permission to retrieve. If you don't specify this parameter, the operation retrieves the default version. To see the list of available versions, use [ListPermissionVersions].
    public var permissionVersion: Swift.Int?

    public init(
        permissionArn: Swift.String? = nil,
        permissionVersion: Swift.Int? = nil
    )
    {
        self.permissionArn = permissionArn
        self.permissionVersion = permissionVersion
    }
}

struct GetPermissionInputBody: Swift.Equatable {
    let permissionArn: Swift.String?
    let permissionVersion: Swift.Int?
}

extension GetPermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionArn
        case permissionVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionArn)
        permissionArn = permissionArnDecoded
        let permissionVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .permissionVersion)
        permissionVersion = permissionVersionDecoded
    }
}

public enum GetPermissionOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArn.Malformed": return try await MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "Unavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceShareArn.NotFound": return try await UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPermissionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.permission = output.permission
        } else {
            self.permission = nil
        }
    }
}

public struct GetPermissionOutputResponse: Swift.Equatable {
    /// An object with details about the permission.
    public var permission: RAMClientTypes.ResourceSharePermissionDetail?

    public init(
        permission: RAMClientTypes.ResourceSharePermissionDetail? = nil
    )
    {
        self.permission = permission
    }
}

struct GetPermissionOutputResponseBody: Swift.Equatable {
    let permission: RAMClientTypes.ResourceSharePermissionDetail?
}

extension GetPermissionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permission
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceSharePermissionDetail.self, forKey: .permission)
        permission = permissionDecoded
    }
}

extension GetResourcePoliciesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case principal
        case resourceArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let principal = self.principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for string0 in resourceArns {
                try resourceArnsContainer.encode(string0)
            }
        }
    }
}

extension GetResourcePoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/getresourcepolicies"
    }
}

public struct GetResourcePoliciesInput: Swift.Equatable {
    /// Specifies the total number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value that is specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next part of the results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// Specifies the principal.
    public var principal: Swift.String?
    /// Specifies the [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resources whose policies you want to retrieve.
    /// This member is required.
    public var resourceArns: [Swift.String]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        principal: Swift.String? = nil,
        resourceArns: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principal = principal
        self.resourceArns = resourceArns
    }
}

struct GetResourcePoliciesInputBody: Swift.Equatable {
    let resourceArns: [Swift.String]?
    let principal: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetResourcePoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case principal
        case resourceArns
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let principalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principal)
        principal = principalDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

public enum GetResourcePoliciesOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextToken": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArn.Malformed": return try await MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceArn.NotFound": return try await ResourceArnNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "Unavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetResourcePoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetResourcePoliciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.policies = output.policies
        } else {
            self.nextToken = nil
            self.policies = nil
        }
    }
}

public struct GetResourcePoliciesOutputResponse: Swift.Equatable {
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?
    /// An array of resource policy documents in JSON format.
    public var policies: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        policies: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.policies = policies
    }
}

struct GetResourcePoliciesOutputResponseBody: Swift.Equatable {
    let policies: [Swift.String]?
    let nextToken: Swift.String?
}

extension GetResourcePoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case policies
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .policies)
        var policiesDecoded0:[Swift.String]? = nil
        if let policiesContainer = policiesContainer {
            policiesDecoded0 = [Swift.String]()
            for string0 in policiesContainer {
                if let string0 = string0 {
                    policiesDecoded0?.append(string0)
                }
            }
        }
        policies = policiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetResourceShareAssociationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationStatus
        case associationType
        case maxResults
        case nextToken
        case principal
        case resourceArn
        case resourceShareArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationStatus = self.associationStatus {
            try encodeContainer.encode(associationStatus.rawValue, forKey: .associationStatus)
        }
        if let associationType = self.associationType {
            try encodeContainer.encode(associationType.rawValue, forKey: .associationType)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let principal = self.principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceShareArns = resourceShareArns {
            var resourceShareArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShareArns)
            for string0 in resourceShareArns {
                try resourceShareArnsContainer.encode(string0)
            }
        }
    }
}

extension GetResourceShareAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/getresourceshareassociations"
    }
}

public struct GetResourceShareAssociationsInput: Swift.Equatable {
    /// Specifies that you want to retrieve only associations that have this status.
    public var associationStatus: RAMClientTypes.ResourceShareAssociationStatus?
    /// Specifies whether you want to retrieve the associations that involve a specified resource or principal.
    ///
    /// * PRINCIPAL – list the principals whose associations you want to see.
    ///
    /// * RESOURCE – list the resources whose associations you want to see.
    /// This member is required.
    public var associationType: RAMClientTypes.ResourceShareAssociationType?
    /// Specifies the total number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value that is specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next part of the results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// Specifies the ID of the principal whose resource shares you want to retrieve. This can be an Amazon Web Services account ID, an organization ID, an organizational unit ID, or the [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of an individual IAM role or user. You cannot specify this parameter if the association type is RESOURCE.
    public var principal: Swift.String?
    /// Specifies the [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of a resource whose resource shares you want to retrieve. You cannot specify this parameter if the association type is PRINCIPAL.
    public var resourceArn: Swift.String?
    /// Specifies a list of [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource share whose associations you want to retrieve.
    public var resourceShareArns: [Swift.String]?

    public init(
        associationStatus: RAMClientTypes.ResourceShareAssociationStatus? = nil,
        associationType: RAMClientTypes.ResourceShareAssociationType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        principal: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceShareArns: [Swift.String]? = nil
    )
    {
        self.associationStatus = associationStatus
        self.associationType = associationType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principal = principal
        self.resourceArn = resourceArn
        self.resourceShareArns = resourceShareArns
    }
}

struct GetResourceShareAssociationsInputBody: Swift.Equatable {
    let associationType: RAMClientTypes.ResourceShareAssociationType?
    let resourceShareArns: [Swift.String]?
    let resourceArn: Swift.String?
    let principal: Swift.String?
    let associationStatus: RAMClientTypes.ResourceShareAssociationStatus?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetResourceShareAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationStatus
        case associationType
        case maxResults
        case nextToken
        case principal
        case resourceArn
        case resourceShareArns
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationTypeDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceShareAssociationType.self, forKey: .associationType)
        associationType = associationTypeDecoded
        let resourceShareArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceShareArns)
        var resourceShareArnsDecoded0:[Swift.String]? = nil
        if let resourceShareArnsContainer = resourceShareArnsContainer {
            resourceShareArnsDecoded0 = [Swift.String]()
            for string0 in resourceShareArnsContainer {
                if let string0 = string0 {
                    resourceShareArnsDecoded0?.append(string0)
                }
            }
        }
        resourceShareArns = resourceShareArnsDecoded0
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let principalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principal)
        principal = principalDecoded
        let associationStatusDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceShareAssociationStatus.self, forKey: .associationStatus)
        associationStatus = associationStatusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

public enum GetResourceShareAssociationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextToken": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArn.Malformed": return try await MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "Unavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceShareArn.NotFound": return try await UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetResourceShareAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetResourceShareAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceShareAssociations = output.resourceShareAssociations
        } else {
            self.nextToken = nil
            self.resourceShareAssociations = nil
        }
    }
}

public struct GetResourceShareAssociationsOutputResponse: Swift.Equatable {
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?
    /// An array of objects that contain the details about the associations.
    public var resourceShareAssociations: [RAMClientTypes.ResourceShareAssociation]?

    public init(
        nextToken: Swift.String? = nil,
        resourceShareAssociations: [RAMClientTypes.ResourceShareAssociation]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceShareAssociations = resourceShareAssociations
    }
}

struct GetResourceShareAssociationsOutputResponseBody: Swift.Equatable {
    let resourceShareAssociations: [RAMClientTypes.ResourceShareAssociation]?
    let nextToken: Swift.String?
}

extension GetResourceShareAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resourceShareAssociations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareAssociationsContainer = try containerValues.decodeIfPresent([RAMClientTypes.ResourceShareAssociation?].self, forKey: .resourceShareAssociations)
        var resourceShareAssociationsDecoded0:[RAMClientTypes.ResourceShareAssociation]? = nil
        if let resourceShareAssociationsContainer = resourceShareAssociationsContainer {
            resourceShareAssociationsDecoded0 = [RAMClientTypes.ResourceShareAssociation]()
            for structure0 in resourceShareAssociationsContainer {
                if let structure0 = structure0 {
                    resourceShareAssociationsDecoded0?.append(structure0)
                }
            }
        }
        resourceShareAssociations = resourceShareAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetResourceShareInvitationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceShareArns
        case resourceShareInvitationArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceShareArns = resourceShareArns {
            var resourceShareArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShareArns)
            for string0 in resourceShareArns {
                try resourceShareArnsContainer.encode(string0)
            }
        }
        if let resourceShareInvitationArns = resourceShareInvitationArns {
            var resourceShareInvitationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShareInvitationArns)
            for string0 in resourceShareInvitationArns {
                try resourceShareInvitationArnsContainer.encode(string0)
            }
        }
    }
}

extension GetResourceShareInvitationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/getresourceshareinvitations"
    }
}

public struct GetResourceShareInvitationsInput: Swift.Equatable {
    /// Specifies the total number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value that is specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next part of the results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// Specifies that you want details about invitations only for the resource shares described by this list of [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html)
    public var resourceShareArns: [Swift.String]?
    /// Specifies the [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource share invitations you want information about.
    public var resourceShareInvitationArns: [Swift.String]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceShareArns: [Swift.String]? = nil,
        resourceShareInvitationArns: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceShareArns = resourceShareArns
        self.resourceShareInvitationArns = resourceShareInvitationArns
    }
}

struct GetResourceShareInvitationsInputBody: Swift.Equatable {
    let resourceShareInvitationArns: [Swift.String]?
    let resourceShareArns: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetResourceShareInvitationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceShareArns
        case resourceShareInvitationArns
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceShareInvitationArns)
        var resourceShareInvitationArnsDecoded0:[Swift.String]? = nil
        if let resourceShareInvitationArnsContainer = resourceShareInvitationArnsContainer {
            resourceShareInvitationArnsDecoded0 = [Swift.String]()
            for string0 in resourceShareInvitationArnsContainer {
                if let string0 = string0 {
                    resourceShareInvitationArnsDecoded0?.append(string0)
                }
            }
        }
        resourceShareInvitationArns = resourceShareInvitationArnsDecoded0
        let resourceShareArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceShareArns)
        var resourceShareArnsDecoded0:[Swift.String]? = nil
        if let resourceShareArnsContainer = resourceShareArnsContainer {
            resourceShareArnsDecoded0 = [Swift.String]()
            for string0 in resourceShareArnsContainer {
                if let string0 = string0 {
                    resourceShareArnsDecoded0?.append(string0)
                }
            }
        }
        resourceShareArns = resourceShareArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

public enum GetResourceShareInvitationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidMaxResults": return try await InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextToken": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArn.Malformed": return try await MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceShareInvitationArn.NotFound": return try await ResourceShareInvitationArnNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "Unavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceShareArn.NotFound": return try await UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetResourceShareInvitationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetResourceShareInvitationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceShareInvitations = output.resourceShareInvitations
        } else {
            self.nextToken = nil
            self.resourceShareInvitations = nil
        }
    }
}

public struct GetResourceShareInvitationsOutputResponse: Swift.Equatable {
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?
    /// An array of objects that contain the details about the invitations.
    public var resourceShareInvitations: [RAMClientTypes.ResourceShareInvitation]?

    public init(
        nextToken: Swift.String? = nil,
        resourceShareInvitations: [RAMClientTypes.ResourceShareInvitation]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceShareInvitations = resourceShareInvitations
    }
}

struct GetResourceShareInvitationsOutputResponseBody: Swift.Equatable {
    let resourceShareInvitations: [RAMClientTypes.ResourceShareInvitation]?
    let nextToken: Swift.String?
}

extension GetResourceShareInvitationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resourceShareInvitations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationsContainer = try containerValues.decodeIfPresent([RAMClientTypes.ResourceShareInvitation?].self, forKey: .resourceShareInvitations)
        var resourceShareInvitationsDecoded0:[RAMClientTypes.ResourceShareInvitation]? = nil
        if let resourceShareInvitationsContainer = resourceShareInvitationsContainer {
            resourceShareInvitationsDecoded0 = [RAMClientTypes.ResourceShareInvitation]()
            for structure0 in resourceShareInvitationsContainer {
                if let structure0 = structure0 {
                    resourceShareInvitationsDecoded0?.append(structure0)
                }
            }
        }
        resourceShareInvitations = resourceShareInvitationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetResourceSharesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case name
        case nextToken
        case permissionArn
        case permissionVersion
        case resourceOwner
        case resourceShareArns
        case resourceShareStatus
        case tagFilters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let permissionArn = self.permissionArn {
            try encodeContainer.encode(permissionArn, forKey: .permissionArn)
        }
        if let permissionVersion = self.permissionVersion {
            try encodeContainer.encode(permissionVersion, forKey: .permissionVersion)
        }
        if let resourceOwner = self.resourceOwner {
            try encodeContainer.encode(resourceOwner.rawValue, forKey: .resourceOwner)
        }
        if let resourceShareArns = resourceShareArns {
            var resourceShareArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShareArns)
            for string0 in resourceShareArns {
                try resourceShareArnsContainer.encode(string0)
            }
        }
        if let resourceShareStatus = self.resourceShareStatus {
            try encodeContainer.encode(resourceShareStatus.rawValue, forKey: .resourceShareStatus)
        }
        if let tagFilters = tagFilters {
            var tagFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagFilters)
            for tagfilter0 in tagFilters {
                try tagFiltersContainer.encode(tagfilter0)
            }
        }
    }
}

extension GetResourceSharesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/getresourceshares"
    }
}

public struct GetResourceSharesInput: Swift.Equatable {
    /// Specifies the total number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value that is specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next part of the results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies the name of an individual resource share that you want to retrieve details about.
    public var name: Swift.String?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// Specifies that you want to retrieve details of only those resource shares that use the managed permission with this [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html).
    public var permissionArn: Swift.String?
    /// Specifies that you want to retrieve details for only those resource shares that use the specified version of the managed permission.
    public var permissionVersion: Swift.Int?
    /// Specifies that you want to retrieve details of only those resource shares that match the following:
    ///
    /// * SELF – resource shares that your account shares with other accounts
    ///
    /// * OTHER-ACCOUNTS – resource shares that other accounts share with your account
    /// This member is required.
    public var resourceOwner: RAMClientTypes.ResourceOwner?
    /// Specifies the [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of individual resource shares that you want information about.
    public var resourceShareArns: [Swift.String]?
    /// Specifies that you want to retrieve details of only those resource shares that have this status.
    public var resourceShareStatus: RAMClientTypes.ResourceShareStatus?
    /// Specifies that you want to retrieve details of only those resource shares that match the specified tag keys and values.
    public var tagFilters: [RAMClientTypes.TagFilter]?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        permissionArn: Swift.String? = nil,
        permissionVersion: Swift.Int? = nil,
        resourceOwner: RAMClientTypes.ResourceOwner? = nil,
        resourceShareArns: [Swift.String]? = nil,
        resourceShareStatus: RAMClientTypes.ResourceShareStatus? = nil,
        tagFilters: [RAMClientTypes.TagFilter]? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.permissionArn = permissionArn
        self.permissionVersion = permissionVersion
        self.resourceOwner = resourceOwner
        self.resourceShareArns = resourceShareArns
        self.resourceShareStatus = resourceShareStatus
        self.tagFilters = tagFilters
    }
}

struct GetResourceSharesInputBody: Swift.Equatable {
    let resourceShareArns: [Swift.String]?
    let resourceShareStatus: RAMClientTypes.ResourceShareStatus?
    let resourceOwner: RAMClientTypes.ResourceOwner?
    let name: Swift.String?
    let tagFilters: [RAMClientTypes.TagFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let permissionArn: Swift.String?
    let permissionVersion: Swift.Int?
}

extension GetResourceSharesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case name
        case nextToken
        case permissionArn
        case permissionVersion
        case resourceOwner
        case resourceShareArns
        case resourceShareStatus
        case tagFilters
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceShareArns)
        var resourceShareArnsDecoded0:[Swift.String]? = nil
        if let resourceShareArnsContainer = resourceShareArnsContainer {
            resourceShareArnsDecoded0 = [Swift.String]()
            for string0 in resourceShareArnsContainer {
                if let string0 = string0 {
                    resourceShareArnsDecoded0?.append(string0)
                }
            }
        }
        resourceShareArns = resourceShareArnsDecoded0
        let resourceShareStatusDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceShareStatus.self, forKey: .resourceShareStatus)
        resourceShareStatus = resourceShareStatusDecoded
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceOwner.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagFiltersContainer = try containerValues.decodeIfPresent([RAMClientTypes.TagFilter?].self, forKey: .tagFilters)
        var tagFiltersDecoded0:[RAMClientTypes.TagFilter]? = nil
        if let tagFiltersContainer = tagFiltersContainer {
            tagFiltersDecoded0 = [RAMClientTypes.TagFilter]()
            for structure0 in tagFiltersContainer {
                if let structure0 = structure0 {
                    tagFiltersDecoded0?.append(structure0)
                }
            }
        }
        tagFilters = tagFiltersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let permissionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionArn)
        permissionArn = permissionArnDecoded
        let permissionVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .permissionVersion)
        permissionVersion = permissionVersionDecoded
    }
}

public enum GetResourceSharesOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextToken": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArn.Malformed": return try await MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "Unavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceShareArn.NotFound": return try await UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetResourceSharesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetResourceSharesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceShares = output.resourceShares
        } else {
            self.nextToken = nil
            self.resourceShares = nil
        }
    }
}

public struct GetResourceSharesOutputResponse: Swift.Equatable {
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?
    /// An array of objects that contain the information about the resource shares.
    public var resourceShares: [RAMClientTypes.ResourceShare]?

    public init(
        nextToken: Swift.String? = nil,
        resourceShares: [RAMClientTypes.ResourceShare]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceShares = resourceShares
    }
}

struct GetResourceSharesOutputResponseBody: Swift.Equatable {
    let resourceShares: [RAMClientTypes.ResourceShare]?
    let nextToken: Swift.String?
}

extension GetResourceSharesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resourceShares
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceSharesContainer = try containerValues.decodeIfPresent([RAMClientTypes.ResourceShare?].self, forKey: .resourceShares)
        var resourceSharesDecoded0:[RAMClientTypes.ResourceShare]? = nil
        if let resourceSharesContainer = resourceSharesContainer {
            resourceSharesDecoded0 = [RAMClientTypes.ResourceShare]()
            for structure0 in resourceSharesContainer {
                if let structure0 = structure0 {
                    resourceSharesDecoded0?.append(structure0)
                }
            }
        }
        resourceShares = resourceSharesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension IdempotentParameterMismatchException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: IdempotentParameterMismatchExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation failed because the client token input parameter matched one that was used with a previous call to the operation, but at least one of the other input parameters is different from the previous call.
public struct IdempotentParameterMismatchException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IdempotentParameterMismatch" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct IdempotentParameterMismatchExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension IdempotentParameterMismatchExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidClientTokenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidClientTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation failed because the specified client token isn't valid.
public struct InvalidClientTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidClientToken" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidClientTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidClientTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidMaxResultsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidMaxResultsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation failed because the specified value for MaxResults isn't valid.
public struct InvalidMaxResultsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidMaxResults" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidMaxResultsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidMaxResultsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation failed because the specified value for NextToken isn't valid. You must specify a value you received in the NextToken response of a previous call to this operation.
public struct InvalidNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextToken" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation failed because a parameter you specified isn't valid.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameter" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPolicyException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidPolicyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation failed because a policy you specified isn't valid.
public struct InvalidPolicyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidPolicyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPolicyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourceTypeException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidResourceTypeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation failed because the specified resource type isn't valid.
public struct InvalidResourceTypeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResourceType.Unknown" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidResourceTypeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidResourceTypeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidStateTransitionException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidStateTransitionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation failed because the requested operation isn't valid for the resource share in its current state.
public struct InvalidStateTransitionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidStateTransitionException.Unknown" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidStateTransitionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidStateTransitionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListPendingInvitationResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceRegionScope
        case resourceShareInvitationArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceRegionScope = self.resourceRegionScope {
            try encodeContainer.encode(resourceRegionScope.rawValue, forKey: .resourceRegionScope)
        }
        if let resourceShareInvitationArn = self.resourceShareInvitationArn {
            try encodeContainer.encode(resourceShareInvitationArn, forKey: .resourceShareInvitationArn)
        }
    }
}

extension ListPendingInvitationResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listpendinginvitationresources"
    }
}

public struct ListPendingInvitationResourcesInput: Swift.Equatable {
    /// Specifies the total number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value that is specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next part of the results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// Specifies that you want the results to include only resources that have the specified scope.
    ///
    /// * ALL – the results include both global and regional resources or resource types.
    ///
    /// * GLOBAL – the results include only global resources or resource types.
    ///
    /// * REGIONAL – the results include only regional resources or resource types.
    ///
    ///
    /// The default value is ALL.
    public var resourceRegionScope: RAMClientTypes.ResourceRegionScopeFilter?
    /// Specifies the [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the invitation. You can use [GetResourceShareInvitations] to find the ARN of the invitation.
    /// This member is required.
    public var resourceShareInvitationArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceRegionScope: RAMClientTypes.ResourceRegionScopeFilter? = nil,
        resourceShareInvitationArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceRegionScope = resourceRegionScope
        self.resourceShareInvitationArn = resourceShareInvitationArn
    }
}

struct ListPendingInvitationResourcesInputBody: Swift.Equatable {
    let resourceShareInvitationArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let resourceRegionScope: RAMClientTypes.ResourceRegionScopeFilter?
}

extension ListPendingInvitationResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceRegionScope
        case resourceShareInvitationArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareInvitationArn)
        resourceShareInvitationArn = resourceShareInvitationArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let resourceRegionScopeDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceRegionScopeFilter.self, forKey: .resourceRegionScope)
        resourceRegionScope = resourceRegionScopeDecoded
    }
}

public enum ListPendingInvitationResourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextToken": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArn.Malformed": return try await MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceShareInvitationArn.AlreadyRejected": return try await ResourceShareInvitationAlreadyRejectedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceShareInvitationArn.NotFound": return try await ResourceShareInvitationArnNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceShareInvitationArn.Expired": return try await ResourceShareInvitationExpiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "Unavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPendingInvitationResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPendingInvitationResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resources = output.resources
        } else {
            self.nextToken = nil
            self.resources = nil
        }
    }
}

public struct ListPendingInvitationResourcesOutputResponse: Swift.Equatable {
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?
    /// An array of objects that contain the information about the resources included the specified resource share.
    public var resources: [RAMClientTypes.Resource]?

    public init(
        nextToken: Swift.String? = nil,
        resources: [RAMClientTypes.Resource]? = nil
    )
    {
        self.nextToken = nextToken
        self.resources = resources
    }
}

struct ListPendingInvitationResourcesOutputResponseBody: Swift.Equatable {
    let resources: [RAMClientTypes.Resource]?
    let nextToken: Swift.String?
}

extension ListPendingInvitationResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesContainer = try containerValues.decodeIfPresent([RAMClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[RAMClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [RAMClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPermissionAssociationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationStatus
        case defaultVersion
        case featureSet
        case maxResults
        case nextToken
        case permissionArn
        case permissionVersion
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationStatus = self.associationStatus {
            try encodeContainer.encode(associationStatus.rawValue, forKey: .associationStatus)
        }
        if let defaultVersion = self.defaultVersion {
            try encodeContainer.encode(defaultVersion, forKey: .defaultVersion)
        }
        if let featureSet = self.featureSet {
            try encodeContainer.encode(featureSet.rawValue, forKey: .featureSet)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let permissionArn = self.permissionArn {
            try encodeContainer.encode(permissionArn, forKey: .permissionArn)
        }
        if let permissionVersion = self.permissionVersion {
            try encodeContainer.encode(permissionVersion, forKey: .permissionVersion)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }
}

extension ListPermissionAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listpermissionassociations"
    }
}

public struct ListPermissionAssociationsInput: Swift.Equatable {
    /// Specifies that you want to list only those associations with resource shares that match this status.
    public var associationStatus: RAMClientTypes.ResourceShareAssociationStatus?
    /// When true, specifies that you want to list only those associations with resource shares that use the default version of the specified managed permission. When false (the default value), lists associations with resource shares that use any version of the specified managed permission.
    public var defaultVersion: Swift.Bool?
    /// Specifies that you want to list only those associations with resource shares that have a featureSet with this value.
    public var featureSet: RAMClientTypes.PermissionFeatureSet?
    /// Specifies the total number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value that is specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next part of the results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// Specifies the [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the managed permission.
    public var permissionArn: Swift.String?
    /// Specifies that you want to list only those associations with resource shares that use this version of the managed permission. If you don't provide a value for this parameter, then the operation returns information about associations with resource shares that use any version of the managed permission.
    public var permissionVersion: Swift.Int?
    /// Specifies that you want to list only those associations with resource shares that include at least one resource of this resource type.
    public var resourceType: Swift.String?

    public init(
        associationStatus: RAMClientTypes.ResourceShareAssociationStatus? = nil,
        defaultVersion: Swift.Bool? = nil,
        featureSet: RAMClientTypes.PermissionFeatureSet? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        permissionArn: Swift.String? = nil,
        permissionVersion: Swift.Int? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.associationStatus = associationStatus
        self.defaultVersion = defaultVersion
        self.featureSet = featureSet
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.permissionArn = permissionArn
        self.permissionVersion = permissionVersion
        self.resourceType = resourceType
    }
}

struct ListPermissionAssociationsInputBody: Swift.Equatable {
    let permissionArn: Swift.String?
    let permissionVersion: Swift.Int?
    let associationStatus: RAMClientTypes.ResourceShareAssociationStatus?
    let resourceType: Swift.String?
    let featureSet: RAMClientTypes.PermissionFeatureSet?
    let defaultVersion: Swift.Bool?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListPermissionAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationStatus
        case defaultVersion
        case featureSet
        case maxResults
        case nextToken
        case permissionArn
        case permissionVersion
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionArn)
        permissionArn = permissionArnDecoded
        let permissionVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .permissionVersion)
        permissionVersion = permissionVersionDecoded
        let associationStatusDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceShareAssociationStatus.self, forKey: .associationStatus)
        associationStatus = associationStatusDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let featureSetDecoded = try containerValues.decodeIfPresent(RAMClientTypes.PermissionFeatureSet.self, forKey: .featureSet)
        featureSet = featureSetDecoded
        let defaultVersionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .defaultVersion)
        defaultVersion = defaultVersionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

public enum ListPermissionAssociationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextToken": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArn.Malformed": return try await MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "Unavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPermissionAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPermissionAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissions = output.permissions
        } else {
            self.nextToken = nil
            self.permissions = nil
        }
    }
}

public struct ListPermissionAssociationsOutputResponse: Swift.Equatable {
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?
    /// A structure with information about this customer managed permission.
    public var permissions: [RAMClientTypes.AssociatedPermission]?

    public init(
        nextToken: Swift.String? = nil,
        permissions: [RAMClientTypes.AssociatedPermission]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissions = permissions
    }
}

struct ListPermissionAssociationsOutputResponseBody: Swift.Equatable {
    let permissions: [RAMClientTypes.AssociatedPermission]?
    let nextToken: Swift.String?
}

extension ListPermissionAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case permissions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsContainer = try containerValues.decodeIfPresent([RAMClientTypes.AssociatedPermission?].self, forKey: .permissions)
        var permissionsDecoded0:[RAMClientTypes.AssociatedPermission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [RAMClientTypes.AssociatedPermission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPermissionVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case permissionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let permissionArn = self.permissionArn {
            try encodeContainer.encode(permissionArn, forKey: .permissionArn)
        }
    }
}

extension ListPermissionVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listpermissionversions"
    }
}

public struct ListPermissionVersionsInput: Swift.Equatable {
    /// Specifies the total number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value that is specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next part of the results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// Specifies the [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the RAM permission whose versions you want to list. You can use the permissionVersion parameter on the [AssociateResourceSharePermission] operation to specify a non-default version to attach.
    /// This member is required.
    public var permissionArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        permissionArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.permissionArn = permissionArn
    }
}

struct ListPermissionVersionsInputBody: Swift.Equatable {
    let permissionArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListPermissionVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case permissionArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionArn)
        permissionArn = permissionArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

public enum ListPermissionVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextToken": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArn.Malformed": return try await MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "Unavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceShareArn.NotFound": return try await UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPermissionVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPermissionVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissions = output.permissions
        } else {
            self.nextToken = nil
            self.permissions = nil
        }
    }
}

public struct ListPermissionVersionsOutputResponse: Swift.Equatable {
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?
    /// An array of objects that contain details for each of the available versions.
    public var permissions: [RAMClientTypes.ResourceSharePermissionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        permissions: [RAMClientTypes.ResourceSharePermissionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissions = permissions
    }
}

struct ListPermissionVersionsOutputResponseBody: Swift.Equatable {
    let permissions: [RAMClientTypes.ResourceSharePermissionSummary]?
    let nextToken: Swift.String?
}

extension ListPermissionVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case permissions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsContainer = try containerValues.decodeIfPresent([RAMClientTypes.ResourceSharePermissionSummary?].self, forKey: .permissions)
        var permissionsDecoded0:[RAMClientTypes.ResourceSharePermissionSummary]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [RAMClientTypes.ResourceSharePermissionSummary]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case permissionType
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let permissionType = self.permissionType {
            try encodeContainer.encode(permissionType.rawValue, forKey: .permissionType)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }
}

extension ListPermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listpermissions"
    }
}

public struct ListPermissionsInput: Swift.Equatable {
    /// Specifies the total number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value that is specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next part of the results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// Specifies that you want to list only permissions of this type:
    ///
    /// * AWS – returns only Amazon Web Services managed permissions.
    ///
    /// * LOCAL – returns only customer managed permissions
    ///
    /// * ALL – returns both Amazon Web Services managed permissions and customer managed permissions.
    ///
    ///
    /// If you don't specify this parameter, the default is All.
    public var permissionType: RAMClientTypes.PermissionTypeFilter?
    /// Specifies that you want to list only those permissions that apply to the specified resource type. This parameter is not case sensitive. For example, to list only permissions that apply to Amazon EC2 subnets, specify ec2:subnet. You can use the [ListResourceTypes] operation to get the specific string required.
    public var resourceType: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        permissionType: RAMClientTypes.PermissionTypeFilter? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.permissionType = permissionType
        self.resourceType = resourceType
    }
}

struct ListPermissionsInputBody: Swift.Equatable {
    let resourceType: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let permissionType: RAMClientTypes.PermissionTypeFilter?
}

extension ListPermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case permissionType
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let permissionTypeDecoded = try containerValues.decodeIfPresent(RAMClientTypes.PermissionTypeFilter.self, forKey: .permissionType)
        permissionType = permissionTypeDecoded
    }
}

public enum ListPermissionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextToken": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "Unavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissions = output.permissions
        } else {
            self.nextToken = nil
            self.permissions = nil
        }
    }
}

public struct ListPermissionsOutputResponse: Swift.Equatable {
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?
    /// An array of objects with information about the permissions.
    public var permissions: [RAMClientTypes.ResourceSharePermissionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        permissions: [RAMClientTypes.ResourceSharePermissionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissions = permissions
    }
}

struct ListPermissionsOutputResponseBody: Swift.Equatable {
    let permissions: [RAMClientTypes.ResourceSharePermissionSummary]?
    let nextToken: Swift.String?
}

extension ListPermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case permissions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsContainer = try containerValues.decodeIfPresent([RAMClientTypes.ResourceSharePermissionSummary?].self, forKey: .permissions)
        var permissionsDecoded0:[RAMClientTypes.ResourceSharePermissionSummary]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [RAMClientTypes.ResourceSharePermissionSummary]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPrincipalsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case principals
        case resourceArn
        case resourceOwner
        case resourceShareArns
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for string0 in principals {
                try principalsContainer.encode(string0)
            }
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceOwner = self.resourceOwner {
            try encodeContainer.encode(resourceOwner.rawValue, forKey: .resourceOwner)
        }
        if let resourceShareArns = resourceShareArns {
            var resourceShareArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShareArns)
            for string0 in resourceShareArns {
                try resourceShareArnsContainer.encode(string0)
            }
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }
}

extension ListPrincipalsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listprincipals"
    }
}

public struct ListPrincipalsInput: Swift.Equatable {
    /// Specifies the total number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value that is specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next part of the results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// Specifies that you want to list information for only the listed principals. You can include the following values:
    ///
    /// * An Amazon Web Services account ID, for example: 123456789012
    ///
    /// * An [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of an organization in Organizations, for example: organizations::123456789012:organization/o-exampleorgid
    ///
    /// * An ARN of an organizational unit (OU) in Organizations, for example: organizations::123456789012:ou/o-exampleorgid/ou-examplerootid-exampleouid123
    ///
    /// * An ARN of an IAM role, for example: iam::123456789012:role/rolename
    ///
    /// * An ARN of an IAM user, for example: iam::123456789012user/username
    ///
    ///
    /// Not all resource types can be shared with IAM roles and users. For more information, see [Sharing with IAM roles and users](https://docs.aws.amazon.com/ram/latest/userguide/permissions.html#permissions-rbp-supported-resource-types) in the Resource Access Manager User Guide.
    public var principals: [Swift.String]?
    /// Specifies that you want to list principal information for the resource share with the specified [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html).
    public var resourceArn: Swift.String?
    /// Specifies that you want to list information for only resource shares that match the following:
    ///
    /// * SELF – principals that your account is sharing resources with
    ///
    /// * OTHER-ACCOUNTS – principals that are sharing resources with your account
    /// This member is required.
    public var resourceOwner: RAMClientTypes.ResourceOwner?
    /// Specifies that you want to list information for only principals associated with the resource shares specified by a list the [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html).
    public var resourceShareArns: [Swift.String]?
    /// Specifies that you want to list information for only principals associated with resource shares that include the specified resource type. For a list of valid values, query the [ListResourceTypes] operation.
    public var resourceType: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        principals: [Swift.String]? = nil,
        resourceArn: Swift.String? = nil,
        resourceOwner: RAMClientTypes.ResourceOwner? = nil,
        resourceShareArns: [Swift.String]? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principals = principals
        self.resourceArn = resourceArn
        self.resourceOwner = resourceOwner
        self.resourceShareArns = resourceShareArns
        self.resourceType = resourceType
    }
}

struct ListPrincipalsInputBody: Swift.Equatable {
    let resourceOwner: RAMClientTypes.ResourceOwner?
    let resourceArn: Swift.String?
    let principals: [Swift.String]?
    let resourceType: Swift.String?
    let resourceShareArns: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListPrincipalsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case principals
        case resourceArn
        case resourceOwner
        case resourceShareArns
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceOwner.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let principalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .principals)
        var principalsDecoded0:[Swift.String]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [Swift.String]()
            for string0 in principalsContainer {
                if let string0 = string0 {
                    principalsDecoded0?.append(string0)
                }
            }
        }
        principals = principalsDecoded0
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceShareArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceShareArns)
        var resourceShareArnsDecoded0:[Swift.String]? = nil
        if let resourceShareArnsContainer = resourceShareArnsContainer {
            resourceShareArnsDecoded0 = [Swift.String]()
            for string0 in resourceShareArnsContainer {
                if let string0 = string0 {
                    resourceShareArnsDecoded0?.append(string0)
                }
            }
        }
        resourceShareArns = resourceShareArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

public enum ListPrincipalsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextToken": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArn.Malformed": return try await MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "Unavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceShareArn.NotFound": return try await UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPrincipalsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPrincipalsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.principals = output.principals
        } else {
            self.nextToken = nil
            self.principals = nil
        }
    }
}

public struct ListPrincipalsOutputResponse: Swift.Equatable {
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?
    /// An array of objects that contain the details about the principals.
    public var principals: [RAMClientTypes.Principal]?

    public init(
        nextToken: Swift.String? = nil,
        principals: [RAMClientTypes.Principal]? = nil
    )
    {
        self.nextToken = nextToken
        self.principals = principals
    }
}

struct ListPrincipalsOutputResponseBody: Swift.Equatable {
    let principals: [RAMClientTypes.Principal]?
    let nextToken: Swift.String?
}

extension ListPrincipalsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case principals
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalsContainer = try containerValues.decodeIfPresent([RAMClientTypes.Principal?].self, forKey: .principals)
        var principalsDecoded0:[RAMClientTypes.Principal]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [RAMClientTypes.Principal]()
            for structure0 in principalsContainer {
                if let structure0 = structure0 {
                    principalsDecoded0?.append(structure0)
                }
            }
        }
        principals = principalsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListReplacePermissionAssociationsWorkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case status
        case workIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let workIds = workIds {
            var workIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .workIds)
            for string0 in workIds {
                try workIdsContainer.encode(string0)
            }
        }
    }
}

extension ListReplacePermissionAssociationsWorkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listreplacepermissionassociationswork"
    }
}

public struct ListReplacePermissionAssociationsWorkInput: Swift.Equatable {
    /// Specifies the total number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value that is specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next part of the results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// Specifies that you want to see only the details about requests with a status that matches this value.
    public var status: RAMClientTypes.ReplacePermissionAssociationsWorkStatus?
    /// A list of IDs. These values come from the idfield of the replacePermissionAssociationsWorkstructure returned by the [ReplacePermissionAssociations] operation.
    public var workIds: [Swift.String]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: RAMClientTypes.ReplacePermissionAssociationsWorkStatus? = nil,
        workIds: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
        self.workIds = workIds
    }
}

struct ListReplacePermissionAssociationsWorkInputBody: Swift.Equatable {
    let workIds: [Swift.String]?
    let status: RAMClientTypes.ReplacePermissionAssociationsWorkStatus?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListReplacePermissionAssociationsWorkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case status
        case workIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .workIds)
        var workIdsDecoded0:[Swift.String]? = nil
        if let workIdsContainer = workIdsContainer {
            workIdsDecoded0 = [Swift.String]()
            for string0 in workIdsContainer {
                if let string0 = string0 {
                    workIdsDecoded0?.append(string0)
                }
            }
        }
        workIds = workIdsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ReplacePermissionAssociationsWorkStatus.self, forKey: .status)
        status = statusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

public enum ListReplacePermissionAssociationsWorkOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextToken": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "Unavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListReplacePermissionAssociationsWorkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListReplacePermissionAssociationsWorkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.replacePermissionAssociationsWorks = output.replacePermissionAssociationsWorks
        } else {
            self.nextToken = nil
            self.replacePermissionAssociationsWorks = nil
        }
    }
}

public struct ListReplacePermissionAssociationsWorkOutputResponse: Swift.Equatable {
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?
    /// An array of data structures that provide details of the matching work IDs.
    public var replacePermissionAssociationsWorks: [RAMClientTypes.ReplacePermissionAssociationsWork]?

    public init(
        nextToken: Swift.String? = nil,
        replacePermissionAssociationsWorks: [RAMClientTypes.ReplacePermissionAssociationsWork]? = nil
    )
    {
        self.nextToken = nextToken
        self.replacePermissionAssociationsWorks = replacePermissionAssociationsWorks
    }
}

struct ListReplacePermissionAssociationsWorkOutputResponseBody: Swift.Equatable {
    let replacePermissionAssociationsWorks: [RAMClientTypes.ReplacePermissionAssociationsWork]?
    let nextToken: Swift.String?
}

extension ListReplacePermissionAssociationsWorkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case replacePermissionAssociationsWorks
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replacePermissionAssociationsWorksContainer = try containerValues.decodeIfPresent([RAMClientTypes.ReplacePermissionAssociationsWork?].self, forKey: .replacePermissionAssociationsWorks)
        var replacePermissionAssociationsWorksDecoded0:[RAMClientTypes.ReplacePermissionAssociationsWork]? = nil
        if let replacePermissionAssociationsWorksContainer = replacePermissionAssociationsWorksContainer {
            replacePermissionAssociationsWorksDecoded0 = [RAMClientTypes.ReplacePermissionAssociationsWork]()
            for structure0 in replacePermissionAssociationsWorksContainer {
                if let structure0 = structure0 {
                    replacePermissionAssociationsWorksDecoded0?.append(structure0)
                }
            }
        }
        replacePermissionAssociationsWorks = replacePermissionAssociationsWorksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResourceSharePermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceShareArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceShareArn = self.resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
    }
}

extension ListResourceSharePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listresourcesharepermissions"
    }
}

public struct ListResourceSharePermissionsInput: Swift.Equatable {
    /// Specifies the total number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value that is specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next part of the results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// Specifies the [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource share for which you want to retrieve the associated permissions.
    /// This member is required.
    public var resourceShareArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceShareArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceShareArn = resourceShareArn
    }
}

struct ListResourceSharePermissionsInputBody: Swift.Equatable {
    let resourceShareArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListResourceSharePermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceShareArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

public enum ListResourceSharePermissionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextToken": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArn.Malformed": return try await MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "Unavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceShareArn.NotFound": return try await UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListResourceSharePermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListResourceSharePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissions = output.permissions
        } else {
            self.nextToken = nil
            self.permissions = nil
        }
    }
}

public struct ListResourceSharePermissionsOutputResponse: Swift.Equatable {
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?
    /// An array of objects that describe the permissions associated with the resource share.
    public var permissions: [RAMClientTypes.ResourceSharePermissionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        permissions: [RAMClientTypes.ResourceSharePermissionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissions = permissions
    }
}

struct ListResourceSharePermissionsOutputResponseBody: Swift.Equatable {
    let permissions: [RAMClientTypes.ResourceSharePermissionSummary]?
    let nextToken: Swift.String?
}

extension ListResourceSharePermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case permissions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsContainer = try containerValues.decodeIfPresent([RAMClientTypes.ResourceSharePermissionSummary?].self, forKey: .permissions)
        var permissionsDecoded0:[RAMClientTypes.ResourceSharePermissionSummary]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [RAMClientTypes.ResourceSharePermissionSummary]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResourceTypesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceRegionScope
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceRegionScope = self.resourceRegionScope {
            try encodeContainer.encode(resourceRegionScope.rawValue, forKey: .resourceRegionScope)
        }
    }
}

extension ListResourceTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listresourcetypes"
    }
}

public struct ListResourceTypesInput: Swift.Equatable {
    /// Specifies the total number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value that is specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next part of the results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// Specifies that you want the results to include only resources that have the specified scope.
    ///
    /// * ALL – the results include both global and regional resources or resource types.
    ///
    /// * GLOBAL – the results include only global resources or resource types.
    ///
    /// * REGIONAL – the results include only regional resources or resource types.
    ///
    ///
    /// The default value is ALL.
    public var resourceRegionScope: RAMClientTypes.ResourceRegionScopeFilter?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceRegionScope: RAMClientTypes.ResourceRegionScopeFilter? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceRegionScope = resourceRegionScope
    }
}

struct ListResourceTypesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let resourceRegionScope: RAMClientTypes.ResourceRegionScopeFilter?
}

extension ListResourceTypesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceRegionScope
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let resourceRegionScopeDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceRegionScopeFilter.self, forKey: .resourceRegionScope)
        resourceRegionScope = resourceRegionScopeDecoded
    }
}

public enum ListResourceTypesOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextToken": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "Unavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListResourceTypesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListResourceTypesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceTypes = output.resourceTypes
        } else {
            self.nextToken = nil
            self.resourceTypes = nil
        }
    }
}

public struct ListResourceTypesOutputResponse: Swift.Equatable {
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?
    /// An array of objects that contain information about the resource types that can be shared using RAM.
    public var resourceTypes: [RAMClientTypes.ServiceNameAndResourceType]?

    public init(
        nextToken: Swift.String? = nil,
        resourceTypes: [RAMClientTypes.ServiceNameAndResourceType]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceTypes = resourceTypes
    }
}

struct ListResourceTypesOutputResponseBody: Swift.Equatable {
    let resourceTypes: [RAMClientTypes.ServiceNameAndResourceType]?
    let nextToken: Swift.String?
}

extension ListResourceTypesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resourceTypes
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypesContainer = try containerValues.decodeIfPresent([RAMClientTypes.ServiceNameAndResourceType?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[RAMClientTypes.ServiceNameAndResourceType]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [RAMClientTypes.ServiceNameAndResourceType]()
            for structure0 in resourceTypesContainer {
                if let structure0 = structure0 {
                    resourceTypesDecoded0?.append(structure0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case principal
        case resourceArns
        case resourceOwner
        case resourceRegionScope
        case resourceShareArns
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let principal = self.principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for string0 in resourceArns {
                try resourceArnsContainer.encode(string0)
            }
        }
        if let resourceOwner = self.resourceOwner {
            try encodeContainer.encode(resourceOwner.rawValue, forKey: .resourceOwner)
        }
        if let resourceRegionScope = self.resourceRegionScope {
            try encodeContainer.encode(resourceRegionScope.rawValue, forKey: .resourceRegionScope)
        }
        if let resourceShareArns = resourceShareArns {
            var resourceShareArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShareArns)
            for string0 in resourceShareArns {
                try resourceShareArnsContainer.encode(string0)
            }
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }
}

extension ListResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listresources"
    }
}

public struct ListResourcesInput: Swift.Equatable {
    /// Specifies the total number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value that is specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next part of the results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// Specifies that you want to list only the resource shares that are associated with the specified principal.
    public var principal: Swift.String?
    /// Specifies that you want to list only the resource shares that include resources with the specified [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html).
    public var resourceArns: [Swift.String]?
    /// Specifies that you want to list only the resource shares that match the following:
    ///
    /// * SELF – resources that your account shares with other accounts
    ///
    /// * OTHER-ACCOUNTS – resources that other accounts share with your account
    /// This member is required.
    public var resourceOwner: RAMClientTypes.ResourceOwner?
    /// Specifies that you want the results to include only resources that have the specified scope.
    ///
    /// * ALL – the results include both global and regional resources or resource types.
    ///
    /// * GLOBAL – the results include only global resources or resource types.
    ///
    /// * REGIONAL – the results include only regional resources or resource types.
    ///
    ///
    /// The default value is ALL.
    public var resourceRegionScope: RAMClientTypes.ResourceRegionScopeFilter?
    /// Specifies that you want to list only resources in the resource shares identified by the specified [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html).
    public var resourceShareArns: [Swift.String]?
    /// Specifies that you want to list only the resource shares that include resources of the specified resource type. For valid values, query the [ListResourceTypes] operation.
    public var resourceType: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        principal: Swift.String? = nil,
        resourceArns: [Swift.String]? = nil,
        resourceOwner: RAMClientTypes.ResourceOwner? = nil,
        resourceRegionScope: RAMClientTypes.ResourceRegionScopeFilter? = nil,
        resourceShareArns: [Swift.String]? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principal = principal
        self.resourceArns = resourceArns
        self.resourceOwner = resourceOwner
        self.resourceRegionScope = resourceRegionScope
        self.resourceShareArns = resourceShareArns
        self.resourceType = resourceType
    }
}

struct ListResourcesInputBody: Swift.Equatable {
    let resourceOwner: RAMClientTypes.ResourceOwner?
    let principal: Swift.String?
    let resourceType: Swift.String?
    let resourceArns: [Swift.String]?
    let resourceShareArns: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let resourceRegionScope: RAMClientTypes.ResourceRegionScopeFilter?
}

extension ListResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case principal
        case resourceArns
        case resourceOwner
        case resourceRegionScope
        case resourceShareArns
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceOwner.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let principalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principal)
        principal = principalDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let resourceShareArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceShareArns)
        var resourceShareArnsDecoded0:[Swift.String]? = nil
        if let resourceShareArnsContainer = resourceShareArnsContainer {
            resourceShareArnsDecoded0 = [Swift.String]()
            for string0 in resourceShareArnsContainer {
                if let string0 = string0 {
                    resourceShareArnsDecoded0?.append(string0)
                }
            }
        }
        resourceShareArns = resourceShareArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let resourceRegionScopeDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceRegionScopeFilter.self, forKey: .resourceRegionScope)
        resourceRegionScope = resourceRegionScopeDecoded
    }
}

public enum ListResourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextToken": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceType.Unknown": return try await InvalidResourceTypeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArn.Malformed": return try await MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "Unavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceShareArn.NotFound": return try await UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resources = output.resources
        } else {
            self.nextToken = nil
            self.resources = nil
        }
    }
}

public struct ListResourcesOutputResponse: Swift.Equatable {
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?
    /// An array of objects that contain information about the resources.
    public var resources: [RAMClientTypes.Resource]?

    public init(
        nextToken: Swift.String? = nil,
        resources: [RAMClientTypes.Resource]? = nil
    )
    {
        self.nextToken = nextToken
        self.resources = resources
    }
}

struct ListResourcesOutputResponseBody: Swift.Equatable {
    let resources: [RAMClientTypes.Resource]?
    let nextToken: Swift.String?
}

extension ListResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesContainer = try containerValues.decodeIfPresent([RAMClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[RAMClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [RAMClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MalformedArnException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MalformedArnExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation failed because the specified [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) has a format that isn't valid.
public struct MalformedArnException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidArn.Malformed" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct MalformedArnExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MalformedArnExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MalformedPolicyTemplateException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MalformedPolicyTemplateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation failed because the policy template that you provided isn't valid.
public struct MalformedPolicyTemplateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MalformedPolicyTemplateException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct MalformedPolicyTemplateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MalformedPolicyTemplateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MissingRequiredParameterException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MissingRequiredParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation failed because a required input parameter is missing.
public struct MissingRequiredParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MissingRequiredParameter" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct MissingRequiredParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MissingRequiredParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OperationNotPermittedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: OperationNotPermittedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation failed because the requested operation isn't permitted.
public struct OperationNotPermittedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OperationNotPermitted" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct OperationNotPermittedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OperationNotPermittedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PermissionAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PermissionAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation failed because a permission with the specified name already exists in the requested Amazon Web Services Region. Choose a different name.
public struct PermissionAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PermissionAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct PermissionAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PermissionAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RAMClientTypes {
    public enum PermissionFeatureSet: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createdFromPolicy
        case promotingToStandard
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [PermissionFeatureSet] {
            return [
                .createdFromPolicy,
                .promotingToStandard,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createdFromPolicy: return "CREATED_FROM_POLICY"
            case .promotingToStandard: return "PROMOTING_TO_STANDARD"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PermissionFeatureSet(rawValue: rawValue) ?? PermissionFeatureSet.sdkUnknown(rawValue)
        }
    }
}

extension PermissionLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PermissionLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation failed because it would exceed the maximum number of permissions you can create in each Amazon Web Services Region. To view the limits for your Amazon Web Services account, see the [RAM page in the Service Quotas console](https://console.aws.amazon.com/servicequotas/home/services/ram/quotas).
public struct PermissionLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PermissionLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct PermissionLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PermissionLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RAMClientTypes {
    public enum PermissionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case attachable
        case deleted
        case deleting
        case unattachable
        case sdkUnknown(Swift.String)

        public static var allCases: [PermissionStatus] {
            return [
                .attachable,
                .deleted,
                .deleting,
                .unattachable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .attachable: return "ATTACHABLE"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .unattachable: return "UNATTACHABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PermissionStatus(rawValue: rawValue) ?? PermissionStatus.sdkUnknown(rawValue)
        }
    }
}

extension RAMClientTypes {
    public enum PermissionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsManaged
        case customerManaged
        case sdkUnknown(Swift.String)

        public static var allCases: [PermissionType] {
            return [
                .awsManaged,
                .customerManaged,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsManaged: return "AWS_MANAGED"
            case .customerManaged: return "CUSTOMER_MANAGED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PermissionType(rawValue: rawValue) ?? PermissionType.sdkUnknown(rawValue)
        }
    }
}

extension RAMClientTypes {
    public enum PermissionTypeFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case awsManaged
        case customerManaged
        case sdkUnknown(Swift.String)

        public static var allCases: [PermissionTypeFilter] {
            return [
                .all,
                .awsManaged,
                .customerManaged,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .awsManaged: return "AWS_MANAGED"
            case .customerManaged: return "CUSTOMER_MANAGED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PermissionTypeFilter(rawValue: rawValue) ?? PermissionTypeFilter.sdkUnknown(rawValue)
        }
    }
}

extension PermissionVersionsLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PermissionVersionsLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation failed because it would exceed the limit for the number of versions you can have for a permission. To view the limits for your Amazon Web Services account, see the [RAM page in the Service Quotas console](https://console.aws.amazon.com/servicequotas/home/services/ram/quotas).
public struct PermissionVersionsLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PermissionVersionsLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct PermissionVersionsLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PermissionVersionsLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RAMClientTypes.Principal: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case external
        case id
        case lastUpdatedTime
        case resourceShareArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let external = self.external {
            try encodeContainer.encode(external, forKey: .external)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let resourceShareArn = self.resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let externalDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .external)
        external = externalDecoded
    }
}

extension RAMClientTypes {
    /// Describes a principal for use with Resource Access Manager.
    public struct Principal: Swift.Equatable {
        /// The date and time when the principal was associated with the resource share.
        public var creationTime: ClientRuntime.Date?
        /// Indicates the relationship between the Amazon Web Services account the principal belongs to and the account that owns the resource share:
        ///
        /// * True – The two accounts belong to same organization.
        ///
        /// * False – The two accounts do not belong to the same organization.
        public var external: Swift.Bool?
        /// The ID of the principal that can be associated with a resource share.
        public var id: Swift.String?
        /// The date and time when the association between the resource share and the principal was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of a resource share the principal is associated with.
        public var resourceShareArn: Swift.String?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            external: Swift.Bool? = nil,
            id: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            resourceShareArn: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.external = external
            self.id = id
            self.lastUpdatedTime = lastUpdatedTime
            self.resourceShareArn = resourceShareArn
        }
    }

}

extension PromotePermissionCreatedFromPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case name
        case permissionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permissionArn = self.permissionArn {
            try encodeContainer.encode(permissionArn, forKey: .permissionArn)
        }
    }
}

extension PromotePermissionCreatedFromPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/promotepermissioncreatedfrompolicy"
    }
}

public struct PromotePermissionCreatedFromPolicyInput: Swift.Equatable {
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value.](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// Specifies a name for the promoted customer managed permission.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the CREATED_FROM_POLICY permission that you want to promote. You can get this [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) by calling the [ListResourceSharePermissions] operation.
    /// This member is required.
    public var permissionArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        permissionArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.name = name
        self.permissionArn = permissionArn
    }
}

struct PromotePermissionCreatedFromPolicyInputBody: Swift.Equatable {
    let permissionArn: Swift.String?
    let name: Swift.String?
    let clientToken: Swift.String?
}

extension PromotePermissionCreatedFromPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case name
        case permissionArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionArn)
        permissionArn = permissionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public enum PromotePermissionCreatedFromPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArn.Malformed": return try await MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "Unavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceShareArn.NotFound": return try await UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PromotePermissionCreatedFromPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PromotePermissionCreatedFromPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.permission = output.permission
        } else {
            self.clientToken = nil
            self.permission = nil
        }
    }
}

public struct PromotePermissionCreatedFromPolicyOutputResponse: Swift.Equatable {
    /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other parameters must also have the same values that you used in the first call.
    public var clientToken: Swift.String?
    /// Information about an RAM permission.
    public var permission: RAMClientTypes.ResourceSharePermissionSummary?

    public init(
        clientToken: Swift.String? = nil,
        permission: RAMClientTypes.ResourceSharePermissionSummary? = nil
    )
    {
        self.clientToken = clientToken
        self.permission = permission
    }
}

struct PromotePermissionCreatedFromPolicyOutputResponseBody: Swift.Equatable {
    let permission: RAMClientTypes.ResourceSharePermissionSummary?
    let clientToken: Swift.String?
}

extension PromotePermissionCreatedFromPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case permission
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceSharePermissionSummary.self, forKey: .permission)
        permission = permissionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension PromoteResourceShareCreatedFromPolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceShareArn = resourceShareArn else {
                let message = "Creating a URL Query Item failed. resourceShareArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceShareArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceShareArn".urlPercentEncoding(), value: Swift.String(resourceShareArn).urlPercentEncoding())
            items.append(resourceShareArnQueryItem)
            return items
        }
    }
}

extension PromoteResourceShareCreatedFromPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/promoteresourcesharecreatedfrompolicy"
    }
}

public struct PromoteResourceShareCreatedFromPolicyInput: Swift.Equatable {
    /// Specifies the [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource share to promote.
    /// This member is required.
    public var resourceShareArn: Swift.String?

    public init(
        resourceShareArn: Swift.String? = nil
    )
    {
        self.resourceShareArn = resourceShareArn
    }
}

struct PromoteResourceShareCreatedFromPolicyInputBody: Swift.Equatable {
}

extension PromoteResourceShareCreatedFromPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

public enum PromoteResourceShareCreatedFromPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidStateTransitionException.Unknown": return try await InvalidStateTransitionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArn.Malformed": return try await MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceShareLimitExceeded": return try await ResourceShareLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "Unavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceShareArn.NotFound": return try await UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnmatchedPolicyPermissionException": return try await UnmatchedPolicyPermissionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PromoteResourceShareCreatedFromPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PromoteResourceShareCreatedFromPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.returnValue = output.returnValue
        } else {
            self.returnValue = nil
        }
    }
}

public struct PromoteResourceShareCreatedFromPolicyOutputResponse: Swift.Equatable {
    /// A return value of true indicates that the request succeeded. A value of false indicates that the request failed.
    public var returnValue: Swift.Bool?

    public init(
        returnValue: Swift.Bool? = nil
    )
    {
        self.returnValue = returnValue
    }
}

struct PromoteResourceShareCreatedFromPolicyOutputResponseBody: Swift.Equatable {
    let returnValue: Swift.Bool?
}

extension PromoteResourceShareCreatedFromPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case returnValue
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnValue)
        returnValue = returnValueDecoded
    }
}

extension RejectResourceShareInvitationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShareInvitationArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let resourceShareInvitationArn = self.resourceShareInvitationArn {
            try encodeContainer.encode(resourceShareInvitationArn, forKey: .resourceShareInvitationArn)
        }
    }
}

extension RejectResourceShareInvitationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/rejectresourceshareinvitation"
    }
}

public struct RejectResourceShareInvitationInput: Swift.Equatable {
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value.](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// Specifies the [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the invitation that you want to reject.
    /// This member is required.
    public var resourceShareInvitationArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        resourceShareInvitationArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShareInvitationArn = resourceShareInvitationArn
    }
}

struct RejectResourceShareInvitationInputBody: Swift.Equatable {
    let resourceShareInvitationArn: Swift.String?
    let clientToken: Swift.String?
}

extension RejectResourceShareInvitationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShareInvitationArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareInvitationArn)
        resourceShareInvitationArn = resourceShareInvitationArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public enum RejectResourceShareInvitationOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "IdempotentParameterMismatch": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidClientToken": return try await InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArn.Malformed": return try await MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceShareInvitationArn.AlreadyAccepted": return try await ResourceShareInvitationAlreadyAcceptedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceShareInvitationArn.AlreadyRejected": return try await ResourceShareInvitationAlreadyRejectedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceShareInvitationArn.NotFound": return try await ResourceShareInvitationArnNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceShareInvitationArn.Expired": return try await ResourceShareInvitationExpiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "Unavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RejectResourceShareInvitationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RejectResourceShareInvitationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.resourceShareInvitation = output.resourceShareInvitation
        } else {
            self.clientToken = nil
            self.resourceShareInvitation = nil
        }
    }
}

public struct RejectResourceShareInvitationOutputResponse: Swift.Equatable {
    /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other parameters must also have the same values that you used in the first call.
    public var clientToken: Swift.String?
    /// An object that contains the details about the rejected invitation.
    public var resourceShareInvitation: RAMClientTypes.ResourceShareInvitation?

    public init(
        clientToken: Swift.String? = nil,
        resourceShareInvitation: RAMClientTypes.ResourceShareInvitation? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShareInvitation = resourceShareInvitation
    }
}

struct RejectResourceShareInvitationOutputResponseBody: Swift.Equatable {
    let resourceShareInvitation: RAMClientTypes.ResourceShareInvitation?
    let clientToken: Swift.String?
}

extension RejectResourceShareInvitationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShareInvitation
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceShareInvitation.self, forKey: .resourceShareInvitation)
        resourceShareInvitation = resourceShareInvitationDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension ReplacePermissionAssociationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case fromPermissionArn
        case fromPermissionVersion
        case toPermissionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let fromPermissionArn = self.fromPermissionArn {
            try encodeContainer.encode(fromPermissionArn, forKey: .fromPermissionArn)
        }
        if let fromPermissionVersion = self.fromPermissionVersion {
            try encodeContainer.encode(fromPermissionVersion, forKey: .fromPermissionVersion)
        }
        if let toPermissionArn = self.toPermissionArn {
            try encodeContainer.encode(toPermissionArn, forKey: .toPermissionArn)
        }
    }
}

extension ReplacePermissionAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/replacepermissionassociations"
    }
}

public struct ReplacePermissionAssociationsInput: Swift.Equatable {
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value.](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// Specifies the [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the managed permission that you want to replace.
    /// This member is required.
    public var fromPermissionArn: Swift.String?
    /// Specifies that you want to updated the permissions for only those resource shares that use the specified version of the managed permission.
    public var fromPermissionVersion: Swift.Int?
    /// Specifies the ARN of the managed permission that you want to associate with resource shares in place of the one specified by fromPerssionArn and fromPermissionVersion. The operation always associates the version that is currently the default for the specified managed permission.
    /// This member is required.
    public var toPermissionArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        fromPermissionArn: Swift.String? = nil,
        fromPermissionVersion: Swift.Int? = nil,
        toPermissionArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.fromPermissionArn = fromPermissionArn
        self.fromPermissionVersion = fromPermissionVersion
        self.toPermissionArn = toPermissionArn
    }
}

struct ReplacePermissionAssociationsInputBody: Swift.Equatable {
    let fromPermissionArn: Swift.String?
    let fromPermissionVersion: Swift.Int?
    let toPermissionArn: Swift.String?
    let clientToken: Swift.String?
}

extension ReplacePermissionAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case fromPermissionArn
        case fromPermissionVersion
        case toPermissionArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromPermissionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fromPermissionArn)
        fromPermissionArn = fromPermissionArnDecoded
        let fromPermissionVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fromPermissionVersion)
        fromPermissionVersion = fromPermissionVersionDecoded
        let toPermissionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .toPermissionArn)
        toPermissionArn = toPermissionArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public enum ReplacePermissionAssociationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "IdempotentParameterMismatch": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidClientToken": return try await InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArn.Malformed": return try await MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "Unavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceShareArn.NotFound": return try await UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ReplacePermissionAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ReplacePermissionAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.replacePermissionAssociationsWork = output.replacePermissionAssociationsWork
        } else {
            self.clientToken = nil
            self.replacePermissionAssociationsWork = nil
        }
    }
}

public struct ReplacePermissionAssociationsOutputResponse: Swift.Equatable {
    /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other parameters must also have the same values that you used in the first call.
    public var clientToken: Swift.String?
    /// Specifies a data structure that you can use to track the asynchronous tasks that RAM performs to complete this operation. You can use the [ListReplacePermissionAssociationsWork] operation and pass the id value returned in this structure.
    public var replacePermissionAssociationsWork: RAMClientTypes.ReplacePermissionAssociationsWork?

    public init(
        clientToken: Swift.String? = nil,
        replacePermissionAssociationsWork: RAMClientTypes.ReplacePermissionAssociationsWork? = nil
    )
    {
        self.clientToken = clientToken
        self.replacePermissionAssociationsWork = replacePermissionAssociationsWork
    }
}

struct ReplacePermissionAssociationsOutputResponseBody: Swift.Equatable {
    let replacePermissionAssociationsWork: RAMClientTypes.ReplacePermissionAssociationsWork?
    let clientToken: Swift.String?
}

extension ReplacePermissionAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case replacePermissionAssociationsWork
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replacePermissionAssociationsWorkDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ReplacePermissionAssociationsWork.self, forKey: .replacePermissionAssociationsWork)
        replacePermissionAssociationsWork = replacePermissionAssociationsWorkDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension RAMClientTypes.ReplacePermissionAssociationsWork: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case fromPermissionArn
        case fromPermissionVersion
        case id
        case lastUpdatedTime
        case status
        case statusMessage
        case toPermissionArn
        case toPermissionVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let fromPermissionArn = self.fromPermissionArn {
            try encodeContainer.encode(fromPermissionArn, forKey: .fromPermissionArn)
        }
        if let fromPermissionVersion = self.fromPermissionVersion {
            try encodeContainer.encode(fromPermissionVersion, forKey: .fromPermissionVersion)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let toPermissionArn = self.toPermissionArn {
            try encodeContainer.encode(toPermissionArn, forKey: .toPermissionArn)
        }
        if let toPermissionVersion = self.toPermissionVersion {
            try encodeContainer.encode(toPermissionVersion, forKey: .toPermissionVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let fromPermissionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fromPermissionArn)
        fromPermissionArn = fromPermissionArnDecoded
        let fromPermissionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fromPermissionVersion)
        fromPermissionVersion = fromPermissionVersionDecoded
        let toPermissionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .toPermissionArn)
        toPermissionArn = toPermissionArnDecoded
        let toPermissionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .toPermissionVersion)
        toPermissionVersion = toPermissionVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ReplacePermissionAssociationsWorkStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension RAMClientTypes {
    /// A structure that represents the background work that RAM performs when you invoke the [ReplacePermissionAssociations] operation.
    public struct ReplacePermissionAssociationsWork: Swift.Equatable {
        /// The date and time when this asynchronous background task was created.
        public var creationTime: ClientRuntime.Date?
        /// The [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the managed permission that this background task is replacing.
        public var fromPermissionArn: Swift.String?
        /// The version of the managed permission that this background task is replacing.
        public var fromPermissionVersion: Swift.String?
        /// The unique identifier for the background task associated with one [ReplacePermissionAssociations] request.
        public var id: Swift.String?
        /// The date and time when the status of this background task was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// Specifies the current status of the background tasks for the specified ID. The output is one of the following strings:
        ///
        /// * IN_PROGRESS
        ///
        /// * COMPLETED
        ///
        /// * FAILED
        public var status: RAMClientTypes.ReplacePermissionAssociationsWorkStatus?
        /// Specifies the reason for a FAILED status. This field is present only when there status is FAILED.
        public var statusMessage: Swift.String?
        /// The ARN of the managed permission that this background task is associating with the resource shares in place of the managed permission and version specified in fromPermissionArn and fromPermissionVersion.
        public var toPermissionArn: Swift.String?
        /// The version of the managed permission that this background task is associating with the resource shares. This is always the version that is currently the default for this managed permission.
        public var toPermissionVersion: Swift.String?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            fromPermissionArn: Swift.String? = nil,
            fromPermissionVersion: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            status: RAMClientTypes.ReplacePermissionAssociationsWorkStatus? = nil,
            statusMessage: Swift.String? = nil,
            toPermissionArn: Swift.String? = nil,
            toPermissionVersion: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.fromPermissionArn = fromPermissionArn
            self.fromPermissionVersion = fromPermissionVersion
            self.id = id
            self.lastUpdatedTime = lastUpdatedTime
            self.status = status
            self.statusMessage = statusMessage
            self.toPermissionArn = toPermissionArn
            self.toPermissionVersion = toPermissionVersion
        }
    }

}

extension RAMClientTypes {
    public enum ReplacePermissionAssociationsWorkStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplacePermissionAssociationsWorkStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplacePermissionAssociationsWorkStatus(rawValue: rawValue) ?? ReplacePermissionAssociationsWorkStatus.sdkUnknown(rawValue)
        }
    }
}

extension RAMClientTypes.Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case lastUpdatedTime
        case resourceGroupArn
        case resourceRegionScope
        case resourceShareArn
        case status
        case statusMessage
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let resourceGroupArn = self.resourceGroupArn {
            try encodeContainer.encode(resourceGroupArn, forKey: .resourceGroupArn)
        }
        if let resourceRegionScope = self.resourceRegionScope {
            try encodeContainer.encode(resourceRegionScope.rawValue, forKey: .resourceRegionScope)
        }
        if let resourceShareArn = self.resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let resourceGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupArn)
        resourceGroupArn = resourceGroupArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let resourceRegionScopeDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceRegionScope.self, forKey: .resourceRegionScope)
        resourceRegionScope = resourceRegionScopeDecoded
    }
}

extension RAMClientTypes {
    /// Describes a resource associated with a resource share in RAM.
    public struct Resource: Swift.Equatable {
        /// The [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource.
        public var arn: Swift.String?
        /// The date and time when the resource was associated with the resource share.
        public var creationTime: ClientRuntime.Date?
        /// The date an time when the association between the resource and the resource share was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource group. This value is available only if the resource is part of a resource group.
        public var resourceGroupArn: Swift.String?
        /// Specifies the scope of visibility of this resource:
        ///
        /// * REGIONAL – The resource can be accessed only by using requests that target the Amazon Web Services Region in which the resource exists.
        ///
        /// * GLOBAL – The resource can be accessed from any Amazon Web Services Region.
        public var resourceRegionScope: RAMClientTypes.ResourceRegionScope?
        /// The [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource share this resource is associated with.
        public var resourceShareArn: Swift.String?
        /// The current status of the resource.
        public var status: RAMClientTypes.ResourceStatus?
        /// A message about the status of the resource.
        public var statusMessage: Swift.String?
        /// The resource type. This takes the form of: service-code:resource-code, and is case-insensitive. For example, an Amazon EC2 Subnet would be represented by the string ec2:subnet.
        public var type: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            resourceGroupArn: Swift.String? = nil,
            resourceRegionScope: RAMClientTypes.ResourceRegionScope? = nil,
            resourceShareArn: Swift.String? = nil,
            status: RAMClientTypes.ResourceStatus? = nil,
            statusMessage: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.lastUpdatedTime = lastUpdatedTime
            self.resourceGroupArn = resourceGroupArn
            self.resourceRegionScope = resourceRegionScope
            self.resourceShareArn = resourceShareArn
            self.status = status
            self.statusMessage = statusMessage
            self.type = type
        }
    }

}

extension ResourceArnNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceArnNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation failed because the specified [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) was not found.
public struct ResourceArnNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResourceArn.NotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceArnNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceArnNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RAMClientTypes {
    public enum ResourceOwner: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case otherAccounts
        case `self`
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceOwner] {
            return [
                .otherAccounts,
                .self,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .otherAccounts: return "OTHER-ACCOUNTS"
            case .self: return "SELF"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceOwner(rawValue: rawValue) ?? ResourceOwner.sdkUnknown(rawValue)
        }
    }
}

extension RAMClientTypes {
    public enum ResourceRegionScope: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case global
        case regional
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceRegionScope] {
            return [
                .global,
                .regional,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .global: return "GLOBAL"
            case .regional: return "REGIONAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceRegionScope(rawValue: rawValue) ?? ResourceRegionScope.sdkUnknown(rawValue)
        }
    }
}

extension RAMClientTypes {
    public enum ResourceRegionScopeFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case global
        case regional
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceRegionScopeFilter] {
            return [
                .all,
                .global,
                .regional,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .global: return "GLOBAL"
            case .regional: return "REGIONAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceRegionScopeFilter(rawValue: rawValue) ?? ResourceRegionScopeFilter.sdkUnknown(rawValue)
        }
    }
}

extension RAMClientTypes.ResourceShare: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowExternalPrincipals
        case creationTime
        case featureSet
        case lastUpdatedTime
        case name
        case owningAccountId
        case resourceShareArn
        case status
        case statusMessage
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowExternalPrincipals = self.allowExternalPrincipals {
            try encodeContainer.encode(allowExternalPrincipals, forKey: .allowExternalPrincipals)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let featureSet = self.featureSet {
            try encodeContainer.encode(featureSet.rawValue, forKey: .featureSet)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owningAccountId = self.owningAccountId {
            try encodeContainer.encode(owningAccountId, forKey: .owningAccountId)
        }
        if let resourceShareArn = self.resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let owningAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owningAccountId)
        owningAccountId = owningAccountIdDecoded
        let allowExternalPrincipalsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowExternalPrincipals)
        allowExternalPrincipals = allowExternalPrincipalsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceShareStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([RAMClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RAMClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RAMClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let featureSetDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceShareFeatureSet.self, forKey: .featureSet)
        featureSet = featureSetDecoded
    }
}

extension RAMClientTypes {
    /// Describes a resource share in RAM.
    public struct ResourceShare: Swift.Equatable {
        /// Indicates whether principals outside your organization in Organizations can be associated with a resource share.
        ///
        /// * True – the resource share can be shared with any Amazon Web Services account.
        ///
        /// * False – the resource share can be shared with only accounts in the same organization as the account that owns the resource share.
        public var allowExternalPrincipals: Swift.Bool?
        /// The date and time when the resource share was created.
        public var creationTime: ClientRuntime.Date?
        /// Indicates what features are available for this resource share. This parameter can have one of the following values:
        ///
        /// * STANDARD – A resource share that supports all functionality. These resource shares are visible to all principals you share the resource share with. You can modify these resource shares in RAM using the console or APIs. This resource share might have been created by RAM, or it might have been CREATED_FROM_POLICY and then promoted.
        ///
        /// * CREATED_FROM_POLICY – The customer manually shared a resource by attaching a resource-based policy. That policy did not match any existing managed permissions, so RAM created this customer managed permission automatically on the customer's behalf based on the attached policy document. This type of resource share is visible only to the Amazon Web Services account that created it. You can't modify it in RAM unless you promote it. For more information, see [PromoteResourceShareCreatedFromPolicy].
        ///
        /// * PROMOTING_TO_STANDARD – This resource share was originally CREATED_FROM_POLICY, but the customer ran the [PromoteResourceShareCreatedFromPolicy] and that operation is still in progress. This value changes to STANDARD when complete.
        public var featureSet: RAMClientTypes.ResourceShareFeatureSet?
        /// The date and time when the resource share was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The name of the resource share.
        public var name: Swift.String?
        /// The ID of the Amazon Web Services account that owns the resource share.
        public var owningAccountId: Swift.String?
        /// The [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource share
        public var resourceShareArn: Swift.String?
        /// The current status of the resource share.
        public var status: RAMClientTypes.ResourceShareStatus?
        /// A message about the status of the resource share.
        public var statusMessage: Swift.String?
        /// The tag key and value pairs attached to the resource share.
        public var tags: [RAMClientTypes.Tag]?

        public init(
            allowExternalPrincipals: Swift.Bool? = nil,
            creationTime: ClientRuntime.Date? = nil,
            featureSet: RAMClientTypes.ResourceShareFeatureSet? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            owningAccountId: Swift.String? = nil,
            resourceShareArn: Swift.String? = nil,
            status: RAMClientTypes.ResourceShareStatus? = nil,
            statusMessage: Swift.String? = nil,
            tags: [RAMClientTypes.Tag]? = nil
        )
        {
            self.allowExternalPrincipals = allowExternalPrincipals
            self.creationTime = creationTime
            self.featureSet = featureSet
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.owningAccountId = owningAccountId
            self.resourceShareArn = resourceShareArn
            self.status = status
            self.statusMessage = statusMessage
            self.tags = tags
        }
    }

}

extension RAMClientTypes.ResourceShareAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedEntity
        case associationType
        case creationTime
        case external
        case lastUpdatedTime
        case resourceShareArn
        case resourceShareName
        case status
        case statusMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedEntity = self.associatedEntity {
            try encodeContainer.encode(associatedEntity, forKey: .associatedEntity)
        }
        if let associationType = self.associationType {
            try encodeContainer.encode(associationType.rawValue, forKey: .associationType)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let external = self.external {
            try encodeContainer.encode(external, forKey: .external)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let resourceShareArn = self.resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
        if let resourceShareName = self.resourceShareName {
            try encodeContainer.encode(resourceShareName, forKey: .resourceShareName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let resourceShareNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareName)
        resourceShareName = resourceShareNameDecoded
        let associatedEntityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedEntity)
        associatedEntity = associatedEntityDecoded
        let associationTypeDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceShareAssociationType.self, forKey: .associationType)
        associationType = associationTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceShareAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let externalDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .external)
        external = externalDecoded
    }
}

extension RAMClientTypes {
    /// Describes an association between a resource share and either a principal or a resource.
    public struct ResourceShareAssociation: Swift.Equatable {
        /// The associated entity. This can be either of the following:
        ///
        /// * For a resource association, this is the [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource.
        ///
        /// * For principal associations, this is one of the following:
        ///
        /// * The ID of an Amazon Web Services account
        ///
        /// * The [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of an organization in Organizations
        ///
        /// * The ARN of an organizational unit (OU) in Organizations
        ///
        /// * The ARN of an IAM role
        ///
        /// * The ARN of an IAM user
        public var associatedEntity: Swift.String?
        /// The type of entity included in this association.
        public var associationType: RAMClientTypes.ResourceShareAssociationType?
        /// The date and time when the association was created.
        public var creationTime: ClientRuntime.Date?
        /// Indicates whether the principal belongs to the same organization in Organizations as the Amazon Web Services account that owns the resource share.
        public var external: Swift.Bool?
        /// The date and time when the association was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource share.
        public var resourceShareArn: Swift.String?
        /// The name of the resource share.
        public var resourceShareName: Swift.String?
        /// The current status of the association.
        public var status: RAMClientTypes.ResourceShareAssociationStatus?
        /// A message about the status of the association.
        public var statusMessage: Swift.String?

        public init(
            associatedEntity: Swift.String? = nil,
            associationType: RAMClientTypes.ResourceShareAssociationType? = nil,
            creationTime: ClientRuntime.Date? = nil,
            external: Swift.Bool? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            resourceShareArn: Swift.String? = nil,
            resourceShareName: Swift.String? = nil,
            status: RAMClientTypes.ResourceShareAssociationStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.associatedEntity = associatedEntity
            self.associationType = associationType
            self.creationTime = creationTime
            self.external = external
            self.lastUpdatedTime = lastUpdatedTime
            self.resourceShareArn = resourceShareArn
            self.resourceShareName = resourceShareName
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension RAMClientTypes {
    public enum ResourceShareAssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case associated
        case associating
        case disassociated
        case disassociating
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceShareAssociationStatus] {
            return [
                .associated,
                .associating,
                .disassociated,
                .disassociating,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .associated: return "ASSOCIATED"
            case .associating: return "ASSOCIATING"
            case .disassociated: return "DISASSOCIATED"
            case .disassociating: return "DISASSOCIATING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceShareAssociationStatus(rawValue: rawValue) ?? ResourceShareAssociationStatus.sdkUnknown(rawValue)
        }
    }
}

extension RAMClientTypes {
    public enum ResourceShareAssociationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case principal
        case resource
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceShareAssociationType] {
            return [
                .principal,
                .resource,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .principal: return "PRINCIPAL"
            case .resource: return "RESOURCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceShareAssociationType(rawValue: rawValue) ?? ResourceShareAssociationType.sdkUnknown(rawValue)
        }
    }
}

extension RAMClientTypes {
    public enum ResourceShareFeatureSet: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createdFromPolicy
        case promotingToStandard
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceShareFeatureSet] {
            return [
                .createdFromPolicy,
                .promotingToStandard,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createdFromPolicy: return "CREATED_FROM_POLICY"
            case .promotingToStandard: return "PROMOTING_TO_STANDARD"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceShareFeatureSet(rawValue: rawValue) ?? ResourceShareFeatureSet.sdkUnknown(rawValue)
        }
    }
}

extension RAMClientTypes.ResourceShareInvitation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invitationTimestamp
        case receiverAccountId
        case receiverArn
        case resourceShareArn
        case resourceShareAssociations
        case resourceShareInvitationArn
        case resourceShareName
        case senderAccountId
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invitationTimestamp = self.invitationTimestamp {
            try encodeContainer.encodeTimestamp(invitationTimestamp, format: .epochSeconds, forKey: .invitationTimestamp)
        }
        if let receiverAccountId = self.receiverAccountId {
            try encodeContainer.encode(receiverAccountId, forKey: .receiverAccountId)
        }
        if let receiverArn = self.receiverArn {
            try encodeContainer.encode(receiverArn, forKey: .receiverArn)
        }
        if let resourceShareArn = self.resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
        if let resourceShareAssociations = resourceShareAssociations {
            var resourceShareAssociationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShareAssociations)
            for resourceshareassociation0 in resourceShareAssociations {
                try resourceShareAssociationsContainer.encode(resourceshareassociation0)
            }
        }
        if let resourceShareInvitationArn = self.resourceShareInvitationArn {
            try encodeContainer.encode(resourceShareInvitationArn, forKey: .resourceShareInvitationArn)
        }
        if let resourceShareName = self.resourceShareName {
            try encodeContainer.encode(resourceShareName, forKey: .resourceShareName)
        }
        if let senderAccountId = self.senderAccountId {
            try encodeContainer.encode(senderAccountId, forKey: .senderAccountId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareInvitationArn)
        resourceShareInvitationArn = resourceShareInvitationArnDecoded
        let resourceShareNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareName)
        resourceShareName = resourceShareNameDecoded
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let senderAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .senderAccountId)
        senderAccountId = senderAccountIdDecoded
        let receiverAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .receiverAccountId)
        receiverAccountId = receiverAccountIdDecoded
        let invitationTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .invitationTimestamp)
        invitationTimestamp = invitationTimestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceShareInvitationStatus.self, forKey: .status)
        status = statusDecoded
        let resourceShareAssociationsContainer = try containerValues.decodeIfPresent([RAMClientTypes.ResourceShareAssociation?].self, forKey: .resourceShareAssociations)
        var resourceShareAssociationsDecoded0:[RAMClientTypes.ResourceShareAssociation]? = nil
        if let resourceShareAssociationsContainer = resourceShareAssociationsContainer {
            resourceShareAssociationsDecoded0 = [RAMClientTypes.ResourceShareAssociation]()
            for structure0 in resourceShareAssociationsContainer {
                if let structure0 = structure0 {
                    resourceShareAssociationsDecoded0?.append(structure0)
                }
            }
        }
        resourceShareAssociations = resourceShareAssociationsDecoded0
        let receiverArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .receiverArn)
        receiverArn = receiverArnDecoded
    }
}

extension RAMClientTypes {
    /// Describes an invitation for an Amazon Web Services account to join a resource share.
    public struct ResourceShareInvitation: Swift.Equatable {
        /// The date and time when the invitation was sent.
        public var invitationTimestamp: ClientRuntime.Date?
        /// The ID of the Amazon Web Services account that received the invitation.
        public var receiverAccountId: Swift.String?
        /// The [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the IAM user or role that received the invitation.
        public var receiverArn: Swift.String?
        /// The [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource share
        public var resourceShareArn: Swift.String?
        /// To view the resources associated with a pending resource share invitation, use [ListPendingInvitationResources].
        @available(*, deprecated, message: "This member has been deprecated. Use ListPendingInvitationResources.")
        public var resourceShareAssociations: [RAMClientTypes.ResourceShareAssociation]?
        /// The [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the invitation.
        public var resourceShareInvitationArn: Swift.String?
        /// The name of the resource share.
        public var resourceShareName: Swift.String?
        /// The ID of the Amazon Web Services account that sent the invitation.
        public var senderAccountId: Swift.String?
        /// The current status of the invitation.
        public var status: RAMClientTypes.ResourceShareInvitationStatus?

        public init(
            invitationTimestamp: ClientRuntime.Date? = nil,
            receiverAccountId: Swift.String? = nil,
            receiverArn: Swift.String? = nil,
            resourceShareArn: Swift.String? = nil,
            resourceShareAssociations: [RAMClientTypes.ResourceShareAssociation]? = nil,
            resourceShareInvitationArn: Swift.String? = nil,
            resourceShareName: Swift.String? = nil,
            senderAccountId: Swift.String? = nil,
            status: RAMClientTypes.ResourceShareInvitationStatus? = nil
        )
        {
            self.invitationTimestamp = invitationTimestamp
            self.receiverAccountId = receiverAccountId
            self.receiverArn = receiverArn
            self.resourceShareArn = resourceShareArn
            self.resourceShareAssociations = resourceShareAssociations
            self.resourceShareInvitationArn = resourceShareInvitationArn
            self.resourceShareName = resourceShareName
            self.senderAccountId = senderAccountId
            self.status = status
        }
    }

}

extension ResourceShareInvitationAlreadyAcceptedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceShareInvitationAlreadyAcceptedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation failed because the specified invitation was already accepted.
public struct ResourceShareInvitationAlreadyAcceptedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResourceShareInvitationArn.AlreadyAccepted" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceShareInvitationAlreadyAcceptedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceShareInvitationAlreadyAcceptedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceShareInvitationAlreadyRejectedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceShareInvitationAlreadyRejectedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation failed because the specified invitation was already rejected.
public struct ResourceShareInvitationAlreadyRejectedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResourceShareInvitationArn.AlreadyRejected" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceShareInvitationAlreadyRejectedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceShareInvitationAlreadyRejectedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceShareInvitationArnNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceShareInvitationArnNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation failed because the specified [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) for an invitation was not found.
public struct ResourceShareInvitationArnNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResourceShareInvitationArn.NotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceShareInvitationArnNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceShareInvitationArnNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceShareInvitationExpiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceShareInvitationExpiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation failed because the specified invitation is past its expiration date and time.
public struct ResourceShareInvitationExpiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResourceShareInvitationArn.Expired" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceShareInvitationExpiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceShareInvitationExpiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RAMClientTypes {
    public enum ResourceShareInvitationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accepted
        case expired
        case pending
        case rejected
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceShareInvitationStatus] {
            return [
                .accepted,
                .expired,
                .pending,
                .rejected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accepted: return "ACCEPTED"
            case .expired: return "EXPIRED"
            case .pending: return "PENDING"
            case .rejected: return "REJECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceShareInvitationStatus(rawValue: rawValue) ?? ResourceShareInvitationStatus.sdkUnknown(rawValue)
        }
    }
}

extension ResourceShareLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceShareLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation failed because it would exceed the limit for resource shares for your account. To view the limits for your Amazon Web Services account, see the [RAM page in the Service Quotas console](https://console.aws.amazon.com/servicequotas/home/services/ram/quotas).
public struct ResourceShareLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceShareLimitExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceShareLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceShareLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RAMClientTypes.ResourceSharePermissionDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case defaultVersion
        case featureSet
        case isResourceTypeDefault
        case lastUpdatedTime
        case name
        case permission
        case permissionType
        case resourceType
        case status
        case tags
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let defaultVersion = self.defaultVersion {
            try encodeContainer.encode(defaultVersion, forKey: .defaultVersion)
        }
        if let featureSet = self.featureSet {
            try encodeContainer.encode(featureSet.rawValue, forKey: .featureSet)
        }
        if let isResourceTypeDefault = self.isResourceTypeDefault {
            try encodeContainer.encode(isResourceTypeDefault, forKey: .isResourceTypeDefault)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permission = self.permission {
            try encodeContainer.encode(permission, forKey: .permission)
        }
        if let permissionType = self.permissionType {
            try encodeContainer.encode(permissionType.rawValue, forKey: .permissionType)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let defaultVersionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .defaultVersion)
        defaultVersion = defaultVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let permissionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permission)
        permission = permissionDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let isResourceTypeDefaultDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isResourceTypeDefault)
        isResourceTypeDefault = isResourceTypeDefaultDecoded
        let permissionTypeDecoded = try containerValues.decodeIfPresent(RAMClientTypes.PermissionType.self, forKey: .permissionType)
        permissionType = permissionTypeDecoded
        let featureSetDecoded = try containerValues.decodeIfPresent(RAMClientTypes.PermissionFeatureSet.self, forKey: .featureSet)
        featureSet = featureSetDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RAMClientTypes.PermissionStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([RAMClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RAMClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RAMClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension RAMClientTypes {
    /// Information about a RAM managed permission.
    public struct ResourceSharePermissionDetail: Swift.Equatable {
        /// The [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of this RAM managed permission.
        public var arn: Swift.String?
        /// The date and time when the permission was created.
        public var creationTime: ClientRuntime.Date?
        /// Specifies whether the version of the permission represented in this response is the default version for this permission.
        public var defaultVersion: Swift.Bool?
        /// Indicates what features are available for this resource share. This parameter can have one of the following values:
        ///
        /// * STANDARD – A resource share that supports all functionality. These resource shares are visible to all principals you share the resource share with. You can modify these resource shares in RAM using the console or APIs. This resource share might have been created by RAM, or it might have been CREATED_FROM_POLICY and then promoted.
        ///
        /// * CREATED_FROM_POLICY – The customer manually shared a resource by attaching a resource-based policy. That policy did not match any existing managed permissions, so RAM created this customer managed permission automatically on the customer's behalf based on the attached policy document. This type of resource share is visible only to the Amazon Web Services account that created it. You can't modify it in RAM unless you promote it. For more information, see [PromoteResourceShareCreatedFromPolicy].
        ///
        /// * PROMOTING_TO_STANDARD – This resource share was originally CREATED_FROM_POLICY, but the customer ran the [PromoteResourceShareCreatedFromPolicy] and that operation is still in progress. This value changes to STANDARD when complete.
        public var featureSet: RAMClientTypes.PermissionFeatureSet?
        /// Specifies whether the version of the permission represented in this response is the default version for all resources of this resource type.
        public var isResourceTypeDefault: Swift.Bool?
        /// The date and time when the permission was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The name of this permission.
        public var name: Swift.String?
        /// The permission's effect and actions in JSON format. The effect indicates whether the specified actions are allowed or denied. The actions list the operations to which the principal is granted or denied access.
        public var permission: Swift.String?
        /// The type of managed permission. This can be one of the following values:
        ///
        /// * AWS_MANAGED – Amazon Web Services created and manages this managed permission. You can associate it with your resource shares, but you can't modify it.
        ///
        /// * CUSTOMER_MANAGED – You, or another principal in your account created this managed permission. You can associate it with your resource shares and create new versions that have different permissions.
        public var permissionType: RAMClientTypes.PermissionType?
        /// The resource type to which this permission applies.
        public var resourceType: Swift.String?
        /// The current status of the association between the permission and the resource share. The following are the possible values:
        ///
        /// * ATTACHABLE – This permission or version can be associated with resource shares.
        ///
        /// * UNATTACHABLE – This permission or version can't currently be associated with resource shares.
        ///
        /// * DELETING – This permission or version is in the process of being deleted.
        ///
        /// * DELETED – This permission or version is deleted.
        public var status: RAMClientTypes.PermissionStatus?
        /// The tag key and value pairs attached to the resource share.
        public var tags: [RAMClientTypes.Tag]?
        /// The version of the permission described in this response.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            defaultVersion: Swift.Bool? = nil,
            featureSet: RAMClientTypes.PermissionFeatureSet? = nil,
            isResourceTypeDefault: Swift.Bool? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            permission: Swift.String? = nil,
            permissionType: RAMClientTypes.PermissionType? = nil,
            resourceType: Swift.String? = nil,
            status: RAMClientTypes.PermissionStatus? = nil,
            tags: [RAMClientTypes.Tag]? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.defaultVersion = defaultVersion
            self.featureSet = featureSet
            self.isResourceTypeDefault = isResourceTypeDefault
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.permission = permission
            self.permissionType = permissionType
            self.resourceType = resourceType
            self.status = status
            self.tags = tags
            self.version = version
        }
    }

}

extension RAMClientTypes.ResourceSharePermissionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case defaultVersion
        case featureSet
        case isResourceTypeDefault
        case lastUpdatedTime
        case name
        case permissionType
        case resourceType
        case status
        case tags
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let defaultVersion = self.defaultVersion {
            try encodeContainer.encode(defaultVersion, forKey: .defaultVersion)
        }
        if let featureSet = self.featureSet {
            try encodeContainer.encode(featureSet.rawValue, forKey: .featureSet)
        }
        if let isResourceTypeDefault = self.isResourceTypeDefault {
            try encodeContainer.encode(isResourceTypeDefault, forKey: .isResourceTypeDefault)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permissionType = self.permissionType {
            try encodeContainer.encode(permissionType.rawValue, forKey: .permissionType)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let defaultVersionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .defaultVersion)
        defaultVersion = defaultVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let isResourceTypeDefaultDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isResourceTypeDefault)
        isResourceTypeDefault = isResourceTypeDefaultDecoded
        let permissionTypeDecoded = try containerValues.decodeIfPresent(RAMClientTypes.PermissionType.self, forKey: .permissionType)
        permissionType = permissionTypeDecoded
        let featureSetDecoded = try containerValues.decodeIfPresent(RAMClientTypes.PermissionFeatureSet.self, forKey: .featureSet)
        featureSet = featureSetDecoded
        let tagsContainer = try containerValues.decodeIfPresent([RAMClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RAMClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RAMClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension RAMClientTypes {
    /// Information about an RAM permission.
    public struct ResourceSharePermissionSummary: Swift.Equatable {
        /// The [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the permission you want information about.
        public var arn: Swift.String?
        /// The date and time when the permission was created.
        public var creationTime: ClientRuntime.Date?
        /// Specifies whether the version of the managed permission used by this resource share is the default version for this managed permission.
        public var defaultVersion: Swift.Bool?
        /// Indicates what features are available for this resource share. This parameter can have one of the following values:
        ///
        /// * STANDARD – A resource share that supports all functionality. These resource shares are visible to all principals you share the resource share with. You can modify these resource shares in RAM using the console or APIs. This resource share might have been created by RAM, or it might have been CREATED_FROM_POLICY and then promoted.
        ///
        /// * CREATED_FROM_POLICY – The customer manually shared a resource by attaching a resource-based policy. That policy did not match any existing managed permissions, so RAM created this customer managed permission automatically on the customer's behalf based on the attached policy document. This type of resource share is visible only to the Amazon Web Services account that created it. You can't modify it in RAM unless you promote it. For more information, see [PromoteResourceShareCreatedFromPolicy].
        ///
        /// * PROMOTING_TO_STANDARD – This resource share was originally CREATED_FROM_POLICY, but the customer ran the [PromoteResourceShareCreatedFromPolicy] and that operation is still in progress. This value changes to STANDARD when complete.
        public var featureSet: RAMClientTypes.PermissionFeatureSet?
        /// Specifies whether the managed permission associated with this resource share is the default managed permission for all resources of this resource type.
        public var isResourceTypeDefault: Swift.Bool?
        /// The date and time when the permission was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The name of this managed permission.
        public var name: Swift.String?
        /// The type of managed permission. This can be one of the following values:
        ///
        /// * AWS_MANAGED – Amazon Web Services created and manages this managed permission. You can associate it with your resource shares, but you can't modify it.
        ///
        /// * CUSTOMER_MANAGED – You, or another principal in your account created this managed permission. You can associate it with your resource shares and create new versions that have different permissions.
        public var permissionType: RAMClientTypes.PermissionType?
        /// The type of resource to which this permission applies. This takes the form of: service-code:resource-code, and is case-insensitive. For example, an Amazon EC2 Subnet would be represented by the string ec2:subnet.
        public var resourceType: Swift.String?
        /// The current status of the permission.
        public var status: Swift.String?
        /// A list of the tag key value pairs currently attached to the permission.
        public var tags: [RAMClientTypes.Tag]?
        /// The version of the permission associated with this resource share.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            defaultVersion: Swift.Bool? = nil,
            featureSet: RAMClientTypes.PermissionFeatureSet? = nil,
            isResourceTypeDefault: Swift.Bool? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            permissionType: RAMClientTypes.PermissionType? = nil,
            resourceType: Swift.String? = nil,
            status: Swift.String? = nil,
            tags: [RAMClientTypes.Tag]? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.defaultVersion = defaultVersion
            self.featureSet = featureSet
            self.isResourceTypeDefault = isResourceTypeDefault
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.permissionType = permissionType
            self.resourceType = resourceType
            self.status = status
            self.tags = tags
            self.version = version
        }
    }

}

extension RAMClientTypes {
    public enum ResourceShareStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleted
        case deleting
        case failed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceShareStatus] {
            return [
                .active,
                .deleted,
                .deleting,
                .failed,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceShareStatus(rawValue: rawValue) ?? ResourceShareStatus.sdkUnknown(rawValue)
        }
    }
}

extension RAMClientTypes {
    public enum ResourceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case limitExceeded
        case pending
        case unavailable
        case zonalResourceInaccessible
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceStatus] {
            return [
                .available,
                .limitExceeded,
                .pending,
                .unavailable,
                .zonalResourceInaccessible,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .limitExceeded: return "LIMIT_EXCEEDED"
            case .pending: return "PENDING"
            case .unavailable: return "UNAVAILABLE"
            case .zonalResourceInaccessible: return "ZONAL_RESOURCE_INACCESSIBLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceStatus(rawValue: rawValue) ?? ResourceStatus.sdkUnknown(rawValue)
        }
    }
}

extension ServerInternalException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServerInternalExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation failed because the service could not respond to the request due to an internal problem. Try again later.
public struct ServerInternalException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalError" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServerInternalExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServerInternalExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RAMClientTypes.ServiceNameAndResourceType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceRegionScope
        case resourceType
        case serviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceRegionScope = self.resourceRegionScope {
            try encodeContainer.encode(resourceRegionScope.rawValue, forKey: .resourceRegionScope)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let resourceRegionScopeDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceRegionScope.self, forKey: .resourceRegionScope)
        resourceRegionScope = resourceRegionScopeDecoded
    }
}

extension RAMClientTypes {
    /// Information about a shareable resource type and the Amazon Web Services service to which resources of that type belong.
    public struct ServiceNameAndResourceType: Swift.Equatable {
        /// Specifies the scope of visibility of resources of this type:
        ///
        /// * REGIONAL – The resource can be accessed only by using requests that target the Amazon Web Services Region in which the resource exists.
        ///
        /// * GLOBAL – The resource can be accessed from any Amazon Web Services Region.
        public var resourceRegionScope: RAMClientTypes.ResourceRegionScope?
        /// The type of the resource. This takes the form of: service-code:resource-code, and is case-insensitive. For example, an Amazon EC2 Subnet would be represented by the string ec2:subnet.
        public var resourceType: Swift.String?
        /// The name of the Amazon Web Services service to which resources of this type belong.
        public var serviceName: Swift.String?

        public init(
            resourceRegionScope: RAMClientTypes.ResourceRegionScope? = nil,
            resourceType: Swift.String? = nil,
            serviceName: Swift.String? = nil
        )
        {
            self.resourceRegionScope = resourceRegionScope
            self.resourceType = resourceType
            self.serviceName = serviceName
        }
    }

}

extension ServiceUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation failed because the service isn't available. Try again later.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "Unavailable" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SetDefaultPermissionVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case permissionArn
        case permissionVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let permissionArn = self.permissionArn {
            try encodeContainer.encode(permissionArn, forKey: .permissionArn)
        }
        if let permissionVersion = self.permissionVersion {
            try encodeContainer.encode(permissionVersion, forKey: .permissionVersion)
        }
    }
}

extension SetDefaultPermissionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/setdefaultpermissionversion"
    }
}

public struct SetDefaultPermissionVersionInput: Swift.Equatable {
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value.](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// Specifies the [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the customer managed permission whose default version you want to change.
    /// This member is required.
    public var permissionArn: Swift.String?
    /// Specifies the version number that you want to designate as the default for customer managed permission. To see a list of all available version numbers, use [ListPermissionVersions].
    /// This member is required.
    public var permissionVersion: Swift.Int?

    public init(
        clientToken: Swift.String? = nil,
        permissionArn: Swift.String? = nil,
        permissionVersion: Swift.Int? = nil
    )
    {
        self.clientToken = clientToken
        self.permissionArn = permissionArn
        self.permissionVersion = permissionVersion
    }
}

struct SetDefaultPermissionVersionInputBody: Swift.Equatable {
    let permissionArn: Swift.String?
    let permissionVersion: Swift.Int?
    let clientToken: Swift.String?
}

extension SetDefaultPermissionVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case permissionArn
        case permissionVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionArn)
        permissionArn = permissionArnDecoded
        let permissionVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .permissionVersion)
        permissionVersion = permissionVersionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public enum SetDefaultPermissionVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "IdempotentParameterMismatch": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidClientToken": return try await InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArn.Malformed": return try await MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "Unavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceShareArn.NotFound": return try await UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SetDefaultPermissionVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SetDefaultPermissionVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.returnValue = output.returnValue
        } else {
            self.clientToken = nil
            self.returnValue = nil
        }
    }
}

public struct SetDefaultPermissionVersionOutputResponse: Swift.Equatable {
    /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other parameters must also have the same values that you used in the first call.
    public var clientToken: Swift.String?
    /// A boolean value that indicates whether the operation was successful.
    public var returnValue: Swift.Bool?

    public init(
        clientToken: Swift.String? = nil,
        returnValue: Swift.Bool? = nil
    )
    {
        self.clientToken = clientToken
        self.returnValue = returnValue
    }
}

struct SetDefaultPermissionVersionOutputResponseBody: Swift.Equatable {
    let returnValue: Swift.Bool?
    let clientToken: Swift.String?
}

extension SetDefaultPermissionVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case returnValue
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnValue)
        returnValue = returnValueDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension RAMClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension RAMClientTypes {
    /// A structure containing a tag. A tag is metadata that you can attach to your resources to help organize and categorize them. You can also use them to help you secure your resources. For more information, see [Controlling access to Amazon Web Services resources using tags](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_tags.html). For more information about tags, see [Tagging Amazon Web Services resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) in the Amazon Web Services General Reference Guide.
    public struct Tag: Swift.Equatable {
        /// The key, or name, attached to the tag. Every tag must have a key. Key names are case sensitive.
        public var key: Swift.String?
        /// The string value attached to the tag. The value can be an empty string. Key values are case sensitive.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension RAMClientTypes.TagFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKey
        case tagValues
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKey = self.tagKey {
            try encodeContainer.encode(tagKey, forKey: .tagKey)
        }
        if let tagValues = tagValues {
            var tagValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagValues)
            for tagvalue0 in tagValues {
                try tagValuesContainer.encode(tagvalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
        let tagValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagValues)
        var tagValuesDecoded0:[Swift.String]? = nil
        if let tagValuesContainer = tagValuesContainer {
            tagValuesDecoded0 = [Swift.String]()
            for string0 in tagValuesContainer {
                if let string0 = string0 {
                    tagValuesDecoded0?.append(string0)
                }
            }
        }
        tagValues = tagValuesDecoded0
    }
}

extension RAMClientTypes {
    /// A tag key and optional list of possible values that you can use to filter results for tagged resources.
    public struct TagFilter: Swift.Equatable {
        /// The tag key. This must have a valid string value and can't be empty.
        public var tagKey: Swift.String?
        /// A list of zero or more tag values. If no values are provided, then the filter matches any tag with the specified key, regardless of its value.
        public var tagValues: [Swift.String]?

        public init(
            tagKey: Swift.String? = nil,
            tagValues: [Swift.String]? = nil
        )
        {
            self.tagKey = tagKey
            self.tagValues = tagValues
        }
    }

}

extension TagLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TagLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation failed because it would exceed the limit for tags for your Amazon Web Services account.
public struct TagLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TagLimitExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TagLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TagLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagPolicyViolationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TagPolicyViolationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation failed because the specified tag key is a reserved word and can't be used.
public struct TagPolicyViolationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TagPolicyViolation" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TagPolicyViolationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TagPolicyViolationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case resourceShareArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceShareArn = self.resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tagresource"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// Specifies the [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the managed permission that you want to add tags to. You must specify either resourceArn, or resourceShareArn, but not both.
    public var resourceArn: Swift.String?
    /// Specifies the [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource share that you want to add tags to. You must specify either resourceShareArn, or resourceArn, but not both.
    public var resourceShareArn: Swift.String?
    /// A list of one or more tag key and value pairs. The tag key must be present and not be an empty string. The tag value must be present but can be an empty string.
    /// This member is required.
    public var tags: [RAMClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        resourceShareArn: Swift.String? = nil,
        tags: [RAMClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.resourceShareArn = resourceShareArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceShareArn: Swift.String?
    let tags: [RAMClientTypes.Tag]?
    let resourceArn: Swift.String?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case resourceShareArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([RAMClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RAMClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RAMClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

public enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArn.Malformed": return try await MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceArn.NotFound": return try await ResourceArnNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "Unavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagLimitExceeded": return try await TagLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagPolicyViolation": return try await TagPolicyViolationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceShareArn.NotFound": return try await UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() { }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation failed because it exceeded the rate at which you are allowed to perform this operation. Please try again later.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnknownResourceException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnknownResourceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation failed because a specified resource couldn't be found.
public struct UnknownResourceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResourceShareArn.NotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnknownResourceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnknownResourceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnmatchedPolicyPermissionException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnmatchedPolicyPermissionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There isn't an existing managed permission defined in RAM that has the same IAM permissions as the resource-based policy attached to the resource. You should first run [PromotePermissionCreatedFromPolicy] to create that managed permission.
public struct UnmatchedPolicyPermissionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnmatchedPolicyPermissionException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnmatchedPolicyPermissionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnmatchedPolicyPermissionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case resourceShareArn
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceShareArn = self.resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/untagresource"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// Specifies the [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the managed permission that you want to remove tags from. You must specify either resourceArn, or resourceShareArn, but not both.
    public var resourceArn: Swift.String?
    /// Specifies the [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource share that you want to remove tags from. The tags are removed from the resource share, not the resources in the resource share. You must specify either resourceShareArn, or resourceArn, but not both.
    public var resourceShareArn: Swift.String?
    /// Specifies a list of one or more tag keys that you want to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        resourceShareArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.resourceShareArn = resourceShareArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceShareArn: Swift.String?
    let tagKeys: [Swift.String]?
    let resourceArn: Swift.String?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case resourceShareArn
        case tagKeys
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

public enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArn.Malformed": return try await MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "Unavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceShareArn.NotFound": return try await UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() { }
}

extension UpdateResourceShareInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowExternalPrincipals
        case clientToken
        case name
        case resourceShareArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowExternalPrincipals = self.allowExternalPrincipals {
            try encodeContainer.encode(allowExternalPrincipals, forKey: .allowExternalPrincipals)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceShareArn = self.resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
    }
}

extension UpdateResourceShareInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateresourceshare"
    }
}

public struct UpdateResourceShareInput: Swift.Equatable {
    /// Specifies whether principals outside your organization in Organizations can be associated with a resource share.
    public var allowExternalPrincipals: Swift.Bool?
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value.](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// If specified, the new name that you want to attach to the resource share.
    public var name: Swift.String?
    /// Specifies the [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource share that you want to modify.
    /// This member is required.
    public var resourceShareArn: Swift.String?

    public init(
        allowExternalPrincipals: Swift.Bool? = nil,
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        resourceShareArn: Swift.String? = nil
    )
    {
        self.allowExternalPrincipals = allowExternalPrincipals
        self.clientToken = clientToken
        self.name = name
        self.resourceShareArn = resourceShareArn
    }
}

struct UpdateResourceShareInputBody: Swift.Equatable {
    let resourceShareArn: Swift.String?
    let name: Swift.String?
    let allowExternalPrincipals: Swift.Bool?
    let clientToken: Swift.String?
}

extension UpdateResourceShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowExternalPrincipals
        case clientToken
        case name
        case resourceShareArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let allowExternalPrincipalsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowExternalPrincipals)
        allowExternalPrincipals = allowExternalPrincipalsDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public enum UpdateResourceShareOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "IdempotentParameterMismatch": return try await IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidClientToken": return try await InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArn.Malformed": return try await MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalError": return try await ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "Unavailable": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceShareArn.NotFound": return try await UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateResourceShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateResourceShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.resourceShare = output.resourceShare
        } else {
            self.clientToken = nil
            self.resourceShare = nil
        }
    }
}

public struct UpdateResourceShareOutputResponse: Swift.Equatable {
    /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other parameters must also have the same values that you used in the first call.
    public var clientToken: Swift.String?
    /// Information about the resource share.
    public var resourceShare: RAMClientTypes.ResourceShare?

    public init(
        clientToken: Swift.String? = nil,
        resourceShare: RAMClientTypes.ResourceShare? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShare = resourceShare
    }
}

struct UpdateResourceShareOutputResponseBody: Swift.Equatable {
    let resourceShare: RAMClientTypes.ResourceShare?
    let clientToken: Swift.String?
}

extension UpdateResourceShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShare
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceShare.self, forKey: .resourceShare)
        resourceShare = resourceShareDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}
