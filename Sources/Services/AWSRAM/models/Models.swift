// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AcceptResourceShareInvitationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShareInvitationArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let resourceShareInvitationArn = self.resourceShareInvitationArn {
            try encodeContainer.encode(resourceShareInvitationArn, forKey: .resourceShareInvitationArn)
        }
    }
}

extension AcceptResourceShareInvitationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/acceptresourceshareinvitation"
    }
}

public struct AcceptResourceShareInvitationInput: Swift.Equatable {
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value.](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you.
    public var clientToken: Swift.String?
    /// The [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the invitation that you want to accept.
    /// This member is required.
    public var resourceShareInvitationArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        resourceShareInvitationArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShareInvitationArn = resourceShareInvitationArn
    }
}

struct AcceptResourceShareInvitationInputBody: Swift.Equatable {
    let resourceShareInvitationArn: Swift.String?
    let clientToken: Swift.String?
}

extension AcceptResourceShareInvitationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShareInvitationArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareInvitationArn)
        resourceShareInvitationArn = resourceShareInvitationArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension AcceptResourceShareInvitationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptResourceShareInvitationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatch" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientToken" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareInvitationArn.AlreadyAccepted" : self = .resourceShareInvitationAlreadyAcceptedException(try ResourceShareInvitationAlreadyAcceptedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareInvitationArn.AlreadyRejected" : self = .resourceShareInvitationAlreadyRejectedException(try ResourceShareInvitationAlreadyRejectedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareInvitationArn.NotFound" : self = .resourceShareInvitationArnNotFoundException(try ResourceShareInvitationArnNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareInvitationArn.Expired" : self = .resourceShareInvitationExpiredException(try ResourceShareInvitationExpiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AcceptResourceShareInvitationOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidClientTokenException(InvalidClientTokenException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceShareInvitationAlreadyAcceptedException(ResourceShareInvitationAlreadyAcceptedException)
    case resourceShareInvitationAlreadyRejectedException(ResourceShareInvitationAlreadyRejectedException)
    case resourceShareInvitationArnNotFoundException(ResourceShareInvitationArnNotFoundException)
    case resourceShareInvitationExpiredException(ResourceShareInvitationExpiredException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptResourceShareInvitationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AcceptResourceShareInvitationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.resourceShareInvitation = output.resourceShareInvitation
        } else {
            self.clientToken = nil
            self.resourceShareInvitation = nil
        }
    }
}

public struct AcceptResourceShareInvitationOutputResponse: Swift.Equatable {
    /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other parameters must also have the same values that you used in the first call.
    public var clientToken: Swift.String?
    /// An object that contains information about the specified invitation.
    public var resourceShareInvitation: RAMClientTypes.ResourceShareInvitation?

    public init (
        clientToken: Swift.String? = nil,
        resourceShareInvitation: RAMClientTypes.ResourceShareInvitation? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShareInvitation = resourceShareInvitation
    }
}

struct AcceptResourceShareInvitationOutputResponseBody: Swift.Equatable {
    let resourceShareInvitation: RAMClientTypes.ResourceShareInvitation?
    let clientToken: Swift.String?
}

extension AcceptResourceShareInvitationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShareInvitation
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceShareInvitation.self, forKey: .resourceShareInvitation)
        resourceShareInvitation = resourceShareInvitationDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension AssociateResourceShareInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case principals
        case resourceArns
        case resourceShareArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for string0 in principals {
                try principalsContainer.encode(string0)
            }
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for string0 in resourceArns {
                try resourceArnsContainer.encode(string0)
            }
        }
        if let resourceShareArn = self.resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
    }
}

extension AssociateResourceShareInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/associateresourceshare"
    }
}

public struct AssociateResourceShareInput: Swift.Equatable {
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value.](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you.
    public var clientToken: Swift.String?
    /// Specifies a list of principals to whom you want to the resource share. This can be null if you want to add only resources. What the principals can do with the resources in the share is determined by the RAM permissions that you associate with the resource share. See [AssociateResourceSharePermission]. You can include the following values:
    ///
    /// * An Amazon Web Services account ID, for example: 123456789012
    ///
    /// * An [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of an organization in Organizations, for example: organizations::123456789012:organization/o-exampleorgid
    ///
    /// * An ARN of an organizational unit (OU) in Organizations, for example: organizations::123456789012:ou/o-exampleorgid/ou-examplerootid-exampleouid123
    ///
    /// * An ARN of an IAM role, for example: iam::123456789012:role/rolename
    ///
    /// * An ARN of an IAM user, for example: iam::123456789012user/username
    ///
    ///
    /// Not all resource types can be shared with IAM roles and users. For more information, see [Sharing with IAM roles and users](https://docs.aws.amazon.com/ram/latest/userguide/permissions.html#permissions-rbp-supported-resource-types) in the Resource Access Manager User Guide.
    public var principals: [Swift.String]?
    /// Specifies a list of [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resources that you want to share. This can be null if you want to add only principals.
    public var resourceArns: [Swift.String]?
    /// Specifies the [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource share that you want to add principals or resources to.
    /// This member is required.
    public var resourceShareArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        principals: [Swift.String]? = nil,
        resourceArns: [Swift.String]? = nil,
        resourceShareArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.principals = principals
        self.resourceArns = resourceArns
        self.resourceShareArn = resourceShareArn
    }
}

struct AssociateResourceShareInputBody: Swift.Equatable {
    let resourceShareArn: Swift.String?
    let resourceArns: [Swift.String]?
    let principals: [Swift.String]?
    let clientToken: Swift.String?
}

extension AssociateResourceShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case principals
        case resourceArns
        case resourceShareArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let principalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .principals)
        var principalsDecoded0:[Swift.String]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [Swift.String]()
            for string0 in principalsContainer {
                if let string0 = string0 {
                    principalsDecoded0?.append(string0)
                }
            }
        }
        principals = principalsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension AssociateResourceShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateResourceShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatch" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientToken" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateTransitionException.Unknown" : self = .invalidStateTransitionException(try InvalidStateTransitionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareLimitExceeded" : self = .resourceShareLimitExceededException(try ResourceShareLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareArn.NotFound" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateResourceShareOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidClientTokenException(InvalidClientTokenException)
    case invalidParameterException(InvalidParameterException)
    case invalidStateTransitionException(InvalidStateTransitionException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceShareLimitExceededException(ResourceShareLimitExceededException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateResourceShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssociateResourceShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.resourceShareAssociations = output.resourceShareAssociations
        } else {
            self.clientToken = nil
            self.resourceShareAssociations = nil
        }
    }
}

public struct AssociateResourceShareOutputResponse: Swift.Equatable {
    /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other parameters must also have the same values that you used in the first call.
    public var clientToken: Swift.String?
    /// An array of objects that contain information about the associations.
    public var resourceShareAssociations: [RAMClientTypes.ResourceShareAssociation]?

    public init (
        clientToken: Swift.String? = nil,
        resourceShareAssociations: [RAMClientTypes.ResourceShareAssociation]? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShareAssociations = resourceShareAssociations
    }
}

struct AssociateResourceShareOutputResponseBody: Swift.Equatable {
    let resourceShareAssociations: [RAMClientTypes.ResourceShareAssociation]?
    let clientToken: Swift.String?
}

extension AssociateResourceShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShareAssociations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareAssociationsContainer = try containerValues.decodeIfPresent([RAMClientTypes.ResourceShareAssociation?].self, forKey: .resourceShareAssociations)
        var resourceShareAssociationsDecoded0:[RAMClientTypes.ResourceShareAssociation]? = nil
        if let resourceShareAssociationsContainer = resourceShareAssociationsContainer {
            resourceShareAssociationsDecoded0 = [RAMClientTypes.ResourceShareAssociation]()
            for structure0 in resourceShareAssociationsContainer {
                if let structure0 = structure0 {
                    resourceShareAssociationsDecoded0?.append(structure0)
                }
            }
        }
        resourceShareAssociations = resourceShareAssociationsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension AssociateResourceSharePermissionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case permissionArn
        case permissionVersion
        case replace
        case resourceShareArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let permissionArn = self.permissionArn {
            try encodeContainer.encode(permissionArn, forKey: .permissionArn)
        }
        if let permissionVersion = self.permissionVersion {
            try encodeContainer.encode(permissionVersion, forKey: .permissionVersion)
        }
        if let replace = self.replace {
            try encodeContainer.encode(replace, forKey: .replace)
        }
        if let resourceShareArn = self.resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
    }
}

extension AssociateResourceSharePermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/associateresourcesharepermission"
    }
}

public struct AssociateResourceSharePermissionInput: Swift.Equatable {
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value.](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you.
    public var clientToken: Swift.String?
    /// Specifies the [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the RAM permission to associate with the resource share. To find the ARN for a permission, use either the [ListPermissions] operation or go to the [Permissions library](https://console.aws.amazon.com/ram/home#Permissions:) page in the RAM console and then choose the name of the permission. The ARN is displayed on the detail page.
    /// This member is required.
    public var permissionArn: Swift.String?
    /// Specifies the version of the RAM permission to associate with the resource share. If you don't specify this parameter, the operation uses the version designated as the default. You can use the [ListPermissionVersions] operation to discover the available versions of a permission.
    public var permissionVersion: Swift.Int?
    /// Specifies whether the specified permission should replace or add to the existing permission associated with the resource share. Use true to replace the current permissions. Use false to add the permission to the current permission. The default value is false. A resource share can have only one permission per resource type. If a resource share already has a permission for the specified resource type and you don't set replace to true then the operation returns an error. This helps prevent accidental overwriting of a permission.
    public var replace: Swift.Bool?
    /// Specifies the [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource share to which you want to add or replace permissions.
    /// This member is required.
    public var resourceShareArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        permissionArn: Swift.String? = nil,
        permissionVersion: Swift.Int? = nil,
        replace: Swift.Bool? = nil,
        resourceShareArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.permissionArn = permissionArn
        self.permissionVersion = permissionVersion
        self.replace = replace
        self.resourceShareArn = resourceShareArn
    }
}

struct AssociateResourceSharePermissionInputBody: Swift.Equatable {
    let resourceShareArn: Swift.String?
    let permissionArn: Swift.String?
    let replace: Swift.Bool?
    let clientToken: Swift.String?
    let permissionVersion: Swift.Int?
}

extension AssociateResourceSharePermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case permissionArn
        case permissionVersion
        case replace
        case resourceShareArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let permissionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionArn)
        permissionArn = permissionArnDecoded
        let replaceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .replace)
        replace = replaceDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let permissionVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .permissionVersion)
        permissionVersion = permissionVersionDecoded
    }
}

extension AssociateResourceSharePermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateResourceSharePermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidClientToken" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareArn.NotFound" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateResourceSharePermissionOutputError: Swift.Error, Swift.Equatable {
    case invalidClientTokenException(InvalidClientTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateResourceSharePermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssociateResourceSharePermissionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.returnValue = output.returnValue
        } else {
            self.clientToken = nil
            self.returnValue = nil
        }
    }
}

public struct AssociateResourceSharePermissionOutputResponse: Swift.Equatable {
    /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other parameters must also have the same values that you used in the first call.
    public var clientToken: Swift.String?
    /// A return value of true indicates that the request succeeded. A value of false indicates that the request failed.
    public var returnValue: Swift.Bool?

    public init (
        clientToken: Swift.String? = nil,
        returnValue: Swift.Bool? = nil
    )
    {
        self.clientToken = clientToken
        self.returnValue = returnValue
    }
}

struct AssociateResourceSharePermissionOutputResponseBody: Swift.Equatable {
    let returnValue: Swift.Bool?
    let clientToken: Swift.String?
}

extension AssociateResourceSharePermissionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case returnValue
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnValue)
        returnValue = returnValueDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateResourceShareInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowExternalPrincipals
        case clientToken
        case name
        case permissionArns
        case principals
        case resourceArns
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowExternalPrincipals = self.allowExternalPrincipals {
            try encodeContainer.encode(allowExternalPrincipals, forKey: .allowExternalPrincipals)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permissionArns = permissionArns {
            var permissionArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissionArns)
            for string0 in permissionArns {
                try permissionArnsContainer.encode(string0)
            }
        }
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for string0 in principals {
                try principalsContainer.encode(string0)
            }
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for string0 in resourceArns {
                try resourceArnsContainer.encode(string0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateResourceShareInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createresourceshare"
    }
}

public struct CreateResourceShareInput: Swift.Equatable {
    /// Specifies whether principals outside your organization in Organizations can be associated with a resource share. A value of true lets you share with individual Amazon Web Services accounts that are not in your organization. A value of false only has meaning if your account is a member of an Amazon Web Services Organization. The default value is true.
    public var allowExternalPrincipals: Swift.Bool?
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value.](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you.
    public var clientToken: Swift.String?
    /// Specifies the name of the resource share.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the RAM permission to associate with the resource share. If you do not specify an ARN for the permission, RAM automatically attaches the default version of the permission for each resource type. You can associate only one permission with each resource type included in the resource share.
    public var permissionArns: [Swift.String]?
    /// Specifies a list of one or more principals to associate with the resource share. You can include the following values:
    ///
    /// * An Amazon Web Services account ID, for example: 123456789012
    ///
    /// * An [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of an organization in Organizations, for example: organizations::123456789012:organization/o-exampleorgid
    ///
    /// * An ARN of an organizational unit (OU) in Organizations, for example: organizations::123456789012:ou/o-exampleorgid/ou-examplerootid-exampleouid123
    ///
    /// * An ARN of an IAM role, for example: iam::123456789012:role/rolename
    ///
    /// * An ARN of an IAM user, for example: iam::123456789012user/username
    ///
    ///
    /// Not all resource types can be shared with IAM roles and users. For more information, see [Sharing with IAM roles and users](https://docs.aws.amazon.com/ram/latest/userguide/permissions.html#permissions-rbp-supported-resource-types) in the Resource Access Manager User Guide.
    public var principals: [Swift.String]?
    /// Specifies a list of one or more ARNs of the resources to associate with the resource share.
    public var resourceArns: [Swift.String]?
    /// Specifies one or more tags to attach to the resource share itself. It doesn't attach the tags to the resources associated with the resource share.
    public var tags: [RAMClientTypes.Tag]?

    public init (
        allowExternalPrincipals: Swift.Bool? = nil,
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        permissionArns: [Swift.String]? = nil,
        principals: [Swift.String]? = nil,
        resourceArns: [Swift.String]? = nil,
        tags: [RAMClientTypes.Tag]? = nil
    )
    {
        self.allowExternalPrincipals = allowExternalPrincipals
        self.clientToken = clientToken
        self.name = name
        self.permissionArns = permissionArns
        self.principals = principals
        self.resourceArns = resourceArns
        self.tags = tags
    }
}

struct CreateResourceShareInputBody: Swift.Equatable {
    let name: Swift.String?
    let resourceArns: [Swift.String]?
    let principals: [Swift.String]?
    let tags: [RAMClientTypes.Tag]?
    let allowExternalPrincipals: Swift.Bool?
    let clientToken: Swift.String?
    let permissionArns: [Swift.String]?
}

extension CreateResourceShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowExternalPrincipals
        case clientToken
        case name
        case permissionArns
        case principals
        case resourceArns
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let principalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .principals)
        var principalsDecoded0:[Swift.String]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [Swift.String]()
            for string0 in principalsContainer {
                if let string0 = string0 {
                    principalsDecoded0?.append(string0)
                }
            }
        }
        principals = principalsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([RAMClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RAMClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RAMClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let allowExternalPrincipalsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowExternalPrincipals)
        allowExternalPrincipals = allowExternalPrincipalsDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let permissionArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .permissionArns)
        var permissionArnsDecoded0:[Swift.String]? = nil
        if let permissionArnsContainer = permissionArnsContainer {
            permissionArnsDecoded0 = [Swift.String]()
            for string0 in permissionArnsContainer {
                if let string0 = string0 {
                    permissionArnsDecoded0?.append(string0)
                }
            }
        }
        permissionArns = permissionArnsDecoded0
    }
}

extension CreateResourceShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResourceShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatch" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientToken" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateTransitionException.Unknown" : self = .invalidStateTransitionException(try InvalidStateTransitionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareLimitExceeded" : self = .resourceShareLimitExceededException(try ResourceShareLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagPolicyViolation" : self = .tagPolicyViolationException(try TagPolicyViolationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareArn.NotFound" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateResourceShareOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidClientTokenException(InvalidClientTokenException)
    case invalidParameterException(InvalidParameterException)
    case invalidStateTransitionException(InvalidStateTransitionException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceShareLimitExceededException(ResourceShareLimitExceededException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tagPolicyViolationException(TagPolicyViolationException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResourceShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateResourceShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.resourceShare = output.resourceShare
        } else {
            self.clientToken = nil
            self.resourceShare = nil
        }
    }
}

public struct CreateResourceShareOutputResponse: Swift.Equatable {
    /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other parameters must also have the same values that you used in the first call.
    public var clientToken: Swift.String?
    /// An object with information about the new resource share.
    public var resourceShare: RAMClientTypes.ResourceShare?

    public init (
        clientToken: Swift.String? = nil,
        resourceShare: RAMClientTypes.ResourceShare? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShare = resourceShare
    }
}

struct CreateResourceShareOutputResponseBody: Swift.Equatable {
    let resourceShare: RAMClientTypes.ResourceShare?
    let clientToken: Swift.String?
}

extension CreateResourceShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShare
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceShare.self, forKey: .resourceShare)
        resourceShare = resourceShareDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeleteResourceShareInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceShareArn = resourceShareArn else {
                let message = "Creating a URL Query Item failed. resourceShareArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let resourceShareArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceShareArn".urlPercentEncoding(), value: Swift.String(resourceShareArn).urlPercentEncoding())
            items.append(resourceShareArnQueryItem)
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension DeleteResourceShareInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteresourceshare"
    }
}

public struct DeleteResourceShareInput: Swift.Equatable {
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value.](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you.
    public var clientToken: Swift.String?
    /// Specifies the [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource share to delete.
    /// This member is required.
    public var resourceShareArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        resourceShareArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShareArn = resourceShareArn
    }
}

struct DeleteResourceShareInputBody: Swift.Equatable {
}

extension DeleteResourceShareInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteResourceShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourceShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatch" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientToken" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateTransitionException.Unknown" : self = .invalidStateTransitionException(try InvalidStateTransitionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareArn.NotFound" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteResourceShareOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidClientTokenException(InvalidClientTokenException)
    case invalidParameterException(InvalidParameterException)
    case invalidStateTransitionException(InvalidStateTransitionException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourceShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteResourceShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.returnValue = output.returnValue
        } else {
            self.clientToken = nil
            self.returnValue = nil
        }
    }
}

public struct DeleteResourceShareOutputResponse: Swift.Equatable {
    /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other parameters must also have the same values that you used in the first call.
    public var clientToken: Swift.String?
    /// A return value of true indicates that the request succeeded. A value of false indicates that the request failed.
    public var returnValue: Swift.Bool?

    public init (
        clientToken: Swift.String? = nil,
        returnValue: Swift.Bool? = nil
    )
    {
        self.clientToken = clientToken
        self.returnValue = returnValue
    }
}

struct DeleteResourceShareOutputResponseBody: Swift.Equatable {
    let returnValue: Swift.Bool?
    let clientToken: Swift.String?
}

extension DeleteResourceShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case returnValue
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnValue)
        returnValue = returnValueDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DisassociateResourceShareInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case principals
        case resourceArns
        case resourceShareArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for string0 in principals {
                try principalsContainer.encode(string0)
            }
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for string0 in resourceArns {
                try resourceArnsContainer.encode(string0)
            }
        }
        if let resourceShareArn = self.resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
    }
}

extension DisassociateResourceShareInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/disassociateresourceshare"
    }
}

public struct DisassociateResourceShareInput: Swift.Equatable {
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value.](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you.
    public var clientToken: Swift.String?
    /// Specifies a list of one or more principals that no longer are to have access to the resources in this resource share. You can include the following values:
    ///
    /// * An Amazon Web Services account ID, for example: 123456789012
    ///
    /// * An [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of an organization in Organizations, for example: organizations::123456789012:organization/o-exampleorgid
    ///
    /// * An ARN of an organizational unit (OU) in Organizations, for example: organizations::123456789012:ou/o-exampleorgid/ou-examplerootid-exampleouid123
    ///
    /// * An ARN of an IAM role, for example: iam::123456789012:role/rolename
    ///
    /// * An ARN of an IAM user, for example: iam::123456789012user/username
    ///
    ///
    /// Not all resource types can be shared with IAM roles and users. For more information, see [Sharing with IAM roles and users](https://docs.aws.amazon.com/ram/latest/userguide/permissions.html#permissions-rbp-supported-resource-types) in the Resource Access Manager User Guide.
    public var principals: [Swift.String]?
    /// Specifies a list of [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) for one or more resources that you want to remove from the resource share. After the operation runs, these resources are no longer shared with principals outside of the Amazon Web Services account that created the resources.
    public var resourceArns: [Swift.String]?
    /// Specifies [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource share that you want to remove resources from.
    /// This member is required.
    public var resourceShareArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        principals: [Swift.String]? = nil,
        resourceArns: [Swift.String]? = nil,
        resourceShareArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.principals = principals
        self.resourceArns = resourceArns
        self.resourceShareArn = resourceShareArn
    }
}

struct DisassociateResourceShareInputBody: Swift.Equatable {
    let resourceShareArn: Swift.String?
    let resourceArns: [Swift.String]?
    let principals: [Swift.String]?
    let clientToken: Swift.String?
}

extension DisassociateResourceShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case principals
        case resourceArns
        case resourceShareArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let principalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .principals)
        var principalsDecoded0:[Swift.String]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [Swift.String]()
            for string0 in principalsContainer {
                if let string0 = string0 {
                    principalsDecoded0?.append(string0)
                }
            }
        }
        principals = principalsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DisassociateResourceShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateResourceShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatch" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientToken" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateTransitionException.Unknown" : self = .invalidStateTransitionException(try InvalidStateTransitionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareLimitExceeded" : self = .resourceShareLimitExceededException(try ResourceShareLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareArn.NotFound" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateResourceShareOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidClientTokenException(InvalidClientTokenException)
    case invalidParameterException(InvalidParameterException)
    case invalidStateTransitionException(InvalidStateTransitionException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceShareLimitExceededException(ResourceShareLimitExceededException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateResourceShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DisassociateResourceShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.resourceShareAssociations = output.resourceShareAssociations
        } else {
            self.clientToken = nil
            self.resourceShareAssociations = nil
        }
    }
}

public struct DisassociateResourceShareOutputResponse: Swift.Equatable {
    /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other parameters must also have the same values that you used in the first call.
    public var clientToken: Swift.String?
    /// An array of objects that contain information about the updated associations for this resource share.
    public var resourceShareAssociations: [RAMClientTypes.ResourceShareAssociation]?

    public init (
        clientToken: Swift.String? = nil,
        resourceShareAssociations: [RAMClientTypes.ResourceShareAssociation]? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShareAssociations = resourceShareAssociations
    }
}

struct DisassociateResourceShareOutputResponseBody: Swift.Equatable {
    let resourceShareAssociations: [RAMClientTypes.ResourceShareAssociation]?
    let clientToken: Swift.String?
}

extension DisassociateResourceShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShareAssociations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareAssociationsContainer = try containerValues.decodeIfPresent([RAMClientTypes.ResourceShareAssociation?].self, forKey: .resourceShareAssociations)
        var resourceShareAssociationsDecoded0:[RAMClientTypes.ResourceShareAssociation]? = nil
        if let resourceShareAssociationsContainer = resourceShareAssociationsContainer {
            resourceShareAssociationsDecoded0 = [RAMClientTypes.ResourceShareAssociation]()
            for structure0 in resourceShareAssociationsContainer {
                if let structure0 = structure0 {
                    resourceShareAssociationsDecoded0?.append(structure0)
                }
            }
        }
        resourceShareAssociations = resourceShareAssociationsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DisassociateResourceSharePermissionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case permissionArn
        case resourceShareArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let permissionArn = self.permissionArn {
            try encodeContainer.encode(permissionArn, forKey: .permissionArn)
        }
        if let resourceShareArn = self.resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
    }
}

extension DisassociateResourceSharePermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/disassociateresourcesharepermission"
    }
}

public struct DisassociateResourceSharePermissionInput: Swift.Equatable {
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value.](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you.
    public var clientToken: Swift.String?
    /// The [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the permission to disassociate from the resource share. Changes to permissions take effect immediately.
    /// This member is required.
    public var permissionArn: Swift.String?
    /// The [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource share from which you want to disassociate a permission.
    /// This member is required.
    public var resourceShareArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        permissionArn: Swift.String? = nil,
        resourceShareArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.permissionArn = permissionArn
        self.resourceShareArn = resourceShareArn
    }
}

struct DisassociateResourceSharePermissionInputBody: Swift.Equatable {
    let resourceShareArn: Swift.String?
    let permissionArn: Swift.String?
    let clientToken: Swift.String?
}

extension DisassociateResourceSharePermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case permissionArn
        case resourceShareArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let permissionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionArn)
        permissionArn = permissionArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DisassociateResourceSharePermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateResourceSharePermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidClientToken" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateTransitionException.Unknown" : self = .invalidStateTransitionException(try InvalidStateTransitionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareArn.NotFound" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateResourceSharePermissionOutputError: Swift.Error, Swift.Equatable {
    case invalidClientTokenException(InvalidClientTokenException)
    case invalidParameterException(InvalidParameterException)
    case invalidStateTransitionException(InvalidStateTransitionException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateResourceSharePermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DisassociateResourceSharePermissionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.returnValue = output.returnValue
        } else {
            self.clientToken = nil
            self.returnValue = nil
        }
    }
}

public struct DisassociateResourceSharePermissionOutputResponse: Swift.Equatable {
    /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other parameters must also have the same values that you used in the first call.
    public var clientToken: Swift.String?
    /// A return value of true indicates that the request succeeded. A value of false indicates that the request failed.
    public var returnValue: Swift.Bool?

    public init (
        clientToken: Swift.String? = nil,
        returnValue: Swift.Bool? = nil
    )
    {
        self.clientToken = clientToken
        self.returnValue = returnValue
    }
}

struct DisassociateResourceSharePermissionOutputResponseBody: Swift.Equatable {
    let returnValue: Swift.Bool?
    let clientToken: Swift.String?
}

extension DisassociateResourceSharePermissionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case returnValue
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnValue)
        returnValue = returnValueDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension EnableSharingWithAwsOrganizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/enablesharingwithawsorganization"
    }
}

public struct EnableSharingWithAwsOrganizationInput: Swift.Equatable {

    public init () { }
}

struct EnableSharingWithAwsOrganizationInputBody: Swift.Equatable {
}

extension EnableSharingWithAwsOrganizationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension EnableSharingWithAwsOrganizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableSharingWithAwsOrganizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum EnableSharingWithAwsOrganizationOutputError: Swift.Error, Swift.Equatable {
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableSharingWithAwsOrganizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: EnableSharingWithAwsOrganizationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.returnValue = output.returnValue
        } else {
            self.returnValue = nil
        }
    }
}

public struct EnableSharingWithAwsOrganizationOutputResponse: Swift.Equatable {
    /// A return value of true indicates that the request succeeded. A value of false indicates that the request failed.
    public var returnValue: Swift.Bool?

    public init (
        returnValue: Swift.Bool? = nil
    )
    {
        self.returnValue = returnValue
    }
}

struct EnableSharingWithAwsOrganizationOutputResponseBody: Swift.Equatable {
    let returnValue: Swift.Bool?
}

extension EnableSharingWithAwsOrganizationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case returnValue
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnValue)
        returnValue = returnValueDecoded
    }
}

extension GetPermissionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionArn
        case permissionVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let permissionArn = self.permissionArn {
            try encodeContainer.encode(permissionArn, forKey: .permissionArn)
        }
        if let permissionVersion = self.permissionVersion {
            try encodeContainer.encode(permissionVersion, forKey: .permissionVersion)
        }
    }
}

extension GetPermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/getpermission"
    }
}

public struct GetPermissionInput: Swift.Equatable {
    /// Specifies the [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the permission whose contents you want to retrieve. To find the ARN for a permission, use either the [ListPermissions] operation or go to the [Permissions library](https://console.aws.amazon.com/ram/home#Permissions:) page in the RAM console and then choose the name of the permission. The ARN is displayed on the detail page.
    /// This member is required.
    public var permissionArn: Swift.String?
    /// Specifies identifier for the version of the RAM permission to retrieve. If you don't specify this parameter, the operation retrieves the default version.
    public var permissionVersion: Swift.Int?

    public init (
        permissionArn: Swift.String? = nil,
        permissionVersion: Swift.Int? = nil
    )
    {
        self.permissionArn = permissionArn
        self.permissionVersion = permissionVersion
    }
}

struct GetPermissionInputBody: Swift.Equatable {
    let permissionArn: Swift.String?
    let permissionVersion: Swift.Int?
}

extension GetPermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionArn
        case permissionVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionArn)
        permissionArn = permissionArnDecoded
        let permissionVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .permissionVersion)
        permissionVersion = permissionVersionDecoded
    }
}

extension GetPermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareArn.NotFound" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetPermissionOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetPermissionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.permission = output.permission
        } else {
            self.permission = nil
        }
    }
}

public struct GetPermissionOutputResponse: Swift.Equatable {
    /// An object that contains information about the permission.
    public var permission: RAMClientTypes.ResourceSharePermissionDetail?

    public init (
        permission: RAMClientTypes.ResourceSharePermissionDetail? = nil
    )
    {
        self.permission = permission
    }
}

struct GetPermissionOutputResponseBody: Swift.Equatable {
    let permission: RAMClientTypes.ResourceSharePermissionDetail?
}

extension GetPermissionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permission
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceSharePermissionDetail.self, forKey: .permission)
        permission = permissionDecoded
    }
}

extension GetResourcePoliciesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case principal
        case resourceArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let principal = self.principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for string0 in resourceArns {
                try resourceArnsContainer.encode(string0)
            }
        }
    }
}

extension GetResourcePoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/getresourcepolicies"
    }
}

public struct GetResourcePoliciesInput: Swift.Equatable {
    /// Specifies the total number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value that is specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next part of the results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// Specifies the principal.
    public var principal: Swift.String?
    /// Specifies the [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resources whose policies you want to retrieve.
    /// This member is required.
    public var resourceArns: [Swift.String]?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        principal: Swift.String? = nil,
        resourceArns: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principal = principal
        self.resourceArns = resourceArns
    }
}

struct GetResourcePoliciesInputBody: Swift.Equatable {
    let resourceArns: [Swift.String]?
    let principal: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetResourcePoliciesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case principal
        case resourceArns
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let principalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principal)
        principal = principalDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetResourcePoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourcePoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextToken" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceArn.NotFound" : self = .resourceArnNotFoundException(try ResourceArnNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetResourcePoliciesOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case resourceArnNotFoundException(ResourceArnNotFoundException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourcePoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetResourcePoliciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.policies = output.policies
        } else {
            self.nextToken = nil
            self.policies = nil
        }
    }
}

public struct GetResourcePoliciesOutputResponse: Swift.Equatable {
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?
    /// An array of resource policy documents in JSON format.
    public var policies: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        policies: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.policies = policies
    }
}

struct GetResourcePoliciesOutputResponseBody: Swift.Equatable {
    let policies: [Swift.String]?
    let nextToken: Swift.String?
}

extension GetResourcePoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case policies
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .policies)
        var policiesDecoded0:[Swift.String]? = nil
        if let policiesContainer = policiesContainer {
            policiesDecoded0 = [Swift.String]()
            for string0 in policiesContainer {
                if let string0 = string0 {
                    policiesDecoded0?.append(string0)
                }
            }
        }
        policies = policiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetResourceShareAssociationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationStatus
        case associationType
        case maxResults
        case nextToken
        case principal
        case resourceArn
        case resourceShareArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationStatus = self.associationStatus {
            try encodeContainer.encode(associationStatus.rawValue, forKey: .associationStatus)
        }
        if let associationType = self.associationType {
            try encodeContainer.encode(associationType.rawValue, forKey: .associationType)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let principal = self.principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceShareArns = resourceShareArns {
            var resourceShareArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShareArns)
            for string0 in resourceShareArns {
                try resourceShareArnsContainer.encode(string0)
            }
        }
    }
}

extension GetResourceShareAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/getresourceshareassociations"
    }
}

public struct GetResourceShareAssociationsInput: Swift.Equatable {
    /// Specifies that you want to retrieve only associations with this status.
    public var associationStatus: RAMClientTypes.ResourceShareAssociationStatus?
    /// Specifies whether you want to retrieve the associations that involve a specified resource or principal.
    ///
    /// * PRINCIPAL – list the principals that are associated with the specified resource share.
    ///
    /// * RESOURCE – list the resources that are associated with the specified resource share.
    /// This member is required.
    public var associationType: RAMClientTypes.ResourceShareAssociationType?
    /// Specifies the total number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value that is specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next part of the results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// Specifies the ID of the principal whose resource shares you want to retrieve. This can be an Amazon Web Services account ID, an organization ID, an organizational unit ID, or the [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of an individual IAM user or role. You cannot specify this parameter if the association type is RESOURCE.
    public var principal: Swift.String?
    /// Specifies the [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource whose resource shares you want to retrieve. You cannot specify this parameter if the association type is PRINCIPAL.
    public var resourceArn: Swift.String?
    /// Specifies a list of [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource share whose associations you want to retrieve.
    public var resourceShareArns: [Swift.String]?

    public init (
        associationStatus: RAMClientTypes.ResourceShareAssociationStatus? = nil,
        associationType: RAMClientTypes.ResourceShareAssociationType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        principal: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceShareArns: [Swift.String]? = nil
    )
    {
        self.associationStatus = associationStatus
        self.associationType = associationType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principal = principal
        self.resourceArn = resourceArn
        self.resourceShareArns = resourceShareArns
    }
}

struct GetResourceShareAssociationsInputBody: Swift.Equatable {
    let associationType: RAMClientTypes.ResourceShareAssociationType?
    let resourceShareArns: [Swift.String]?
    let resourceArn: Swift.String?
    let principal: Swift.String?
    let associationStatus: RAMClientTypes.ResourceShareAssociationStatus?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetResourceShareAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationStatus
        case associationType
        case maxResults
        case nextToken
        case principal
        case resourceArn
        case resourceShareArns
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associationTypeDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceShareAssociationType.self, forKey: .associationType)
        associationType = associationTypeDecoded
        let resourceShareArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceShareArns)
        var resourceShareArnsDecoded0:[Swift.String]? = nil
        if let resourceShareArnsContainer = resourceShareArnsContainer {
            resourceShareArnsDecoded0 = [Swift.String]()
            for string0 in resourceShareArnsContainer {
                if let string0 = string0 {
                    resourceShareArnsDecoded0?.append(string0)
                }
            }
        }
        resourceShareArns = resourceShareArnsDecoded0
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let principalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principal)
        principal = principalDecoded
        let associationStatusDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceShareAssociationStatus.self, forKey: .associationStatus)
        associationStatus = associationStatusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetResourceShareAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceShareAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextToken" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareArn.NotFound" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetResourceShareAssociationsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceShareAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetResourceShareAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceShareAssociations = output.resourceShareAssociations
        } else {
            self.nextToken = nil
            self.resourceShareAssociations = nil
        }
    }
}

public struct GetResourceShareAssociationsOutputResponse: Swift.Equatable {
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?
    /// An array of objects that contain the details about the associations.
    public var resourceShareAssociations: [RAMClientTypes.ResourceShareAssociation]?

    public init (
        nextToken: Swift.String? = nil,
        resourceShareAssociations: [RAMClientTypes.ResourceShareAssociation]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceShareAssociations = resourceShareAssociations
    }
}

struct GetResourceShareAssociationsOutputResponseBody: Swift.Equatable {
    let resourceShareAssociations: [RAMClientTypes.ResourceShareAssociation]?
    let nextToken: Swift.String?
}

extension GetResourceShareAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resourceShareAssociations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareAssociationsContainer = try containerValues.decodeIfPresent([RAMClientTypes.ResourceShareAssociation?].self, forKey: .resourceShareAssociations)
        var resourceShareAssociationsDecoded0:[RAMClientTypes.ResourceShareAssociation]? = nil
        if let resourceShareAssociationsContainer = resourceShareAssociationsContainer {
            resourceShareAssociationsDecoded0 = [RAMClientTypes.ResourceShareAssociation]()
            for structure0 in resourceShareAssociationsContainer {
                if let structure0 = structure0 {
                    resourceShareAssociationsDecoded0?.append(structure0)
                }
            }
        }
        resourceShareAssociations = resourceShareAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetResourceShareInvitationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceShareArns
        case resourceShareInvitationArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceShareArns = resourceShareArns {
            var resourceShareArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShareArns)
            for string0 in resourceShareArns {
                try resourceShareArnsContainer.encode(string0)
            }
        }
        if let resourceShareInvitationArns = resourceShareInvitationArns {
            var resourceShareInvitationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShareInvitationArns)
            for string0 in resourceShareInvitationArns {
                try resourceShareInvitationArnsContainer.encode(string0)
            }
        }
    }
}

extension GetResourceShareInvitationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/getresourceshareinvitations"
    }
}

public struct GetResourceShareInvitationsInput: Swift.Equatable {
    /// Specifies the total number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value that is specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next part of the results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// Specifies that you want details about invitations only for the resource shares described by this list of [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html)
    public var resourceShareArns: [Swift.String]?
    /// Specifies the [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource share invitations you want information about.
    public var resourceShareInvitationArns: [Swift.String]?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceShareArns: [Swift.String]? = nil,
        resourceShareInvitationArns: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceShareArns = resourceShareArns
        self.resourceShareInvitationArns = resourceShareInvitationArns
    }
}

struct GetResourceShareInvitationsInputBody: Swift.Equatable {
    let resourceShareInvitationArns: [Swift.String]?
    let resourceShareArns: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetResourceShareInvitationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceShareArns
        case resourceShareInvitationArns
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceShareInvitationArns)
        var resourceShareInvitationArnsDecoded0:[Swift.String]? = nil
        if let resourceShareInvitationArnsContainer = resourceShareInvitationArnsContainer {
            resourceShareInvitationArnsDecoded0 = [Swift.String]()
            for string0 in resourceShareInvitationArnsContainer {
                if let string0 = string0 {
                    resourceShareInvitationArnsDecoded0?.append(string0)
                }
            }
        }
        resourceShareInvitationArns = resourceShareInvitationArnsDecoded0
        let resourceShareArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceShareArns)
        var resourceShareArnsDecoded0:[Swift.String]? = nil
        if let resourceShareArnsContainer = resourceShareArnsContainer {
            resourceShareArnsDecoded0 = [Swift.String]()
            for string0 in resourceShareArnsContainer {
                if let string0 = string0 {
                    resourceShareArnsDecoded0?.append(string0)
                }
            }
        }
        resourceShareArns = resourceShareArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetResourceShareInvitationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceShareInvitationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidMaxResults" : self = .invalidMaxResultsException(try InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextToken" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareInvitationArn.NotFound" : self = .resourceShareInvitationArnNotFoundException(try ResourceShareInvitationArnNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareArn.NotFound" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetResourceShareInvitationsOutputError: Swift.Error, Swift.Equatable {
    case invalidMaxResultsException(InvalidMaxResultsException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case resourceShareInvitationArnNotFoundException(ResourceShareInvitationArnNotFoundException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceShareInvitationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetResourceShareInvitationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceShareInvitations = output.resourceShareInvitations
        } else {
            self.nextToken = nil
            self.resourceShareInvitations = nil
        }
    }
}

public struct GetResourceShareInvitationsOutputResponse: Swift.Equatable {
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?
    /// An array of objects that contain the details about the invitations.
    public var resourceShareInvitations: [RAMClientTypes.ResourceShareInvitation]?

    public init (
        nextToken: Swift.String? = nil,
        resourceShareInvitations: [RAMClientTypes.ResourceShareInvitation]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceShareInvitations = resourceShareInvitations
    }
}

struct GetResourceShareInvitationsOutputResponseBody: Swift.Equatable {
    let resourceShareInvitations: [RAMClientTypes.ResourceShareInvitation]?
    let nextToken: Swift.String?
}

extension GetResourceShareInvitationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resourceShareInvitations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationsContainer = try containerValues.decodeIfPresent([RAMClientTypes.ResourceShareInvitation?].self, forKey: .resourceShareInvitations)
        var resourceShareInvitationsDecoded0:[RAMClientTypes.ResourceShareInvitation]? = nil
        if let resourceShareInvitationsContainer = resourceShareInvitationsContainer {
            resourceShareInvitationsDecoded0 = [RAMClientTypes.ResourceShareInvitation]()
            for structure0 in resourceShareInvitationsContainer {
                if let structure0 = structure0 {
                    resourceShareInvitationsDecoded0?.append(structure0)
                }
            }
        }
        resourceShareInvitations = resourceShareInvitationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetResourceSharesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case name
        case nextToken
        case permissionArn
        case resourceOwner
        case resourceShareArns
        case resourceShareStatus
        case tagFilters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let permissionArn = self.permissionArn {
            try encodeContainer.encode(permissionArn, forKey: .permissionArn)
        }
        if let resourceOwner = self.resourceOwner {
            try encodeContainer.encode(resourceOwner.rawValue, forKey: .resourceOwner)
        }
        if let resourceShareArns = resourceShareArns {
            var resourceShareArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShareArns)
            for string0 in resourceShareArns {
                try resourceShareArnsContainer.encode(string0)
            }
        }
        if let resourceShareStatus = self.resourceShareStatus {
            try encodeContainer.encode(resourceShareStatus.rawValue, forKey: .resourceShareStatus)
        }
        if let tagFilters = tagFilters {
            var tagFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagFilters)
            for tagfilter0 in tagFilters {
                try tagFiltersContainer.encode(tagfilter0)
            }
        }
    }
}

extension GetResourceSharesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/getresourceshares"
    }
}

public struct GetResourceSharesInput: Swift.Equatable {
    /// Specifies the total number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value that is specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next part of the results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies the name of an individual resource share that you want to retrieve details about.
    public var name: Swift.String?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// Specifies that you want to retrieve details of only those resource shares that use the RAM permission with this [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html).
    public var permissionArn: Swift.String?
    /// Specifies that you want to retrieve details of only those resource shares that match the following:
    ///
    /// * SELF – resource shares that your account shares with other accounts
    ///
    /// * OTHER-ACCOUNTS – resource shares that other accounts share with your account
    /// This member is required.
    public var resourceOwner: RAMClientTypes.ResourceOwner?
    /// Specifies the [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of individual resource shares that you want information about.
    public var resourceShareArns: [Swift.String]?
    /// Specifies that you want to retrieve details of only those resource shares that have this status.
    public var resourceShareStatus: RAMClientTypes.ResourceShareStatus?
    /// Specifies that you want to retrieve details of only those resource shares that match the specified tag keys and values.
    public var tagFilters: [RAMClientTypes.TagFilter]?

    public init (
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        permissionArn: Swift.String? = nil,
        resourceOwner: RAMClientTypes.ResourceOwner? = nil,
        resourceShareArns: [Swift.String]? = nil,
        resourceShareStatus: RAMClientTypes.ResourceShareStatus? = nil,
        tagFilters: [RAMClientTypes.TagFilter]? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.permissionArn = permissionArn
        self.resourceOwner = resourceOwner
        self.resourceShareArns = resourceShareArns
        self.resourceShareStatus = resourceShareStatus
        self.tagFilters = tagFilters
    }
}

struct GetResourceSharesInputBody: Swift.Equatable {
    let resourceShareArns: [Swift.String]?
    let resourceShareStatus: RAMClientTypes.ResourceShareStatus?
    let resourceOwner: RAMClientTypes.ResourceOwner?
    let name: Swift.String?
    let tagFilters: [RAMClientTypes.TagFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let permissionArn: Swift.String?
}

extension GetResourceSharesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case name
        case nextToken
        case permissionArn
        case resourceOwner
        case resourceShareArns
        case resourceShareStatus
        case tagFilters
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceShareArns)
        var resourceShareArnsDecoded0:[Swift.String]? = nil
        if let resourceShareArnsContainer = resourceShareArnsContainer {
            resourceShareArnsDecoded0 = [Swift.String]()
            for string0 in resourceShareArnsContainer {
                if let string0 = string0 {
                    resourceShareArnsDecoded0?.append(string0)
                }
            }
        }
        resourceShareArns = resourceShareArnsDecoded0
        let resourceShareStatusDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceShareStatus.self, forKey: .resourceShareStatus)
        resourceShareStatus = resourceShareStatusDecoded
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceOwner.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagFiltersContainer = try containerValues.decodeIfPresent([RAMClientTypes.TagFilter?].self, forKey: .tagFilters)
        var tagFiltersDecoded0:[RAMClientTypes.TagFilter]? = nil
        if let tagFiltersContainer = tagFiltersContainer {
            tagFiltersDecoded0 = [RAMClientTypes.TagFilter]()
            for structure0 in tagFiltersContainer {
                if let structure0 = structure0 {
                    tagFiltersDecoded0?.append(structure0)
                }
            }
        }
        tagFilters = tagFiltersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let permissionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionArn)
        permissionArn = permissionArnDecoded
    }
}

extension GetResourceSharesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceSharesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextToken" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareArn.NotFound" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetResourceSharesOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceSharesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetResourceSharesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceShares = output.resourceShares
        } else {
            self.nextToken = nil
            self.resourceShares = nil
        }
    }
}

public struct GetResourceSharesOutputResponse: Swift.Equatable {
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?
    /// An array of objects that contain the information about the resource shares.
    public var resourceShares: [RAMClientTypes.ResourceShare]?

    public init (
        nextToken: Swift.String? = nil,
        resourceShares: [RAMClientTypes.ResourceShare]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceShares = resourceShares
    }
}

struct GetResourceSharesOutputResponseBody: Swift.Equatable {
    let resourceShares: [RAMClientTypes.ResourceShare]?
    let nextToken: Swift.String?
}

extension GetResourceSharesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resourceShares
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceSharesContainer = try containerValues.decodeIfPresent([RAMClientTypes.ResourceShare?].self, forKey: .resourceShares)
        var resourceSharesDecoded0:[RAMClientTypes.ResourceShare]? = nil
        if let resourceSharesContainer = resourceSharesContainer {
            resourceSharesDecoded0 = [RAMClientTypes.ResourceShare]()
            for structure0 in resourceSharesContainer {
                if let structure0 = structure0 {
                    resourceSharesDecoded0?.append(structure0)
                }
            }
        }
        resourceShares = resourceSharesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension IdempotentParameterMismatchException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: IdempotentParameterMismatchExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client token input parameter was matched one used with a previous call to the operation, but at least one of the other input parameters is different from the previous call.
public struct IdempotentParameterMismatchException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IdempotentParameterMismatchExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension IdempotentParameterMismatchExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidClientTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidClientTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client token is not valid.
public struct InvalidClientTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidClientTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidClientTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidMaxResultsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidMaxResultsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified value for MaxResults is not valid.
public struct InvalidMaxResultsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidMaxResultsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidMaxResultsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified value for NextToken is not valid.
public struct InvalidNextTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A parameter is not valid.
public struct InvalidParameterException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourceTypeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidResourceTypeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource type is not valid.
public struct InvalidResourceTypeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidResourceTypeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidResourceTypeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidStateTransitionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidStateTransitionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested state transition is not valid.
public struct InvalidStateTransitionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidStateTransitionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidStateTransitionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListPendingInvitationResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceRegionScope
        case resourceShareInvitationArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceRegionScope = self.resourceRegionScope {
            try encodeContainer.encode(resourceRegionScope.rawValue, forKey: .resourceRegionScope)
        }
        if let resourceShareInvitationArn = self.resourceShareInvitationArn {
            try encodeContainer.encode(resourceShareInvitationArn, forKey: .resourceShareInvitationArn)
        }
    }
}

extension ListPendingInvitationResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listpendinginvitationresources"
    }
}

public struct ListPendingInvitationResourcesInput: Swift.Equatable {
    /// Specifies the total number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value that is specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next part of the results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// Specifies that you want the results to include only resources that have the specified scope.
    ///
    /// * ALL – the results include both global and regional resources or resource types.
    ///
    /// * GLOBAL – the results include only global resources or resource types.
    ///
    /// * REGIONAL – the results include only regional resources or resource types.
    ///
    ///
    /// The default value is ALL.
    public var resourceRegionScope: RAMClientTypes.ResourceRegionScopeFilter?
    /// Specifies the [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the invitation. You can use [GetResourceShareInvitations] to find the ARN of the invitation.
    /// This member is required.
    public var resourceShareInvitationArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceRegionScope: RAMClientTypes.ResourceRegionScopeFilter? = nil,
        resourceShareInvitationArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceRegionScope = resourceRegionScope
        self.resourceShareInvitationArn = resourceShareInvitationArn
    }
}

struct ListPendingInvitationResourcesInputBody: Swift.Equatable {
    let resourceShareInvitationArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let resourceRegionScope: RAMClientTypes.ResourceRegionScopeFilter?
}

extension ListPendingInvitationResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceRegionScope
        case resourceShareInvitationArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareInvitationArn)
        resourceShareInvitationArn = resourceShareInvitationArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let resourceRegionScopeDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceRegionScopeFilter.self, forKey: .resourceRegionScope)
        resourceRegionScope = resourceRegionScopeDecoded
    }
}

extension ListPendingInvitationResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPendingInvitationResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextToken" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameter" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareInvitationArn.AlreadyRejected" : self = .resourceShareInvitationAlreadyRejectedException(try ResourceShareInvitationAlreadyRejectedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareInvitationArn.NotFound" : self = .resourceShareInvitationArnNotFoundException(try ResourceShareInvitationArnNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareInvitationArn.Expired" : self = .resourceShareInvitationExpiredException(try ResourceShareInvitationExpiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPendingInvitationResourcesOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case resourceShareInvitationAlreadyRejectedException(ResourceShareInvitationAlreadyRejectedException)
    case resourceShareInvitationArnNotFoundException(ResourceShareInvitationArnNotFoundException)
    case resourceShareInvitationExpiredException(ResourceShareInvitationExpiredException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPendingInvitationResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPendingInvitationResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resources = output.resources
        } else {
            self.nextToken = nil
            self.resources = nil
        }
    }
}

public struct ListPendingInvitationResourcesOutputResponse: Swift.Equatable {
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?
    /// An array of objects that contain the information about the resources included the specified resource share.
    public var resources: [RAMClientTypes.Resource]?

    public init (
        nextToken: Swift.String? = nil,
        resources: [RAMClientTypes.Resource]? = nil
    )
    {
        self.nextToken = nextToken
        self.resources = resources
    }
}

struct ListPendingInvitationResourcesOutputResponseBody: Swift.Equatable {
    let resources: [RAMClientTypes.Resource]?
    let nextToken: Swift.String?
}

extension ListPendingInvitationResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resources
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesContainer = try containerValues.decodeIfPresent([RAMClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[RAMClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [RAMClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPermissionVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case permissionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let permissionArn = self.permissionArn {
            try encodeContainer.encode(permissionArn, forKey: .permissionArn)
        }
    }
}

extension ListPermissionVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listpermissionversions"
    }
}

public struct ListPermissionVersionsInput: Swift.Equatable {
    /// Specifies the total number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value that is specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next part of the results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// Specifies the [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the RAM permission whose versions you want to list. You can use the permissionVersion parameter on the [AssociateResourceSharePermission] operation to specify a non-default version to attach.
    /// This member is required.
    public var permissionArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        permissionArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.permissionArn = permissionArn
    }
}

struct ListPermissionVersionsInputBody: Swift.Equatable {
    let permissionArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListPermissionVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case permissionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionArn)
        permissionArn = permissionArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPermissionVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPermissionVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextToken" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareArn.NotFound" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPermissionVersionsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPermissionVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPermissionVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissions = output.permissions
        } else {
            self.nextToken = nil
            self.permissions = nil
        }
    }
}

public struct ListPermissionVersionsOutputResponse: Swift.Equatable {
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?
    /// An array of objects that contain details for each of the available versions.
    public var permissions: [RAMClientTypes.ResourceSharePermissionSummary]?

    public init (
        nextToken: Swift.String? = nil,
        permissions: [RAMClientTypes.ResourceSharePermissionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissions = permissions
    }
}

struct ListPermissionVersionsOutputResponseBody: Swift.Equatable {
    let permissions: [RAMClientTypes.ResourceSharePermissionSummary]?
    let nextToken: Swift.String?
}

extension ListPermissionVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case permissions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsContainer = try containerValues.decodeIfPresent([RAMClientTypes.ResourceSharePermissionSummary?].self, forKey: .permissions)
        var permissionsDecoded0:[RAMClientTypes.ResourceSharePermissionSummary]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [RAMClientTypes.ResourceSharePermissionSummary]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }
}

extension ListPermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listpermissions"
    }
}

public struct ListPermissionsInput: Swift.Equatable {
    /// Specifies the total number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value that is specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next part of the results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// Specifies that you want to list permissions for only the specified resource type. For example, to list only permissions that apply to EC2 subnets, specify ec2:Subnet. You can use the [ListResourceTypes] operation to get the specific string required.
    public var resourceType: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceType = resourceType
    }
}

struct ListPermissionsInputBody: Swift.Equatable {
    let resourceType: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListPermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextToken" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPermissionsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissions = output.permissions
        } else {
            self.nextToken = nil
            self.permissions = nil
        }
    }
}

public struct ListPermissionsOutputResponse: Swift.Equatable {
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?
    /// An array of objects with information about the permissions.
    public var permissions: [RAMClientTypes.ResourceSharePermissionSummary]?

    public init (
        nextToken: Swift.String? = nil,
        permissions: [RAMClientTypes.ResourceSharePermissionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissions = permissions
    }
}

struct ListPermissionsOutputResponseBody: Swift.Equatable {
    let permissions: [RAMClientTypes.ResourceSharePermissionSummary]?
    let nextToken: Swift.String?
}

extension ListPermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case permissions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsContainer = try containerValues.decodeIfPresent([RAMClientTypes.ResourceSharePermissionSummary?].self, forKey: .permissions)
        var permissionsDecoded0:[RAMClientTypes.ResourceSharePermissionSummary]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [RAMClientTypes.ResourceSharePermissionSummary]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPrincipalsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case principals
        case resourceArn
        case resourceOwner
        case resourceShareArns
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for string0 in principals {
                try principalsContainer.encode(string0)
            }
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceOwner = self.resourceOwner {
            try encodeContainer.encode(resourceOwner.rawValue, forKey: .resourceOwner)
        }
        if let resourceShareArns = resourceShareArns {
            var resourceShareArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShareArns)
            for string0 in resourceShareArns {
                try resourceShareArnsContainer.encode(string0)
            }
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }
}

extension ListPrincipalsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listprincipals"
    }
}

public struct ListPrincipalsInput: Swift.Equatable {
    /// Specifies the total number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value that is specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next part of the results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// Specifies that you want to list information for only the listed principals. You can include the following values:
    ///
    /// * An Amazon Web Services account ID, for example: 123456789012
    ///
    /// * An [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of an organization in Organizations, for example: organizations::123456789012:organization/o-exampleorgid
    ///
    /// * An ARN of an organizational unit (OU) in Organizations, for example: organizations::123456789012:ou/o-exampleorgid/ou-examplerootid-exampleouid123
    ///
    /// * An ARN of an IAM role, for example: iam::123456789012:role/rolename
    ///
    /// * An ARN of an IAM user, for example: iam::123456789012user/username
    ///
    ///
    /// Not all resource types can be shared with IAM roles and users. For more information, see [Sharing with IAM roles and users](https://docs.aws.amazon.com/ram/latest/userguide/permissions.html#permissions-rbp-supported-resource-types) in the Resource Access Manager User Guide.
    public var principals: [Swift.String]?
    /// Specifies that you want to list principal information for the resource share with the specified [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html).
    public var resourceArn: Swift.String?
    /// Specifies that you want to list information for only resource shares that match the following:
    ///
    /// * SELF – principals that your account is sharing resources with
    ///
    /// * OTHER-ACCOUNTS – principals that are sharing resources with your account
    /// This member is required.
    public var resourceOwner: RAMClientTypes.ResourceOwner?
    /// Specifies that you want to list information for only principals associated with the resource shares specified by a list the [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html).
    public var resourceShareArns: [Swift.String]?
    /// Specifies that you want to list information for only principals associated with resource shares that include the specified resource type. For a list of valid values, query the [ListResourceTypes] operation.
    public var resourceType: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        principals: [Swift.String]? = nil,
        resourceArn: Swift.String? = nil,
        resourceOwner: RAMClientTypes.ResourceOwner? = nil,
        resourceShareArns: [Swift.String]? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principals = principals
        self.resourceArn = resourceArn
        self.resourceOwner = resourceOwner
        self.resourceShareArns = resourceShareArns
        self.resourceType = resourceType
    }
}

struct ListPrincipalsInputBody: Swift.Equatable {
    let resourceOwner: RAMClientTypes.ResourceOwner?
    let resourceArn: Swift.String?
    let principals: [Swift.String]?
    let resourceType: Swift.String?
    let resourceShareArns: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListPrincipalsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case principals
        case resourceArn
        case resourceOwner
        case resourceShareArns
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceOwner.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let principalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .principals)
        var principalsDecoded0:[Swift.String]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [Swift.String]()
            for string0 in principalsContainer {
                if let string0 = string0 {
                    principalsDecoded0?.append(string0)
                }
            }
        }
        principals = principalsDecoded0
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceShareArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceShareArns)
        var resourceShareArnsDecoded0:[Swift.String]? = nil
        if let resourceShareArnsContainer = resourceShareArnsContainer {
            resourceShareArnsDecoded0 = [Swift.String]()
            for string0 in resourceShareArnsContainer {
                if let string0 = string0 {
                    resourceShareArnsDecoded0?.append(string0)
                }
            }
        }
        resourceShareArns = resourceShareArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPrincipalsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPrincipalsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextToken" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareArn.NotFound" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPrincipalsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPrincipalsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPrincipalsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.principals = output.principals
        } else {
            self.nextToken = nil
            self.principals = nil
        }
    }
}

public struct ListPrincipalsOutputResponse: Swift.Equatable {
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?
    /// An array of objects that contain the details about the principals.
    public var principals: [RAMClientTypes.Principal]?

    public init (
        nextToken: Swift.String? = nil,
        principals: [RAMClientTypes.Principal]? = nil
    )
    {
        self.nextToken = nextToken
        self.principals = principals
    }
}

struct ListPrincipalsOutputResponseBody: Swift.Equatable {
    let principals: [RAMClientTypes.Principal]?
    let nextToken: Swift.String?
}

extension ListPrincipalsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case principals
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalsContainer = try containerValues.decodeIfPresent([RAMClientTypes.Principal?].self, forKey: .principals)
        var principalsDecoded0:[RAMClientTypes.Principal]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [RAMClientTypes.Principal]()
            for structure0 in principalsContainer {
                if let structure0 = structure0 {
                    principalsDecoded0?.append(structure0)
                }
            }
        }
        principals = principalsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResourceSharePermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceShareArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceShareArn = self.resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
    }
}

extension ListResourceSharePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listresourcesharepermissions"
    }
}

public struct ListResourceSharePermissionsInput: Swift.Equatable {
    /// Specifies the total number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value that is specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next part of the results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// Specifies the [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource share for which you want to retrieve the associated permissions.
    /// This member is required.
    public var resourceShareArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceShareArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceShareArn = resourceShareArn
    }
}

struct ListResourceSharePermissionsInputBody: Swift.Equatable {
    let resourceShareArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListResourceSharePermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceShareArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListResourceSharePermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourceSharePermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextToken" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareArn.NotFound" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListResourceSharePermissionsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourceSharePermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListResourceSharePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissions = output.permissions
        } else {
            self.nextToken = nil
            self.permissions = nil
        }
    }
}

public struct ListResourceSharePermissionsOutputResponse: Swift.Equatable {
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?
    /// An array of objects that describe the permissions associated with the resource share.
    public var permissions: [RAMClientTypes.ResourceSharePermissionSummary]?

    public init (
        nextToken: Swift.String? = nil,
        permissions: [RAMClientTypes.ResourceSharePermissionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissions = permissions
    }
}

struct ListResourceSharePermissionsOutputResponseBody: Swift.Equatable {
    let permissions: [RAMClientTypes.ResourceSharePermissionSummary]?
    let nextToken: Swift.String?
}

extension ListResourceSharePermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case permissions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsContainer = try containerValues.decodeIfPresent([RAMClientTypes.ResourceSharePermissionSummary?].self, forKey: .permissions)
        var permissionsDecoded0:[RAMClientTypes.ResourceSharePermissionSummary]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [RAMClientTypes.ResourceSharePermissionSummary]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResourceTypesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceRegionScope
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceRegionScope = self.resourceRegionScope {
            try encodeContainer.encode(resourceRegionScope.rawValue, forKey: .resourceRegionScope)
        }
    }
}

extension ListResourceTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listresourcetypes"
    }
}

public struct ListResourceTypesInput: Swift.Equatable {
    /// Specifies the total number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value that is specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next part of the results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// Specifies that you want the results to include only resources that have the specified scope.
    ///
    /// * ALL – the results include both global and regional resources or resource types.
    ///
    /// * GLOBAL – the results include only global resources or resource types.
    ///
    /// * REGIONAL – the results include only regional resources or resource types.
    ///
    ///
    /// The default value is ALL.
    public var resourceRegionScope: RAMClientTypes.ResourceRegionScopeFilter?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceRegionScope: RAMClientTypes.ResourceRegionScopeFilter? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceRegionScope = resourceRegionScope
    }
}

struct ListResourceTypesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let resourceRegionScope: RAMClientTypes.ResourceRegionScopeFilter?
}

extension ListResourceTypesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceRegionScope
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let resourceRegionScopeDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceRegionScopeFilter.self, forKey: .resourceRegionScope)
        resourceRegionScope = resourceRegionScopeDecoded
    }
}

extension ListResourceTypesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourceTypesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextToken" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListResourceTypesOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourceTypesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListResourceTypesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceTypes = output.resourceTypes
        } else {
            self.nextToken = nil
            self.resourceTypes = nil
        }
    }
}

public struct ListResourceTypesOutputResponse: Swift.Equatable {
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?
    /// An array of objects that contain information about the resource types that can be shared using RAM.
    public var resourceTypes: [RAMClientTypes.ServiceNameAndResourceType]?

    public init (
        nextToken: Swift.String? = nil,
        resourceTypes: [RAMClientTypes.ServiceNameAndResourceType]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceTypes = resourceTypes
    }
}

struct ListResourceTypesOutputResponseBody: Swift.Equatable {
    let resourceTypes: [RAMClientTypes.ServiceNameAndResourceType]?
    let nextToken: Swift.String?
}

extension ListResourceTypesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resourceTypes
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypesContainer = try containerValues.decodeIfPresent([RAMClientTypes.ServiceNameAndResourceType?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[RAMClientTypes.ServiceNameAndResourceType]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [RAMClientTypes.ServiceNameAndResourceType]()
            for structure0 in resourceTypesContainer {
                if let structure0 = structure0 {
                    resourceTypesDecoded0?.append(structure0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case principal
        case resourceArns
        case resourceOwner
        case resourceRegionScope
        case resourceShareArns
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let principal = self.principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for string0 in resourceArns {
                try resourceArnsContainer.encode(string0)
            }
        }
        if let resourceOwner = self.resourceOwner {
            try encodeContainer.encode(resourceOwner.rawValue, forKey: .resourceOwner)
        }
        if let resourceRegionScope = self.resourceRegionScope {
            try encodeContainer.encode(resourceRegionScope.rawValue, forKey: .resourceRegionScope)
        }
        if let resourceShareArns = resourceShareArns {
            var resourceShareArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShareArns)
            for string0 in resourceShareArns {
                try resourceShareArnsContainer.encode(string0)
            }
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }
}

extension ListResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listresources"
    }
}

public struct ListResourcesInput: Swift.Equatable {
    /// Specifies the total number of results that you want included on each page of the response. If you do not include this parameter, it defaults to a value that is specific to the operation. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next part of the results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// Specifies that you want to list only the resource shares that are associated with the specified principal.
    public var principal: Swift.String?
    /// Specifies that you want to list only the resource shares that include resources with the specified [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html).
    public var resourceArns: [Swift.String]?
    /// Specifies that you want to list only the resource shares that match the following:
    ///
    /// * SELF – resources that your account shares with other accounts
    ///
    /// * OTHER-ACCOUNTS – resources that other accounts share with your account
    /// This member is required.
    public var resourceOwner: RAMClientTypes.ResourceOwner?
    /// Specifies that you want the results to include only resources that have the specified scope.
    ///
    /// * ALL – the results include both global and regional resources or resource types.
    ///
    /// * GLOBAL – the results include only global resources or resource types.
    ///
    /// * REGIONAL – the results include only regional resources or resource types.
    ///
    ///
    /// The default value is ALL.
    public var resourceRegionScope: RAMClientTypes.ResourceRegionScopeFilter?
    /// Specifies that you want to list only resources in the resource shares identified by the specified [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html).
    public var resourceShareArns: [Swift.String]?
    /// Specifies that you want to list only the resource shares that include resources of the specified resource type. For valid values, query the [ListResourceTypes] operation.
    public var resourceType: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        principal: Swift.String? = nil,
        resourceArns: [Swift.String]? = nil,
        resourceOwner: RAMClientTypes.ResourceOwner? = nil,
        resourceRegionScope: RAMClientTypes.ResourceRegionScopeFilter? = nil,
        resourceShareArns: [Swift.String]? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principal = principal
        self.resourceArns = resourceArns
        self.resourceOwner = resourceOwner
        self.resourceRegionScope = resourceRegionScope
        self.resourceShareArns = resourceShareArns
        self.resourceType = resourceType
    }
}

struct ListResourcesInputBody: Swift.Equatable {
    let resourceOwner: RAMClientTypes.ResourceOwner?
    let principal: Swift.String?
    let resourceType: Swift.String?
    let resourceArns: [Swift.String]?
    let resourceShareArns: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let resourceRegionScope: RAMClientTypes.ResourceRegionScopeFilter?
}

extension ListResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case principal
        case resourceArns
        case resourceOwner
        case resourceRegionScope
        case resourceShareArns
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceOwner.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let principalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principal)
        principal = principalDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let resourceShareArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceShareArns)
        var resourceShareArnsDecoded0:[Swift.String]? = nil
        if let resourceShareArnsContainer = resourceShareArnsContainer {
            resourceShareArnsDecoded0 = [Swift.String]()
            for string0 in resourceShareArnsContainer {
                if let string0 = string0 {
                    resourceShareArnsDecoded0?.append(string0)
                }
            }
        }
        resourceShareArns = resourceShareArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let resourceRegionScopeDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceRegionScopeFilter.self, forKey: .resourceRegionScope)
        resourceRegionScope = resourceRegionScopeDecoded
    }
}

extension ListResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextToken" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceType.Unknown" : self = .invalidResourceTypeException(try InvalidResourceTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareArn.NotFound" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListResourcesOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case invalidResourceTypeException(InvalidResourceTypeException)
    case malformedArnException(MalformedArnException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resources = output.resources
        } else {
            self.nextToken = nil
            self.resources = nil
        }
    }
}

public struct ListResourcesOutputResponse: Swift.Equatable {
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?
    /// An array of objects that contain information about the resources.
    public var resources: [RAMClientTypes.Resource]?

    public init (
        nextToken: Swift.String? = nil,
        resources: [RAMClientTypes.Resource]? = nil
    )
    {
        self.nextToken = nextToken
        self.resources = resources
    }
}

struct ListResourcesOutputResponseBody: Swift.Equatable {
    let resources: [RAMClientTypes.Resource]?
    let nextToken: Swift.String?
}

extension ListResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resources
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesContainer = try containerValues.decodeIfPresent([RAMClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[RAMClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [RAMClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MalformedArnException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MalformedArnExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The format of an Amazon Resource Name (ARN) is not valid.
public struct MalformedArnException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MalformedArnExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MalformedArnExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MissingRequiredParameterException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MissingRequiredParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A required input parameter is missing.
public struct MissingRequiredParameterException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MissingRequiredParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MissingRequiredParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OperationNotPermittedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: OperationNotPermittedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested operation is not permitted.
public struct OperationNotPermittedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OperationNotPermittedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OperationNotPermittedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RAMClientTypes.Principal: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case external
        case id
        case lastUpdatedTime
        case resourceShareArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let external = self.external {
            try encodeContainer.encode(external, forKey: .external)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let resourceShareArn = self.resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let externalDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .external)
        external = externalDecoded
    }
}

extension RAMClientTypes {
    /// Describes a principal for use with Resource Access Manager.
    public struct Principal: Swift.Equatable {
        /// The date and time when the principal was associated with the resource share.
        public var creationTime: ClientRuntime.Date?
        /// Indicates whether the principal belongs to the same organization in Organizations as the Amazon Web Services account that owns the resource share.
        public var external: Swift.Bool?
        /// The ID of the principal.
        public var id: Swift.String?
        /// The date and time when the association was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of a resource share the principal is associated with.
        public var resourceShareArn: Swift.String?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            external: Swift.Bool? = nil,
            id: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            resourceShareArn: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.external = external
            self.id = id
            self.lastUpdatedTime = lastUpdatedTime
            self.resourceShareArn = resourceShareArn
        }
    }

}

extension PromoteResourceShareCreatedFromPolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceShareArn = resourceShareArn else {
                let message = "Creating a URL Query Item failed. resourceShareArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let resourceShareArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceShareArn".urlPercentEncoding(), value: Swift.String(resourceShareArn).urlPercentEncoding())
            items.append(resourceShareArnQueryItem)
            return items
        }
    }
}

extension PromoteResourceShareCreatedFromPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/promoteresourcesharecreatedfrompolicy"
    }
}

public struct PromoteResourceShareCreatedFromPolicyInput: Swift.Equatable {
    /// Specifies the [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource share to promote.
    /// This member is required.
    public var resourceShareArn: Swift.String?

    public init (
        resourceShareArn: Swift.String? = nil
    )
    {
        self.resourceShareArn = resourceShareArn
    }
}

struct PromoteResourceShareCreatedFromPolicyInputBody: Swift.Equatable {
}

extension PromoteResourceShareCreatedFromPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension PromoteResourceShareCreatedFromPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PromoteResourceShareCreatedFromPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameter" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceShareLimitExceeded" : self = .resourceShareLimitExceededException(try ResourceShareLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareArn.NotFound" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PromoteResourceShareCreatedFromPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceShareLimitExceededException(ResourceShareLimitExceededException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PromoteResourceShareCreatedFromPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PromoteResourceShareCreatedFromPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.returnValue = output.returnValue
        } else {
            self.returnValue = nil
        }
    }
}

public struct PromoteResourceShareCreatedFromPolicyOutputResponse: Swift.Equatable {
    /// A return value of true indicates that the request succeeded. A value of false indicates that the request failed.
    public var returnValue: Swift.Bool?

    public init (
        returnValue: Swift.Bool? = nil
    )
    {
        self.returnValue = returnValue
    }
}

struct PromoteResourceShareCreatedFromPolicyOutputResponseBody: Swift.Equatable {
    let returnValue: Swift.Bool?
}

extension PromoteResourceShareCreatedFromPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case returnValue
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let returnValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .returnValue)
        returnValue = returnValueDecoded
    }
}

extension RejectResourceShareInvitationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShareInvitationArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let resourceShareInvitationArn = self.resourceShareInvitationArn {
            try encodeContainer.encode(resourceShareInvitationArn, forKey: .resourceShareInvitationArn)
        }
    }
}

extension RejectResourceShareInvitationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/rejectresourceshareinvitation"
    }
}

public struct RejectResourceShareInvitationInput: Swift.Equatable {
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value.](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you.
    public var clientToken: Swift.String?
    /// Specifies the [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the invitation that you want to reject.
    /// This member is required.
    public var resourceShareInvitationArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        resourceShareInvitationArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShareInvitationArn = resourceShareInvitationArn
    }
}

struct RejectResourceShareInvitationInputBody: Swift.Equatable {
    let resourceShareInvitationArn: Swift.String?
    let clientToken: Swift.String?
}

extension RejectResourceShareInvitationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShareInvitationArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareInvitationArn)
        resourceShareInvitationArn = resourceShareInvitationArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension RejectResourceShareInvitationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RejectResourceShareInvitationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatch" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientToken" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareInvitationArn.AlreadyAccepted" : self = .resourceShareInvitationAlreadyAcceptedException(try ResourceShareInvitationAlreadyAcceptedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareInvitationArn.AlreadyRejected" : self = .resourceShareInvitationAlreadyRejectedException(try ResourceShareInvitationAlreadyRejectedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareInvitationArn.NotFound" : self = .resourceShareInvitationArnNotFoundException(try ResourceShareInvitationArnNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareInvitationArn.Expired" : self = .resourceShareInvitationExpiredException(try ResourceShareInvitationExpiredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RejectResourceShareInvitationOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidClientTokenException(InvalidClientTokenException)
    case malformedArnException(MalformedArnException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceShareInvitationAlreadyAcceptedException(ResourceShareInvitationAlreadyAcceptedException)
    case resourceShareInvitationAlreadyRejectedException(ResourceShareInvitationAlreadyRejectedException)
    case resourceShareInvitationArnNotFoundException(ResourceShareInvitationArnNotFoundException)
    case resourceShareInvitationExpiredException(ResourceShareInvitationExpiredException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RejectResourceShareInvitationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RejectResourceShareInvitationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.resourceShareInvitation = output.resourceShareInvitation
        } else {
            self.clientToken = nil
            self.resourceShareInvitation = nil
        }
    }
}

public struct RejectResourceShareInvitationOutputResponse: Swift.Equatable {
    /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other parameters must also have the same values that you used in the first call.
    public var clientToken: Swift.String?
    /// An object that contains the details about the rejected invitation.
    public var resourceShareInvitation: RAMClientTypes.ResourceShareInvitation?

    public init (
        clientToken: Swift.String? = nil,
        resourceShareInvitation: RAMClientTypes.ResourceShareInvitation? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShareInvitation = resourceShareInvitation
    }
}

struct RejectResourceShareInvitationOutputResponseBody: Swift.Equatable {
    let resourceShareInvitation: RAMClientTypes.ResourceShareInvitation?
    let clientToken: Swift.String?
}

extension RejectResourceShareInvitationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShareInvitation
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceShareInvitation.self, forKey: .resourceShareInvitation)
        resourceShareInvitation = resourceShareInvitationDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension RAMClientTypes.Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case lastUpdatedTime
        case resourceGroupArn
        case resourceRegionScope
        case resourceShareArn
        case status
        case statusMessage
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let resourceGroupArn = self.resourceGroupArn {
            try encodeContainer.encode(resourceGroupArn, forKey: .resourceGroupArn)
        }
        if let resourceRegionScope = self.resourceRegionScope {
            try encodeContainer.encode(resourceRegionScope.rawValue, forKey: .resourceRegionScope)
        }
        if let resourceShareArn = self.resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let resourceGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceGroupArn)
        resourceGroupArn = resourceGroupArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let resourceRegionScopeDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceRegionScope.self, forKey: .resourceRegionScope)
        resourceRegionScope = resourceRegionScopeDecoded
    }
}

extension RAMClientTypes {
    /// Describes a resource associated with a resource share in RAM.
    public struct Resource: Swift.Equatable {
        /// The [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource.
        public var arn: Swift.String?
        /// The date and time when the resource was associated with the resource share.
        public var creationTime: ClientRuntime.Date?
        /// The date an time when the association was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource group. This value is available only if the resource is part of a resource group.
        public var resourceGroupArn: Swift.String?
        /// Specifies the scope of visibility of this resource:
        ///
        /// * REGIONAL – The resource can be accessed only by using requests that target the Amazon Web Services Region in which the resource exists.
        ///
        /// * GLOBAL – The resource can be accessed from any Amazon Web Services Region.
        public var resourceRegionScope: RAMClientTypes.ResourceRegionScope?
        /// The [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource share this resource is associated with.
        public var resourceShareArn: Swift.String?
        /// The current status of the resource.
        public var status: RAMClientTypes.ResourceStatus?
        /// A message about the status of the resource.
        public var statusMessage: Swift.String?
        /// The resource type. This takes the form of: service-code:resource-code
        public var type: Swift.String?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            resourceGroupArn: Swift.String? = nil,
            resourceRegionScope: RAMClientTypes.ResourceRegionScope? = nil,
            resourceShareArn: Swift.String? = nil,
            status: RAMClientTypes.ResourceStatus? = nil,
            statusMessage: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.lastUpdatedTime = lastUpdatedTime
            self.resourceGroupArn = resourceGroupArn
            self.resourceRegionScope = resourceRegionScope
            self.resourceShareArn = resourceShareArn
            self.status = status
            self.statusMessage = statusMessage
            self.type = type
        }
    }

}

extension ResourceArnNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceArnNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified Amazon Resource Name (ARN) was not found.
public struct ResourceArnNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceArnNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceArnNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RAMClientTypes {
    public enum ResourceOwner: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case otherAccounts
        case `self`
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceOwner] {
            return [
                .otherAccounts,
                .self,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .otherAccounts: return "OTHER-ACCOUNTS"
            case .self: return "SELF"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceOwner(rawValue: rawValue) ?? ResourceOwner.sdkUnknown(rawValue)
        }
    }
}

extension RAMClientTypes {
    public enum ResourceRegionScope: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case global
        case regional
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceRegionScope] {
            return [
                .global,
                .regional,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .global: return "GLOBAL"
            case .regional: return "REGIONAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceRegionScope(rawValue: rawValue) ?? ResourceRegionScope.sdkUnknown(rawValue)
        }
    }
}

extension RAMClientTypes {
    public enum ResourceRegionScopeFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case global
        case regional
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceRegionScopeFilter] {
            return [
                .all,
                .global,
                .regional,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .global: return "GLOBAL"
            case .regional: return "REGIONAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceRegionScopeFilter(rawValue: rawValue) ?? ResourceRegionScopeFilter.sdkUnknown(rawValue)
        }
    }
}

extension RAMClientTypes.ResourceShare: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowExternalPrincipals
        case creationTime
        case featureSet
        case lastUpdatedTime
        case name
        case owningAccountId
        case resourceShareArn
        case status
        case statusMessage
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowExternalPrincipals = self.allowExternalPrincipals {
            try encodeContainer.encode(allowExternalPrincipals, forKey: .allowExternalPrincipals)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let featureSet = self.featureSet {
            try encodeContainer.encode(featureSet.rawValue, forKey: .featureSet)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owningAccountId = self.owningAccountId {
            try encodeContainer.encode(owningAccountId, forKey: .owningAccountId)
        }
        if let resourceShareArn = self.resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let owningAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owningAccountId)
        owningAccountId = owningAccountIdDecoded
        let allowExternalPrincipalsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowExternalPrincipals)
        allowExternalPrincipals = allowExternalPrincipalsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceShareStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([RAMClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RAMClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RAMClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let featureSetDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceShareFeatureSet.self, forKey: .featureSet)
        featureSet = featureSetDecoded
    }
}

extension RAMClientTypes {
    /// Describes a resource share in RAM.
    public struct ResourceShare: Swift.Equatable {
        /// Indicates whether principals outside your organization in Organizations can be associated with a resource share.
        public var allowExternalPrincipals: Swift.Bool?
        /// The date and time when the resource share was created.
        public var creationTime: ClientRuntime.Date?
        /// Indicates how the resource share was created. Possible values include:
        ///
        /// * CREATED_FROM_POLICY - Indicates that the resource share was created from an Identity and Access Management (IAM) resource-based permission policy attached to the resource. This type of resource share is visible only to the Amazon Web Services account that created it. You can't modify it in RAM unless you promote it. For more information, see [PromoteResourceShareCreatedFromPolicy].
        ///
        /// * PROMOTING_TO_STANDARD - The resource share is in the process of being promoted. For more information, see [PromoteResourceShareCreatedFromPolicy].
        ///
        /// * STANDARD - Indicates that the resource share was created in RAM using the console or APIs. These resource shares are visible to all principals you share the resource share with. You can modify these resource shares in RAM using the console or APIs.
        public var featureSet: RAMClientTypes.ResourceShareFeatureSet?
        /// The date and time when the resource share was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The name of the resource share.
        public var name: Swift.String?
        /// The ID of the Amazon Web Services account that owns the resource share.
        public var owningAccountId: Swift.String?
        /// The [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource share
        public var resourceShareArn: Swift.String?
        /// The current status of the resource share.
        public var status: RAMClientTypes.ResourceShareStatus?
        /// A message about the status of the resource share.
        public var statusMessage: Swift.String?
        /// The tag key and value pairs attached to the resource share.
        public var tags: [RAMClientTypes.Tag]?

        public init (
            allowExternalPrincipals: Swift.Bool? = nil,
            creationTime: ClientRuntime.Date? = nil,
            featureSet: RAMClientTypes.ResourceShareFeatureSet? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            owningAccountId: Swift.String? = nil,
            resourceShareArn: Swift.String? = nil,
            status: RAMClientTypes.ResourceShareStatus? = nil,
            statusMessage: Swift.String? = nil,
            tags: [RAMClientTypes.Tag]? = nil
        )
        {
            self.allowExternalPrincipals = allowExternalPrincipals
            self.creationTime = creationTime
            self.featureSet = featureSet
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.owningAccountId = owningAccountId
            self.resourceShareArn = resourceShareArn
            self.status = status
            self.statusMessage = statusMessage
            self.tags = tags
        }
    }

}

extension RAMClientTypes.ResourceShareAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedEntity
        case associationType
        case creationTime
        case external
        case lastUpdatedTime
        case resourceShareArn
        case resourceShareName
        case status
        case statusMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedEntity = self.associatedEntity {
            try encodeContainer.encode(associatedEntity, forKey: .associatedEntity)
        }
        if let associationType = self.associationType {
            try encodeContainer.encode(associationType.rawValue, forKey: .associationType)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let external = self.external {
            try encodeContainer.encode(external, forKey: .external)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let resourceShareArn = self.resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
        if let resourceShareName = self.resourceShareName {
            try encodeContainer.encode(resourceShareName, forKey: .resourceShareName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let resourceShareNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareName)
        resourceShareName = resourceShareNameDecoded
        let associatedEntityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedEntity)
        associatedEntity = associatedEntityDecoded
        let associationTypeDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceShareAssociationType.self, forKey: .associationType)
        associationType = associationTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceShareAssociationStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let externalDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .external)
        external = externalDecoded
    }
}

extension RAMClientTypes {
    /// Describes an association with a resource share and either a principal or a resource.
    public struct ResourceShareAssociation: Swift.Equatable {
        /// The associated entity. This can be either of the following:
        ///
        /// * For a resource association, this is the [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource.
        ///
        /// * For principal associations, this is one of the following:
        ///
        /// * The ID of an Amazon Web Services account
        ///
        /// * The [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of an organization in Organizations
        ///
        /// * The ARN of an organizational unit (OU) in Organizations
        ///
        /// * The ARN of an IAM role
        ///
        /// * The ARN of an IAM user
        public var associatedEntity: Swift.String?
        /// The type of entity included in this association.
        public var associationType: RAMClientTypes.ResourceShareAssociationType?
        /// The date and time when the association was created.
        public var creationTime: ClientRuntime.Date?
        /// Indicates whether the principal belongs to the same organization in Organizations as the Amazon Web Services account that owns the resource share.
        public var external: Swift.Bool?
        /// The date and time when the association was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource share.
        public var resourceShareArn: Swift.String?
        /// The name of the resource share.
        public var resourceShareName: Swift.String?
        /// The current status of the association.
        public var status: RAMClientTypes.ResourceShareAssociationStatus?
        /// A message about the status of the association.
        public var statusMessage: Swift.String?

        public init (
            associatedEntity: Swift.String? = nil,
            associationType: RAMClientTypes.ResourceShareAssociationType? = nil,
            creationTime: ClientRuntime.Date? = nil,
            external: Swift.Bool? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            resourceShareArn: Swift.String? = nil,
            resourceShareName: Swift.String? = nil,
            status: RAMClientTypes.ResourceShareAssociationStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.associatedEntity = associatedEntity
            self.associationType = associationType
            self.creationTime = creationTime
            self.external = external
            self.lastUpdatedTime = lastUpdatedTime
            self.resourceShareArn = resourceShareArn
            self.resourceShareName = resourceShareName
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension RAMClientTypes {
    public enum ResourceShareAssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case associated
        case associating
        case disassociated
        case disassociating
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceShareAssociationStatus] {
            return [
                .associated,
                .associating,
                .disassociated,
                .disassociating,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .associated: return "ASSOCIATED"
            case .associating: return "ASSOCIATING"
            case .disassociated: return "DISASSOCIATED"
            case .disassociating: return "DISASSOCIATING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceShareAssociationStatus(rawValue: rawValue) ?? ResourceShareAssociationStatus.sdkUnknown(rawValue)
        }
    }
}

extension RAMClientTypes {
    public enum ResourceShareAssociationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case principal
        case resource
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceShareAssociationType] {
            return [
                .principal,
                .resource,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .principal: return "PRINCIPAL"
            case .resource: return "RESOURCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceShareAssociationType(rawValue: rawValue) ?? ResourceShareAssociationType.sdkUnknown(rawValue)
        }
    }
}

extension RAMClientTypes {
    public enum ResourceShareFeatureSet: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createdFromPolicy
        case promotingToStandard
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceShareFeatureSet] {
            return [
                .createdFromPolicy,
                .promotingToStandard,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createdFromPolicy: return "CREATED_FROM_POLICY"
            case .promotingToStandard: return "PROMOTING_TO_STANDARD"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceShareFeatureSet(rawValue: rawValue) ?? ResourceShareFeatureSet.sdkUnknown(rawValue)
        }
    }
}

extension RAMClientTypes.ResourceShareInvitation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invitationTimestamp
        case receiverAccountId
        case receiverArn
        case resourceShareArn
        case resourceShareAssociations
        case resourceShareInvitationArn
        case resourceShareName
        case senderAccountId
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invitationTimestamp = self.invitationTimestamp {
            try encodeContainer.encodeTimestamp(invitationTimestamp, format: .epochSeconds, forKey: .invitationTimestamp)
        }
        if let receiverAccountId = self.receiverAccountId {
            try encodeContainer.encode(receiverAccountId, forKey: .receiverAccountId)
        }
        if let receiverArn = self.receiverArn {
            try encodeContainer.encode(receiverArn, forKey: .receiverArn)
        }
        if let resourceShareArn = self.resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
        if let resourceShareAssociations = resourceShareAssociations {
            var resourceShareAssociationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceShareAssociations)
            for resourceshareassociation0 in resourceShareAssociations {
                try resourceShareAssociationsContainer.encode(resourceshareassociation0)
            }
        }
        if let resourceShareInvitationArn = self.resourceShareInvitationArn {
            try encodeContainer.encode(resourceShareInvitationArn, forKey: .resourceShareInvitationArn)
        }
        if let resourceShareName = self.resourceShareName {
            try encodeContainer.encode(resourceShareName, forKey: .resourceShareName)
        }
        if let senderAccountId = self.senderAccountId {
            try encodeContainer.encode(senderAccountId, forKey: .senderAccountId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareInvitationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareInvitationArn)
        resourceShareInvitationArn = resourceShareInvitationArnDecoded
        let resourceShareNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareName)
        resourceShareName = resourceShareNameDecoded
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let senderAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .senderAccountId)
        senderAccountId = senderAccountIdDecoded
        let receiverAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .receiverAccountId)
        receiverAccountId = receiverAccountIdDecoded
        let invitationTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .invitationTimestamp)
        invitationTimestamp = invitationTimestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceShareInvitationStatus.self, forKey: .status)
        status = statusDecoded
        let resourceShareAssociationsContainer = try containerValues.decodeIfPresent([RAMClientTypes.ResourceShareAssociation?].self, forKey: .resourceShareAssociations)
        var resourceShareAssociationsDecoded0:[RAMClientTypes.ResourceShareAssociation]? = nil
        if let resourceShareAssociationsContainer = resourceShareAssociationsContainer {
            resourceShareAssociationsDecoded0 = [RAMClientTypes.ResourceShareAssociation]()
            for structure0 in resourceShareAssociationsContainer {
                if let structure0 = structure0 {
                    resourceShareAssociationsDecoded0?.append(structure0)
                }
            }
        }
        resourceShareAssociations = resourceShareAssociationsDecoded0
        let receiverArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .receiverArn)
        receiverArn = receiverArnDecoded
    }
}

extension RAMClientTypes {
    /// Describes an invitation for an Amazon Web Services account to join a resource share.
    public struct ResourceShareInvitation: Swift.Equatable {
        /// The date and time when the invitation was sent.
        public var invitationTimestamp: ClientRuntime.Date?
        /// The ID of the Amazon Web Services account that received the invitation.
        public var receiverAccountId: Swift.String?
        /// The [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the IAM user or role that received the invitation.
        public var receiverArn: Swift.String?
        /// The [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource share
        public var resourceShareArn: Swift.String?
        /// To view the resources associated with a pending resource share invitation, use [ListPendingInvitationResources].
        @available(*, deprecated, message: "This member has been deprecated. Use ListPendingInvitationResources.")
        public var resourceShareAssociations: [RAMClientTypes.ResourceShareAssociation]?
        /// The [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the invitation.
        public var resourceShareInvitationArn: Swift.String?
        /// The name of the resource share.
        public var resourceShareName: Swift.String?
        /// The ID of the Amazon Web Services account that sent the invitation.
        public var senderAccountId: Swift.String?
        /// The current status of the invitation.
        public var status: RAMClientTypes.ResourceShareInvitationStatus?

        public init (
            invitationTimestamp: ClientRuntime.Date? = nil,
            receiverAccountId: Swift.String? = nil,
            receiverArn: Swift.String? = nil,
            resourceShareArn: Swift.String? = nil,
            resourceShareAssociations: [RAMClientTypes.ResourceShareAssociation]? = nil,
            resourceShareInvitationArn: Swift.String? = nil,
            resourceShareName: Swift.String? = nil,
            senderAccountId: Swift.String? = nil,
            status: RAMClientTypes.ResourceShareInvitationStatus? = nil
        )
        {
            self.invitationTimestamp = invitationTimestamp
            self.receiverAccountId = receiverAccountId
            self.receiverArn = receiverArn
            self.resourceShareArn = resourceShareArn
            self.resourceShareAssociations = resourceShareAssociations
            self.resourceShareInvitationArn = resourceShareInvitationArn
            self.resourceShareName = resourceShareName
            self.senderAccountId = senderAccountId
            self.status = status
        }
    }

}

extension ResourceShareInvitationAlreadyAcceptedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceShareInvitationAlreadyAcceptedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified invitation was already accepted.
public struct ResourceShareInvitationAlreadyAcceptedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceShareInvitationAlreadyAcceptedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceShareInvitationAlreadyAcceptedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceShareInvitationAlreadyRejectedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceShareInvitationAlreadyRejectedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified invitation was already rejected.
public struct ResourceShareInvitationAlreadyRejectedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceShareInvitationAlreadyRejectedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceShareInvitationAlreadyRejectedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceShareInvitationArnNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceShareInvitationArnNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified Amazon Resource Name (ARN) for an invitation was not found.
public struct ResourceShareInvitationArnNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceShareInvitationArnNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceShareInvitationArnNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceShareInvitationExpiredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceShareInvitationExpiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified invitation is expired.
public struct ResourceShareInvitationExpiredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceShareInvitationExpiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceShareInvitationExpiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RAMClientTypes {
    public enum ResourceShareInvitationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accepted
        case expired
        case pending
        case rejected
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceShareInvitationStatus] {
            return [
                .accepted,
                .expired,
                .pending,
                .rejected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accepted: return "ACCEPTED"
            case .expired: return "EXPIRED"
            case .pending: return "PENDING"
            case .rejected: return "REJECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceShareInvitationStatus(rawValue: rawValue) ?? ResourceShareInvitationStatus.sdkUnknown(rawValue)
        }
    }
}

extension ResourceShareLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceShareLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This request would exceed the limit for resource shares for your account.
public struct ResourceShareLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceShareLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceShareLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RAMClientTypes.ResourceSharePermissionDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case defaultVersion
        case isResourceTypeDefault
        case lastUpdatedTime
        case name
        case permission
        case resourceType
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let defaultVersion = self.defaultVersion {
            try encodeContainer.encode(defaultVersion, forKey: .defaultVersion)
        }
        if let isResourceTypeDefault = self.isResourceTypeDefault {
            try encodeContainer.encode(isResourceTypeDefault, forKey: .isResourceTypeDefault)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permission = self.permission {
            try encodeContainer.encode(permission, forKey: .permission)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let defaultVersionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .defaultVersion)
        defaultVersion = defaultVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let permissionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permission)
        permission = permissionDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let isResourceTypeDefaultDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isResourceTypeDefault)
        isResourceTypeDefault = isResourceTypeDefaultDecoded
    }
}

extension RAMClientTypes {
    /// Information about an RAM permission.
    public struct ResourceSharePermissionDetail: Swift.Equatable {
        /// The [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of this RAM permission.
        public var arn: Swift.String?
        /// The date and time when the permission was created.
        public var creationTime: ClientRuntime.Date?
        /// Specifies whether the version of the permission represented in this structure is the default version for this permission.
        public var defaultVersion: Swift.Bool?
        /// Specifies whether the version of the permission represented in this structure is the default version for all resources of this resource type.
        public var isResourceTypeDefault: Swift.Bool?
        /// The date and time when the permission was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The name of this permission.
        public var name: Swift.String?
        /// The permission's effect and actions in JSON format. The effect indicates whether the specified actions are allowed or denied. The actions list the operations to which the principal is granted or denied access.
        public var permission: Swift.String?
        /// The resource type to which this permission applies.
        public var resourceType: Swift.String?
        /// The version of the permission represented in this structure.
        public var version: Swift.String?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            defaultVersion: Swift.Bool? = nil,
            isResourceTypeDefault: Swift.Bool? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            permission: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.defaultVersion = defaultVersion
            self.isResourceTypeDefault = isResourceTypeDefault
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.permission = permission
            self.resourceType = resourceType
            self.version = version
        }
    }

}

extension RAMClientTypes.ResourceSharePermissionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case defaultVersion
        case isResourceTypeDefault
        case lastUpdatedTime
        case name
        case resourceType
        case status
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let defaultVersion = self.defaultVersion {
            try encodeContainer.encode(defaultVersion, forKey: .defaultVersion)
        }
        if let isResourceTypeDefault = self.isResourceTypeDefault {
            try encodeContainer.encode(isResourceTypeDefault, forKey: .isResourceTypeDefault)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let defaultVersionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .defaultVersion)
        defaultVersion = defaultVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let isResourceTypeDefaultDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isResourceTypeDefault)
        isResourceTypeDefault = isResourceTypeDefaultDecoded
    }
}

extension RAMClientTypes {
    /// Information about an RAM permission that is associated with a resource share and any of its resources of a specified type.
    public struct ResourceSharePermissionSummary: Swift.Equatable {
        /// The [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the permission you want information about.
        public var arn: Swift.String?
        /// The date and time when the permission was created.
        public var creationTime: ClientRuntime.Date?
        /// Specifies whether the version of the permission represented in this structure is the default version for this permission.
        public var defaultVersion: Swift.Bool?
        /// Specifies whether the version of the permission represented in this structure is the default version for all resources of this resource type.
        public var isResourceTypeDefault: Swift.Bool?
        /// The date and time when the permission was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The name of this permission.
        public var name: Swift.String?
        /// The type of resource to which this permission applies.
        public var resourceType: Swift.String?
        /// The current status of the permission.
        public var status: Swift.String?
        /// The version of the permission represented in this structure.
        public var version: Swift.String?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            defaultVersion: Swift.Bool? = nil,
            isResourceTypeDefault: Swift.Bool? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            status: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.defaultVersion = defaultVersion
            self.isResourceTypeDefault = isResourceTypeDefault
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.resourceType = resourceType
            self.status = status
            self.version = version
        }
    }

}

extension RAMClientTypes {
    public enum ResourceShareStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleted
        case deleting
        case failed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceShareStatus] {
            return [
                .active,
                .deleted,
                .deleting,
                .failed,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceShareStatus(rawValue: rawValue) ?? ResourceShareStatus.sdkUnknown(rawValue)
        }
    }
}

extension RAMClientTypes {
    public enum ResourceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case limitExceeded
        case pending
        case unavailable
        case zonalResourceInaccessible
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceStatus] {
            return [
                .available,
                .limitExceeded,
                .pending,
                .unavailable,
                .zonalResourceInaccessible,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .limitExceeded: return "LIMIT_EXCEEDED"
            case .pending: return "PENDING"
            case .unavailable: return "UNAVAILABLE"
            case .zonalResourceInaccessible: return "ZONAL_RESOURCE_INACCESSIBLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceStatus(rawValue: rawValue) ?? ResourceStatus.sdkUnknown(rawValue)
        }
    }
}

extension ServerInternalException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServerInternalExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service could not respond to the request due to an internal problem.
public struct ServerInternalException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServerInternalExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServerInternalExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RAMClientTypes.ServiceNameAndResourceType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceRegionScope
        case resourceType
        case serviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceRegionScope = self.resourceRegionScope {
            try encodeContainer.encode(resourceRegionScope.rawValue, forKey: .resourceRegionScope)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let resourceRegionScopeDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceRegionScope.self, forKey: .resourceRegionScope)
        resourceRegionScope = resourceRegionScopeDecoded
    }
}

extension RAMClientTypes {
    /// Information about a shareable resource type and the Amazon Web Services service to which resources of that type belong.
    public struct ServiceNameAndResourceType: Swift.Equatable {
        /// Specifies the scope of visibility of resources of this type:
        ///
        /// * REGIONAL – The resource can be accessed only by using requests that target the Amazon Web Services Region in which the resource exists.
        ///
        /// * GLOBAL – The resource can be accessed from any Amazon Web Services Region.
        public var resourceRegionScope: RAMClientTypes.ResourceRegionScope?
        /// The type of the resource.
        public var resourceType: Swift.String?
        /// The name of the Amazon Web Services service to which resources of this type belong.
        public var serviceName: Swift.String?

        public init (
            resourceRegionScope: RAMClientTypes.ResourceRegionScope? = nil,
            resourceType: Swift.String? = nil,
            serviceName: Swift.String? = nil
        )
        {
            self.resourceRegionScope = resourceRegionScope
            self.resourceType = resourceType
            self.serviceName = serviceName
        }
    }

}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service is not available.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RAMClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension RAMClientTypes {
    /// A structure containing a tag. A tag is metadata that you can attach to your resources to help organize and categorize them. You can also use them to help you secure your resources. For more information, see [Controlling access to Amazon Web Services resources using tags](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_tags.html). For more information about tags, see [Tagging Amazon Web Services resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) in the Amazon Web Services General Reference Guide.
    public struct Tag: Swift.Equatable {
        /// The key, or name, attached to the tag. Every tag must have a key. Key names are case sensitive.
        public var key: Swift.String?
        /// The string value attached to the tag. The value can be an empty string. Key values are case sensitive.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension RAMClientTypes.TagFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKey
        case tagValues
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKey = self.tagKey {
            try encodeContainer.encode(tagKey, forKey: .tagKey)
        }
        if let tagValues = tagValues {
            var tagValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagValues)
            for tagvalue0 in tagValues {
                try tagValuesContainer.encode(tagvalue0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
        let tagValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagValues)
        var tagValuesDecoded0:[Swift.String]? = nil
        if let tagValuesContainer = tagValuesContainer {
            tagValuesDecoded0 = [Swift.String]()
            for string0 in tagValuesContainer {
                if let string0 = string0 {
                    tagValuesDecoded0?.append(string0)
                }
            }
        }
        tagValues = tagValuesDecoded0
    }
}

extension RAMClientTypes {
    /// A tag key and optional list of possible values that you can use to filter results for tagged resources.
    public struct TagFilter: Swift.Equatable {
        /// The tag key. This must have a valid string value and can't be empty.
        public var tagKey: Swift.String?
        /// A list of zero or more tag values. If no values are provided, then the filter matches any tag with the specified key, regardless of its value.
        public var tagValues: [Swift.String]?

        public init (
            tagKey: Swift.String? = nil,
            tagValues: [Swift.String]? = nil
        )
        {
            self.tagKey = tagKey
            self.tagValues = tagValues
        }
    }

}

extension TagLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TagLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This request would exceed the limit for tags for your account.
public struct TagLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TagLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TagLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagPolicyViolationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TagPolicyViolationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified tag key is a reserved word and can't be used.
public struct TagPolicyViolationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TagPolicyViolationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TagPolicyViolationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceShareArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceShareArn = self.resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tagresource"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// Specifies the [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource share that you want to add tags to.
    /// This member is required.
    public var resourceShareArn: Swift.String?
    /// A list of one or more tag key and value pairs. The tag key must be present and not be an empty string. The tag value must be present but can be an empty string.
    /// This member is required.
    public var tags: [RAMClientTypes.Tag]?

    public init (
        resourceShareArn: Swift.String? = nil,
        tags: [RAMClientTypes.Tag]? = nil
    )
    {
        self.resourceShareArn = resourceShareArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceShareArn: Swift.String?
    let tags: [RAMClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceShareArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([RAMClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[RAMClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [RAMClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceArn.NotFound" : self = .resourceArnNotFoundException(try ResourceArnNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagLimitExceeded" : self = .tagLimitExceededException(try TagLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagPolicyViolation" : self = .tagPolicyViolationException(try TagPolicyViolationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareArn.NotFound" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case resourceArnNotFoundException(ResourceArnNotFoundException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tagLimitExceededException(TagLimitExceededException)
    case tagPolicyViolationException(TagPolicyViolationException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You exceeded the rate at which you are allowed to perform this operation. Please try again later.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnknownResourceException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UnknownResourceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A specified resource was not found.
public struct UnknownResourceException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnknownResourceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnknownResourceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceShareArn
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceShareArn = self.resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/untagresource"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// Specifies the [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource share that you want to remove tags from. The tags are removed from the resource share, not the resources in the resource share.
    /// This member is required.
    public var resourceShareArn: Swift.String?
    /// Specifies a list of one or more tag keys that you want to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceShareArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceShareArn = resourceShareArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceShareArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceShareArn
        case tagKeys
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateResourceShareInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowExternalPrincipals
        case clientToken
        case name
        case resourceShareArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowExternalPrincipals = self.allowExternalPrincipals {
            try encodeContainer.encode(allowExternalPrincipals, forKey: .allowExternalPrincipals)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceShareArn = self.resourceShareArn {
            try encodeContainer.encode(resourceShareArn, forKey: .resourceShareArn)
        }
    }
}

extension UpdateResourceShareInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateresourceshare"
    }
}

public struct UpdateResourceShareInput: Swift.Equatable {
    /// Specifies whether principals outside your organization in Organizations can be associated with a resource share.
    public var allowExternalPrincipals: Swift.Bool?
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value.](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you.
    public var clientToken: Swift.String?
    /// If specified, the new name that you want to attach to the resource share.
    public var name: Swift.String?
    /// Specifies the [Amazon Resoure Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource share that you want to modify.
    /// This member is required.
    public var resourceShareArn: Swift.String?

    public init (
        allowExternalPrincipals: Swift.Bool? = nil,
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        resourceShareArn: Swift.String? = nil
    )
    {
        self.allowExternalPrincipals = allowExternalPrincipals
        self.clientToken = clientToken
        self.name = name
        self.resourceShareArn = resourceShareArn
    }
}

struct UpdateResourceShareInputBody: Swift.Equatable {
    let resourceShareArn: Swift.String?
    let name: Swift.String?
    let allowExternalPrincipals: Swift.Bool?
    let clientToken: Swift.String?
}

extension UpdateResourceShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowExternalPrincipals
        case clientToken
        case name
        case resourceShareArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceShareArn)
        resourceShareArn = resourceShareArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let allowExternalPrincipalsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowExternalPrincipals)
        allowExternalPrincipals = allowExternalPrincipalsDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateResourceShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResourceShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IdempotentParameterMismatch" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClientToken" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameter" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArn.Malformed" : self = .malformedArnException(try MalformedArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingRequiredParameter" : self = .missingRequiredParameterException(try MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermitted" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalError" : self = .serverInternalException(try ServerInternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Unavailable" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceShareArn.NotFound" : self = .unknownResourceException(try UnknownResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateResourceShareOutputError: Swift.Error, Swift.Equatable {
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidClientTokenException(InvalidClientTokenException)
    case invalidParameterException(InvalidParameterException)
    case malformedArnException(MalformedArnException)
    case missingRequiredParameterException(MissingRequiredParameterException)
    case operationNotPermittedException(OperationNotPermittedException)
    case serverInternalException(ServerInternalException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknownResourceException(UnknownResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResourceShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateResourceShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.resourceShare = output.resourceShare
        } else {
            self.clientToken = nil
            self.resourceShare = nil
        }
    }
}

public struct UpdateResourceShareOutputResponse: Swift.Equatable {
    /// The idempotency identifier associated with this request. If you want to repeat the same operation in an idempotent manner then you must include this value in the clientToken request parameter of that later call. All other parameters must also have the same values that you used in the first call.
    public var clientToken: Swift.String?
    /// Information about the resource share.
    public var resourceShare: RAMClientTypes.ResourceShare?

    public init (
        clientToken: Swift.String? = nil,
        resourceShare: RAMClientTypes.ResourceShare? = nil
    )
    {
        self.clientToken = clientToken
        self.resourceShare = resourceShare
    }
}

struct UpdateResourceShareOutputResponseBody: Swift.Equatable {
    let resourceShare: RAMClientTypes.ResourceShare?
    let clientToken: Swift.String?
}

extension UpdateResourceShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case resourceShare
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceShareDecoded = try containerValues.decodeIfPresent(RAMClientTypes.ResourceShare.self, forKey: .resourceShare)
        resourceShare = resourceShareDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}
