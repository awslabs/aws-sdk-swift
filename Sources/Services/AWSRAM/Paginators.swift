// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension RAMClient {
    /// Paginate over `[GetResourcePoliciesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetResourcePoliciesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetResourcePoliciesOutputResponse`
    public func getResourcePoliciesPaginated(input: GetResourcePoliciesInput) -> ClientRuntime.PaginatorSequence<GetResourcePoliciesInput, GetResourcePoliciesOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetResourcePoliciesInput, GetResourcePoliciesOutputResponse>(input: input, inputKey: \GetResourcePoliciesInput.nextToken, outputKey: \GetResourcePoliciesOutputResponse.nextToken, paginationFunction: self.getResourcePolicies(input:))
    }
}

extension GetResourcePoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetResourcePoliciesInput {
        return GetResourcePoliciesInput(
            maxResults: self.maxResults,
            nextToken: token,
            principal: self.principal,
            resourceArns: self.resourceArns
        )}
}
extension RAMClient {
    /// Paginate over `[GetResourceShareAssociationsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetResourceShareAssociationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetResourceShareAssociationsOutputResponse`
    public func getResourceShareAssociationsPaginated(input: GetResourceShareAssociationsInput) -> ClientRuntime.PaginatorSequence<GetResourceShareAssociationsInput, GetResourceShareAssociationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetResourceShareAssociationsInput, GetResourceShareAssociationsOutputResponse>(input: input, inputKey: \GetResourceShareAssociationsInput.nextToken, outputKey: \GetResourceShareAssociationsOutputResponse.nextToken, paginationFunction: self.getResourceShareAssociations(input:))
    }
}

extension GetResourceShareAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetResourceShareAssociationsInput {
        return GetResourceShareAssociationsInput(
            associationStatus: self.associationStatus,
            associationType: self.associationType,
            maxResults: self.maxResults,
            nextToken: token,
            principal: self.principal,
            resourceArn: self.resourceArn,
            resourceShareArns: self.resourceShareArns
        )}
}
extension RAMClient {
    /// Paginate over `[GetResourceShareInvitationsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetResourceShareInvitationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetResourceShareInvitationsOutputResponse`
    public func getResourceShareInvitationsPaginated(input: GetResourceShareInvitationsInput) -> ClientRuntime.PaginatorSequence<GetResourceShareInvitationsInput, GetResourceShareInvitationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetResourceShareInvitationsInput, GetResourceShareInvitationsOutputResponse>(input: input, inputKey: \GetResourceShareInvitationsInput.nextToken, outputKey: \GetResourceShareInvitationsOutputResponse.nextToken, paginationFunction: self.getResourceShareInvitations(input:))
    }
}

extension GetResourceShareInvitationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetResourceShareInvitationsInput {
        return GetResourceShareInvitationsInput(
            maxResults: self.maxResults,
            nextToken: token,
            resourceShareArns: self.resourceShareArns,
            resourceShareInvitationArns: self.resourceShareInvitationArns
        )}
}
extension RAMClient {
    /// Paginate over `[GetResourceSharesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetResourceSharesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetResourceSharesOutputResponse`
    public func getResourceSharesPaginated(input: GetResourceSharesInput) -> ClientRuntime.PaginatorSequence<GetResourceSharesInput, GetResourceSharesOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetResourceSharesInput, GetResourceSharesOutputResponse>(input: input, inputKey: \GetResourceSharesInput.nextToken, outputKey: \GetResourceSharesOutputResponse.nextToken, paginationFunction: self.getResourceShares(input:))
    }
}

extension GetResourceSharesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetResourceSharesInput {
        return GetResourceSharesInput(
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token,
            permissionArn: self.permissionArn,
            resourceOwner: self.resourceOwner,
            resourceShareArns: self.resourceShareArns,
            resourceShareStatus: self.resourceShareStatus,
            tagFilters: self.tagFilters
        )}
}
extension RAMClient {
    /// Paginate over `[ListPendingInvitationResourcesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPendingInvitationResourcesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPendingInvitationResourcesOutputResponse`
    public func listPendingInvitationResourcesPaginated(input: ListPendingInvitationResourcesInput) -> ClientRuntime.PaginatorSequence<ListPendingInvitationResourcesInput, ListPendingInvitationResourcesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListPendingInvitationResourcesInput, ListPendingInvitationResourcesOutputResponse>(input: input, inputKey: \ListPendingInvitationResourcesInput.nextToken, outputKey: \ListPendingInvitationResourcesOutputResponse.nextToken, paginationFunction: self.listPendingInvitationResources(input:))
    }
}

extension ListPendingInvitationResourcesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPendingInvitationResourcesInput {
        return ListPendingInvitationResourcesInput(
            maxResults: self.maxResults,
            nextToken: token,
            resourceRegionScope: self.resourceRegionScope,
            resourceShareInvitationArn: self.resourceShareInvitationArn
        )}
}
extension RAMClient {
    /// Paginate over `[ListPermissionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPermissionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPermissionsOutputResponse`
    public func listPermissionsPaginated(input: ListPermissionsInput) -> ClientRuntime.PaginatorSequence<ListPermissionsInput, ListPermissionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListPermissionsInput, ListPermissionsOutputResponse>(input: input, inputKey: \ListPermissionsInput.nextToken, outputKey: \ListPermissionsOutputResponse.nextToken, paginationFunction: self.listPermissions(input:))
    }
}

extension ListPermissionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPermissionsInput {
        return ListPermissionsInput(
            maxResults: self.maxResults,
            nextToken: token,
            resourceType: self.resourceType
        )}
}
extension RAMClient {
    /// Paginate over `[ListPermissionVersionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPermissionVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPermissionVersionsOutputResponse`
    public func listPermissionVersionsPaginated(input: ListPermissionVersionsInput) -> ClientRuntime.PaginatorSequence<ListPermissionVersionsInput, ListPermissionVersionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListPermissionVersionsInput, ListPermissionVersionsOutputResponse>(input: input, inputKey: \ListPermissionVersionsInput.nextToken, outputKey: \ListPermissionVersionsOutputResponse.nextToken, paginationFunction: self.listPermissionVersions(input:))
    }
}

extension ListPermissionVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPermissionVersionsInput {
        return ListPermissionVersionsInput(
            maxResults: self.maxResults,
            nextToken: token,
            permissionArn: self.permissionArn
        )}
}
extension RAMClient {
    /// Paginate over `[ListPrincipalsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPrincipalsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPrincipalsOutputResponse`
    public func listPrincipalsPaginated(input: ListPrincipalsInput) -> ClientRuntime.PaginatorSequence<ListPrincipalsInput, ListPrincipalsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListPrincipalsInput, ListPrincipalsOutputResponse>(input: input, inputKey: \ListPrincipalsInput.nextToken, outputKey: \ListPrincipalsOutputResponse.nextToken, paginationFunction: self.listPrincipals(input:))
    }
}

extension ListPrincipalsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPrincipalsInput {
        return ListPrincipalsInput(
            maxResults: self.maxResults,
            nextToken: token,
            principals: self.principals,
            resourceArn: self.resourceArn,
            resourceOwner: self.resourceOwner,
            resourceShareArns: self.resourceShareArns,
            resourceType: self.resourceType
        )}
}
extension RAMClient {
    /// Paginate over `[ListResourcesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResourcesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResourcesOutputResponse`
    public func listResourcesPaginated(input: ListResourcesInput) -> ClientRuntime.PaginatorSequence<ListResourcesInput, ListResourcesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListResourcesInput, ListResourcesOutputResponse>(input: input, inputKey: \ListResourcesInput.nextToken, outputKey: \ListResourcesOutputResponse.nextToken, paginationFunction: self.listResources(input:))
    }
}

extension ListResourcesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResourcesInput {
        return ListResourcesInput(
            maxResults: self.maxResults,
            nextToken: token,
            principal: self.principal,
            resourceArns: self.resourceArns,
            resourceOwner: self.resourceOwner,
            resourceRegionScope: self.resourceRegionScope,
            resourceShareArns: self.resourceShareArns,
            resourceType: self.resourceType
        )}
}
extension RAMClient {
    /// Paginate over `[ListResourceSharePermissionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResourceSharePermissionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResourceSharePermissionsOutputResponse`
    public func listResourceSharePermissionsPaginated(input: ListResourceSharePermissionsInput) -> ClientRuntime.PaginatorSequence<ListResourceSharePermissionsInput, ListResourceSharePermissionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListResourceSharePermissionsInput, ListResourceSharePermissionsOutputResponse>(input: input, inputKey: \ListResourceSharePermissionsInput.nextToken, outputKey: \ListResourceSharePermissionsOutputResponse.nextToken, paginationFunction: self.listResourceSharePermissions(input:))
    }
}

extension ListResourceSharePermissionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResourceSharePermissionsInput {
        return ListResourceSharePermissionsInput(
            maxResults: self.maxResults,
            nextToken: token,
            resourceShareArn: self.resourceShareArn
        )}
}
extension RAMClient {
    /// Paginate over `[ListResourceTypesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResourceTypesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResourceTypesOutputResponse`
    public func listResourceTypesPaginated(input: ListResourceTypesInput) -> ClientRuntime.PaginatorSequence<ListResourceTypesInput, ListResourceTypesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListResourceTypesInput, ListResourceTypesOutputResponse>(input: input, inputKey: \ListResourceTypesInput.nextToken, outputKey: \ListResourceTypesOutputResponse.nextToken, paginationFunction: self.listResourceTypes(input:))
    }
}

extension ListResourceTypesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResourceTypesInput {
        return ListResourceTypesInput(
            maxResults: self.maxResults,
            nextToken: token,
            resourceRegionScope: self.resourceRegionScope
        )}
}
