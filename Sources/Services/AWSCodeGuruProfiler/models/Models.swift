// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension CodeGuruProfilerClientTypes {
    public enum ActionGroup: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Permission group type for Agent APIs - ConfigureAgent, PostAgentProfile
        case agentPermissions
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionGroup] {
            return [
                .agentPermissions,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agentPermissions: return "agentPermissions"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActionGroup(rawValue: rawValue) ?? ActionGroup.sdkUnknown(rawValue)
        }
    }
}

extension AddNotificationChannelsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channels = channels {
            var channelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .channels)
            for channel0 in channels {
                try channelsContainer.encode(channel0)
            }
        }
    }
}

extension AddNotificationChannelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profilingGroupName = profilingGroupName else {
            return nil
        }
        return "/profilingGroups/\(profilingGroupName.urlPercentEncoding())/notificationConfiguration"
    }
}

/// The structure representing the AddNotificationChannelsRequest.
public struct AddNotificationChannelsInput: Swift.Equatable {
    /// One or 2 channels to report to when anomalies are detected.
    /// This member is required.
    public var channels: [CodeGuruProfilerClientTypes.Channel]?
    /// The name of the profiling group that we are setting up notifications for.
    /// This member is required.
    public var profilingGroupName: Swift.String?

    public init(
        channels: [CodeGuruProfilerClientTypes.Channel]? = nil,
        profilingGroupName: Swift.String? = nil
    )
    {
        self.channels = channels
        self.profilingGroupName = profilingGroupName
    }
}

struct AddNotificationChannelsInputBody: Swift.Equatable {
    let channels: [CodeGuruProfilerClientTypes.Channel]?
}

extension AddNotificationChannelsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsContainer = try containerValues.decodeIfPresent([CodeGuruProfilerClientTypes.Channel?].self, forKey: .channels)
        var channelsDecoded0:[CodeGuruProfilerClientTypes.Channel]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [CodeGuruProfilerClientTypes.Channel]()
            for structure0 in channelsContainer {
                if let structure0 = structure0 {
                    channelsDecoded0?.append(structure0)
                }
            }
        }
        channels = channelsDecoded0
    }
}

extension AddNotificationChannelsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AddNotificationChannelsOutputBody = try responseDecoder.decode(responseBody: data)
            self.notificationConfiguration = output.notificationConfiguration
        } else {
            self.notificationConfiguration = nil
        }
    }
}

/// The structure representing the AddNotificationChannelsResponse.
public struct AddNotificationChannelsOutput: Swift.Equatable {
    /// The new notification configuration for this profiling group.
    public var notificationConfiguration: CodeGuruProfilerClientTypes.NotificationConfiguration?

    public init(
        notificationConfiguration: CodeGuruProfilerClientTypes.NotificationConfiguration? = nil
    )
    {
        self.notificationConfiguration = notificationConfiguration
    }
}

struct AddNotificationChannelsOutputBody: Swift.Equatable {
    let notificationConfiguration: CodeGuruProfilerClientTypes.NotificationConfiguration?
}

extension AddNotificationChannelsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationConfigurationDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.NotificationConfiguration.self, forKey: .notificationConfiguration)
        notificationConfiguration = notificationConfigurationDecoded
    }
}

enum AddNotificationChannelsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CodeGuruProfilerClientTypes.AgentConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentParameters
        case periodInSeconds
        case shouldProfile
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentParameters = agentParameters {
            var agentParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .agentParameters)
            for (dictKey0, agentParameters0) in agentParameters {
                try agentParametersContainer.encode(agentParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let periodInSeconds = self.periodInSeconds {
            try encodeContainer.encode(periodInSeconds, forKey: .periodInSeconds)
        }
        if let shouldProfile = self.shouldProfile {
            try encodeContainer.encode(shouldProfile, forKey: .shouldProfile)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shouldProfileDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .shouldProfile)
        shouldProfile = shouldProfileDecoded
        let periodInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .periodInSeconds)
        periodInSeconds = periodInSecondsDecoded
        let agentParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .agentParameters)
        var agentParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let agentParametersContainer = agentParametersContainer {
            agentParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in agentParametersContainer {
                if let string0 = string0 {
                    agentParametersDecoded0?[key0] = string0
                }
            }
        }
        agentParameters = agentParametersDecoded0
    }
}

extension CodeGuruProfilerClientTypes {
    /// The response of [ConfigureAgent](https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ConfigureAgent.html) that specifies if an agent profiles or not and for how long to return profiling data.
    public struct AgentConfiguration: Swift.Equatable {
        /// Parameters used by the profiler. The valid parameters are:
        ///
        /// * MaxStackDepth - The maximum depth of the stacks in the code that is represented in the profile. For example, if CodeGuru Profiler finds a method A, which calls method B, which calls method C, which calls method D, then the depth is 4. If the maxDepth is set to 2, then the profiler evaluates A and B.
        ///
        /// * MemoryUsageLimitPercent - The percentage of memory that is used by the profiler.
        ///
        /// * MinimumTimeForReportingInMilliseconds - The minimum time in milliseconds between sending reports.
        ///
        /// * ReportingIntervalInMilliseconds - The reporting interval in milliseconds used to report profiles.
        ///
        /// * SamplingIntervalInMilliseconds - The sampling interval in milliseconds that is used to profile samples.
        public var agentParameters: [Swift.String:Swift.String]?
        /// How long a profiling agent should send profiling data using [ConfigureAgent](https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ConfigureAgent.html). For example, if this is set to 300, the profiling agent calls [ConfigureAgent](https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ConfigureAgent.html) every 5 minutes to submit the profiled data collected during that period.
        /// This member is required.
        public var periodInSeconds: Swift.Int?
        /// A Boolean that specifies whether the profiling agent collects profiling data or not. Set to true to enable profiling.
        /// This member is required.
        public var shouldProfile: Swift.Bool?

        public init(
            agentParameters: [Swift.String:Swift.String]? = nil,
            periodInSeconds: Swift.Int? = nil,
            shouldProfile: Swift.Bool? = nil
        )
        {
            self.agentParameters = agentParameters
            self.periodInSeconds = periodInSeconds
            self.shouldProfile = shouldProfile
        }
    }

}

extension CodeGuruProfilerClientTypes.AgentOrchestrationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profilingEnabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let profilingEnabled = self.profilingEnabled {
            try encodeContainer.encode(profilingEnabled, forKey: .profilingEnabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profilingEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .profilingEnabled)
        profilingEnabled = profilingEnabledDecoded
    }
}

extension CodeGuruProfilerClientTypes {
    /// Specifies whether profiling is enabled or disabled for a profiling group. It is used by [ConfigureAgent](https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ConfigureAgent.html) to enable or disable profiling for a profiling group.
    public struct AgentOrchestrationConfig: Swift.Equatable {
        /// A Boolean that specifies whether the profiling agent collects profiling data or not. Set to true to enable profiling.
        /// This member is required.
        public var profilingEnabled: Swift.Bool?

        public init(
            profilingEnabled: Swift.Bool? = nil
        )
        {
            self.profilingEnabled = profilingEnabled
        }
    }

}

extension CodeGuruProfilerClientTypes {
    public enum AgentParameterField: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Maximum stack depth to be captured by the CodeGuru Profiler.
        case maxStackDepth
        /// Percentage of memory to be used by CodeGuru profiler. Minimum of 30MB is required for the agent.
        case memoryUsageLimitPercent
        /// Minimum time in milliseconds between sending reports.
        case minimumTimeForReportingInMilliseconds
        /// Reporting interval in milliseconds used to report profiles.
        case reportingIntervalInMilliseconds
        /// Sampling interval in milliseconds used to sample profiles.
        case samplingIntervalInMilliseconds
        case sdkUnknown(Swift.String)

        public static var allCases: [AgentParameterField] {
            return [
                .maxStackDepth,
                .memoryUsageLimitPercent,
                .minimumTimeForReportingInMilliseconds,
                .reportingIntervalInMilliseconds,
                .samplingIntervalInMilliseconds,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .maxStackDepth: return "MaxStackDepth"
            case .memoryUsageLimitPercent: return "MemoryUsageLimitPercent"
            case .minimumTimeForReportingInMilliseconds: return "MinimumTimeForReportingInMilliseconds"
            case .reportingIntervalInMilliseconds: return "ReportingIntervalInMilliseconds"
            case .samplingIntervalInMilliseconds: return "SamplingIntervalInMilliseconds"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AgentParameterField(rawValue: rawValue) ?? AgentParameterField.sdkUnknown(rawValue)
        }
    }
}

extension CodeGuruProfilerClientTypes.AggregatedProfileTime: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case period
        case start
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let period = self.period {
            try encodeContainer.encode(period.rawValue, forKey: .period)
        }
        if let start = self.start {
            try encodeContainer.encodeTimestamp(start, format: .dateTime, forKey: .start)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .start)
        start = startDecoded
        let periodDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.AggregationPeriod.self, forKey: .period)
        period = periodDecoded
    }
}

extension CodeGuruProfilerClientTypes {
    /// Specifies the aggregation period and aggregation start time for an aggregated profile. An aggregated profile is used to collect posted agent profiles during an aggregation period. There are three possible aggregation periods (1 day, 1 hour, or 5 minutes).
    public struct AggregatedProfileTime: Swift.Equatable {
        /// The aggregation period. This indicates the period during which an aggregation profile collects posted agent profiles for a profiling group. Use one of three valid durations that are specified using the ISO 8601 format.
        ///
        /// * P1D — 1 day
        ///
        /// * PT1H — 1 hour
        ///
        /// * PT5M — 5 minutes
        public var period: CodeGuruProfilerClientTypes.AggregationPeriod?
        /// The time that aggregation of posted agent profiles for a profiling group starts. The aggregation profile contains profiles posted by the agent starting at this time for an aggregation period specified by the period property of the AggregatedProfileTime object. Specify start using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        public var start: ClientRuntime.Date?

        public init(
            period: CodeGuruProfilerClientTypes.AggregationPeriod? = nil,
            start: ClientRuntime.Date? = nil
        )
        {
            self.period = period
            self.start = start
        }
    }

}

extension CodeGuruProfilerClientTypes {
    public enum AggregationPeriod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Period of one day.
        case p1d
        /// Period of one hour.
        case pt1h
        /// Period of five minutes.
        case pt5m
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregationPeriod] {
            return [
                .p1d,
                .pt1h,
                .pt5m,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .p1d: return "P1D"
            case .pt1h: return "PT1H"
            case .pt5m: return "PT5M"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AggregationPeriod(rawValue: rawValue) ?? AggregationPeriod.sdkUnknown(rawValue)
        }
    }
}

extension CodeGuruProfilerClientTypes.Anomaly: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instances
        case metric
        case reason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instances = instances {
            var instancesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instances)
            for anomalyinstance0 in instances {
                try instancesContainer.encode(anomalyinstance0)
            }
        }
        if let metric = self.metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.Metric.self, forKey: .metric)
        metric = metricDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
        let instancesContainer = try containerValues.decodeIfPresent([CodeGuruProfilerClientTypes.AnomalyInstance?].self, forKey: .instances)
        var instancesDecoded0:[CodeGuruProfilerClientTypes.AnomalyInstance]? = nil
        if let instancesContainer = instancesContainer {
            instancesDecoded0 = [CodeGuruProfilerClientTypes.AnomalyInstance]()
            for structure0 in instancesContainer {
                if let structure0 = structure0 {
                    instancesDecoded0?.append(structure0)
                }
            }
        }
        instances = instancesDecoded0
    }
}

extension CodeGuruProfilerClientTypes {
    /// Details about an anomaly in a specific metric of application profile. The anomaly is detected using analysis of the metric data over a period of time.
    public struct Anomaly: Swift.Equatable {
        /// A list of the instances of the detected anomalies during the requested period.
        /// This member is required.
        public var instances: [CodeGuruProfilerClientTypes.AnomalyInstance]?
        /// Details about the metric that the analysis used when it detected the anomaly. The metric includes the name of the frame that was analyzed with the type and thread states used to derive the metric value for that frame.
        /// This member is required.
        public var metric: CodeGuruProfilerClientTypes.Metric?
        /// The reason for which metric was flagged as anomalous.
        /// This member is required.
        public var reason: Swift.String?

        public init(
            instances: [CodeGuruProfilerClientTypes.AnomalyInstance]? = nil,
            metric: CodeGuruProfilerClientTypes.Metric? = nil,
            reason: Swift.String? = nil
        )
        {
            self.instances = instances
            self.metric = metric
            self.reason = reason
        }
    }

}

extension CodeGuruProfilerClientTypes.AnomalyInstance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case id
        case startTime
        case userFeedback
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .dateTime, forKey: .endTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
        if let userFeedback = self.userFeedback {
            try encodeContainer.encode(userFeedback, forKey: .userFeedback)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endTime)
        endTime = endTimeDecoded
        let userFeedbackDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.UserFeedback.self, forKey: .userFeedback)
        userFeedback = userFeedbackDecoded
    }
}

extension CodeGuruProfilerClientTypes {
    /// The specific duration in which the metric is flagged as anomalous.
    public struct AnomalyInstance: Swift.Equatable {
        /// The end time of the period during which the metric is flagged as anomalous. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        public var endTime: ClientRuntime.Date?
        /// The universally unique identifier (UUID) of an instance of an anomaly in a metric.
        /// This member is required.
        public var id: Swift.String?
        /// The start time of the period during which the metric is flagged as anomalous. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        /// This member is required.
        public var startTime: ClientRuntime.Date?
        /// Feedback type on a specific instance of anomaly submitted by the user.
        public var userFeedback: CodeGuruProfilerClientTypes.UserFeedback?

        public init(
            endTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            userFeedback: CodeGuruProfilerClientTypes.UserFeedback? = nil
        )
        {
            self.endTime = endTime
            self.id = id
            self.startTime = startTime
            self.userFeedback = userFeedback
        }
    }

}

extension BatchGetFrameMetricDataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frameMetrics
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let frameMetrics = frameMetrics {
            var frameMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .frameMetrics)
            for framemetric0 in frameMetrics {
                try frameMetricsContainer.encode(framemetric0)
            }
        }
    }
}

extension BatchGetFrameMetricDataInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let period = period {
                let periodQueryItem = ClientRuntime.URLQueryItem(name: "period".urlPercentEncoding(), value: Swift.String(period).urlPercentEncoding())
                items.append(periodQueryItem)
            }
            if let startTime = startTime {
                let startTimeQueryItem = ClientRuntime.URLQueryItem(name: "startTime".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: startTime)).urlPercentEncoding())
                items.append(startTimeQueryItem)
            }
            if let endTime = endTime {
                let endTimeQueryItem = ClientRuntime.URLQueryItem(name: "endTime".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: endTime)).urlPercentEncoding())
                items.append(endTimeQueryItem)
            }
            if let targetResolution = targetResolution {
                let targetResolutionQueryItem = ClientRuntime.URLQueryItem(name: "targetResolution".urlPercentEncoding(), value: Swift.String(targetResolution.rawValue).urlPercentEncoding())
                items.append(targetResolutionQueryItem)
            }
            return items
        }
    }
}

extension BatchGetFrameMetricDataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profilingGroupName = profilingGroupName else {
            return nil
        }
        return "/profilingGroups/\(profilingGroupName.urlPercentEncoding())/frames/-/metrics"
    }
}

/// The structure representing the BatchGetFrameMetricDataRequest.
public struct BatchGetFrameMetricDataInput: Swift.Equatable {
    /// The end time of the time period for the returned time series values. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
    public var endTime: ClientRuntime.Date?
    /// The details of the metrics that are used to request a time series of values. The metric includes the name of the frame, the aggregation type to calculate the metric value for the frame, and the thread states to use to get the count for the metric value of the frame.
    public var frameMetrics: [CodeGuruProfilerClientTypes.FrameMetric]?
    /// The duration of the frame metrics used to return the time series values. Specify using the ISO 8601 format. The maximum period duration is one day (PT24H or P1D).
    public var period: Swift.String?
    /// The name of the profiling group associated with the the frame metrics used to return the time series values.
    /// This member is required.
    public var profilingGroupName: Swift.String?
    /// The start time of the time period for the frame metrics used to return the time series values. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
    public var startTime: ClientRuntime.Date?
    /// The requested resolution of time steps for the returned time series of values. If the requested target resolution is not available due to data not being retained we provide a best effort result by falling back to the most granular available resolution after the target resolution. There are 3 valid values.
    ///
    /// * P1D — 1 day
    ///
    /// * PT1H — 1 hour
    ///
    /// * PT5M — 5 minutes
    public var targetResolution: CodeGuruProfilerClientTypes.AggregationPeriod?

    public init(
        endTime: ClientRuntime.Date? = nil,
        frameMetrics: [CodeGuruProfilerClientTypes.FrameMetric]? = nil,
        period: Swift.String? = nil,
        profilingGroupName: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        targetResolution: CodeGuruProfilerClientTypes.AggregationPeriod? = nil
    )
    {
        self.endTime = endTime
        self.frameMetrics = frameMetrics
        self.period = period
        self.profilingGroupName = profilingGroupName
        self.startTime = startTime
        self.targetResolution = targetResolution
    }
}

struct BatchGetFrameMetricDataInputBody: Swift.Equatable {
    let frameMetrics: [CodeGuruProfilerClientTypes.FrameMetric]?
}

extension BatchGetFrameMetricDataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frameMetrics
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameMetricsContainer = try containerValues.decodeIfPresent([CodeGuruProfilerClientTypes.FrameMetric?].self, forKey: .frameMetrics)
        var frameMetricsDecoded0:[CodeGuruProfilerClientTypes.FrameMetric]? = nil
        if let frameMetricsContainer = frameMetricsContainer {
            frameMetricsDecoded0 = [CodeGuruProfilerClientTypes.FrameMetric]()
            for structure0 in frameMetricsContainer {
                if let structure0 = structure0 {
                    frameMetricsDecoded0?.append(structure0)
                }
            }
        }
        frameMetrics = frameMetricsDecoded0
    }
}

extension BatchGetFrameMetricDataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchGetFrameMetricDataOutputBody = try responseDecoder.decode(responseBody: data)
            self.endTime = output.endTime
            self.endTimes = output.endTimes
            self.frameMetricData = output.frameMetricData
            self.resolution = output.resolution
            self.startTime = output.startTime
            self.unprocessedEndTimes = output.unprocessedEndTimes
        } else {
            self.endTime = nil
            self.endTimes = nil
            self.frameMetricData = nil
            self.resolution = nil
            self.startTime = nil
            self.unprocessedEndTimes = nil
        }
    }
}

/// The structure representing the BatchGetFrameMetricDataResponse.
public struct BatchGetFrameMetricDataOutput: Swift.Equatable {
    /// The end time of the time period for the returned time series values. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// List of instances, or time steps, in the time series. For example, if the period is one day (PT24H)), and the resolution is five minutes (PT5M), then there are 288 endTimes in the list that are each five minutes appart.
    /// This member is required.
    public var endTimes: [CodeGuruProfilerClientTypes.TimestampStructure]?
    /// Details of the metrics to request a time series of values. The metric includes the name of the frame, the aggregation type to calculate the metric value for the frame, and the thread states to use to get the count for the metric value of the frame.
    /// This member is required.
    public var frameMetricData: [CodeGuruProfilerClientTypes.FrameMetricDatum]?
    /// Resolution or granularity of the profile data used to generate the time series. This is the value used to jump through time steps in a time series. There are 3 valid values.
    ///
    /// * P1D — 1 day
    ///
    /// * PT1H — 1 hour
    ///
    /// * PT5M — 5 minutes
    /// This member is required.
    public var resolution: CodeGuruProfilerClientTypes.AggregationPeriod?
    /// The start time of the time period for the returned time series values. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
    /// This member is required.
    public var startTime: ClientRuntime.Date?
    /// List of instances which remained unprocessed. This will create a missing time step in the list of end times.
    /// This member is required.
    public var unprocessedEndTimes: [Swift.String:[CodeGuruProfilerClientTypes.TimestampStructure]]?

    public init(
        endTime: ClientRuntime.Date? = nil,
        endTimes: [CodeGuruProfilerClientTypes.TimestampStructure]? = nil,
        frameMetricData: [CodeGuruProfilerClientTypes.FrameMetricDatum]? = nil,
        resolution: CodeGuruProfilerClientTypes.AggregationPeriod? = nil,
        startTime: ClientRuntime.Date? = nil,
        unprocessedEndTimes: [Swift.String:[CodeGuruProfilerClientTypes.TimestampStructure]]? = nil
    )
    {
        self.endTime = endTime
        self.endTimes = endTimes
        self.frameMetricData = frameMetricData
        self.resolution = resolution
        self.startTime = startTime
        self.unprocessedEndTimes = unprocessedEndTimes
    }
}

struct BatchGetFrameMetricDataOutputBody: Swift.Equatable {
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let resolution: CodeGuruProfilerClientTypes.AggregationPeriod?
    let endTimes: [CodeGuruProfilerClientTypes.TimestampStructure]?
    let unprocessedEndTimes: [Swift.String:[CodeGuruProfilerClientTypes.TimestampStructure]]?
    let frameMetricData: [CodeGuruProfilerClientTypes.FrameMetricDatum]?
}

extension BatchGetFrameMetricDataOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case endTimes
        case frameMetricData
        case resolution
        case startTime
        case unprocessedEndTimes
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endTime)
        endTime = endTimeDecoded
        let resolutionDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.AggregationPeriod.self, forKey: .resolution)
        resolution = resolutionDecoded
        let endTimesContainer = try containerValues.decodeIfPresent([CodeGuruProfilerClientTypes.TimestampStructure?].self, forKey: .endTimes)
        var endTimesDecoded0:[CodeGuruProfilerClientTypes.TimestampStructure]? = nil
        if let endTimesContainer = endTimesContainer {
            endTimesDecoded0 = [CodeGuruProfilerClientTypes.TimestampStructure]()
            for structure0 in endTimesContainer {
                if let structure0 = structure0 {
                    endTimesDecoded0?.append(structure0)
                }
            }
        }
        endTimes = endTimesDecoded0
        let unprocessedEndTimesContainer = try containerValues.decodeIfPresent([Swift.String: [CodeGuruProfilerClientTypes.TimestampStructure?]?].self, forKey: .unprocessedEndTimes)
        var unprocessedEndTimesDecoded0: [Swift.String:[CodeGuruProfilerClientTypes.TimestampStructure]]? = nil
        if let unprocessedEndTimesContainer = unprocessedEndTimesContainer {
            unprocessedEndTimesDecoded0 = [Swift.String:[CodeGuruProfilerClientTypes.TimestampStructure]]()
            for (key0, listoftimestamps0) in unprocessedEndTimesContainer {
                var listoftimestamps0Decoded0: [CodeGuruProfilerClientTypes.TimestampStructure]? = nil
                if let listoftimestamps0 = listoftimestamps0 {
                    listoftimestamps0Decoded0 = [CodeGuruProfilerClientTypes.TimestampStructure]()
                    for structure1 in listoftimestamps0 {
                        if let structure1 = structure1 {
                            listoftimestamps0Decoded0?.append(structure1)
                        }
                    }
                }
                unprocessedEndTimesDecoded0?[key0] = listoftimestamps0Decoded0
            }
        }
        unprocessedEndTimes = unprocessedEndTimesDecoded0
        let frameMetricDataContainer = try containerValues.decodeIfPresent([CodeGuruProfilerClientTypes.FrameMetricDatum?].self, forKey: .frameMetricData)
        var frameMetricDataDecoded0:[CodeGuruProfilerClientTypes.FrameMetricDatum]? = nil
        if let frameMetricDataContainer = frameMetricDataContainer {
            frameMetricDataDecoded0 = [CodeGuruProfilerClientTypes.FrameMetricDatum]()
            for structure0 in frameMetricDataContainer {
                if let structure0 = structure0 {
                    frameMetricDataDecoded0?.append(structure0)
                }
            }
        }
        frameMetricData = frameMetricDataDecoded0
    }
}

enum BatchGetFrameMetricDataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CodeGuruProfilerClientTypes.Channel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventPublishers
        case id
        case uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventPublishers = eventPublishers {
            var eventPublishersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventPublishers)
            for eventpublisher0 in eventPublishers {
                try eventPublishersContainer.encode(eventpublisher0.rawValue)
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let eventPublishersContainer = try containerValues.decodeIfPresent([CodeGuruProfilerClientTypes.EventPublisher?].self, forKey: .eventPublishers)
        var eventPublishersDecoded0:[CodeGuruProfilerClientTypes.EventPublisher]? = nil
        if let eventPublishersContainer = eventPublishersContainer {
            eventPublishersDecoded0 = [CodeGuruProfilerClientTypes.EventPublisher]()
            for string0 in eventPublishersContainer {
                if let string0 = string0 {
                    eventPublishersDecoded0?.append(string0)
                }
            }
        }
        eventPublishers = eventPublishersDecoded0
    }
}

extension CodeGuruProfilerClientTypes {
    /// Notification medium for users to get alerted for events that occur in application profile. We support SNS topic as a notification channel.
    public struct Channel: Swift.Equatable {
        /// List of publishers for different type of events that may be detected in an application from the profile. Anomaly detection is the only event publisher in Profiler.
        /// This member is required.
        public var eventPublishers: [CodeGuruProfilerClientTypes.EventPublisher]?
        /// Unique identifier for each Channel in the notification configuration of a Profiling Group. A random UUID for channelId is used when adding a channel to the notification configuration if not specified in the request.
        public var id: Swift.String?
        /// Unique arn of the resource to be used for notifications. We support a valid SNS topic arn as a channel uri.
        /// This member is required.
        public var uri: Swift.String?

        public init(
            eventPublishers: [CodeGuruProfilerClientTypes.EventPublisher]? = nil,
            id: Swift.String? = nil,
            uri: Swift.String? = nil
        )
        {
            self.eventPublishers = eventPublishers
            self.id = id
            self.uri = uri
        }
    }

}

extension CodeGuruProfilerClientTypes {
    public enum ComputePlatform: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Compute platform meant to used for AWS Lambda.
        case awslambda
        /// Compute platform meant to used for all usecases (like EC2, Fargate, physical servers etc.) but AWS Lambda.
        case `default`
        case sdkUnknown(Swift.String)

        public static var allCases: [ComputePlatform] {
            return [
                .awslambda,
                .default,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awslambda: return "AWSLambda"
            case .default: return "Default"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComputePlatform(rawValue: rawValue) ?? ComputePlatform.sdkUnknown(rawValue)
        }
    }
}

extension ConfigureAgentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetInstanceId
        case metadata
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetInstanceId = self.fleetInstanceId {
            try encodeContainer.encode(fleetInstanceId, forKey: .fleetInstanceId)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, metadata0) in metadata {
                try metadataContainer.encode(metadata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension ConfigureAgentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profilingGroupName = profilingGroupName else {
            return nil
        }
        return "/profilingGroups/\(profilingGroupName.urlPercentEncoding())/configureAgent"
    }
}

/// The structure representing the configureAgentRequest.
public struct ConfigureAgentInput: Swift.Equatable {
    /// A universally unique identifier (UUID) for a profiling instance. For example, if the profiling instance is an Amazon EC2 instance, it is the instance ID. If it is an AWS Fargate container, it is the container's task ID.
    public var fleetInstanceId: Swift.String?
    /// Metadata captured about the compute platform the agent is running on. It includes information about sampling and reporting. The valid fields are:
    ///
    /// * COMPUTE_PLATFORM - The compute platform on which the agent is running
    ///
    /// * AGENT_ID - The ID for an agent instance.
    ///
    /// * AWS_REQUEST_ID - The AWS request ID of a Lambda invocation.
    ///
    /// * EXECUTION_ENVIRONMENT - The execution environment a Lambda function is running on.
    ///
    /// * LAMBDA_FUNCTION_ARN - The Amazon Resource Name (ARN) that is used to invoke a Lambda function.
    ///
    /// * LAMBDA_MEMORY_LIMIT_IN_MB - The memory allocated to a Lambda function.
    ///
    /// * LAMBDA_REMAINING_TIME_IN_MILLISECONDS - The time in milliseconds before execution of a Lambda function times out.
    ///
    /// * LAMBDA_TIME_GAP_BETWEEN_INVOKES_IN_MILLISECONDS - The time in milliseconds between two invocations of a Lambda function.
    ///
    /// * LAMBDA_PREVIOUS_EXECUTION_TIME_IN_MILLISECONDS - The time in milliseconds for the previous Lambda invocation.
    public var metadata: [Swift.String:Swift.String]?
    /// The name of the profiling group for which the configured agent is collecting profiling data.
    /// This member is required.
    public var profilingGroupName: Swift.String?

    public init(
        fleetInstanceId: Swift.String? = nil,
        metadata: [Swift.String:Swift.String]? = nil,
        profilingGroupName: Swift.String? = nil
    )
    {
        self.fleetInstanceId = fleetInstanceId
        self.metadata = metadata
        self.profilingGroupName = profilingGroupName
    }
}

struct ConfigureAgentInputBody: Swift.Equatable {
    let fleetInstanceId: Swift.String?
    let metadata: [Swift.String:Swift.String]?
}

extension ConfigureAgentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetInstanceId
        case metadata
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetInstanceId)
        fleetInstanceId = fleetInstanceIdDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in metadataContainer {
                if let string0 = string0 {
                    metadataDecoded0?[key0] = string0
                }
            }
        }
        metadata = metadataDecoded0
    }
}

extension ConfigureAgentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CodeGuruProfilerClientTypes.AgentConfiguration = try responseDecoder.decode(responseBody: data)
            self.configuration = output
        } else {
            self.configuration = nil
        }
    }
}

/// The structure representing the configureAgentResponse.
public struct ConfigureAgentOutput: Swift.Equatable {
    /// An [AgentConfiguration](https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_AgentConfiguration.html) object that specifies if an agent profiles or not and for how long to return profiling data.
    /// This member is required.
    public var configuration: CodeGuruProfilerClientTypes.AgentConfiguration?

    public init(
        configuration: CodeGuruProfilerClientTypes.AgentConfiguration? = nil
    )
    {
        self.configuration = configuration
    }
}

struct ConfigureAgentOutputBody: Swift.Equatable {
    let configuration: CodeGuruProfilerClientTypes.AgentConfiguration?
}

extension ConfigureAgentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.AgentConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

enum ConfigureAgentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested operation would cause a conflict with the current state of a service resource associated with the request. Resolve the conflict before retrying this request.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateProfilingGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentOrchestrationConfig
        case computePlatform
        case profilingGroupName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentOrchestrationConfig = self.agentOrchestrationConfig {
            try encodeContainer.encode(agentOrchestrationConfig, forKey: .agentOrchestrationConfig)
        }
        if let computePlatform = self.computePlatform {
            try encodeContainer.encode(computePlatform.rawValue, forKey: .computePlatform)
        }
        if let profilingGroupName = self.profilingGroupName {
            try encodeContainer.encode(profilingGroupName, forKey: .profilingGroupName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateProfilingGroupInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let clientToken = clientToken else {
                let message = "Creating a URL Query Item failed. clientToken is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
            return items
        }
    }
}

extension CreateProfilingGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/profilingGroups"
    }
}

/// The structure representing the createProfiliingGroupRequest.
public struct CreateProfilingGroupInput: Swift.Equatable {
    /// Specifies whether profiling is enabled or disabled for the created profiling group.
    public var agentOrchestrationConfig: CodeGuruProfilerClientTypes.AgentOrchestrationConfig?
    /// Amazon CodeGuru Profiler uses this universally unique identifier (UUID) to prevent the accidental creation of duplicate profiling groups if there are failures and retries.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The compute platform of the profiling group. Use AWSLambda if your application runs on AWS Lambda. Use Default if your application runs on a compute platform that is not AWS Lambda, such an Amazon EC2 instance, an on-premises server, or a different platform. If not specified, Default is used.
    public var computePlatform: CodeGuruProfilerClientTypes.ComputePlatform?
    /// The name of the profiling group to create.
    /// This member is required.
    public var profilingGroupName: Swift.String?
    /// A list of tags to add to the created profiling group.
    public var tags: [Swift.String:Swift.String]?

    public init(
        agentOrchestrationConfig: CodeGuruProfilerClientTypes.AgentOrchestrationConfig? = nil,
        clientToken: Swift.String? = nil,
        computePlatform: CodeGuruProfilerClientTypes.ComputePlatform? = nil,
        profilingGroupName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.agentOrchestrationConfig = agentOrchestrationConfig
        self.clientToken = clientToken
        self.computePlatform = computePlatform
        self.profilingGroupName = profilingGroupName
        self.tags = tags
    }
}

struct CreateProfilingGroupInputBody: Swift.Equatable {
    let profilingGroupName: Swift.String?
    let computePlatform: CodeGuruProfilerClientTypes.ComputePlatform?
    let agentOrchestrationConfig: CodeGuruProfilerClientTypes.AgentOrchestrationConfig?
    let tags: [Swift.String:Swift.String]?
}

extension CreateProfilingGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentOrchestrationConfig
        case computePlatform
        case profilingGroupName
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profilingGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profilingGroupName)
        profilingGroupName = profilingGroupNameDecoded
        let computePlatformDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.ComputePlatform.self, forKey: .computePlatform)
        computePlatform = computePlatformDecoded
        let agentOrchestrationConfigDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.AgentOrchestrationConfig.self, forKey: .agentOrchestrationConfig)
        agentOrchestrationConfig = agentOrchestrationConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProfilingGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CodeGuruProfilerClientTypes.ProfilingGroupDescription = try responseDecoder.decode(responseBody: data)
            self.profilingGroup = output
        } else {
            self.profilingGroup = nil
        }
    }
}

/// The structure representing the createProfilingGroupResponse.
public struct CreateProfilingGroupOutput: Swift.Equatable {
    /// The returned [ProfilingGroupDescription](https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ProfilingGroupDescription.html) object that contains information about the created profiling group.
    /// This member is required.
    public var profilingGroup: CodeGuruProfilerClientTypes.ProfilingGroupDescription?

    public init(
        profilingGroup: CodeGuruProfilerClientTypes.ProfilingGroupDescription? = nil
    )
    {
        self.profilingGroup = profilingGroup
    }
}

struct CreateProfilingGroupOutputBody: Swift.Equatable {
    let profilingGroup: CodeGuruProfilerClientTypes.ProfilingGroupDescription?
}

extension CreateProfilingGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profilingGroup
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profilingGroupDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.ProfilingGroupDescription.self, forKey: .profilingGroup)
        profilingGroup = profilingGroupDecoded
    }
}

enum CreateProfilingGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteProfilingGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profilingGroupName = profilingGroupName else {
            return nil
        }
        return "/profilingGroups/\(profilingGroupName.urlPercentEncoding())"
    }
}

/// The structure representing the deleteProfilingGroupRequest.
public struct DeleteProfilingGroupInput: Swift.Equatable {
    /// The name of the profiling group to delete.
    /// This member is required.
    public var profilingGroupName: Swift.String?

    public init(
        profilingGroupName: Swift.String? = nil
    )
    {
        self.profilingGroupName = profilingGroupName
    }
}

struct DeleteProfilingGroupInputBody: Swift.Equatable {
}

extension DeleteProfilingGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProfilingGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// The structure representing the deleteProfilingGroupResponse.
public struct DeleteProfilingGroupOutput: Swift.Equatable {

    public init() { }
}

enum DeleteProfilingGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeProfilingGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profilingGroupName = profilingGroupName else {
            return nil
        }
        return "/profilingGroups/\(profilingGroupName.urlPercentEncoding())"
    }
}

/// The structure representing the describeProfilingGroupRequest.
public struct DescribeProfilingGroupInput: Swift.Equatable {
    /// The name of the profiling group to get information about.
    /// This member is required.
    public var profilingGroupName: Swift.String?

    public init(
        profilingGroupName: Swift.String? = nil
    )
    {
        self.profilingGroupName = profilingGroupName
    }
}

struct DescribeProfilingGroupInputBody: Swift.Equatable {
}

extension DescribeProfilingGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeProfilingGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CodeGuruProfilerClientTypes.ProfilingGroupDescription = try responseDecoder.decode(responseBody: data)
            self.profilingGroup = output
        } else {
            self.profilingGroup = nil
        }
    }
}

/// The structure representing the describeProfilingGroupResponse.
public struct DescribeProfilingGroupOutput: Swift.Equatable {
    /// The returned [ProfilingGroupDescription](https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ProfilingGroupDescription.html) object that contains information about the requested profiling group.
    /// This member is required.
    public var profilingGroup: CodeGuruProfilerClientTypes.ProfilingGroupDescription?

    public init(
        profilingGroup: CodeGuruProfilerClientTypes.ProfilingGroupDescription? = nil
    )
    {
        self.profilingGroup = profilingGroup
    }
}

struct DescribeProfilingGroupOutputBody: Swift.Equatable {
    let profilingGroup: CodeGuruProfilerClientTypes.ProfilingGroupDescription?
}

extension DescribeProfilingGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profilingGroup
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profilingGroupDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.ProfilingGroupDescription.self, forKey: .profilingGroup)
        profilingGroup = profilingGroupDecoded
    }
}

enum DescribeProfilingGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CodeGuruProfilerClientTypes {
    public enum EventPublisher: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Notifications for Anomaly Detection
        case anomalyDetection
        case sdkUnknown(Swift.String)

        public static var allCases: [EventPublisher] {
            return [
                .anomalyDetection,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .anomalyDetection: return "AnomalyDetection"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventPublisher(rawValue: rawValue) ?? EventPublisher.sdkUnknown(rawValue)
        }
    }
}

extension CodeGuruProfilerClientTypes {
    public enum FeedbackType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Profiler recommendation flagged as not useful.
        case negative
        /// Profiler recommendation flagged as useful.
        case positive
        case sdkUnknown(Swift.String)

        public static var allCases: [FeedbackType] {
            return [
                .negative,
                .positive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .negative: return "Negative"
            case .positive: return "Positive"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FeedbackType(rawValue: rawValue) ?? FeedbackType.sdkUnknown(rawValue)
        }
    }
}

extension CodeGuruProfilerClientTypes.FindingsReportSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case profileEndTime
        case profileStartTime
        case profilingGroupName
        case totalNumberOfFindings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let profileEndTime = self.profileEndTime {
            try encodeContainer.encodeTimestamp(profileEndTime, format: .dateTime, forKey: .profileEndTime)
        }
        if let profileStartTime = self.profileStartTime {
            try encodeContainer.encodeTimestamp(profileStartTime, format: .dateTime, forKey: .profileStartTime)
        }
        if let profilingGroupName = self.profilingGroupName {
            try encodeContainer.encode(profilingGroupName, forKey: .profilingGroupName)
        }
        if let totalNumberOfFindings = self.totalNumberOfFindings {
            try encodeContainer.encode(totalNumberOfFindings, forKey: .totalNumberOfFindings)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let profilingGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profilingGroupName)
        profilingGroupName = profilingGroupNameDecoded
        let profileStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .profileStartTime)
        profileStartTime = profileStartTimeDecoded
        let profileEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .profileEndTime)
        profileEndTime = profileEndTimeDecoded
        let totalNumberOfFindingsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalNumberOfFindings)
        totalNumberOfFindings = totalNumberOfFindingsDecoded
    }
}

extension CodeGuruProfilerClientTypes {
    /// Information about potential recommendations that might be created from the analysis of profiling data.
    public struct FindingsReportSummary: Swift.Equatable {
        /// The universally unique identifier (UUID) of the recommendation report.
        public var id: Swift.String?
        /// The end time of the period during which the metric is flagged as anomalous. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        public var profileEndTime: ClientRuntime.Date?
        /// The start time of the profile the analysis data is about. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        public var profileStartTime: ClientRuntime.Date?
        /// The name of the profiling group that is associated with the analysis data.
        public var profilingGroupName: Swift.String?
        /// The total number of different recommendations that were found by the analysis.
        public var totalNumberOfFindings: Swift.Int?

        public init(
            id: Swift.String? = nil,
            profileEndTime: ClientRuntime.Date? = nil,
            profileStartTime: ClientRuntime.Date? = nil,
            profilingGroupName: Swift.String? = nil,
            totalNumberOfFindings: Swift.Int? = nil
        )
        {
            self.id = id
            self.profileEndTime = profileEndTime
            self.profileStartTime = profileStartTime
            self.profilingGroupName = profilingGroupName
            self.totalNumberOfFindings = totalNumberOfFindings
        }
    }

}

extension CodeGuruProfilerClientTypes.FrameMetric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frameName
        case threadStates
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let frameName = self.frameName {
            try encodeContainer.encode(frameName, forKey: .frameName)
        }
        if let threadStates = threadStates {
            var threadStatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .threadStates)
            for string0 in threadStates {
                try threadStatesContainer.encode(string0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameName)
        frameName = frameNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.MetricType.self, forKey: .type)
        type = typeDecoded
        let threadStatesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .threadStates)
        var threadStatesDecoded0:[Swift.String]? = nil
        if let threadStatesContainer = threadStatesContainer {
            threadStatesDecoded0 = [Swift.String]()
            for string0 in threadStatesContainer {
                if let string0 = string0 {
                    threadStatesDecoded0?.append(string0)
                }
            }
        }
        threadStates = threadStatesDecoded0
    }
}

extension CodeGuruProfilerClientTypes {
    /// The frame name, metric type, and thread states. These are used to derive the value of the metric for the frame.
    public struct FrameMetric: Swift.Equatable {
        /// Name of the method common across the multiple occurrences of a frame in an application profile.
        /// This member is required.
        public var frameName: Swift.String?
        /// List of application runtime thread states used to get the counts for a frame a derive a metric value.
        /// This member is required.
        public var threadStates: [Swift.String]?
        /// A type of aggregation that specifies how a metric for a frame is analyzed. The supported value AggregatedRelativeTotalTime is an aggregation of the metric value for one frame that is calculated across the occurrences of all frames in a profile.
        /// This member is required.
        public var type: CodeGuruProfilerClientTypes.MetricType?

        public init(
            frameName: Swift.String? = nil,
            threadStates: [Swift.String]? = nil,
            type: CodeGuruProfilerClientTypes.MetricType? = nil
        )
        {
            self.frameName = frameName
            self.threadStates = threadStates
            self.type = type
        }
    }

}

extension CodeGuruProfilerClientTypes.FrameMetricDatum: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frameMetric
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let frameMetric = self.frameMetric {
            try encodeContainer.encode(frameMetric, forKey: .frameMetric)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for framemetricvalue0 in values {
                try valuesContainer.encode(framemetricvalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameMetricDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.FrameMetric.self, forKey: .frameMetric)
        frameMetric = frameMetricDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.Double?].self, forKey: .values)
        var valuesDecoded0:[Swift.Double]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.Double]()
            for double0 in valuesContainer {
                if let double0 = double0 {
                    valuesDecoded0?.append(double0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension CodeGuruProfilerClientTypes {
    /// Information about a frame metric and its values.
    public struct FrameMetricDatum: Swift.Equatable {
        /// The frame name, metric type, and thread states. These are used to derive the value of the metric for the frame.
        /// This member is required.
        public var frameMetric: CodeGuruProfilerClientTypes.FrameMetric?
        /// A list of values that are associated with a frame metric.
        /// This member is required.
        public var values: [Swift.Double]?

        public init(
            frameMetric: CodeGuruProfilerClientTypes.FrameMetric? = nil,
            values: [Swift.Double]? = nil
        )
        {
            self.frameMetric = frameMetric
            self.values = values
        }
    }

}

extension GetFindingsReportAccountSummaryInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let dailyReportsOnly = dailyReportsOnly {
                let dailyReportsOnlyQueryItem = ClientRuntime.URLQueryItem(name: "dailyReportsOnly".urlPercentEncoding(), value: Swift.String(dailyReportsOnly).urlPercentEncoding())
                items.append(dailyReportsOnlyQueryItem)
            }
            return items
        }
    }
}

extension GetFindingsReportAccountSummaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/internal/findingsReports"
    }
}

/// The structure representing the GetFindingsReportAccountSummaryRequest.
public struct GetFindingsReportAccountSummaryInput: Swift.Equatable {
    /// A Boolean value indicating whether to only return reports from daily profiles. If set to True, only analysis data from daily profiles is returned. If set to False, analysis data is returned from smaller time windows (for example, one hour).
    public var dailyReportsOnly: Swift.Bool?
    /// The maximum number of results returned by  GetFindingsReportAccountSummary in paginated output. When this parameter is used, GetFindingsReportAccountSummary only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another GetFindingsReportAccountSummary request with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The nextToken value returned from a previous paginated GetFindingsReportAccountSummary request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.
    public var nextToken: Swift.String?

    public init(
        dailyReportsOnly: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dailyReportsOnly = dailyReportsOnly
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetFindingsReportAccountSummaryInputBody: Swift.Equatable {
}

extension GetFindingsReportAccountSummaryInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetFindingsReportAccountSummaryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFindingsReportAccountSummaryOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.reportSummaries = output.reportSummaries
        } else {
            self.nextToken = nil
            self.reportSummaries = nil
        }
    }
}

/// The structure representing the GetFindingsReportAccountSummaryResponse.
public struct GetFindingsReportAccountSummaryOutput: Swift.Equatable {
    /// The nextToken value to include in a future GetFindingsReportAccountSummary request. When the results of a GetFindingsReportAccountSummary request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The return list of [FindingsReportSummary](https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_FindingsReportSummary.html) objects taht contain summaries of analysis results for all profiling groups in your AWS account.
    /// This member is required.
    public var reportSummaries: [CodeGuruProfilerClientTypes.FindingsReportSummary]?

    public init(
        nextToken: Swift.String? = nil,
        reportSummaries: [CodeGuruProfilerClientTypes.FindingsReportSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.reportSummaries = reportSummaries
    }
}

struct GetFindingsReportAccountSummaryOutputBody: Swift.Equatable {
    let reportSummaries: [CodeGuruProfilerClientTypes.FindingsReportSummary]?
    let nextToken: Swift.String?
}

extension GetFindingsReportAccountSummaryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case reportSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportSummariesContainer = try containerValues.decodeIfPresent([CodeGuruProfilerClientTypes.FindingsReportSummary?].self, forKey: .reportSummaries)
        var reportSummariesDecoded0:[CodeGuruProfilerClientTypes.FindingsReportSummary]? = nil
        if let reportSummariesContainer = reportSummariesContainer {
            reportSummariesDecoded0 = [CodeGuruProfilerClientTypes.FindingsReportSummary]()
            for structure0 in reportSummariesContainer {
                if let structure0 = structure0 {
                    reportSummariesDecoded0?.append(structure0)
                }
            }
        }
        reportSummaries = reportSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetFindingsReportAccountSummaryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetNotificationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profilingGroupName = profilingGroupName else {
            return nil
        }
        return "/profilingGroups/\(profilingGroupName.urlPercentEncoding())/notificationConfiguration"
    }
}

/// The structure representing the GetNotificationConfigurationRequest.
public struct GetNotificationConfigurationInput: Swift.Equatable {
    /// The name of the profiling group we want to get the notification configuration for.
    /// This member is required.
    public var profilingGroupName: Swift.String?

    public init(
        profilingGroupName: Swift.String? = nil
    )
    {
        self.profilingGroupName = profilingGroupName
    }
}

struct GetNotificationConfigurationInputBody: Swift.Equatable {
}

extension GetNotificationConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetNotificationConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetNotificationConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.notificationConfiguration = output.notificationConfiguration
        } else {
            self.notificationConfiguration = nil
        }
    }
}

/// The structure representing the GetNotificationConfigurationResponse.
public struct GetNotificationConfigurationOutput: Swift.Equatable {
    /// The current notification configuration for this profiling group.
    /// This member is required.
    public var notificationConfiguration: CodeGuruProfilerClientTypes.NotificationConfiguration?

    public init(
        notificationConfiguration: CodeGuruProfilerClientTypes.NotificationConfiguration? = nil
    )
    {
        self.notificationConfiguration = notificationConfiguration
    }
}

struct GetNotificationConfigurationOutputBody: Swift.Equatable {
    let notificationConfiguration: CodeGuruProfilerClientTypes.NotificationConfiguration?
}

extension GetNotificationConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationConfigurationDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.NotificationConfiguration.self, forKey: .notificationConfiguration)
        notificationConfiguration = notificationConfigurationDecoded
    }
}

enum GetNotificationConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profilingGroupName = profilingGroupName else {
            return nil
        }
        return "/profilingGroups/\(profilingGroupName.urlPercentEncoding())/policy"
    }
}

/// The structure representing the getPolicyRequest.
public struct GetPolicyInput: Swift.Equatable {
    /// The name of the profiling group.
    /// This member is required.
    public var profilingGroupName: Swift.String?

    public init(
        profilingGroupName: Swift.String? = nil
    )
    {
        self.profilingGroupName = profilingGroupName
    }
}

struct GetPolicyInputBody: Swift.Equatable {
}

extension GetPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.revisionId = output.revisionId
        } else {
            self.policy = nil
            self.revisionId = nil
        }
    }
}

/// The structure representing the getPolicyResponse.
public struct GetPolicyOutput: Swift.Equatable {
    /// The JSON-formatted resource-based policy attached to the ProfilingGroup.
    /// This member is required.
    public var policy: Swift.String?
    /// A unique identifier for the current revision of the returned policy.
    /// This member is required.
    public var revisionId: Swift.String?

    public init(
        policy: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.revisionId = revisionId
    }
}

struct GetPolicyOutputBody: Swift.Equatable {
    let policy: Swift.String?
    let revisionId: Swift.String?
}

extension GetPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
        case revisionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

enum GetPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetProfileInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accept = accept {
            items.add(Header(name: "Accept", value: Swift.String(accept)))
        }
        return items
    }
}

extension GetProfileInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxDepth = maxDepth {
                let maxDepthQueryItem = ClientRuntime.URLQueryItem(name: "maxDepth".urlPercentEncoding(), value: Swift.String(maxDepth).urlPercentEncoding())
                items.append(maxDepthQueryItem)
            }
            if let period = period {
                let periodQueryItem = ClientRuntime.URLQueryItem(name: "period".urlPercentEncoding(), value: Swift.String(period).urlPercentEncoding())
                items.append(periodQueryItem)
            }
            if let startTime = startTime {
                let startTimeQueryItem = ClientRuntime.URLQueryItem(name: "startTime".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: startTime)).urlPercentEncoding())
                items.append(startTimeQueryItem)
            }
            if let endTime = endTime {
                let endTimeQueryItem = ClientRuntime.URLQueryItem(name: "endTime".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: endTime)).urlPercentEncoding())
                items.append(endTimeQueryItem)
            }
            return items
        }
    }
}

extension GetProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profilingGroupName = profilingGroupName else {
            return nil
        }
        return "/profilingGroups/\(profilingGroupName.urlPercentEncoding())/profile"
    }
}

/// The structure representing the getProfileRequest.
public struct GetProfileInput: Swift.Equatable {
    /// The format of the returned profiling data. The format maps to the Accept and Content-Type headers of the HTTP request. You can specify one of the following: or the default .
    ///
    /// * application/json — standard JSON format
    ///
    /// * application/x-amzn-ion — the Amazon Ion data format. For more information, see [Amazon Ion](http://amzn.github.io/ion-docs/).
    public var accept: Swift.String?
    /// The end time of the requested profile. Specify using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC. If you specify endTime, then you must also specify period or startTime, but not both.
    public var endTime: ClientRuntime.Date?
    /// The maximum depth of the stacks in the code that is represented in the aggregated profile. For example, if CodeGuru Profiler finds a method A, which calls method B, which calls method C, which calls method D, then the depth is 4. If the maxDepth is set to 2, then the aggregated profile contains representations of methods A and B.
    public var maxDepth: Swift.Int?
    /// Used with startTime or endTime to specify the time range for the returned aggregated profile. Specify using the ISO 8601 format. For example, P1DT1H1M1S. To get the latest aggregated profile, specify only period.
    public var period: Swift.String?
    /// The name of the profiling group to get.
    /// This member is required.
    public var profilingGroupName: Swift.String?
    /// The start time of the profile to get. Specify using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC. If you specify startTime, then you must also specify period or endTime, but not both.
    public var startTime: ClientRuntime.Date?

    public init(
        accept: Swift.String? = nil,
        endTime: ClientRuntime.Date? = nil,
        maxDepth: Swift.Int? = nil,
        period: Swift.String? = nil,
        profilingGroupName: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.accept = accept
        self.endTime = endTime
        self.maxDepth = maxDepth
        self.period = period
        self.profilingGroupName = profilingGroupName
        self.startTime = startTime
    }
}

struct GetProfileInputBody: Swift.Equatable {
}

extension GetProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let contentEncodingHeaderValue = httpResponse.headers.value(for: "Content-Encoding") {
            self.contentEncoding = contentEncodingHeaderValue
        } else {
            self.contentEncoding = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        switch httpResponse.body {
        case .data(let data):
            self.profile = data
        case .stream(let stream):
            self.profile = try stream.readToEnd()
        case .none:
            self.profile = nil
        }
    }
}

/// The structure representing the getProfileResponse.
public struct GetProfileOutput: Swift.Equatable {
    /// The content encoding of the profile.
    public var contentEncoding: Swift.String?
    /// The content type of the profile in the payload. It is either application/json or the default application/x-amzn-ion.
    /// This member is required.
    public var contentType: Swift.String?
    /// Information about the profile.
    /// This member is required.
    public var profile: ClientRuntime.Data?

    public init(
        contentEncoding: Swift.String? = nil,
        contentType: Swift.String? = nil,
        profile: ClientRuntime.Data? = nil
    )
    {
        self.contentEncoding = contentEncoding
        self.contentType = contentType
        self.profile = profile
    }
}

struct GetProfileOutputBody: Swift.Equatable {
    let profile: ClientRuntime.Data?
}

extension GetProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profile
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .profile)
        profile = profileDecoded
    }
}

enum GetProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRecommendationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let startTime = startTime else {
                let message = "Creating a URL Query Item failed. startTime is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let startTimeQueryItem = ClientRuntime.URLQueryItem(name: "startTime".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: startTime)).urlPercentEncoding())
            items.append(startTimeQueryItem)
            guard let endTime = endTime else {
                let message = "Creating a URL Query Item failed. endTime is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let endTimeQueryItem = ClientRuntime.URLQueryItem(name: "endTime".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: endTime)).urlPercentEncoding())
            items.append(endTimeQueryItem)
            if let locale = locale {
                let localeQueryItem = ClientRuntime.URLQueryItem(name: "locale".urlPercentEncoding(), value: Swift.String(locale).urlPercentEncoding())
                items.append(localeQueryItem)
            }
            return items
        }
    }
}

extension GetRecommendationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profilingGroupName = profilingGroupName else {
            return nil
        }
        return "/internal/profilingGroups/\(profilingGroupName.urlPercentEncoding())/recommendations"
    }
}

/// The structure representing the GetRecommendationsRequest.
public struct GetRecommendationsInput: Swift.Equatable {
    /// The start time of the profile to get analysis data about. You must specify startTime and endTime. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// The language used to provide analysis. Specify using a string that is one of the following BCP 47 language codes.
    ///
    /// * de-DE - German, Germany
    ///
    /// * en-GB - English, United Kingdom
    ///
    /// * en-US - English, United States
    ///
    /// * es-ES - Spanish, Spain
    ///
    /// * fr-FR - French, France
    ///
    /// * it-IT - Italian, Italy
    ///
    /// * ja-JP - Japanese, Japan
    ///
    /// * ko-KR - Korean, Republic of Korea
    ///
    /// * pt-BR - Portugese, Brazil
    ///
    /// * zh-CN - Chinese, China
    ///
    /// * zh-TW - Chinese, Taiwan
    public var locale: Swift.String?
    /// The name of the profiling group to get analysis data about.
    /// This member is required.
    public var profilingGroupName: Swift.String?
    /// The end time of the profile to get analysis data about. You must specify startTime and endTime. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
    /// This member is required.
    public var startTime: ClientRuntime.Date?

    public init(
        endTime: ClientRuntime.Date? = nil,
        locale: Swift.String? = nil,
        profilingGroupName: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.locale = locale
        self.profilingGroupName = profilingGroupName
        self.startTime = startTime
    }
}

struct GetRecommendationsInputBody: Swift.Equatable {
}

extension GetRecommendationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRecommendationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRecommendationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.anomalies = output.anomalies
            self.profileEndTime = output.profileEndTime
            self.profileStartTime = output.profileStartTime
            self.profilingGroupName = output.profilingGroupName
            self.recommendations = output.recommendations
        } else {
            self.anomalies = nil
            self.profileEndTime = nil
            self.profileStartTime = nil
            self.profilingGroupName = nil
            self.recommendations = nil
        }
    }
}

/// The structure representing the GetRecommendationsResponse.
public struct GetRecommendationsOutput: Swift.Equatable {
    /// The list of anomalies that the analysis has found for this profile.
    /// This member is required.
    public var anomalies: [CodeGuruProfilerClientTypes.Anomaly]?
    /// The end time of the profile the analysis data is about. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
    /// This member is required.
    public var profileEndTime: ClientRuntime.Date?
    /// The start time of the profile the analysis data is about. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
    /// This member is required.
    public var profileStartTime: ClientRuntime.Date?
    /// The name of the profiling group the analysis data is about.
    /// This member is required.
    public var profilingGroupName: Swift.String?
    /// The list of recommendations that the analysis found for this profile.
    /// This member is required.
    public var recommendations: [CodeGuruProfilerClientTypes.Recommendation]?

    public init(
        anomalies: [CodeGuruProfilerClientTypes.Anomaly]? = nil,
        profileEndTime: ClientRuntime.Date? = nil,
        profileStartTime: ClientRuntime.Date? = nil,
        profilingGroupName: Swift.String? = nil,
        recommendations: [CodeGuruProfilerClientTypes.Recommendation]? = nil
    )
    {
        self.anomalies = anomalies
        self.profileEndTime = profileEndTime
        self.profileStartTime = profileStartTime
        self.profilingGroupName = profilingGroupName
        self.recommendations = recommendations
    }
}

struct GetRecommendationsOutputBody: Swift.Equatable {
    let profilingGroupName: Swift.String?
    let profileStartTime: ClientRuntime.Date?
    let profileEndTime: ClientRuntime.Date?
    let recommendations: [CodeGuruProfilerClientTypes.Recommendation]?
    let anomalies: [CodeGuruProfilerClientTypes.Anomaly]?
}

extension GetRecommendationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalies
        case profileEndTime
        case profileStartTime
        case profilingGroupName
        case recommendations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profilingGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profilingGroupName)
        profilingGroupName = profilingGroupNameDecoded
        let profileStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .profileStartTime)
        profileStartTime = profileStartTimeDecoded
        let profileEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .profileEndTime)
        profileEndTime = profileEndTimeDecoded
        let recommendationsContainer = try containerValues.decodeIfPresent([CodeGuruProfilerClientTypes.Recommendation?].self, forKey: .recommendations)
        var recommendationsDecoded0:[CodeGuruProfilerClientTypes.Recommendation]? = nil
        if let recommendationsContainer = recommendationsContainer {
            recommendationsDecoded0 = [CodeGuruProfilerClientTypes.Recommendation]()
            for structure0 in recommendationsContainer {
                if let structure0 = structure0 {
                    recommendationsDecoded0?.append(structure0)
                }
            }
        }
        recommendations = recommendationsDecoded0
        let anomaliesContainer = try containerValues.decodeIfPresent([CodeGuruProfilerClientTypes.Anomaly?].self, forKey: .anomalies)
        var anomaliesDecoded0:[CodeGuruProfilerClientTypes.Anomaly]? = nil
        if let anomaliesContainer = anomaliesContainer {
            anomaliesDecoded0 = [CodeGuruProfilerClientTypes.Anomaly]()
            for structure0 in anomaliesContainer {
                if let structure0 = structure0 {
                    anomaliesDecoded0?.append(structure0)
                }
            }
        }
        anomalies = anomaliesDecoded0
    }
}

enum GetRecommendationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The server encountered an internal error and is unable to complete the request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListFindingsReportsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let dailyReportsOnly = dailyReportsOnly {
                let dailyReportsOnlyQueryItem = ClientRuntime.URLQueryItem(name: "dailyReportsOnly".urlPercentEncoding(), value: Swift.String(dailyReportsOnly).urlPercentEncoding())
                items.append(dailyReportsOnlyQueryItem)
            }
            guard let startTime = startTime else {
                let message = "Creating a URL Query Item failed. startTime is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let startTimeQueryItem = ClientRuntime.URLQueryItem(name: "startTime".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: startTime)).urlPercentEncoding())
            items.append(startTimeQueryItem)
            guard let endTime = endTime else {
                let message = "Creating a URL Query Item failed. endTime is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let endTimeQueryItem = ClientRuntime.URLQueryItem(name: "endTime".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: endTime)).urlPercentEncoding())
            items.append(endTimeQueryItem)
            return items
        }
    }
}

extension ListFindingsReportsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profilingGroupName = profilingGroupName else {
            return nil
        }
        return "/internal/profilingGroups/\(profilingGroupName.urlPercentEncoding())/findingsReports"
    }
}

/// The structure representing the ListFindingsReportsRequest.
public struct ListFindingsReportsInput: Swift.Equatable {
    /// A Boolean value indicating whether to only return reports from daily profiles. If set to True, only analysis data from daily profiles is returned. If set to False, analysis data is returned from smaller time windows (for example, one hour).
    public var dailyReportsOnly: Swift.Bool?
    /// The end time of the profile to get analysis data about. You must specify startTime and endTime. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// The maximum number of report results returned by ListFindingsReports in paginated output. When this parameter is used, ListFindingsReports only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListFindingsReports request with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The nextToken value returned from a previous paginated ListFindingsReportsRequest request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.
    public var nextToken: Swift.String?
    /// The name of the profiling group from which to search for analysis data.
    /// This member is required.
    public var profilingGroupName: Swift.String?
    /// The start time of the profile to get analysis data about. You must specify startTime and endTime. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
    /// This member is required.
    public var startTime: ClientRuntime.Date?

    public init(
        dailyReportsOnly: Swift.Bool? = nil,
        endTime: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        profilingGroupName: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.dailyReportsOnly = dailyReportsOnly
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.profilingGroupName = profilingGroupName
        self.startTime = startTime
    }
}

struct ListFindingsReportsInputBody: Swift.Equatable {
}

extension ListFindingsReportsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListFindingsReportsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFindingsReportsOutputBody = try responseDecoder.decode(responseBody: data)
            self.findingsReportSummaries = output.findingsReportSummaries
            self.nextToken = output.nextToken
        } else {
            self.findingsReportSummaries = nil
            self.nextToken = nil
        }
    }
}

/// The structure representing the ListFindingsReportsResponse.
public struct ListFindingsReportsOutput: Swift.Equatable {
    /// The list of analysis results summaries.
    /// This member is required.
    public var findingsReportSummaries: [CodeGuruProfilerClientTypes.FindingsReportSummary]?
    /// The nextToken value to include in a future ListFindingsReports request. When the results of a ListFindingsReports request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        findingsReportSummaries: [CodeGuruProfilerClientTypes.FindingsReportSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.findingsReportSummaries = findingsReportSummaries
        self.nextToken = nextToken
    }
}

struct ListFindingsReportsOutputBody: Swift.Equatable {
    let findingsReportSummaries: [CodeGuruProfilerClientTypes.FindingsReportSummary]?
    let nextToken: Swift.String?
}

extension ListFindingsReportsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingsReportSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingsReportSummariesContainer = try containerValues.decodeIfPresent([CodeGuruProfilerClientTypes.FindingsReportSummary?].self, forKey: .findingsReportSummaries)
        var findingsReportSummariesDecoded0:[CodeGuruProfilerClientTypes.FindingsReportSummary]? = nil
        if let findingsReportSummariesContainer = findingsReportSummariesContainer {
            findingsReportSummariesDecoded0 = [CodeGuruProfilerClientTypes.FindingsReportSummary]()
            for structure0 in findingsReportSummariesContainer {
                if let structure0 = structure0 {
                    findingsReportSummariesDecoded0?.append(structure0)
                }
            }
        }
        findingsReportSummaries = findingsReportSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListFindingsReportsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProfileTimesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let period = period else {
                let message = "Creating a URL Query Item failed. period is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let periodQueryItem = ClientRuntime.URLQueryItem(name: "period".urlPercentEncoding(), value: Swift.String(period.rawValue).urlPercentEncoding())
            items.append(periodQueryItem)
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let orderBy = orderBy {
                let orderByQueryItem = ClientRuntime.URLQueryItem(name: "orderBy".urlPercentEncoding(), value: Swift.String(orderBy.rawValue).urlPercentEncoding())
                items.append(orderByQueryItem)
            }
            guard let startTime = startTime else {
                let message = "Creating a URL Query Item failed. startTime is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let startTimeQueryItem = ClientRuntime.URLQueryItem(name: "startTime".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: startTime)).urlPercentEncoding())
            items.append(startTimeQueryItem)
            guard let endTime = endTime else {
                let message = "Creating a URL Query Item failed. endTime is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let endTimeQueryItem = ClientRuntime.URLQueryItem(name: "endTime".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: endTime)).urlPercentEncoding())
            items.append(endTimeQueryItem)
            return items
        }
    }
}

extension ListProfileTimesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profilingGroupName = profilingGroupName else {
            return nil
        }
        return "/profilingGroups/\(profilingGroupName.urlPercentEncoding())/profileTimes"
    }
}

/// The structure representing the listProfileTimesRequest.
public struct ListProfileTimesInput: Swift.Equatable {
    /// The end time of the time range from which to list the profiles.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// The maximum number of profile time results returned by ListProfileTimes in paginated output. When this parameter is used, ListProfileTimes only returns maxResults results in a single page with a nextToken response element. The remaining results of the initial request can be seen by sending another ListProfileTimes request with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The nextToken value returned from a previous paginated ListProfileTimes request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.
    public var nextToken: Swift.String?
    /// The order (ascending or descending by start time of the profile) to use when listing profiles. Defaults to TIMESTAMP_DESCENDING.
    public var orderBy: CodeGuruProfilerClientTypes.OrderBy?
    /// The aggregation period. This specifies the period during which an aggregation profile collects posted agent profiles for a profiling group. There are 3 valid values.
    ///
    /// * P1D — 1 day
    ///
    /// * PT1H — 1 hour
    ///
    /// * PT5M — 5 minutes
    /// This member is required.
    public var period: CodeGuruProfilerClientTypes.AggregationPeriod?
    /// The name of the profiling group.
    /// This member is required.
    public var profilingGroupName: Swift.String?
    /// The start time of the time range from which to list the profiles.
    /// This member is required.
    public var startTime: ClientRuntime.Date?

    public init(
        endTime: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        orderBy: CodeGuruProfilerClientTypes.OrderBy? = nil,
        period: CodeGuruProfilerClientTypes.AggregationPeriod? = nil,
        profilingGroupName: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.orderBy = orderBy
        self.period = period
        self.profilingGroupName = profilingGroupName
        self.startTime = startTime
    }
}

struct ListProfileTimesInputBody: Swift.Equatable {
}

extension ListProfileTimesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListProfileTimesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProfileTimesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.profileTimes = output.profileTimes
        } else {
            self.nextToken = nil
            self.profileTimes = nil
        }
    }
}

/// The structure representing the listProfileTimesResponse.
public struct ListProfileTimesOutput: Swift.Equatable {
    /// The nextToken value to include in a future ListProfileTimes request. When the results of a ListProfileTimes request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The list of start times of the available profiles for the aggregation period in the specified time range.
    /// This member is required.
    public var profileTimes: [CodeGuruProfilerClientTypes.ProfileTime]?

    public init(
        nextToken: Swift.String? = nil,
        profileTimes: [CodeGuruProfilerClientTypes.ProfileTime]? = nil
    )
    {
        self.nextToken = nextToken
        self.profileTimes = profileTimes
    }
}

struct ListProfileTimesOutputBody: Swift.Equatable {
    let profileTimes: [CodeGuruProfilerClientTypes.ProfileTime]?
    let nextToken: Swift.String?
}

extension ListProfileTimesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case profileTimes
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileTimesContainer = try containerValues.decodeIfPresent([CodeGuruProfilerClientTypes.ProfileTime?].self, forKey: .profileTimes)
        var profileTimesDecoded0:[CodeGuruProfilerClientTypes.ProfileTime]? = nil
        if let profileTimesContainer = profileTimesContainer {
            profileTimesDecoded0 = [CodeGuruProfilerClientTypes.ProfileTime]()
            for structure0 in profileTimesContainer {
                if let structure0 = structure0 {
                    profileTimesDecoded0?.append(structure0)
                }
            }
        }
        profileTimes = profileTimesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListProfileTimesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProfilingGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let includeDescription = includeDescription {
                let includeDescriptionQueryItem = ClientRuntime.URLQueryItem(name: "includeDescription".urlPercentEncoding(), value: Swift.String(includeDescription).urlPercentEncoding())
                items.append(includeDescriptionQueryItem)
            }
            return items
        }
    }
}

extension ListProfilingGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/profilingGroups"
    }
}

/// The structure representing the listProfilingGroupsRequest.
public struct ListProfilingGroupsInput: Swift.Equatable {
    /// A Boolean value indicating whether to include a description. If true, then a list of [ProfilingGroupDescription](https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ProfilingGroupDescription.html) objects that contain detailed information about profiling groups is returned. If false, then a list of profiling group names is returned.
    public var includeDescription: Swift.Bool?
    /// The maximum number of profiling groups results returned by ListProfilingGroups in paginated output. When this parameter is used, ListProfilingGroups only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListProfilingGroups request with the returned nextToken value.
    public var maxResults: Swift.Int?
    /// The nextToken value returned from a previous paginated ListProfilingGroups request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.
    public var nextToken: Swift.String?

    public init(
        includeDescription: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.includeDescription = includeDescription
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProfilingGroupsInputBody: Swift.Equatable {
}

extension ListProfilingGroupsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListProfilingGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProfilingGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.profilingGroupNames = output.profilingGroupNames
            self.profilingGroups = output.profilingGroups
        } else {
            self.nextToken = nil
            self.profilingGroupNames = nil
            self.profilingGroups = nil
        }
    }
}

/// The structure representing the listProfilingGroupsResponse.
public struct ListProfilingGroupsOutput: Swift.Equatable {
    /// The nextToken value to include in a future ListProfilingGroups request. When the results of a ListProfilingGroups request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// A returned list of profiling group names. A list of the names is returned only if includeDescription is false, otherwise a list of [ProfilingGroupDescription](https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ProfilingGroupDescription.html) objects is returned.
    /// This member is required.
    public var profilingGroupNames: [Swift.String]?
    /// A returned list [ProfilingGroupDescription](https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ProfilingGroupDescription.html) objects. A list of [ProfilingGroupDescription](https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ProfilingGroupDescription.html) objects is returned only if includeDescription is true, otherwise a list of profiling group names is returned.
    public var profilingGroups: [CodeGuruProfilerClientTypes.ProfilingGroupDescription]?

    public init(
        nextToken: Swift.String? = nil,
        profilingGroupNames: [Swift.String]? = nil,
        profilingGroups: [CodeGuruProfilerClientTypes.ProfilingGroupDescription]? = nil
    )
    {
        self.nextToken = nextToken
        self.profilingGroupNames = profilingGroupNames
        self.profilingGroups = profilingGroups
    }
}

struct ListProfilingGroupsOutputBody: Swift.Equatable {
    let profilingGroupNames: [Swift.String]?
    let profilingGroups: [CodeGuruProfilerClientTypes.ProfilingGroupDescription]?
    let nextToken: Swift.String?
}

extension ListProfilingGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case profilingGroupNames
        case profilingGroups
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profilingGroupNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .profilingGroupNames)
        var profilingGroupNamesDecoded0:[Swift.String]? = nil
        if let profilingGroupNamesContainer = profilingGroupNamesContainer {
            profilingGroupNamesDecoded0 = [Swift.String]()
            for string0 in profilingGroupNamesContainer {
                if let string0 = string0 {
                    profilingGroupNamesDecoded0?.append(string0)
                }
            }
        }
        profilingGroupNames = profilingGroupNamesDecoded0
        let profilingGroupsContainer = try containerValues.decodeIfPresent([CodeGuruProfilerClientTypes.ProfilingGroupDescription?].self, forKey: .profilingGroups)
        var profilingGroupsDecoded0:[CodeGuruProfilerClientTypes.ProfilingGroupDescription]? = nil
        if let profilingGroupsContainer = profilingGroupsContainer {
            profilingGroupsDecoded0 = [CodeGuruProfilerClientTypes.ProfilingGroupDescription]()
            for structure0 in profilingGroupsContainer {
                if let structure0 = structure0 {
                    profilingGroupsDecoded0?.append(structure0)
                }
            }
        }
        profilingGroups = profilingGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListProfilingGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that contains the tags to return.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The list of tags assigned to the specified resource. This is the list of tags returned in the response.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CodeGuruProfilerClientTypes.Match: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frameAddress
        case targetFramesIndex
        case thresholdBreachValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let frameAddress = self.frameAddress {
            try encodeContainer.encode(frameAddress, forKey: .frameAddress)
        }
        if let targetFramesIndex = self.targetFramesIndex {
            try encodeContainer.encode(targetFramesIndex, forKey: .targetFramesIndex)
        }
        if let thresholdBreachValue = self.thresholdBreachValue {
            try encodeContainer.encode(thresholdBreachValue, forKey: .thresholdBreachValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetFramesIndexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .targetFramesIndex)
        targetFramesIndex = targetFramesIndexDecoded
        let frameAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameAddress)
        frameAddress = frameAddressDecoded
        let thresholdBreachValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .thresholdBreachValue)
        thresholdBreachValue = thresholdBreachValueDecoded
    }
}

extension CodeGuruProfilerClientTypes {
    /// The part of a profile that contains a recommendation found during analysis.
    public struct Match: Swift.Equatable {
        /// The location in the profiling graph that contains a recommendation found during analysis.
        public var frameAddress: Swift.String?
        /// The target frame that triggered a match.
        public var targetFramesIndex: Swift.Int?
        /// The value in the profile data that exceeded the recommendation threshold.
        public var thresholdBreachValue: Swift.Double?

        public init(
            frameAddress: Swift.String? = nil,
            targetFramesIndex: Swift.Int? = nil,
            thresholdBreachValue: Swift.Double? = nil
        )
        {
            self.frameAddress = frameAddress
            self.targetFramesIndex = targetFramesIndex
            self.thresholdBreachValue = thresholdBreachValue
        }
    }

}

extension CodeGuruProfilerClientTypes {
    public enum MetadataField: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Unique identifier for the agent instance.
        case agentId
        /// AWS requestId of the Lambda invocation.
        case awsRequestId
        /// Compute platform on which agent is running.
        case computePlatform
        /// Execution environment on which Lambda function is running.
        case executionEnvironment
        /// Function ARN that's used to invoke the Lambda function.
        case lambdaFunctionArn
        /// Memory allocated for the Lambda function.
        case lambdaMemoryLimitInMb
        /// Time in milliseconds for the previous Lambda invocation.
        case lambdaPreviousExecutionTimeInMilliseconds
        /// Time in milliseconds left before the execution times out.
        case lambdaRemainingTimeInMilliseconds
        /// Time in milliseconds between two invocations of the Lambda function.
        case lambdaTimeGapBetweenInvokesInMilliseconds
        case sdkUnknown(Swift.String)

        public static var allCases: [MetadataField] {
            return [
                .agentId,
                .awsRequestId,
                .computePlatform,
                .executionEnvironment,
                .lambdaFunctionArn,
                .lambdaMemoryLimitInMb,
                .lambdaPreviousExecutionTimeInMilliseconds,
                .lambdaRemainingTimeInMilliseconds,
                .lambdaTimeGapBetweenInvokesInMilliseconds,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agentId: return "AgentId"
            case .awsRequestId: return "AwsRequestId"
            case .computePlatform: return "ComputePlatform"
            case .executionEnvironment: return "ExecutionEnvironment"
            case .lambdaFunctionArn: return "LambdaFunctionArn"
            case .lambdaMemoryLimitInMb: return "LambdaMemoryLimitInMB"
            case .lambdaPreviousExecutionTimeInMilliseconds: return "LambdaPreviousExecutionTimeInMilliseconds"
            case .lambdaRemainingTimeInMilliseconds: return "LambdaRemainingTimeInMilliseconds"
            case .lambdaTimeGapBetweenInvokesInMilliseconds: return "LambdaTimeGapBetweenInvokesInMilliseconds"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MetadataField(rawValue: rawValue) ?? MetadataField.sdkUnknown(rawValue)
        }
    }
}

extension CodeGuruProfilerClientTypes.Metric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frameName
        case threadStates
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let frameName = self.frameName {
            try encodeContainer.encode(frameName, forKey: .frameName)
        }
        if let threadStates = threadStates {
            var threadStatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .threadStates)
            for string0 in threadStates {
                try threadStatesContainer.encode(string0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .frameName)
        frameName = frameNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.MetricType.self, forKey: .type)
        type = typeDecoded
        let threadStatesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .threadStates)
        var threadStatesDecoded0:[Swift.String]? = nil
        if let threadStatesContainer = threadStatesContainer {
            threadStatesDecoded0 = [Swift.String]()
            for string0 in threadStatesContainer {
                if let string0 = string0 {
                    threadStatesDecoded0?.append(string0)
                }
            }
        }
        threadStates = threadStatesDecoded0
    }
}

extension CodeGuruProfilerClientTypes {
    /// Details about the metric that the analysis used when it detected the anomaly. The metric what is analyzed to create recommendations. It includes the name of the frame that was analyzed and the type and thread states used to derive the metric value for that frame.
    public struct Metric: Swift.Equatable {
        /// The name of the method that appears as a frame in any stack in a profile.
        /// This member is required.
        public var frameName: Swift.String?
        /// The list of application runtime thread states that is used to calculate the metric value for the frame.
        /// This member is required.
        public var threadStates: [Swift.String]?
        /// A type that specifies how a metric for a frame is analyzed. The supported value AggregatedRelativeTotalTime is an aggregation of the metric value for one frame that is calculated across the occurences of all frames in a profile.
        /// This member is required.
        public var type: CodeGuruProfilerClientTypes.MetricType?

        public init(
            frameName: Swift.String? = nil,
            threadStates: [Swift.String]? = nil,
            type: CodeGuruProfilerClientTypes.MetricType? = nil
        )
        {
            self.frameName = frameName
            self.threadStates = threadStates
            self.type = type
        }
    }

}

extension CodeGuruProfilerClientTypes {
    public enum MetricType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Metric value aggregated for all instances of a frame name in a profile relative to the root frame.
        case aggregatedrelativetotaltime
        case sdkUnknown(Swift.String)

        public static var allCases: [MetricType] {
            return [
                .aggregatedrelativetotaltime,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aggregatedrelativetotaltime: return "AggregatedRelativeTotalTime"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MetricType(rawValue: rawValue) ?? MetricType.sdkUnknown(rawValue)
        }
    }
}

extension CodeGuruProfilerClientTypes.NotificationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channels = channels {
            var channelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .channels)
            for channel0 in channels {
                try channelsContainer.encode(channel0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsContainer = try containerValues.decodeIfPresent([CodeGuruProfilerClientTypes.Channel?].self, forKey: .channels)
        var channelsDecoded0:[CodeGuruProfilerClientTypes.Channel]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [CodeGuruProfilerClientTypes.Channel]()
            for structure0 in channelsContainer {
                if let structure0 = structure0 {
                    channelsDecoded0?.append(structure0)
                }
            }
        }
        channels = channelsDecoded0
    }
}

extension CodeGuruProfilerClientTypes {
    /// The configuration for notifications stored for each profiling group. This includes up to to two channels and a list of event publishers associated with each channel.
    public struct NotificationConfiguration: Swift.Equatable {
        /// List of up to two channels to be used for sending notifications for events detected from the application profile.
        public var channels: [CodeGuruProfilerClientTypes.Channel]?

        public init(
            channels: [CodeGuruProfilerClientTypes.Channel]? = nil
        )
        {
            self.channels = channels
        }
    }

}

extension CodeGuruProfilerClientTypes {
    public enum OrderBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Order by timestamp in ascending order.
        case timestampAscending
        /// Order by timestamp in descending order.
        case timestampDescending
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderBy] {
            return [
                .timestampAscending,
                .timestampDescending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .timestampAscending: return "TimestampAscending"
            case .timestampDescending: return "TimestampDescending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrderBy(rawValue: rawValue) ?? OrderBy.sdkUnknown(rawValue)
        }
    }
}

extension CodeGuruProfilerClientTypes.Pattern: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case countersToAggregate
        case description
        case id
        case name
        case resolutionSteps
        case targetFrames
        case thresholdPercent
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let countersToAggregate = countersToAggregate {
            var countersToAggregateContainer = encodeContainer.nestedUnkeyedContainer(forKey: .countersToAggregate)
            for string0 in countersToAggregate {
                try countersToAggregateContainer.encode(string0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resolutionSteps = self.resolutionSteps {
            try encodeContainer.encode(resolutionSteps, forKey: .resolutionSteps)
        }
        if let targetFrames = targetFrames {
            var targetFramesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetFrames)
            for targetframe0 in targetFrames {
                var targetframe0Container = targetFramesContainer.nestedUnkeyedContainer()
                for string1 in targetframe0 {
                    try targetframe0Container.encode(string1)
                }
            }
        }
        if thresholdPercent != 0.0 {
            try encodeContainer.encode(thresholdPercent, forKey: .thresholdPercent)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let resolutionStepsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolutionSteps)
        resolutionSteps = resolutionStepsDecoded
        let targetFramesContainer = try containerValues.decodeIfPresent([[Swift.String?]?].self, forKey: .targetFrames)
        var targetFramesDecoded0:[[Swift.String]]? = nil
        if let targetFramesContainer = targetFramesContainer {
            targetFramesDecoded0 = [[Swift.String]]()
            for list0 in targetFramesContainer {
                var list0Decoded0: [Swift.String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [Swift.String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    targetFramesDecoded0?.append(list0Decoded0)
                }
            }
        }
        targetFrames = targetFramesDecoded0
        let thresholdPercentDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .thresholdPercent) ?? 0.0
        thresholdPercent = thresholdPercentDecoded
        let countersToAggregateContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .countersToAggregate)
        var countersToAggregateDecoded0:[Swift.String]? = nil
        if let countersToAggregateContainer = countersToAggregateContainer {
            countersToAggregateDecoded0 = [Swift.String]()
            for string0 in countersToAggregateContainer {
                if let string0 = string0 {
                    countersToAggregateDecoded0?.append(string0)
                }
            }
        }
        countersToAggregate = countersToAggregateDecoded0
    }
}

extension CodeGuruProfilerClientTypes {
    /// A set of rules used to make a recommendation during an analysis.
    public struct Pattern: Swift.Equatable {
        /// A list of the different counters used to determine if there is a match.
        public var countersToAggregate: [Swift.String]?
        /// The description of the recommendation. This explains a potential inefficiency in a profiled application.
        public var description: Swift.String?
        /// The universally unique identifier (UUID) of this pattern.
        public var id: Swift.String?
        /// The name for this pattern.
        public var name: Swift.String?
        /// A string that contains the steps recommended to address the potential inefficiency.
        public var resolutionSteps: Swift.String?
        /// A list of frame names that were searched during the analysis that generated a recommendation.
        public var targetFrames: [[Swift.String]]?
        /// The percentage of time an application spends in one method that triggers a recommendation. The percentage of time is the same as the percentage of the total gathered sample counts during analysis.
        public var thresholdPercent: Swift.Double

        public init(
            countersToAggregate: [Swift.String]? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            resolutionSteps: Swift.String? = nil,
            targetFrames: [[Swift.String]]? = nil,
            thresholdPercent: Swift.Double = 0.0
        )
        {
            self.countersToAggregate = countersToAggregate
            self.description = description
            self.id = id
            self.name = name
            self.resolutionSteps = resolutionSteps
            self.targetFrames = targetFrames
            self.thresholdPercent = thresholdPercent
        }
    }

}

public struct PostAgentProfileInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PostAgentProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PostAgentProfileInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PostAgentProfileOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let agentProfile = input.operationInput.agentProfile {
            let agentProfileData = agentProfile
            let agentProfileBody = ClientRuntime.HttpBody.data(agentProfileData)
            input.builder.withBody(agentProfileBody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PostAgentProfileInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PostAgentProfileOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension PostAgentProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentProfile
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentProfile = self.agentProfile {
            try encodeContainer.encode(agentProfile.base64EncodedString(), forKey: .agentProfile)
        }
    }
}

extension PostAgentProfileInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let contentType = contentType {
            items.add(Header(name: "Content-Type", value: Swift.String(contentType)))
        }
        return items
    }
}

extension PostAgentProfileInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let profileToken = profileToken {
                let profileTokenQueryItem = ClientRuntime.URLQueryItem(name: "profileToken".urlPercentEncoding(), value: Swift.String(profileToken).urlPercentEncoding())
                items.append(profileTokenQueryItem)
            }
            return items
        }
    }
}

extension PostAgentProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profilingGroupName = profilingGroupName else {
            return nil
        }
        return "/profilingGroups/\(profilingGroupName.urlPercentEncoding())/agentProfile"
    }
}

/// The structure representing the postAgentProfileRequest.
public struct PostAgentProfileInput: Swift.Equatable {
    /// The submitted profiling data.
    /// This member is required.
    public var agentProfile: ClientRuntime.Data?
    /// The format of the submitted profiling data. The format maps to the Accept and Content-Type headers of the HTTP request. You can specify one of the following: or the default .
    ///
    /// * application/json — standard JSON format
    ///
    /// * application/x-amzn-ion — the Amazon Ion data format. For more information, see [Amazon Ion](http://amzn.github.io/ion-docs/).
    /// This member is required.
    public var contentType: Swift.String?
    /// Amazon CodeGuru Profiler uses this universally unique identifier (UUID) to prevent the accidental submission of duplicate profiling data if there are failures and retries.
    public var profileToken: Swift.String?
    /// The name of the profiling group with the aggregated profile that receives the submitted profiling data.
    /// This member is required.
    public var profilingGroupName: Swift.String?

    public init(
        agentProfile: ClientRuntime.Data? = nil,
        contentType: Swift.String? = nil,
        profileToken: Swift.String? = nil,
        profilingGroupName: Swift.String? = nil
    )
    {
        self.agentProfile = agentProfile
        self.contentType = contentType
        self.profileToken = profileToken
        self.profilingGroupName = profilingGroupName
    }
}

struct PostAgentProfileInputBody: Swift.Equatable {
    let agentProfile: ClientRuntime.Data?
}

extension PostAgentProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentProfile
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentProfileDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .agentProfile)
        agentProfile = agentProfileDecoded
    }
}

extension PostAgentProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// The structure representing the postAgentProfileResponse.
public struct PostAgentProfileOutput: Swift.Equatable {

    public init() { }
}

enum PostAgentProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CodeGuruProfilerClientTypes.ProfileTime: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case start
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let start = self.start {
            try encodeContainer.encodeTimestamp(start, format: .dateTime, forKey: .start)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .start)
        start = startDecoded
    }
}

extension CodeGuruProfilerClientTypes {
    /// Contains the start time of a profile.
    public struct ProfileTime: Swift.Equatable {
        /// The start time of a profile. It is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        public var start: ClientRuntime.Date?

        public init(
            start: ClientRuntime.Date? = nil
        )
        {
            self.start = start
        }
    }

}

extension CodeGuruProfilerClientTypes.ProfilingGroupDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentOrchestrationConfig
        case arn
        case computePlatform
        case createdAt
        case name
        case profilingStatus
        case tags
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentOrchestrationConfig = self.agentOrchestrationConfig {
            try encodeContainer.encode(agentOrchestrationConfig, forKey: .agentOrchestrationConfig)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let computePlatform = self.computePlatform {
            try encodeContainer.encode(computePlatform.rawValue, forKey: .computePlatform)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let profilingStatus = self.profilingStatus {
            try encodeContainer.encode(profilingStatus, forKey: .profilingStatus)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let agentOrchestrationConfigDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.AgentOrchestrationConfig.self, forKey: .agentOrchestrationConfig)
        agentOrchestrationConfig = agentOrchestrationConfigDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let profilingStatusDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.ProfilingStatus.self, forKey: .profilingStatus)
        profilingStatus = profilingStatusDecoded
        let computePlatformDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.ComputePlatform.self, forKey: .computePlatform)
        computePlatform = computePlatformDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CodeGuruProfilerClientTypes {
    /// Contains information about a profiling group.
    public struct ProfilingGroupDescription: Swift.Equatable {
        /// An [AgentOrchestrationConfig](https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_AgentOrchestrationConfig.html) object that indicates if the profiling group is enabled for profiled or not.
        public var agentOrchestrationConfig: CodeGuruProfilerClientTypes.AgentOrchestrationConfig?
        /// The Amazon Resource Name (ARN) identifying the profiling group resource.
        public var arn: Swift.String?
        /// The compute platform of the profiling group. If it is set to AWSLambda, then the profiled application runs on AWS Lambda. If it is set to Default, then the profiled application runs on a compute platform that is not AWS Lambda, such an Amazon EC2 instance, an on-premises server, or a different platform. The default is Default.
        public var computePlatform: CodeGuruProfilerClientTypes.ComputePlatform?
        /// The time when the profiling group was created. Specify using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        public var createdAt: ClientRuntime.Date?
        /// The name of the profiling group.
        public var name: Swift.String?
        /// A [ProfilingStatus](https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ProfilingStatus.html) object that includes information about the last time a profile agent pinged back, the last time a profile was received, and the aggregation period and start time for the most recent aggregated profile.
        public var profilingStatus: CodeGuruProfilerClientTypes.ProfilingStatus?
        /// A list of the tags that belong to this profiling group.
        public var tags: [Swift.String:Swift.String]?
        /// The date and time when the profiling group was last updated. Specify using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        public var updatedAt: ClientRuntime.Date?

        public init(
            agentOrchestrationConfig: CodeGuruProfilerClientTypes.AgentOrchestrationConfig? = nil,
            arn: Swift.String? = nil,
            computePlatform: CodeGuruProfilerClientTypes.ComputePlatform? = nil,
            createdAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            profilingStatus: CodeGuruProfilerClientTypes.ProfilingStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.agentOrchestrationConfig = agentOrchestrationConfig
            self.arn = arn
            self.computePlatform = computePlatform
            self.createdAt = createdAt
            self.name = name
            self.profilingStatus = profilingStatus
            self.tags = tags
            self.updatedAt = updatedAt
        }
    }

}

extension CodeGuruProfilerClientTypes.ProfilingStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case latestAgentOrchestratedAt
        case latestAgentProfileReportedAt
        case latestAggregatedProfile
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let latestAgentOrchestratedAt = self.latestAgentOrchestratedAt {
            try encodeContainer.encodeTimestamp(latestAgentOrchestratedAt, format: .dateTime, forKey: .latestAgentOrchestratedAt)
        }
        if let latestAgentProfileReportedAt = self.latestAgentProfileReportedAt {
            try encodeContainer.encodeTimestamp(latestAgentProfileReportedAt, format: .dateTime, forKey: .latestAgentProfileReportedAt)
        }
        if let latestAggregatedProfile = self.latestAggregatedProfile {
            try encodeContainer.encode(latestAggregatedProfile, forKey: .latestAggregatedProfile)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let latestAgentProfileReportedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .latestAgentProfileReportedAt)
        latestAgentProfileReportedAt = latestAgentProfileReportedAtDecoded
        let latestAggregatedProfileDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.AggregatedProfileTime.self, forKey: .latestAggregatedProfile)
        latestAggregatedProfile = latestAggregatedProfileDecoded
        let latestAgentOrchestratedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .latestAgentOrchestratedAt)
        latestAgentOrchestratedAt = latestAgentOrchestratedAtDecoded
    }
}

extension CodeGuruProfilerClientTypes {
    /// Profiling status includes information about the last time a profile agent pinged back, the last time a profile was received, and the aggregation period and start time for the most recent aggregated profile.
    public struct ProfilingStatus: Swift.Equatable {
        /// The date and time when the profiling agent most recently pinged back. Specify using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        public var latestAgentOrchestratedAt: ClientRuntime.Date?
        /// The date and time when the most recent profile was received. Specify using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        public var latestAgentProfileReportedAt: ClientRuntime.Date?
        /// An [AggregatedProfileTime](https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_AggregatedProfileTime.html) object that contains the aggregation period and start time for an aggregated profile.
        public var latestAggregatedProfile: CodeGuruProfilerClientTypes.AggregatedProfileTime?

        public init(
            latestAgentOrchestratedAt: ClientRuntime.Date? = nil,
            latestAgentProfileReportedAt: ClientRuntime.Date? = nil,
            latestAggregatedProfile: CodeGuruProfilerClientTypes.AggregatedProfileTime? = nil
        )
        {
            self.latestAgentOrchestratedAt = latestAgentOrchestratedAt
            self.latestAgentProfileReportedAt = latestAgentProfileReportedAt
            self.latestAggregatedProfile = latestAggregatedProfile
        }
    }

}

extension PutPermissionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case principals
        case revisionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for principal0 in principals {
                try principalsContainer.encode(principal0)
            }
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }
}

extension PutPermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profilingGroupName = profilingGroupName else {
            return nil
        }
        guard let actionGroup = actionGroup else {
            return nil
        }
        return "/profilingGroups/\(profilingGroupName.urlPercentEncoding())/policy/\(actionGroup.rawValue.urlPercentEncoding())"
    }
}

/// The structure representing the putPermissionRequest.
public struct PutPermissionInput: Swift.Equatable {
    /// Specifies an action group that contains permissions to add to a profiling group resource. One action group is supported, agentPermissions, which grants permission to perform actions required by the profiling agent, ConfigureAgent and PostAgentProfile permissions.
    /// This member is required.
    public var actionGroup: CodeGuruProfilerClientTypes.ActionGroup?
    /// A list ARNs for the roles and users you want to grant access to the profiling group. Wildcards are not are supported in the ARNs.
    /// This member is required.
    public var principals: [Swift.String]?
    /// The name of the profiling group to grant access to.
    /// This member is required.
    public var profilingGroupName: Swift.String?
    /// A universally unique identifier (UUID) for the revision of the policy you are adding to the profiling group. Do not specify this when you add permissions to a profiling group for the first time. If a policy already exists on the profiling group, you must specify the revisionId.
    public var revisionId: Swift.String?

    public init(
        actionGroup: CodeGuruProfilerClientTypes.ActionGroup? = nil,
        principals: [Swift.String]? = nil,
        profilingGroupName: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.actionGroup = actionGroup
        self.principals = principals
        self.profilingGroupName = profilingGroupName
        self.revisionId = revisionId
    }
}

struct PutPermissionInputBody: Swift.Equatable {
    let principals: [Swift.String]?
    let revisionId: Swift.String?
}

extension PutPermissionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case principals
        case revisionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .principals)
        var principalsDecoded0:[Swift.String]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [Swift.String]()
            for string0 in principalsContainer {
                if let string0 = string0 {
                    principalsDecoded0?.append(string0)
                }
            }
        }
        principals = principalsDecoded0
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension PutPermissionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutPermissionOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.revisionId = output.revisionId
        } else {
            self.policy = nil
            self.revisionId = nil
        }
    }
}

/// The structure representing the putPermissionResponse.
public struct PutPermissionOutput: Swift.Equatable {
    /// The JSON-formatted resource-based policy on the profiling group that includes the added permissions.
    /// This member is required.
    public var policy: Swift.String?
    /// A universally unique identifier (UUID) for the revision of the resource-based policy that includes the added permissions. The JSON-formatted policy is in the policy element of the response.
    /// This member is required.
    public var revisionId: Swift.String?

    public init(
        policy: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.revisionId = revisionId
    }
}

struct PutPermissionOutputBody: Swift.Equatable {
    let policy: Swift.String?
    let revisionId: Swift.String?
}

extension PutPermissionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
        case revisionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

enum PutPermissionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CodeGuruProfilerClientTypes.Recommendation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allMatchesCount
        case allMatchesSum
        case endTime
        case pattern
        case startTime
        case topMatches
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allMatchesCount = self.allMatchesCount {
            try encodeContainer.encode(allMatchesCount, forKey: .allMatchesCount)
        }
        if let allMatchesSum = self.allMatchesSum {
            try encodeContainer.encode(allMatchesSum, forKey: .allMatchesSum)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .dateTime, forKey: .endTime)
        }
        if let pattern = self.pattern {
            try encodeContainer.encode(pattern, forKey: .pattern)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
        if let topMatches = topMatches {
            var topMatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .topMatches)
            for match0 in topMatches {
                try topMatchesContainer.encode(match0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allMatchesCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allMatchesCount)
        allMatchesCount = allMatchesCountDecoded
        let allMatchesSumDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .allMatchesSum)
        allMatchesSum = allMatchesSumDecoded
        let patternDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.Pattern.self, forKey: .pattern)
        pattern = patternDecoded
        let topMatchesContainer = try containerValues.decodeIfPresent([CodeGuruProfilerClientTypes.Match?].self, forKey: .topMatches)
        var topMatchesDecoded0:[CodeGuruProfilerClientTypes.Match]? = nil
        if let topMatchesContainer = topMatchesContainer {
            topMatchesDecoded0 = [CodeGuruProfilerClientTypes.Match]()
            for structure0 in topMatchesContainer {
                if let structure0 = structure0 {
                    topMatchesDecoded0?.append(structure0)
                }
            }
        }
        topMatches = topMatchesDecoded0
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension CodeGuruProfilerClientTypes {
    /// A potential improvement that was found from analyzing the profiling data.
    public struct Recommendation: Swift.Equatable {
        /// How many different places in the profile graph triggered a match.
        /// This member is required.
        public var allMatchesCount: Swift.Int?
        /// How much of the total sample count is potentially affected.
        /// This member is required.
        public var allMatchesSum: Swift.Double?
        /// End time of the profile that was used by this analysis. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        /// This member is required.
        public var endTime: ClientRuntime.Date?
        /// The pattern that analysis recognized in the profile to make this recommendation.
        /// This member is required.
        public var pattern: CodeGuruProfilerClientTypes.Pattern?
        /// The start time of the profile that was used by this analysis. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        /// This member is required.
        public var startTime: ClientRuntime.Date?
        /// List of the matches with most impact.
        /// This member is required.
        public var topMatches: [CodeGuruProfilerClientTypes.Match]?

        public init(
            allMatchesCount: Swift.Int? = nil,
            allMatchesSum: Swift.Double? = nil,
            endTime: ClientRuntime.Date? = nil,
            pattern: CodeGuruProfilerClientTypes.Pattern? = nil,
            startTime: ClientRuntime.Date? = nil,
            topMatches: [CodeGuruProfilerClientTypes.Match]? = nil
        )
        {
            self.allMatchesCount = allMatchesCount
            self.allMatchesSum = allMatchesSum
            self.endTime = endTime
            self.pattern = pattern
            self.startTime = startTime
            self.topMatches = topMatches
        }
    }

}

extension RemoveNotificationChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profilingGroupName = profilingGroupName else {
            return nil
        }
        guard let channelId = channelId else {
            return nil
        }
        return "/profilingGroups/\(profilingGroupName.urlPercentEncoding())/notificationConfiguration/\(channelId.urlPercentEncoding())"
    }
}

/// The structure representing the RemoveNotificationChannelRequest.
public struct RemoveNotificationChannelInput: Swift.Equatable {
    /// The id of the channel that we want to stop receiving notifications.
    /// This member is required.
    public var channelId: Swift.String?
    /// The name of the profiling group we want to change notification configuration for.
    /// This member is required.
    public var profilingGroupName: Swift.String?

    public init(
        channelId: Swift.String? = nil,
        profilingGroupName: Swift.String? = nil
    )
    {
        self.channelId = channelId
        self.profilingGroupName = profilingGroupName
    }
}

struct RemoveNotificationChannelInputBody: Swift.Equatable {
}

extension RemoveNotificationChannelInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension RemoveNotificationChannelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RemoveNotificationChannelOutputBody = try responseDecoder.decode(responseBody: data)
            self.notificationConfiguration = output.notificationConfiguration
        } else {
            self.notificationConfiguration = nil
        }
    }
}

/// The structure representing the RemoveNotificationChannelResponse.
public struct RemoveNotificationChannelOutput: Swift.Equatable {
    /// The new notification configuration for this profiling group.
    public var notificationConfiguration: CodeGuruProfilerClientTypes.NotificationConfiguration?

    public init(
        notificationConfiguration: CodeGuruProfilerClientTypes.NotificationConfiguration? = nil
    )
    {
        self.notificationConfiguration = notificationConfiguration
    }
}

struct RemoveNotificationChannelOutputBody: Swift.Equatable {
    let notificationConfiguration: CodeGuruProfilerClientTypes.NotificationConfiguration?
}

extension RemoveNotificationChannelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationConfigurationDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.NotificationConfiguration.self, forKey: .notificationConfiguration)
        notificationConfiguration = notificationConfigurationDecoded
    }
}

enum RemoveNotificationChannelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RemovePermissionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let revisionId = revisionId else {
                let message = "Creating a URL Query Item failed. revisionId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let revisionIdQueryItem = ClientRuntime.URLQueryItem(name: "revisionId".urlPercentEncoding(), value: Swift.String(revisionId).urlPercentEncoding())
            items.append(revisionIdQueryItem)
            return items
        }
    }
}

extension RemovePermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profilingGroupName = profilingGroupName else {
            return nil
        }
        guard let actionGroup = actionGroup else {
            return nil
        }
        return "/profilingGroups/\(profilingGroupName.urlPercentEncoding())/policy/\(actionGroup.rawValue.urlPercentEncoding())"
    }
}

/// The structure representing the removePermissionRequest.
public struct RemovePermissionInput: Swift.Equatable {
    /// Specifies an action group that contains the permissions to remove from a profiling group's resource-based policy. One action group is supported, agentPermissions, which grants ConfigureAgent and PostAgentProfile permissions.
    /// This member is required.
    public var actionGroup: CodeGuruProfilerClientTypes.ActionGroup?
    /// The name of the profiling group.
    /// This member is required.
    public var profilingGroupName: Swift.String?
    /// A universally unique identifier (UUID) for the revision of the resource-based policy from which you want to remove permissions.
    /// This member is required.
    public var revisionId: Swift.String?

    public init(
        actionGroup: CodeGuruProfilerClientTypes.ActionGroup? = nil,
        profilingGroupName: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.actionGroup = actionGroup
        self.profilingGroupName = profilingGroupName
        self.revisionId = revisionId
    }
}

struct RemovePermissionInputBody: Swift.Equatable {
}

extension RemovePermissionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension RemovePermissionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RemovePermissionOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.revisionId = output.revisionId
        } else {
            self.policy = nil
            self.revisionId = nil
        }
    }
}

/// The structure representing the removePermissionResponse.
public struct RemovePermissionOutput: Swift.Equatable {
    /// The JSON-formatted resource-based policy on the profiling group after the specified permissions were removed.
    /// This member is required.
    public var policy: Swift.String?
    /// A universally unique identifier (UUID) for the revision of the resource-based policy after the specified permissions were removed. The updated JSON-formatted policy is in the policy element of the response.
    /// This member is required.
    public var revisionId: Swift.String?

    public init(
        policy: Swift.String? = nil,
        revisionId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.revisionId = revisionId
    }
}

struct RemovePermissionOutputBody: Swift.Equatable {
    let policy: Swift.String?
    let revisionId: Swift.String?
}

extension RemovePermissionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
        case revisionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

enum RemovePermissionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource specified in the request does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have exceeded your service quota. To perform the requested action, remove some of the relevant resources, or use [Service Quotas](https://docs.aws.amazon.com/servicequotas/latest/userguide/intro.html) to request a service quota increase.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubmitFeedbackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension SubmitFeedbackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profilingGroupName = profilingGroupName else {
            return nil
        }
        guard let anomalyInstanceId = anomalyInstanceId else {
            return nil
        }
        return "/internal/profilingGroups/\(profilingGroupName.urlPercentEncoding())/anomalies/\(anomalyInstanceId.urlPercentEncoding())/feedback"
    }
}

/// The structure representing the SubmitFeedbackRequest.
public struct SubmitFeedbackInput: Swift.Equatable {
    /// The universally unique identifier (UUID) of the [AnomalyInstance](https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_AnomalyInstance.html) object that is included in the analysis data.
    /// This member is required.
    public var anomalyInstanceId: Swift.String?
    /// Optional feedback about this anomaly.
    public var comment: Swift.String?
    /// The name of the profiling group that is associated with the analysis data.
    /// This member is required.
    public var profilingGroupName: Swift.String?
    /// The feedback tpye. Thee are two valid values, Positive and Negative.
    /// This member is required.
    public var type: CodeGuruProfilerClientTypes.FeedbackType?

    public init(
        anomalyInstanceId: Swift.String? = nil,
        comment: Swift.String? = nil,
        profilingGroupName: Swift.String? = nil,
        type: CodeGuruProfilerClientTypes.FeedbackType? = nil
    )
    {
        self.anomalyInstanceId = anomalyInstanceId
        self.comment = comment
        self.profilingGroupName = profilingGroupName
        self.type = type
    }
}

struct SubmitFeedbackInputBody: Swift.Equatable {
    let type: CodeGuruProfilerClientTypes.FeedbackType?
    let comment: Swift.String?
}

extension SubmitFeedbackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.FeedbackType.self, forKey: .type)
        type = typeDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension SubmitFeedbackOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// The structure representing the SubmitFeedbackResponse.
public struct SubmitFeedbackOutput: Swift.Equatable {

    public init() { }
}

enum SubmitFeedbackOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that the tags are added to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tags that are added to the specified resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeGuruProfilerClientTypes.TimestampStructure: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = self.value {
            try encodeContainer.encodeTimestamp(value, format: .dateTime, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .value)
        value = valueDecoded
    }
}

extension CodeGuruProfilerClientTypes {
    /// A data type that contains a Timestamp object. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
    public struct TimestampStructure: Swift.Equatable {
        /// A Timestamp. This is specified using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
        /// This member is required.
        public var value: ClientRuntime.Date?

        public init(
            value: ClientRuntime.Date? = nil
        )
        {
            self.value = value
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that contains the tags to remove.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tag keys. Existing tags of resources with keys in this list are removed from the specified resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateProfilingGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentOrchestrationConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentOrchestrationConfig = self.agentOrchestrationConfig {
            try encodeContainer.encode(agentOrchestrationConfig, forKey: .agentOrchestrationConfig)
        }
    }
}

extension UpdateProfilingGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let profilingGroupName = profilingGroupName else {
            return nil
        }
        return "/profilingGroups/\(profilingGroupName.urlPercentEncoding())"
    }
}

/// The structure representing the updateProfilingGroupRequest.
public struct UpdateProfilingGroupInput: Swift.Equatable {
    /// Specifies whether profiling is enabled or disabled for a profiling group.
    /// This member is required.
    public var agentOrchestrationConfig: CodeGuruProfilerClientTypes.AgentOrchestrationConfig?
    /// The name of the profiling group to update.
    /// This member is required.
    public var profilingGroupName: Swift.String?

    public init(
        agentOrchestrationConfig: CodeGuruProfilerClientTypes.AgentOrchestrationConfig? = nil,
        profilingGroupName: Swift.String? = nil
    )
    {
        self.agentOrchestrationConfig = agentOrchestrationConfig
        self.profilingGroupName = profilingGroupName
    }
}

struct UpdateProfilingGroupInputBody: Swift.Equatable {
    let agentOrchestrationConfig: CodeGuruProfilerClientTypes.AgentOrchestrationConfig?
}

extension UpdateProfilingGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentOrchestrationConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentOrchestrationConfigDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.AgentOrchestrationConfig.self, forKey: .agentOrchestrationConfig)
        agentOrchestrationConfig = agentOrchestrationConfigDecoded
    }
}

extension UpdateProfilingGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(), let responseDecoder = decoder {
            let output: CodeGuruProfilerClientTypes.ProfilingGroupDescription = try responseDecoder.decode(responseBody: data)
            self.profilingGroup = output
        } else {
            self.profilingGroup = nil
        }
    }
}

/// The structure representing the updateProfilingGroupResponse.
public struct UpdateProfilingGroupOutput: Swift.Equatable {
    /// A [ProfilingGroupDescription](https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ProfilingGroupDescription.html) that contains information about the returned updated profiling group.
    /// This member is required.
    public var profilingGroup: CodeGuruProfilerClientTypes.ProfilingGroupDescription?

    public init(
        profilingGroup: CodeGuruProfilerClientTypes.ProfilingGroupDescription? = nil
    )
    {
        self.profilingGroup = profilingGroup
    }
}

struct UpdateProfilingGroupOutputBody: Swift.Equatable {
    let profilingGroup: CodeGuruProfilerClientTypes.ProfilingGroupDescription?
}

extension UpdateProfilingGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profilingGroup
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profilingGroupDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.ProfilingGroupDescription.self, forKey: .profilingGroup)
        profilingGroup = profilingGroupDecoded
    }
}

enum UpdateProfilingGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CodeGuruProfilerClientTypes.UserFeedback: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CodeGuruProfilerClientTypes.FeedbackType.self, forKey: .type)
        type = typeDecoded
    }
}

extension CodeGuruProfilerClientTypes {
    /// Feedback that can be submitted for each instance of an anomaly by the user. Feedback is be used for improvements in generating recommendations for the application.
    public struct UserFeedback: Swift.Equatable {
        /// Optional Positive or Negative feedback submitted by the user about whether the recommendation is useful or not.
        /// This member is required.
        public var type: CodeGuruProfilerClientTypes.FeedbackType?

        public init(
            type: CodeGuruProfilerClientTypes.FeedbackType? = nil
        )
        {
            self.type = type
        }
    }

}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The parameter is not valid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
