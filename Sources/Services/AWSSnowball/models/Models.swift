// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension SnowballClientTypes.Address: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
        case city = "City"
        case company = "Company"
        case country = "Country"
        case isRestricted = "IsRestricted"
        case landmark = "Landmark"
        case name = "Name"
        case phoneNumber = "PhoneNumber"
        case postalCode = "PostalCode"
        case prefectureOrDistrict = "PrefectureOrDistrict"
        case stateOrProvince = "StateOrProvince"
        case street1 = "Street1"
        case street2 = "Street2"
        case street3 = "Street3"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressId = self.addressId {
            try encodeContainer.encode(addressId, forKey: .addressId)
        }
        if let city = self.city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let company = self.company {
            try encodeContainer.encode(company, forKey: .company)
        }
        if let country = self.country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if isRestricted != false {
            try encodeContainer.encode(isRestricted, forKey: .isRestricted)
        }
        if let landmark = self.landmark {
            try encodeContainer.encode(landmark, forKey: .landmark)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let phoneNumber = self.phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let postalCode = self.postalCode {
            try encodeContainer.encode(postalCode, forKey: .postalCode)
        }
        if let prefectureOrDistrict = self.prefectureOrDistrict {
            try encodeContainer.encode(prefectureOrDistrict, forKey: .prefectureOrDistrict)
        }
        if let stateOrProvince = self.stateOrProvince {
            try encodeContainer.encode(stateOrProvince, forKey: .stateOrProvince)
        }
        if let street1 = self.street1 {
            try encodeContainer.encode(street1, forKey: .street1)
        }
        if let street2 = self.street2 {
            try encodeContainer.encode(street2, forKey: .street2)
        }
        if let street3 = self.street3 {
            try encodeContainer.encode(street3, forKey: .street3)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressId)
        addressId = addressIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let companyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .company)
        company = companyDecoded
        let street1Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .street1)
        street1 = street1Decoded
        let street2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .street2)
        street2 = street2Decoded
        let street3Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .street3)
        street3 = street3Decoded
        let cityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .city)
        city = cityDecoded
        let stateOrProvinceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateOrProvince)
        stateOrProvince = stateOrProvinceDecoded
        let prefectureOrDistrictDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefectureOrDistrict)
        prefectureOrDistrict = prefectureOrDistrictDecoded
        let landmarkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .landmark)
        landmark = landmarkDecoded
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
        let postalCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postalCode)
        postalCode = postalCodeDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let isRestrictedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isRestricted) ?? false
        isRestricted = isRestrictedDecoded
    }
}

extension SnowballClientTypes {
    /// The address that you want the Snow device(s) associated with a specific job to be shipped to. Addresses are validated at the time of creation. The address you provide must be located within the serviceable area of your region. Although no individual elements of the Address are required, if the address is invalid or unsupported, then an exception is thrown.
    public struct Address: Swift.Equatable {
        /// The unique ID for an address.
        public var addressId: Swift.String?
        /// The city in an address that a Snow device is to be delivered to.
        public var city: Swift.String?
        /// The name of the company to receive a Snow device at an address.
        public var company: Swift.String?
        /// The country in an address that a Snow device is to be delivered to.
        public var country: Swift.String?
        /// If the address you are creating is a primary address, then set this option to true. This field is not supported in most regions.
        public var isRestricted: Swift.Bool
        /// This field is no longer used and the value is ignored.
        public var landmark: Swift.String?
        /// The name of a person to receive a Snow device at an address.
        public var name: Swift.String?
        /// The phone number associated with an address that a Snow device is to be delivered to.
        public var phoneNumber: Swift.String?
        /// The postal code in an address that a Snow device is to be delivered to.
        public var postalCode: Swift.String?
        /// This field is no longer used and the value is ignored.
        public var prefectureOrDistrict: Swift.String?
        /// The state or province in an address that a Snow device is to be delivered to.
        public var stateOrProvince: Swift.String?
        /// The first line in a street address that a Snow device is to be delivered to.
        public var street1: Swift.String?
        /// The second line in a street address that a Snow device is to be delivered to.
        public var street2: Swift.String?
        /// The third line in a street address that a Snow device is to be delivered to.
        public var street3: Swift.String?

        public init (
            addressId: Swift.String? = nil,
            city: Swift.String? = nil,
            company: Swift.String? = nil,
            country: Swift.String? = nil,
            isRestricted: Swift.Bool = false,
            landmark: Swift.String? = nil,
            name: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            prefectureOrDistrict: Swift.String? = nil,
            stateOrProvince: Swift.String? = nil,
            street1: Swift.String? = nil,
            street2: Swift.String? = nil,
            street3: Swift.String? = nil
        )
        {
            self.addressId = addressId
            self.city = city
            self.company = company
            self.country = country
            self.isRestricted = isRestricted
            self.landmark = landmark
            self.name = name
            self.phoneNumber = phoneNumber
            self.postalCode = postalCode
            self.prefectureOrDistrict = prefectureOrDistrict
            self.stateOrProvince = stateOrProvince
            self.street1 = street1
            self.street2 = street2
            self.street3 = street3
        }
    }

}

extension CancelClusterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterId = "ClusterId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterId = self.clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
    }
}

extension CancelClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CancelClusterInput: Swift.Equatable {
    /// The 39-character ID for the cluster that you want to cancel, for example CID123e4567-e89b-12d3-a456-426655440000.
    /// This member is required.
    public var clusterId: Swift.String?

    public init (
        clusterId: Swift.String? = nil
    )
    {
        self.clusterId = clusterId
    }
}

struct CancelClusterInputBody: Swift.Equatable {
    let clusterId: Swift.String?
}

extension CancelClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterId = "ClusterId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
    }
}

extension CancelClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSRequestFailedException" : self = .kMSRequestFailedException(try KMSRequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CancelClusterOutputError: Swift.Error, Swift.Equatable {
    case invalidJobStateException(InvalidJobStateException)
    case invalidResourceException(InvalidResourceException)
    case kMSRequestFailedException(KMSRequestFailedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CancelClusterOutputResponse: Swift.Equatable {

    public init () { }
}

extension CancelJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension CancelJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CancelJobInput: Swift.Equatable {
    /// The 39-character job ID for the job that you want to cancel, for example JID123e4567-e89b-12d3-a456-426655440000.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct CancelJobInputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension CancelJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension CancelJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSRequestFailedException" : self = .kMSRequestFailedException(try KMSRequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CancelJobOutputError: Swift.Error, Swift.Equatable {
    case invalidJobStateException(InvalidJobStateException)
    case invalidResourceException(InvalidResourceException)
    case kMSRequestFailedException(KMSRequestFailedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CancelJobOutputResponse: Swift.Equatable {

    public init () { }
}

extension ClusterLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ClusterLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Job creation failed. Currently, clusters support five nodes. If you have fewer than five nodes for your cluster and you have more nodes to create for this cluster, try again and create jobs until your cluster has exactly five nodes.
public struct ClusterLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ClusterLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnowballClientTypes.ClusterListEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterId = "ClusterId"
        case clusterState = "ClusterState"
        case creationDate = "CreationDate"
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterId = self.clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let clusterState = self.clusterState {
            try encodeContainer.encode(clusterState.rawValue, forKey: .clusterState)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let clusterStateDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ClusterState.self, forKey: .clusterState)
        clusterState = clusterStateDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension SnowballClientTypes {
    /// Contains a cluster's state, a cluster's ID, and other important information.
    public struct ClusterListEntry: Swift.Equatable {
        /// The 39-character ID for the cluster that you want to list, for example CID123e4567-e89b-12d3-a456-426655440000.
        public var clusterId: Swift.String?
        /// The current state of this cluster. For information about the state of a specific node, see [JobListEntry$JobState].
        public var clusterState: SnowballClientTypes.ClusterState?
        /// The creation date for this cluster.
        public var creationDate: ClientRuntime.Date?
        /// Defines an optional description of the cluster, for example Environmental Data Cluster-01.
        public var description: Swift.String?

        public init (
            clusterId: Swift.String? = nil,
            clusterState: SnowballClientTypes.ClusterState? = nil,
            creationDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil
        )
        {
            self.clusterId = clusterId
            self.clusterState = clusterState
            self.creationDate = creationDate
            self.description = description
        }
    }

}

extension SnowballClientTypes.ClusterMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
        case clusterId = "ClusterId"
        case clusterState = "ClusterState"
        case creationDate = "CreationDate"
        case description = "Description"
        case forwardingAddressId = "ForwardingAddressId"
        case jobType = "JobType"
        case kmsKeyARN = "KmsKeyARN"
        case notification = "Notification"
        case onDeviceServiceConfiguration = "OnDeviceServiceConfiguration"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingOption = "ShippingOption"
        case snowballType = "SnowballType"
        case taxDocuments = "TaxDocuments"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressId = self.addressId {
            try encodeContainer.encode(addressId, forKey: .addressId)
        }
        if let clusterId = self.clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let clusterState = self.clusterState {
            try encodeContainer.encode(clusterState.rawValue, forKey: .clusterState)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let forwardingAddressId = self.forwardingAddressId {
            try encodeContainer.encode(forwardingAddressId, forKey: .forwardingAddressId)
        }
        if let jobType = self.jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
        if let kmsKeyARN = self.kmsKeyARN {
            try encodeContainer.encode(kmsKeyARN, forKey: .kmsKeyARN)
        }
        if let notification = self.notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let onDeviceServiceConfiguration = self.onDeviceServiceConfiguration {
            try encodeContainer.encode(onDeviceServiceConfiguration, forKey: .onDeviceServiceConfiguration)
        }
        if let resources = self.resources {
            try encodeContainer.encode(resources, forKey: .resources)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
        if let shippingOption = self.shippingOption {
            try encodeContainer.encode(shippingOption.rawValue, forKey: .shippingOption)
        }
        if let snowballType = self.snowballType {
            try encodeContainer.encode(snowballType.rawValue, forKey: .snowballType)
        }
        if let taxDocuments = self.taxDocuments {
            try encodeContainer.encode(taxDocuments, forKey: .taxDocuments)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let kmsKeyARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyARN)
        kmsKeyARN = kmsKeyARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        let clusterStateDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ClusterState.self, forKey: .clusterState)
        clusterState = clusterStateDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let snowballTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.SnowballType.self, forKey: .snowballType)
        snowballType = snowballTypeDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let resourcesDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobResource.self, forKey: .resources)
        resources = resourcesDecoded
        let addressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressId)
        addressId = addressIdDecoded
        let shippingOptionDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ShippingOption.self, forKey: .shippingOption)
        shippingOption = shippingOptionDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
        let forwardingAddressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forwardingAddressId)
        forwardingAddressId = forwardingAddressIdDecoded
        let taxDocumentsDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.TaxDocuments.self, forKey: .taxDocuments)
        taxDocuments = taxDocumentsDecoded
        let onDeviceServiceConfigurationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.OnDeviceServiceConfiguration.self, forKey: .onDeviceServiceConfiguration)
        onDeviceServiceConfiguration = onDeviceServiceConfigurationDecoded
    }
}

extension SnowballClientTypes {
    /// Contains metadata about a specific cluster.
    public struct ClusterMetadata: Swift.Equatable {
        /// The automatically generated ID for a specific address.
        public var addressId: Swift.String?
        /// The automatically generated ID for a cluster.
        public var clusterId: Swift.String?
        /// The current status of the cluster.
        public var clusterState: SnowballClientTypes.ClusterState?
        /// The creation date for this cluster.
        public var creationDate: ClientRuntime.Date?
        /// The optional description of the cluster.
        public var description: Swift.String?
        /// The ID of the address that you want a cluster shipped to, after it will be shipped to its primary address. This field is not supported in most regions.
        public var forwardingAddressId: Swift.String?
        /// The type of job for this cluster. Currently, the only job type supported for clusters is LOCAL_USE.
        public var jobType: SnowballClientTypes.JobType?
        /// The KmsKeyARN Amazon Resource Name (ARN) associated with this cluster. This ARN was created using the [CreateKey](https://docs.aws.amazon.com/kms/latest/APIReference/API_CreateKey.html) API action in Key Management Service (KMS.
        public var kmsKeyARN: Swift.String?
        /// The Amazon Simple Notification Service (Amazon SNS) notification settings for this cluster.
        public var notification: SnowballClientTypes.Notification?
        /// Represents metadata and configuration settings for services on an Amazon Web Services Snow Family device.
        public var onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration?
        /// The arrays of [JobResource] objects that can include updated [S3Resource] objects or [LambdaResource] objects.
        public var resources: SnowballClientTypes.JobResource?
        /// The role ARN associated with this cluster. This ARN was created using the [CreateRole](https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html) API action in Identity and Access Management (IAM).
        public var roleARN: Swift.String?
        /// The shipping speed for each node in this cluster. This speed doesn't dictate how soon you'll get each device, rather it represents how quickly each device moves to its destination while in transit. Regional shipping speeds are as follows:
        ///
        /// * In Australia, you have access to express shipping. Typically, devices shipped express are delivered in about a day.
        ///
        /// * In the European Union (EU), you have access to express shipping. Typically, Snow devices shipped express are delivered in about a day. In addition, most countries in the EU have access to standard shipping, which typically takes less than a week, one way.
        ///
        /// * In India, Snow devices are delivered in one to seven days.
        ///
        /// * In the US, you have access to one-day shipping and two-day shipping.
        public var shippingOption: SnowballClientTypes.ShippingOption?
        /// The type of Snowcone device to use for this cluster. For cluster jobs, Amazon Web Services Snow Family currently supports only the EDGE device type.
        public var snowballType: SnowballClientTypes.SnowballType?
        /// The tax documents required in your Amazon Web Services Region.
        public var taxDocuments: SnowballClientTypes.TaxDocuments?

        public init (
            addressId: Swift.String? = nil,
            clusterId: Swift.String? = nil,
            clusterState: SnowballClientTypes.ClusterState? = nil,
            creationDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            forwardingAddressId: Swift.String? = nil,
            jobType: SnowballClientTypes.JobType? = nil,
            kmsKeyARN: Swift.String? = nil,
            notification: SnowballClientTypes.Notification? = nil,
            onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration? = nil,
            resources: SnowballClientTypes.JobResource? = nil,
            roleARN: Swift.String? = nil,
            shippingOption: SnowballClientTypes.ShippingOption? = nil,
            snowballType: SnowballClientTypes.SnowballType? = nil,
            taxDocuments: SnowballClientTypes.TaxDocuments? = nil
        )
        {
            self.addressId = addressId
            self.clusterId = clusterId
            self.clusterState = clusterState
            self.creationDate = creationDate
            self.description = description
            self.forwardingAddressId = forwardingAddressId
            self.jobType = jobType
            self.kmsKeyARN = kmsKeyARN
            self.notification = notification
            self.onDeviceServiceConfiguration = onDeviceServiceConfiguration
            self.resources = resources
            self.roleARN = roleARN
            self.shippingOption = shippingOption
            self.snowballType = snowballType
            self.taxDocuments = taxDocuments
        }
    }

}

extension SnowballClientTypes {
    public enum ClusterState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awaitingQuorum
        case cancelled
        case complete
        case inUse
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ClusterState] {
            return [
                .awaitingQuorum,
                .cancelled,
                .complete,
                .inUse,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awaitingQuorum: return "AwaitingQuorum"
            case .cancelled: return "Cancelled"
            case .complete: return "Complete"
            case .inUse: return "InUse"
            case .pending: return "Pending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ClusterState(rawValue: rawValue) ?? ClusterState.sdkUnknown(rawValue)
        }
    }
}

extension SnowballClientTypes.CompatibleImage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amiId = "AmiId"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amiId = self.amiId {
            try encodeContainer.encode(amiId, forKey: .amiId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amiId)
        amiId = amiIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension SnowballClientTypes {
    /// A JSON-formatted object that describes a compatible Amazon Machine Image (AMI), including the ID and name for a Snow device AMI. This AMI is compatible with the device's physical hardware requirements, and it should be able to be run in an SBE1 instance on the device.
    public struct CompatibleImage: Swift.Equatable {
        /// The unique identifier for an individual Snow device AMI.
        public var amiId: Swift.String?
        /// The optional name of a compatible image.
        public var name: Swift.String?

        public init (
            amiId: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.amiId = amiId
            self.name = name
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.conflictResource = output.conflictResource
            self.message = output.message
        } else {
            self.conflictResource = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You get this exception when you call CreateReturnShippingLabel more than once when other requests are not completed.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// You get this resource when you call CreateReturnShippingLabel more than once when other requests are not completed. .
    public var conflictResource: Swift.String?
    public var message: Swift.String?

    public init (
        conflictResource: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.conflictResource = conflictResource
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let conflictResource: Swift.String?
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictResource = "ConflictResource"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conflictResourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conflictResource)
        conflictResource = conflictResourceDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateAddressInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = self.address {
            try encodeContainer.encode(address, forKey: .address)
        }
    }
}

extension CreateAddressInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAddressInput: Swift.Equatable {
    /// The address that you want the Snow device shipped to.
    /// This member is required.
    public var address: SnowballClientTypes.Address?

    public init (
        address: SnowballClientTypes.Address? = nil
    )
    {
        self.address = address
    }
}

struct CreateAddressInputBody: Swift.Equatable {
    let address: SnowballClientTypes.Address?
}

extension CreateAddressInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.Address.self, forKey: .address)
        address = addressDecoded
    }
}

extension CreateAddressOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAddressOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidAddressException" : self = .invalidAddressException(try InvalidAddressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedAddressException" : self = .unsupportedAddressException(try UnsupportedAddressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateAddressOutputError: Swift.Error, Swift.Equatable {
    case invalidAddressException(InvalidAddressException)
    case unsupportedAddressException(UnsupportedAddressException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAddressOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateAddressOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.addressId = output.addressId
        } else {
            self.addressId = nil
        }
    }
}

public struct CreateAddressOutputResponse: Swift.Equatable {
    /// The automatically generated ID for a specific address. You'll use this ID when you create a job to specify which address you want the Snow device for that job shipped to.
    public var addressId: Swift.String?

    public init (
        addressId: Swift.String? = nil
    )
    {
        self.addressId = addressId
    }
}

struct CreateAddressOutputResponseBody: Swift.Equatable {
    let addressId: Swift.String?
}

extension CreateAddressOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressId)
        addressId = addressIdDecoded
    }
}

extension CreateClusterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
        case description = "Description"
        case forwardingAddressId = "ForwardingAddressId"
        case jobType = "JobType"
        case kmsKeyARN = "KmsKeyARN"
        case notification = "Notification"
        case onDeviceServiceConfiguration = "OnDeviceServiceConfiguration"
        case remoteManagement = "RemoteManagement"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingOption = "ShippingOption"
        case snowballType = "SnowballType"
        case taxDocuments = "TaxDocuments"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressId = self.addressId {
            try encodeContainer.encode(addressId, forKey: .addressId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let forwardingAddressId = self.forwardingAddressId {
            try encodeContainer.encode(forwardingAddressId, forKey: .forwardingAddressId)
        }
        if let jobType = self.jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
        if let kmsKeyARN = self.kmsKeyARN {
            try encodeContainer.encode(kmsKeyARN, forKey: .kmsKeyARN)
        }
        if let notification = self.notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let onDeviceServiceConfiguration = self.onDeviceServiceConfiguration {
            try encodeContainer.encode(onDeviceServiceConfiguration, forKey: .onDeviceServiceConfiguration)
        }
        if let remoteManagement = self.remoteManagement {
            try encodeContainer.encode(remoteManagement.rawValue, forKey: .remoteManagement)
        }
        if let resources = self.resources {
            try encodeContainer.encode(resources, forKey: .resources)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
        if let shippingOption = self.shippingOption {
            try encodeContainer.encode(shippingOption.rawValue, forKey: .shippingOption)
        }
        if let snowballType = self.snowballType {
            try encodeContainer.encode(snowballType.rawValue, forKey: .snowballType)
        }
        if let taxDocuments = self.taxDocuments {
            try encodeContainer.encode(taxDocuments, forKey: .taxDocuments)
        }
    }
}

extension CreateClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateClusterInput: Swift.Equatable {
    /// The ID for the address that you want the cluster shipped to.
    /// This member is required.
    public var addressId: Swift.String?
    /// An optional description of this specific cluster, for example Environmental Data Cluster-01.
    public var description: Swift.String?
    /// The forwarding address ID for a cluster. This field is not supported in most regions.
    public var forwardingAddressId: Swift.String?
    /// The type of job for this cluster. Currently, the only job type supported for clusters is LOCAL_USE. For more information, see "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide or "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide.
    /// This member is required.
    public var jobType: SnowballClientTypes.JobType?
    /// The KmsKeyARN value that you want to associate with this cluster. KmsKeyARN values are created by using the [CreateKey](https://docs.aws.amazon.com/kms/latest/APIReference/API_CreateKey.html) API action in Key Management Service (KMS).
    public var kmsKeyARN: Swift.String?
    /// The Amazon Simple Notification Service (Amazon SNS) notification settings for this cluster.
    public var notification: SnowballClientTypes.Notification?
    /// Specifies the service or services on the Snow Family device that your transferred data will be exported from or imported into. Amazon Web Services Snow Family device clusters support Amazon S3 and NFS (Network File System).
    public var onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration?
    /// Allows you to securely operate and manage Snow devices in a cluster remotely from outside of your internal network. When set to INSTALLED_AUTOSTART, remote management will automatically be available when the device arrives at your location. Otherwise, you need to use the Snowball Client to manage the device.
    public var remoteManagement: SnowballClientTypes.RemoteManagement?
    /// The resources associated with the cluster job. These resources include Amazon S3 buckets and optional Lambda functions written in the Python language.
    /// This member is required.
    public var resources: SnowballClientTypes.JobResource?
    /// The RoleARN that you want to associate with this cluster. RoleArn values are created by using the [CreateRole](https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html) API action in Identity and Access Management (IAM).
    /// This member is required.
    public var roleARN: Swift.String?
    /// The shipping speed for each node in this cluster. This speed doesn't dictate how soon you'll get each Snowball Edge device, rather it represents how quickly each device moves to its destination while in transit. Regional shipping speeds are as follows:
    ///
    /// * In Australia, you have access to express shipping. Typically, Snow devices shipped express are delivered in about a day.
    ///
    /// * In the European Union (EU), you have access to express shipping. Typically, Snow devices shipped express are delivered in about a day. In addition, most countries in the EU have access to standard shipping, which typically takes less than a week, one way.
    ///
    /// * In India, Snow devices are delivered in one to seven days.
    ///
    /// * In the United States of America (US), you have access to one-day shipping and two-day shipping.
    ///
    ///
    ///
    ///
    /// * In Australia, you have access to express shipping. Typically, devices shipped express are delivered in about a day.
    ///
    /// * In the European Union (EU), you have access to express shipping. Typically, Snow devices shipped express are delivered in about a day. In addition, most countries in the EU have access to standard shipping, which typically takes less than a week, one way.
    ///
    /// * In India, Snow devices are delivered in one to seven days.
    ///
    /// * In the US, you have access to one-day shipping and two-day shipping.
    /// This member is required.
    public var shippingOption: SnowballClientTypes.ShippingOption?
    /// The type of Snow Family devices to use for this cluster. For cluster jobs, Amazon Web Services Snow Family currently supports only the EDGE device type. For more information, see "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide or "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide.
    /// This member is required.
    public var snowballType: SnowballClientTypes.SnowballType?
    /// The tax documents required in your Amazon Web Services Region.
    public var taxDocuments: SnowballClientTypes.TaxDocuments?

    public init (
        addressId: Swift.String? = nil,
        description: Swift.String? = nil,
        forwardingAddressId: Swift.String? = nil,
        jobType: SnowballClientTypes.JobType? = nil,
        kmsKeyARN: Swift.String? = nil,
        notification: SnowballClientTypes.Notification? = nil,
        onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration? = nil,
        remoteManagement: SnowballClientTypes.RemoteManagement? = nil,
        resources: SnowballClientTypes.JobResource? = nil,
        roleARN: Swift.String? = nil,
        shippingOption: SnowballClientTypes.ShippingOption? = nil,
        snowballType: SnowballClientTypes.SnowballType? = nil,
        taxDocuments: SnowballClientTypes.TaxDocuments? = nil
    )
    {
        self.addressId = addressId
        self.description = description
        self.forwardingAddressId = forwardingAddressId
        self.jobType = jobType
        self.kmsKeyARN = kmsKeyARN
        self.notification = notification
        self.onDeviceServiceConfiguration = onDeviceServiceConfiguration
        self.remoteManagement = remoteManagement
        self.resources = resources
        self.roleARN = roleARN
        self.shippingOption = shippingOption
        self.snowballType = snowballType
        self.taxDocuments = taxDocuments
    }
}

struct CreateClusterInputBody: Swift.Equatable {
    let jobType: SnowballClientTypes.JobType?
    let resources: SnowballClientTypes.JobResource?
    let onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration?
    let description: Swift.String?
    let addressId: Swift.String?
    let kmsKeyARN: Swift.String?
    let roleARN: Swift.String?
    let snowballType: SnowballClientTypes.SnowballType?
    let shippingOption: SnowballClientTypes.ShippingOption?
    let notification: SnowballClientTypes.Notification?
    let forwardingAddressId: Swift.String?
    let taxDocuments: SnowballClientTypes.TaxDocuments?
    let remoteManagement: SnowballClientTypes.RemoteManagement?
}

extension CreateClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
        case description = "Description"
        case forwardingAddressId = "ForwardingAddressId"
        case jobType = "JobType"
        case kmsKeyARN = "KmsKeyARN"
        case notification = "Notification"
        case onDeviceServiceConfiguration = "OnDeviceServiceConfiguration"
        case remoteManagement = "RemoteManagement"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingOption = "ShippingOption"
        case snowballType = "SnowballType"
        case taxDocuments = "TaxDocuments"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let resourcesDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobResource.self, forKey: .resources)
        resources = resourcesDecoded
        let onDeviceServiceConfigurationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.OnDeviceServiceConfiguration.self, forKey: .onDeviceServiceConfiguration)
        onDeviceServiceConfiguration = onDeviceServiceConfigurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let addressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressId)
        addressId = addressIdDecoded
        let kmsKeyARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyARN)
        kmsKeyARN = kmsKeyARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        let snowballTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.SnowballType.self, forKey: .snowballType)
        snowballType = snowballTypeDecoded
        let shippingOptionDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ShippingOption.self, forKey: .shippingOption)
        shippingOption = shippingOptionDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
        let forwardingAddressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forwardingAddressId)
        forwardingAddressId = forwardingAddressIdDecoded
        let taxDocumentsDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.TaxDocuments.self, forKey: .taxDocuments)
        taxDocuments = taxDocumentsDecoded
        let remoteManagementDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.RemoteManagement.self, forKey: .remoteManagement)
        remoteManagement = remoteManagementDecoded
    }
}

extension CreateClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "Ec2RequestFailedException" : self = .ec2RequestFailedException(try Ec2RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputCombinationException" : self = .invalidInputCombinationException(try InvalidInputCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSRequestFailedException" : self = .kMSRequestFailedException(try KMSRequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateClusterOutputError: Swift.Error, Swift.Equatable {
    case ec2RequestFailedException(Ec2RequestFailedException)
    case invalidInputCombinationException(InvalidInputCombinationException)
    case invalidResourceException(InvalidResourceException)
    case kMSRequestFailedException(KMSRequestFailedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterId = output.clusterId
        } else {
            self.clusterId = nil
        }
    }
}

public struct CreateClusterOutputResponse: Swift.Equatable {
    /// The automatically generated ID for a cluster.
    public var clusterId: Swift.String?

    public init (
        clusterId: Swift.String? = nil
    )
    {
        self.clusterId = clusterId
    }
}

struct CreateClusterOutputResponseBody: Swift.Equatable {
    let clusterId: Swift.String?
}

extension CreateClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterId = "ClusterId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
    }
}

extension CreateJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
        case clusterId = "ClusterId"
        case description = "Description"
        case deviceConfiguration = "DeviceConfiguration"
        case forwardingAddressId = "ForwardingAddressId"
        case jobType = "JobType"
        case kmsKeyARN = "KmsKeyARN"
        case longTermPricingId = "LongTermPricingId"
        case notification = "Notification"
        case onDeviceServiceConfiguration = "OnDeviceServiceConfiguration"
        case remoteManagement = "RemoteManagement"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingOption = "ShippingOption"
        case snowballCapacityPreference = "SnowballCapacityPreference"
        case snowballType = "SnowballType"
        case taxDocuments = "TaxDocuments"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressId = self.addressId {
            try encodeContainer.encode(addressId, forKey: .addressId)
        }
        if let clusterId = self.clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceConfiguration = self.deviceConfiguration {
            try encodeContainer.encode(deviceConfiguration, forKey: .deviceConfiguration)
        }
        if let forwardingAddressId = self.forwardingAddressId {
            try encodeContainer.encode(forwardingAddressId, forKey: .forwardingAddressId)
        }
        if let jobType = self.jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
        if let kmsKeyARN = self.kmsKeyARN {
            try encodeContainer.encode(kmsKeyARN, forKey: .kmsKeyARN)
        }
        if let longTermPricingId = self.longTermPricingId {
            try encodeContainer.encode(longTermPricingId, forKey: .longTermPricingId)
        }
        if let notification = self.notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let onDeviceServiceConfiguration = self.onDeviceServiceConfiguration {
            try encodeContainer.encode(onDeviceServiceConfiguration, forKey: .onDeviceServiceConfiguration)
        }
        if let remoteManagement = self.remoteManagement {
            try encodeContainer.encode(remoteManagement.rawValue, forKey: .remoteManagement)
        }
        if let resources = self.resources {
            try encodeContainer.encode(resources, forKey: .resources)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
        if let shippingOption = self.shippingOption {
            try encodeContainer.encode(shippingOption.rawValue, forKey: .shippingOption)
        }
        if let snowballCapacityPreference = self.snowballCapacityPreference {
            try encodeContainer.encode(snowballCapacityPreference.rawValue, forKey: .snowballCapacityPreference)
        }
        if let snowballType = self.snowballType {
            try encodeContainer.encode(snowballType.rawValue, forKey: .snowballType)
        }
        if let taxDocuments = self.taxDocuments {
            try encodeContainer.encode(taxDocuments, forKey: .taxDocuments)
        }
    }
}

extension CreateJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateJobInput: Swift.Equatable {
    /// The ID for the address that you want the Snow device shipped to.
    public var addressId: Swift.String?
    /// The ID of a cluster. If you're creating a job for a node in a cluster, you need to provide only this clusterId value. The other job attributes are inherited from the cluster.
    public var clusterId: Swift.String?
    /// Defines an optional description of this specific job, for example Important Photos 2016-08-11.
    public var description: Swift.String?
    /// Defines the device configuration for an Snowcone job. For more information, see "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide or "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide.
    public var deviceConfiguration: SnowballClientTypes.DeviceConfiguration?
    /// The forwarding address ID for a job. This field is not supported in most Regions.
    public var forwardingAddressId: Swift.String?
    /// Defines the type of job that you're creating.
    public var jobType: SnowballClientTypes.JobType?
    /// The KmsKeyARN that you want to associate with this job. KmsKeyARNs are created using the [CreateKey](https://docs.aws.amazon.com/kms/latest/APIReference/API_CreateKey.html) Key Management Service (KMS) API action.
    public var kmsKeyARN: Swift.String?
    /// The ID of the long-term pricing type for the device.
    public var longTermPricingId: Swift.String?
    /// Defines the Amazon Simple Notification Service (Amazon SNS) notification settings for this job.
    public var notification: SnowballClientTypes.Notification?
    /// Specifies the service or services on the Snow Family device that your transferred data will be exported from or imported into. Amazon Web Services Snow Family supports Amazon S3 and NFS (Network File System) and the Amazon Web Services Storage Gateway service Tape Gateway type.
    public var onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration?
    /// Allows you to securely operate and manage Snowcone devices remotely from outside of your internal network. When set to INSTALLED_AUTOSTART, remote management will automatically be available when the device arrives at your location. Otherwise, you need to use the Snowball Client to manage the device.
    public var remoteManagement: SnowballClientTypes.RemoteManagement?
    /// Defines the Amazon S3 buckets associated with this job. With IMPORT jobs, you specify the bucket or buckets that your transferred data will be imported into. With EXPORT jobs, you specify the bucket or buckets that your transferred data will be exported from. Optionally, you can also specify a KeyRange value. If you choose to export a range, you define the length of the range by providing either an inclusive BeginMarker value, an inclusive EndMarker value, or both. Ranges are UTF-8 binary sorted.
    public var resources: SnowballClientTypes.JobResource?
    /// The RoleARN that you want to associate with this job. RoleArns are created using the [CreateRole](https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html) Identity and Access Management (IAM) API action.
    public var roleARN: Swift.String?
    /// The shipping speed for this job. This speed doesn't dictate how soon you'll get the Snow device, rather it represents how quickly the Snow device moves to its destination while in transit. Regional shipping speeds are as follows:
    ///
    /// * In Australia, you have access to express shipping. Typically, Snow devices shipped express are delivered in about a day.
    ///
    /// * In the European Union (EU), you have access to express shipping. Typically, Snow devices shipped express are delivered in about a day. In addition, most countries in the EU have access to standard shipping, which typically takes less than a week, one way.
    ///
    /// * In India, Snow devices are delivered in one to seven days.
    ///
    /// * In the US, you have access to one-day shipping and two-day shipping.
    public var shippingOption: SnowballClientTypes.ShippingOption?
    /// If your job is being created in one of the US regions, you have the option of specifying what size Snow device you'd like for this job. In all other regions, Snowballs come with 80 TB in storage capacity. For more information, see "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide or "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide.
    public var snowballCapacityPreference: SnowballClientTypes.SnowballCapacity?
    /// The type of Snow Family devices to use for this job. For cluster jobs, Amazon Web Services Snow Family currently supports only the EDGE device type. The type of Amazon Web Services Snow device to use for this job. Currently, the only supported device type for cluster jobs is EDGE. For more information, see [Snowball Edge Device Options](https://docs.aws.amazon.com/snowball/latest/developer-guide/device-differences.html) in the Snowball Edge Developer Guide. For more information, see "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide or "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide.
    public var snowballType: SnowballClientTypes.SnowballType?
    /// The tax documents required in your Amazon Web Services Region.
    public var taxDocuments: SnowballClientTypes.TaxDocuments?

    public init (
        addressId: Swift.String? = nil,
        clusterId: Swift.String? = nil,
        description: Swift.String? = nil,
        deviceConfiguration: SnowballClientTypes.DeviceConfiguration? = nil,
        forwardingAddressId: Swift.String? = nil,
        jobType: SnowballClientTypes.JobType? = nil,
        kmsKeyARN: Swift.String? = nil,
        longTermPricingId: Swift.String? = nil,
        notification: SnowballClientTypes.Notification? = nil,
        onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration? = nil,
        remoteManagement: SnowballClientTypes.RemoteManagement? = nil,
        resources: SnowballClientTypes.JobResource? = nil,
        roleARN: Swift.String? = nil,
        shippingOption: SnowballClientTypes.ShippingOption? = nil,
        snowballCapacityPreference: SnowballClientTypes.SnowballCapacity? = nil,
        snowballType: SnowballClientTypes.SnowballType? = nil,
        taxDocuments: SnowballClientTypes.TaxDocuments? = nil
    )
    {
        self.addressId = addressId
        self.clusterId = clusterId
        self.description = description
        self.deviceConfiguration = deviceConfiguration
        self.forwardingAddressId = forwardingAddressId
        self.jobType = jobType
        self.kmsKeyARN = kmsKeyARN
        self.longTermPricingId = longTermPricingId
        self.notification = notification
        self.onDeviceServiceConfiguration = onDeviceServiceConfiguration
        self.remoteManagement = remoteManagement
        self.resources = resources
        self.roleARN = roleARN
        self.shippingOption = shippingOption
        self.snowballCapacityPreference = snowballCapacityPreference
        self.snowballType = snowballType
        self.taxDocuments = taxDocuments
    }
}

struct CreateJobInputBody: Swift.Equatable {
    let jobType: SnowballClientTypes.JobType?
    let resources: SnowballClientTypes.JobResource?
    let onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration?
    let description: Swift.String?
    let addressId: Swift.String?
    let kmsKeyARN: Swift.String?
    let roleARN: Swift.String?
    let snowballCapacityPreference: SnowballClientTypes.SnowballCapacity?
    let shippingOption: SnowballClientTypes.ShippingOption?
    let notification: SnowballClientTypes.Notification?
    let clusterId: Swift.String?
    let snowballType: SnowballClientTypes.SnowballType?
    let forwardingAddressId: Swift.String?
    let taxDocuments: SnowballClientTypes.TaxDocuments?
    let deviceConfiguration: SnowballClientTypes.DeviceConfiguration?
    let remoteManagement: SnowballClientTypes.RemoteManagement?
    let longTermPricingId: Swift.String?
}

extension CreateJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
        case clusterId = "ClusterId"
        case description = "Description"
        case deviceConfiguration = "DeviceConfiguration"
        case forwardingAddressId = "ForwardingAddressId"
        case jobType = "JobType"
        case kmsKeyARN = "KmsKeyARN"
        case longTermPricingId = "LongTermPricingId"
        case notification = "Notification"
        case onDeviceServiceConfiguration = "OnDeviceServiceConfiguration"
        case remoteManagement = "RemoteManagement"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingOption = "ShippingOption"
        case snowballCapacityPreference = "SnowballCapacityPreference"
        case snowballType = "SnowballType"
        case taxDocuments = "TaxDocuments"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let resourcesDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobResource.self, forKey: .resources)
        resources = resourcesDecoded
        let onDeviceServiceConfigurationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.OnDeviceServiceConfiguration.self, forKey: .onDeviceServiceConfiguration)
        onDeviceServiceConfiguration = onDeviceServiceConfigurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let addressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressId)
        addressId = addressIdDecoded
        let kmsKeyARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyARN)
        kmsKeyARN = kmsKeyARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        let snowballCapacityPreferenceDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.SnowballCapacity.self, forKey: .snowballCapacityPreference)
        snowballCapacityPreference = snowballCapacityPreferenceDecoded
        let shippingOptionDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ShippingOption.self, forKey: .shippingOption)
        shippingOption = shippingOptionDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let snowballTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.SnowballType.self, forKey: .snowballType)
        snowballType = snowballTypeDecoded
        let forwardingAddressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forwardingAddressId)
        forwardingAddressId = forwardingAddressIdDecoded
        let taxDocumentsDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.TaxDocuments.self, forKey: .taxDocuments)
        taxDocuments = taxDocumentsDecoded
        let deviceConfigurationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.DeviceConfiguration.self, forKey: .deviceConfiguration)
        deviceConfiguration = deviceConfigurationDecoded
        let remoteManagementDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.RemoteManagement.self, forKey: .remoteManagement)
        remoteManagement = remoteManagementDecoded
        let longTermPricingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .longTermPricingId)
        longTermPricingId = longTermPricingIdDecoded
    }
}

extension CreateJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterLimitExceededException" : self = .clusterLimitExceededException(try ClusterLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Ec2RequestFailedException" : self = .ec2RequestFailedException(try Ec2RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputCombinationException" : self = .invalidInputCombinationException(try InvalidInputCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSRequestFailedException" : self = .kMSRequestFailedException(try KMSRequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateJobOutputError: Swift.Error, Swift.Equatable {
    case clusterLimitExceededException(ClusterLimitExceededException)
    case ec2RequestFailedException(Ec2RequestFailedException)
    case invalidInputCombinationException(InvalidInputCombinationException)
    case invalidResourceException(InvalidResourceException)
    case kMSRequestFailedException(KMSRequestFailedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct CreateJobOutputResponse: Swift.Equatable {
    /// The automatically generated ID for a job, for example JID123e4567-e89b-12d3-a456-426655440000.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct CreateJobOutputResponseBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension CreateJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension CreateLongTermPricingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isLongTermPricingAutoRenew = "IsLongTermPricingAutoRenew"
        case longTermPricingType = "LongTermPricingType"
        case snowballType = "SnowballType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isLongTermPricingAutoRenew = self.isLongTermPricingAutoRenew {
            try encodeContainer.encode(isLongTermPricingAutoRenew, forKey: .isLongTermPricingAutoRenew)
        }
        if let longTermPricingType = self.longTermPricingType {
            try encodeContainer.encode(longTermPricingType.rawValue, forKey: .longTermPricingType)
        }
        if let snowballType = self.snowballType {
            try encodeContainer.encode(snowballType.rawValue, forKey: .snowballType)
        }
    }
}

extension CreateLongTermPricingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateLongTermPricingInput: Swift.Equatable {
    /// Specifies whether the current long-term pricing type for the device should be renewed.
    public var isLongTermPricingAutoRenew: Swift.Bool?
    /// The type of long-term pricing option you want for the device, either 1-year or 3-year long-term pricing.
    /// This member is required.
    public var longTermPricingType: SnowballClientTypes.LongTermPricingType?
    /// The type of Snow Family devices to use for the long-term pricing job.
    public var snowballType: SnowballClientTypes.SnowballType?

    public init (
        isLongTermPricingAutoRenew: Swift.Bool? = nil,
        longTermPricingType: SnowballClientTypes.LongTermPricingType? = nil,
        snowballType: SnowballClientTypes.SnowballType? = nil
    )
    {
        self.isLongTermPricingAutoRenew = isLongTermPricingAutoRenew
        self.longTermPricingType = longTermPricingType
        self.snowballType = snowballType
    }
}

struct CreateLongTermPricingInputBody: Swift.Equatable {
    let longTermPricingType: SnowballClientTypes.LongTermPricingType?
    let isLongTermPricingAutoRenew: Swift.Bool?
    let snowballType: SnowballClientTypes.SnowballType?
}

extension CreateLongTermPricingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isLongTermPricingAutoRenew = "IsLongTermPricingAutoRenew"
        case longTermPricingType = "LongTermPricingType"
        case snowballType = "SnowballType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let longTermPricingTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.LongTermPricingType.self, forKey: .longTermPricingType)
        longTermPricingType = longTermPricingTypeDecoded
        let isLongTermPricingAutoRenewDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isLongTermPricingAutoRenew)
        isLongTermPricingAutoRenew = isLongTermPricingAutoRenewDecoded
        let snowballTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.SnowballType.self, forKey: .snowballType)
        snowballType = snowballTypeDecoded
    }
}

extension CreateLongTermPricingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLongTermPricingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateLongTermPricingOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLongTermPricingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateLongTermPricingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.longTermPricingId = output.longTermPricingId
        } else {
            self.longTermPricingId = nil
        }
    }
}

public struct CreateLongTermPricingOutputResponse: Swift.Equatable {
    /// The ID of the long-term pricing type for the device.
    public var longTermPricingId: Swift.String?

    public init (
        longTermPricingId: Swift.String? = nil
    )
    {
        self.longTermPricingId = longTermPricingId
    }
}

struct CreateLongTermPricingOutputResponseBody: Swift.Equatable {
    let longTermPricingId: Swift.String?
}

extension CreateLongTermPricingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case longTermPricingId = "LongTermPricingId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let longTermPricingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .longTermPricingId)
        longTermPricingId = longTermPricingIdDecoded
    }
}

extension CreateReturnShippingLabelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case shippingOption = "ShippingOption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let shippingOption = self.shippingOption {
            try encodeContainer.encode(shippingOption.rawValue, forKey: .shippingOption)
        }
    }
}

extension CreateReturnShippingLabelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateReturnShippingLabelInput: Swift.Equatable {
    /// The ID for a job that you want to create the return shipping label for; for example, JID123e4567-e89b-12d3-a456-426655440000.
    /// This member is required.
    public var jobId: Swift.String?
    /// The shipping speed for a particular job. This speed doesn't dictate how soon the device is returned to Amazon Web Services. This speed represents how quickly it moves to its destination while in transit. Regional shipping speeds are as follows:
    public var shippingOption: SnowballClientTypes.ShippingOption?

    public init (
        jobId: Swift.String? = nil,
        shippingOption: SnowballClientTypes.ShippingOption? = nil
    )
    {
        self.jobId = jobId
        self.shippingOption = shippingOption
    }
}

struct CreateReturnShippingLabelInputBody: Swift.Equatable {
    let jobId: Swift.String?
    let shippingOption: SnowballClientTypes.ShippingOption?
}

extension CreateReturnShippingLabelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case shippingOption = "ShippingOption"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let shippingOptionDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ShippingOption.self, forKey: .shippingOption)
        shippingOption = shippingOptionDecoded
    }
}

extension CreateReturnShippingLabelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateReturnShippingLabelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputCombinationException" : self = .invalidInputCombinationException(try InvalidInputCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReturnShippingLabelAlreadyExistsException" : self = .returnShippingLabelAlreadyExistsException(try ReturnShippingLabelAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateReturnShippingLabelOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case invalidInputCombinationException(InvalidInputCombinationException)
    case invalidJobStateException(InvalidJobStateException)
    case invalidResourceException(InvalidResourceException)
    case returnShippingLabelAlreadyExistsException(ReturnShippingLabelAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateReturnShippingLabelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateReturnShippingLabelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct CreateReturnShippingLabelOutputResponse: Swift.Equatable {
    /// The status information of the task on a Snow device that is being returned to Amazon Web Services.
    public var status: SnowballClientTypes.ShippingLabelStatus?

    public init (
        status: SnowballClientTypes.ShippingLabelStatus? = nil
    )
    {
        self.status = status
    }
}

struct CreateReturnShippingLabelOutputResponseBody: Swift.Equatable {
    let status: SnowballClientTypes.ShippingLabelStatus?
}

extension CreateReturnShippingLabelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ShippingLabelStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension SnowballClientTypes.DataTransfer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bytesTransferred = "BytesTransferred"
        case objectsTransferred = "ObjectsTransferred"
        case totalBytes = "TotalBytes"
        case totalObjects = "TotalObjects"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if bytesTransferred != 0 {
            try encodeContainer.encode(bytesTransferred, forKey: .bytesTransferred)
        }
        if objectsTransferred != 0 {
            try encodeContainer.encode(objectsTransferred, forKey: .objectsTransferred)
        }
        if totalBytes != 0 {
            try encodeContainer.encode(totalBytes, forKey: .totalBytes)
        }
        if totalObjects != 0 {
            try encodeContainer.encode(totalObjects, forKey: .totalObjects)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bytesTransferredDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bytesTransferred) ?? 0
        bytesTransferred = bytesTransferredDecoded
        let objectsTransferredDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .objectsTransferred) ?? 0
        objectsTransferred = objectsTransferredDecoded
        let totalBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalBytes) ?? 0
        totalBytes = totalBytesDecoded
        let totalObjectsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalObjects) ?? 0
        totalObjects = totalObjectsDecoded
    }
}

extension SnowballClientTypes {
    /// Defines the real-time status of a Snow device's data transfer while the device is at Amazon Web Services. This data is only available while a job has a JobState value of InProgress, for both import and export jobs.
    public struct DataTransfer: Swift.Equatable {
        /// The number of bytes transferred between a Snow device and Amazon S3.
        public var bytesTransferred: Swift.Int
        /// The number of objects transferred between a Snow device and Amazon S3.
        public var objectsTransferred: Swift.Int
        /// The total bytes of data for a transfer between a Snow device and Amazon S3. This value is set to 0 (zero) until all the keys that will be transferred have been listed.
        public var totalBytes: Swift.Int
        /// The total number of objects for a transfer between a Snow device and Amazon S3. This value is set to 0 (zero) until all the keys that will be transferred have been listed.
        public var totalObjects: Swift.Int

        public init (
            bytesTransferred: Swift.Int = 0,
            objectsTransferred: Swift.Int = 0,
            totalBytes: Swift.Int = 0,
            totalObjects: Swift.Int = 0
        )
        {
            self.bytesTransferred = bytesTransferred
            self.objectsTransferred = objectsTransferred
            self.totalBytes = totalBytes
            self.totalObjects = totalObjects
        }
    }

}

extension SnowballClientTypes.DependentService: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceName = "ServiceName"
        case serviceVersion = "ServiceVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName.rawValue, forKey: .serviceName)
        }
        if let serviceVersion = self.serviceVersion {
            try encodeContainer.encode(serviceVersion, forKey: .serviceVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ServiceName.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceVersionDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ServiceVersion.self, forKey: .serviceVersion)
        serviceVersion = serviceVersionDecoded
    }
}

extension SnowballClientTypes {
    /// The name and version of the service dependant on the requested service.
    public struct DependentService: Swift.Equatable {
        /// The name of the dependent service.
        public var serviceName: SnowballClientTypes.ServiceName?
        /// The version of the dependent service.
        public var serviceVersion: SnowballClientTypes.ServiceVersion?

        public init (
            serviceName: SnowballClientTypes.ServiceName? = nil,
            serviceVersion: SnowballClientTypes.ServiceVersion? = nil
        )
        {
            self.serviceName = serviceName
            self.serviceVersion = serviceVersion
        }
    }

}

extension DescribeAddressInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressId = self.addressId {
            try encodeContainer.encode(addressId, forKey: .addressId)
        }
    }
}

extension DescribeAddressInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAddressInput: Swift.Equatable {
    /// The automatically generated ID for a specific address.
    /// This member is required.
    public var addressId: Swift.String?

    public init (
        addressId: Swift.String? = nil
    )
    {
        self.addressId = addressId
    }
}

struct DescribeAddressInputBody: Swift.Equatable {
    let addressId: Swift.String?
}

extension DescribeAddressInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressId)
        addressId = addressIdDecoded
    }
}

extension DescribeAddressOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAddressOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAddressOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAddressOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAddressOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.address = output.address
        } else {
            self.address = nil
        }
    }
}

public struct DescribeAddressOutputResponse: Swift.Equatable {
    /// The address that you want the Snow device(s) associated with a specific job to be shipped to.
    public var address: SnowballClientTypes.Address?

    public init (
        address: SnowballClientTypes.Address? = nil
    )
    {
        self.address = address
    }
}

struct DescribeAddressOutputResponseBody: Swift.Equatable {
    let address: SnowballClientTypes.Address?
}

extension DescribeAddressOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.Address.self, forKey: .address)
        address = addressDecoded
    }
}

extension DescribeAddressesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeAddressesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAddressesInput: Swift.Equatable {
    /// The number of ADDRESS objects to return.
    public var maxResults: Swift.Int?
    /// HTTP requests are stateless. To identify what object comes "next" in the list of ADDRESS objects, you have the option of specifying a value for NextToken as the starting point for your list of returned addresses.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAddressesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeAddressesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAddressesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAddressesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAddressesOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAddressesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAddressesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.addresses = output.addresses
            self.nextToken = output.nextToken
        } else {
            self.addresses = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAddressesOutputResponse: Swift.Equatable {
    /// The Snow device shipping addresses that were created for this account.
    public var addresses: [SnowballClientTypes.Address]?
    /// HTTP requests are stateless. If you use the automatically generated NextToken value in your next DescribeAddresses call, your list of returned addresses will start from this point in the array.
    public var nextToken: Swift.String?

    public init (
        addresses: [SnowballClientTypes.Address]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.addresses = addresses
        self.nextToken = nextToken
    }
}

struct DescribeAddressesOutputResponseBody: Swift.Equatable {
    let addresses: [SnowballClientTypes.Address]?
    let nextToken: Swift.String?
}

extension DescribeAddressesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addresses = "Addresses"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressesContainer = try containerValues.decodeIfPresent([SnowballClientTypes.Address?].self, forKey: .addresses)
        var addressesDecoded0:[SnowballClientTypes.Address]? = nil
        if let addressesContainer = addressesContainer {
            addressesDecoded0 = [SnowballClientTypes.Address]()
            for structure0 in addressesContainer {
                if let structure0 = structure0 {
                    addressesDecoded0?.append(structure0)
                }
            }
        }
        addresses = addressesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeClusterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterId = "ClusterId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterId = self.clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
    }
}

extension DescribeClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeClusterInput: Swift.Equatable {
    /// The automatically generated ID for a cluster.
    /// This member is required.
    public var clusterId: Swift.String?

    public init (
        clusterId: Swift.String? = nil
    )
    {
        self.clusterId = clusterId
    }
}

struct DescribeClusterInputBody: Swift.Equatable {
    let clusterId: Swift.String?
}

extension DescribeClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterId = "ClusterId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
    }
}

extension DescribeClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeClusterOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterMetadata = output.clusterMetadata
        } else {
            self.clusterMetadata = nil
        }
    }
}

public struct DescribeClusterOutputResponse: Swift.Equatable {
    /// Information about a specific cluster, including shipping information, cluster status, and other important metadata.
    public var clusterMetadata: SnowballClientTypes.ClusterMetadata?

    public init (
        clusterMetadata: SnowballClientTypes.ClusterMetadata? = nil
    )
    {
        self.clusterMetadata = clusterMetadata
    }
}

struct DescribeClusterOutputResponseBody: Swift.Equatable {
    let clusterMetadata: SnowballClientTypes.ClusterMetadata?
}

extension DescribeClusterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterMetadata = "ClusterMetadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterMetadataDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ClusterMetadata.self, forKey: .clusterMetadata)
        clusterMetadata = clusterMetadataDecoded
    }
}

extension DescribeJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension DescribeJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeJobInput: Swift.Equatable {
    /// The automatically generated ID for a job, for example JID123e4567-e89b-12d3-a456-426655440000.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeJobInputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension DescribeJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeJobOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobMetadata = output.jobMetadata
            self.subJobMetadata = output.subJobMetadata
        } else {
            self.jobMetadata = nil
            self.subJobMetadata = nil
        }
    }
}

public struct DescribeJobOutputResponse: Swift.Equatable {
    /// Information about a specific job, including shipping information, job status, and other important metadata.
    public var jobMetadata: SnowballClientTypes.JobMetadata?
    /// Information about a specific job part (in the case of an export job), including shipping information, job status, and other important metadata.
    public var subJobMetadata: [SnowballClientTypes.JobMetadata]?

    public init (
        jobMetadata: SnowballClientTypes.JobMetadata? = nil,
        subJobMetadata: [SnowballClientTypes.JobMetadata]? = nil
    )
    {
        self.jobMetadata = jobMetadata
        self.subJobMetadata = subJobMetadata
    }
}

struct DescribeJobOutputResponseBody: Swift.Equatable {
    let jobMetadata: SnowballClientTypes.JobMetadata?
    let subJobMetadata: [SnowballClientTypes.JobMetadata]?
}

extension DescribeJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobMetadata = "JobMetadata"
        case subJobMetadata = "SubJobMetadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobMetadataDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobMetadata.self, forKey: .jobMetadata)
        jobMetadata = jobMetadataDecoded
        let subJobMetadataContainer = try containerValues.decodeIfPresent([SnowballClientTypes.JobMetadata?].self, forKey: .subJobMetadata)
        var subJobMetadataDecoded0:[SnowballClientTypes.JobMetadata]? = nil
        if let subJobMetadataContainer = subJobMetadataContainer {
            subJobMetadataDecoded0 = [SnowballClientTypes.JobMetadata]()
            for structure0 in subJobMetadataContainer {
                if let structure0 = structure0 {
                    subJobMetadataDecoded0?.append(structure0)
                }
            }
        }
        subJobMetadata = subJobMetadataDecoded0
    }
}

extension DescribeReturnShippingLabelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension DescribeReturnShippingLabelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeReturnShippingLabelInput: Swift.Equatable {
    /// The automatically generated ID for a job, for example JID123e4567-e89b-12d3-a456-426655440000.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeReturnShippingLabelInputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension DescribeReturnShippingLabelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeReturnShippingLabelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReturnShippingLabelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeReturnShippingLabelOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case invalidJobStateException(InvalidJobStateException)
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReturnShippingLabelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeReturnShippingLabelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.expirationDate = output.expirationDate
            self.returnShippingLabelURI = output.returnShippingLabelURI
            self.status = output.status
        } else {
            self.expirationDate = nil
            self.returnShippingLabelURI = nil
            self.status = nil
        }
    }
}

public struct DescribeReturnShippingLabelOutputResponse: Swift.Equatable {
    /// The expiration date of the current return shipping label.
    public var expirationDate: ClientRuntime.Date?
    /// The pre-signed Amazon S3 URI used to download the return shipping label.
    public var returnShippingLabelURI: Swift.String?
    /// The status information of the task on a Snow device that is being returned to Amazon Web Services.
    public var status: SnowballClientTypes.ShippingLabelStatus?

    public init (
        expirationDate: ClientRuntime.Date? = nil,
        returnShippingLabelURI: Swift.String? = nil,
        status: SnowballClientTypes.ShippingLabelStatus? = nil
    )
    {
        self.expirationDate = expirationDate
        self.returnShippingLabelURI = returnShippingLabelURI
        self.status = status
    }
}

struct DescribeReturnShippingLabelOutputResponseBody: Swift.Equatable {
    let status: SnowballClientTypes.ShippingLabelStatus?
    let expirationDate: ClientRuntime.Date?
    let returnShippingLabelURI: Swift.String?
}

extension DescribeReturnShippingLabelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expirationDate = "ExpirationDate"
        case returnShippingLabelURI = "ReturnShippingLabelURI"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ShippingLabelStatus.self, forKey: .status)
        status = statusDecoded
        let expirationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
        let returnShippingLabelURIDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .returnShippingLabelURI)
        returnShippingLabelURI = returnShippingLabelURIDecoded
    }
}

extension SnowballClientTypes.DeviceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snowconeDeviceConfiguration = "SnowconeDeviceConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snowconeDeviceConfiguration = self.snowconeDeviceConfiguration {
            try encodeContainer.encode(snowconeDeviceConfiguration, forKey: .snowconeDeviceConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snowconeDeviceConfigurationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.SnowconeDeviceConfiguration.self, forKey: .snowconeDeviceConfiguration)
        snowconeDeviceConfiguration = snowconeDeviceConfigurationDecoded
    }
}

extension SnowballClientTypes {
    /// The container for SnowconeDeviceConfiguration.
    public struct DeviceConfiguration: Swift.Equatable {
        /// Returns information about the device configuration for an Snowcone job.
        public var snowconeDeviceConfiguration: SnowballClientTypes.SnowconeDeviceConfiguration?

        public init (
            snowconeDeviceConfiguration: SnowballClientTypes.SnowconeDeviceConfiguration? = nil
        )
        {
            self.snowconeDeviceConfiguration = snowconeDeviceConfiguration
        }
    }

}

extension SnowballClientTypes {
    public enum DeviceServiceName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case nfsOnDeviceService
        case s3OnDeviceService
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceServiceName] {
            return [
                .nfsOnDeviceService,
                .s3OnDeviceService,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .nfsOnDeviceService: return "NFS_ON_DEVICE_SERVICE"
            case .s3OnDeviceService: return "S3_ON_DEVICE_SERVICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceServiceName(rawValue: rawValue) ?? DeviceServiceName.sdkUnknown(rawValue)
        }
    }
}

extension SnowballClientTypes.EKSOnDeviceServiceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eksAnywhereVersion = "EKSAnywhereVersion"
        case kubernetesVersion = "KubernetesVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eksAnywhereVersion = self.eksAnywhereVersion {
            try encodeContainer.encode(eksAnywhereVersion, forKey: .eksAnywhereVersion)
        }
        if let kubernetesVersion = self.kubernetesVersion {
            try encodeContainer.encode(kubernetesVersion, forKey: .kubernetesVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kubernetesVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kubernetesVersion)
        kubernetesVersion = kubernetesVersionDecoded
        let eksAnywhereVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eksAnywhereVersion)
        eksAnywhereVersion = eksAnywhereVersionDecoded
    }
}

extension SnowballClientTypes {
    /// An object representing the metadata and configuration settings of EKS Anywhere on the Snow Family device.
    public struct EKSOnDeviceServiceConfiguration: Swift.Equatable {
        /// The version of EKS Anywhere on the Snow Family device.
        public var eksAnywhereVersion: Swift.String?
        /// The Kubernetes version for EKS Anywhere on the Snow Family device.
        public var kubernetesVersion: Swift.String?

        public init (
            eksAnywhereVersion: Swift.String? = nil,
            kubernetesVersion: Swift.String? = nil
        )
        {
            self.eksAnywhereVersion = eksAnywhereVersion
            self.kubernetesVersion = kubernetesVersion
        }
    }

}

extension SnowballClientTypes.Ec2AmiResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amiId = "AmiId"
        case snowballAmiId = "SnowballAmiId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amiId = self.amiId {
            try encodeContainer.encode(amiId, forKey: .amiId)
        }
        if let snowballAmiId = self.snowballAmiId {
            try encodeContainer.encode(snowballAmiId, forKey: .snowballAmiId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amiId)
        amiId = amiIdDecoded
        let snowballAmiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snowballAmiId)
        snowballAmiId = snowballAmiIdDecoded
    }
}

extension SnowballClientTypes {
    /// A JSON-formatted object that contains the IDs for an Amazon Machine Image (AMI), including the Amazon EC2 AMI ID and the Snow device AMI ID. Each AMI has these two IDs to simplify identifying the AMI in both the Amazon Web Services Cloud and on the device.
    public struct Ec2AmiResource: Swift.Equatable {
        /// The ID of the AMI in Amazon EC2.
        /// This member is required.
        public var amiId: Swift.String?
        /// The ID of the AMI on the Snow device.
        public var snowballAmiId: Swift.String?

        public init (
            amiId: Swift.String? = nil,
            snowballAmiId: Swift.String? = nil
        )
        {
            self.amiId = amiId
            self.snowballAmiId = snowballAmiId
        }
    }

}

extension Ec2RequestFailedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: Ec2RequestFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your IAM user lacks the necessary Amazon EC2 permissions to perform the attempted action.
public struct Ec2RequestFailedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct Ec2RequestFailedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension Ec2RequestFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnowballClientTypes.EventTriggerDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventResourceARN = "EventResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventResourceARN = self.eventResourceARN {
            try encodeContainer.encode(eventResourceARN, forKey: .eventResourceARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventResourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventResourceARN)
        eventResourceARN = eventResourceARNDecoded
    }
}

extension SnowballClientTypes {
    /// The container for the [EventTriggerDefinition$EventResourceARN].
    public struct EventTriggerDefinition: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for any local Amazon S3 resource that is an Lambda function's event trigger associated with this job.
        public var eventResourceARN: Swift.String?

        public init (
            eventResourceARN: Swift.String? = nil
        )
        {
            self.eventResourceARN = eventResourceARN
        }
    }

}

extension GetJobManifestInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension GetJobManifestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetJobManifestInput: Swift.Equatable {
    /// The ID for a job that you want to get the manifest file for, for example JID123e4567-e89b-12d3-a456-426655440000.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct GetJobManifestInputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension GetJobManifestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension GetJobManifestOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetJobManifestOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetJobManifestOutputError: Swift.Error, Swift.Equatable {
    case invalidJobStateException(InvalidJobStateException)
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetJobManifestOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetJobManifestOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.manifestURI = output.manifestURI
        } else {
            self.manifestURI = nil
        }
    }
}

public struct GetJobManifestOutputResponse: Swift.Equatable {
    /// The Amazon S3 presigned URL for the manifest file associated with the specified JobId value.
    public var manifestURI: Swift.String?

    public init (
        manifestURI: Swift.String? = nil
    )
    {
        self.manifestURI = manifestURI
    }
}

struct GetJobManifestOutputResponseBody: Swift.Equatable {
    let manifestURI: Swift.String?
}

extension GetJobManifestOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case manifestURI = "ManifestURI"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manifestURIDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestURI)
        manifestURI = manifestURIDecoded
    }
}

extension GetJobUnlockCodeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension GetJobUnlockCodeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetJobUnlockCodeInput: Swift.Equatable {
    /// The ID for the job that you want to get the UnlockCode value for, for example JID123e4567-e89b-12d3-a456-426655440000.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct GetJobUnlockCodeInputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension GetJobUnlockCodeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension GetJobUnlockCodeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetJobUnlockCodeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetJobUnlockCodeOutputError: Swift.Error, Swift.Equatable {
    case invalidJobStateException(InvalidJobStateException)
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetJobUnlockCodeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetJobUnlockCodeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unlockCode = output.unlockCode
        } else {
            self.unlockCode = nil
        }
    }
}

public struct GetJobUnlockCodeOutputResponse: Swift.Equatable {
    /// The UnlockCode value for the specified job. The UnlockCode value can be accessed for up to 360 days after the job has been created.
    public var unlockCode: Swift.String?

    public init (
        unlockCode: Swift.String? = nil
    )
    {
        self.unlockCode = unlockCode
    }
}

struct GetJobUnlockCodeOutputResponseBody: Swift.Equatable {
    let unlockCode: Swift.String?
}

extension GetJobUnlockCodeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unlockCode = "UnlockCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unlockCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unlockCode)
        unlockCode = unlockCodeDecoded
    }
}

extension GetSnowballUsageInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetSnowballUsageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSnowballUsageInput: Swift.Equatable {

    public init () { }
}

struct GetSnowballUsageInputBody: Swift.Equatable {
}

extension GetSnowballUsageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSnowballUsageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSnowballUsageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSnowballUsageOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSnowballUsageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSnowballUsageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.snowballLimit = output.snowballLimit
            self.snowballsInUse = output.snowballsInUse
        } else {
            self.snowballLimit = nil
            self.snowballsInUse = nil
        }
    }
}

public struct GetSnowballUsageOutputResponse: Swift.Equatable {
    /// The service limit for number of Snow devices this account can have at once. The default service limit is 1 (one).
    public var snowballLimit: Swift.Int?
    /// The number of Snow devices that this account is currently using.
    public var snowballsInUse: Swift.Int?

    public init (
        snowballLimit: Swift.Int? = nil,
        snowballsInUse: Swift.Int? = nil
    )
    {
        self.snowballLimit = snowballLimit
        self.snowballsInUse = snowballsInUse
    }
}

struct GetSnowballUsageOutputResponseBody: Swift.Equatable {
    let snowballLimit: Swift.Int?
    let snowballsInUse: Swift.Int?
}

extension GetSnowballUsageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snowballLimit = "SnowballLimit"
        case snowballsInUse = "SnowballsInUse"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snowballLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .snowballLimit)
        snowballLimit = snowballLimitDecoded
        let snowballsInUseDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .snowballsInUse)
        snowballsInUse = snowballsInUseDecoded
    }
}

extension GetSoftwareUpdatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension GetSoftwareUpdatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSoftwareUpdatesInput: Swift.Equatable {
    /// The ID for a job that you want to get the software update file for, for example JID123e4567-e89b-12d3-a456-426655440000.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct GetSoftwareUpdatesInputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension GetSoftwareUpdatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension GetSoftwareUpdatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSoftwareUpdatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSoftwareUpdatesOutputError: Swift.Error, Swift.Equatable {
    case invalidJobStateException(InvalidJobStateException)
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSoftwareUpdatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSoftwareUpdatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.updatesURI = output.updatesURI
        } else {
            self.updatesURI = nil
        }
    }
}

public struct GetSoftwareUpdatesOutputResponse: Swift.Equatable {
    /// The Amazon S3 presigned URL for the update file associated with the specified JobId value. The software update will be available for 2 days after this request is made. To access an update after the 2 days have passed, you'll have to make another call to GetSoftwareUpdates.
    public var updatesURI: Swift.String?

    public init (
        updatesURI: Swift.String? = nil
    )
    {
        self.updatesURI = updatesURI
    }
}

struct GetSoftwareUpdatesOutputResponseBody: Swift.Equatable {
    let updatesURI: Swift.String?
}

extension GetSoftwareUpdatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updatesURI = "UpdatesURI"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updatesURIDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatesURI)
        updatesURI = updatesURIDecoded
    }
}

extension SnowballClientTypes.INDTaxDocuments: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gstin = "GSTIN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gstin = self.gstin {
            try encodeContainer.encode(gstin, forKey: .gstin)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gstinDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gstin)
        gstin = gstinDecoded
    }
}

extension SnowballClientTypes {
    /// The tax documents required in Amazon Web Services Region in India.
    public struct INDTaxDocuments: Swift.Equatable {
        /// The Goods and Services Tax (GST) documents required in Amazon Web Services Region in India.
        public var gstin: Swift.String?

        public init (
            gstin: Swift.String? = nil
        )
        {
            self.gstin = gstin
        }
    }

}

extension InvalidAddressException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidAddressExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The address provided was invalid. Check the address with your region's carrier, and try again.
public struct InvalidAddressException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAddressExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidAddressExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInputCombinationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidInputCombinationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Job or cluster creation failed. One or more inputs were invalid. Confirm that the [CreateClusterRequest$SnowballType] value supports your [CreateJobRequest$JobType], and try again.
public struct InvalidInputCombinationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInputCombinationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidInputCombinationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidJobStateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidJobStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The action can't be performed because the job's current state doesn't allow that action to be performed.
public struct InvalidJobStateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidJobStateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidJobStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The NextToken string was altered unexpectedly, and the operation has stopped. Run the operation without changing the NextToken string, and try again.
public struct InvalidNextTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourceException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidResourceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource can't be found. Check the information you provided in your last request, and try again.
public struct InvalidResourceException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The provided resource value is invalid.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceType = resourceType
    }
}

struct InvalidResourceExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: Swift.String?
}

extension InvalidResourceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension SnowballClientTypes.JobListEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "CreationDate"
        case description = "Description"
        case isMaster = "IsMaster"
        case jobId = "JobId"
        case jobState = "JobState"
        case jobType = "JobType"
        case snowballType = "SnowballType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if isMaster != false {
            try encodeContainer.encode(isMaster, forKey: .isMaster)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobState = self.jobState {
            try encodeContainer.encode(jobState.rawValue, forKey: .jobState)
        }
        if let jobType = self.jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
        if let snowballType = self.snowballType {
            try encodeContainer.encode(snowballType.rawValue, forKey: .snowballType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStateDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobState.self, forKey: .jobState)
        jobState = jobStateDecoded
        let isMasterDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isMaster) ?? false
        isMaster = isMasterDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let snowballTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.SnowballType.self, forKey: .snowballType)
        snowballType = snowballTypeDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension SnowballClientTypes {
    /// Each JobListEntry object contains a job's state, a job's ID, and a value that indicates whether the job is a job part, in the case of an export job.
    public struct JobListEntry: Swift.Equatable {
        /// The creation date for this job.
        public var creationDate: ClientRuntime.Date?
        /// The optional description of this specific job, for example Important Photos 2016-08-11.
        public var description: Swift.String?
        /// A value that indicates that this job is a main job. A main job represents a successful request to create an export job. Main jobs aren't associated with any Snowballs. Instead, each main job will have at least one job part, and each job part is associated with a Snowball. It might take some time before the job parts associated with a particular main job are listed, because they are created after the main job is created.
        public var isMaster: Swift.Bool
        /// The automatically generated ID for a job, for example JID123e4567-e89b-12d3-a456-426655440000.
        public var jobId: Swift.String?
        /// The current state of this job.
        public var jobState: SnowballClientTypes.JobState?
        /// The type of job.
        public var jobType: SnowballClientTypes.JobType?
        /// The type of device used with this job.
        public var snowballType: SnowballClientTypes.SnowballType?

        public init (
            creationDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            isMaster: Swift.Bool = false,
            jobId: Swift.String? = nil,
            jobState: SnowballClientTypes.JobState? = nil,
            jobType: SnowballClientTypes.JobType? = nil,
            snowballType: SnowballClientTypes.SnowballType? = nil
        )
        {
            self.creationDate = creationDate
            self.description = description
            self.isMaster = isMaster
            self.jobId = jobId
            self.jobState = jobState
            self.jobType = jobType
            self.snowballType = snowballType
        }
    }

}

extension SnowballClientTypes.JobLogs: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobCompletionReportURI = "JobCompletionReportURI"
        case jobFailureLogURI = "JobFailureLogURI"
        case jobSuccessLogURI = "JobSuccessLogURI"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobCompletionReportURI = self.jobCompletionReportURI {
            try encodeContainer.encode(jobCompletionReportURI, forKey: .jobCompletionReportURI)
        }
        if let jobFailureLogURI = self.jobFailureLogURI {
            try encodeContainer.encode(jobFailureLogURI, forKey: .jobFailureLogURI)
        }
        if let jobSuccessLogURI = self.jobSuccessLogURI {
            try encodeContainer.encode(jobSuccessLogURI, forKey: .jobSuccessLogURI)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobCompletionReportURIDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobCompletionReportURI)
        jobCompletionReportURI = jobCompletionReportURIDecoded
        let jobSuccessLogURIDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobSuccessLogURI)
        jobSuccessLogURI = jobSuccessLogURIDecoded
        let jobFailureLogURIDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobFailureLogURI)
        jobFailureLogURI = jobFailureLogURIDecoded
    }
}

extension SnowballClientTypes {
    /// Contains job logs. Whenever a Snow device is used to import data into or export data out of Amazon S3, you'll have the option of downloading a PDF job report. Job logs are returned as a part of the response syntax of the DescribeJob action in the JobMetadata data type. The job logs can be accessed for up to 60 minutes after this request has been made. To access any of the job logs after 60 minutes have passed, you'll have to make another call to the DescribeJob action. For import jobs, the PDF job report becomes available at the end of the import process. For export jobs, your job report typically becomes available while the Snow device for your job part is being delivered to you. The job report provides you insight into the state of your Amazon S3 data transfer. The report includes details about your job or job part for your records. For deeper visibility into the status of your transferred objects, you can look at the two associated logs: a success log and a failure log. The logs are saved in comma-separated value (CSV) format, and the name of each log includes the ID of the job or job part that the log describes.
    public struct JobLogs: Swift.Equatable {
        /// A link to an Amazon S3 presigned URL where the job completion report is located.
        public var jobCompletionReportURI: Swift.String?
        /// A link to an Amazon S3 presigned URL where the job failure log is located.
        public var jobFailureLogURI: Swift.String?
        /// A link to an Amazon S3 presigned URL where the job success log is located.
        public var jobSuccessLogURI: Swift.String?

        public init (
            jobCompletionReportURI: Swift.String? = nil,
            jobFailureLogURI: Swift.String? = nil,
            jobSuccessLogURI: Swift.String? = nil
        )
        {
            self.jobCompletionReportURI = jobCompletionReportURI
            self.jobFailureLogURI = jobFailureLogURI
            self.jobSuccessLogURI = jobSuccessLogURI
        }
    }

}

extension SnowballClientTypes.JobMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
        case clusterId = "ClusterId"
        case creationDate = "CreationDate"
        case dataTransferProgress = "DataTransferProgress"
        case description = "Description"
        case deviceConfiguration = "DeviceConfiguration"
        case forwardingAddressId = "ForwardingAddressId"
        case jobId = "JobId"
        case jobLogInfo = "JobLogInfo"
        case jobState = "JobState"
        case jobType = "JobType"
        case kmsKeyARN = "KmsKeyARN"
        case longTermPricingId = "LongTermPricingId"
        case notification = "Notification"
        case onDeviceServiceConfiguration = "OnDeviceServiceConfiguration"
        case remoteManagement = "RemoteManagement"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingDetails = "ShippingDetails"
        case snowballCapacityPreference = "SnowballCapacityPreference"
        case snowballType = "SnowballType"
        case taxDocuments = "TaxDocuments"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressId = self.addressId {
            try encodeContainer.encode(addressId, forKey: .addressId)
        }
        if let clusterId = self.clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let dataTransferProgress = self.dataTransferProgress {
            try encodeContainer.encode(dataTransferProgress, forKey: .dataTransferProgress)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceConfiguration = self.deviceConfiguration {
            try encodeContainer.encode(deviceConfiguration, forKey: .deviceConfiguration)
        }
        if let forwardingAddressId = self.forwardingAddressId {
            try encodeContainer.encode(forwardingAddressId, forKey: .forwardingAddressId)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobLogInfo = self.jobLogInfo {
            try encodeContainer.encode(jobLogInfo, forKey: .jobLogInfo)
        }
        if let jobState = self.jobState {
            try encodeContainer.encode(jobState.rawValue, forKey: .jobState)
        }
        if let jobType = self.jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
        if let kmsKeyARN = self.kmsKeyARN {
            try encodeContainer.encode(kmsKeyARN, forKey: .kmsKeyARN)
        }
        if let longTermPricingId = self.longTermPricingId {
            try encodeContainer.encode(longTermPricingId, forKey: .longTermPricingId)
        }
        if let notification = self.notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let onDeviceServiceConfiguration = self.onDeviceServiceConfiguration {
            try encodeContainer.encode(onDeviceServiceConfiguration, forKey: .onDeviceServiceConfiguration)
        }
        if let remoteManagement = self.remoteManagement {
            try encodeContainer.encode(remoteManagement.rawValue, forKey: .remoteManagement)
        }
        if let resources = self.resources {
            try encodeContainer.encode(resources, forKey: .resources)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
        if let shippingDetails = self.shippingDetails {
            try encodeContainer.encode(shippingDetails, forKey: .shippingDetails)
        }
        if let snowballCapacityPreference = self.snowballCapacityPreference {
            try encodeContainer.encode(snowballCapacityPreference.rawValue, forKey: .snowballCapacityPreference)
        }
        if let snowballType = self.snowballType {
            try encodeContainer.encode(snowballType.rawValue, forKey: .snowballType)
        }
        if let taxDocuments = self.taxDocuments {
            try encodeContainer.encode(taxDocuments, forKey: .taxDocuments)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStateDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobState.self, forKey: .jobState)
        jobState = jobStateDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let snowballTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.SnowballType.self, forKey: .snowballType)
        snowballType = snowballTypeDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let resourcesDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobResource.self, forKey: .resources)
        resources = resourcesDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let kmsKeyARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyARN)
        kmsKeyARN = kmsKeyARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        let addressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressId)
        addressId = addressIdDecoded
        let shippingDetailsDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ShippingDetails.self, forKey: .shippingDetails)
        shippingDetails = shippingDetailsDecoded
        let snowballCapacityPreferenceDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.SnowballCapacity.self, forKey: .snowballCapacityPreference)
        snowballCapacityPreference = snowballCapacityPreferenceDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
        let dataTransferProgressDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.DataTransfer.self, forKey: .dataTransferProgress)
        dataTransferProgress = dataTransferProgressDecoded
        let jobLogInfoDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobLogs.self, forKey: .jobLogInfo)
        jobLogInfo = jobLogInfoDecoded
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let forwardingAddressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forwardingAddressId)
        forwardingAddressId = forwardingAddressIdDecoded
        let taxDocumentsDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.TaxDocuments.self, forKey: .taxDocuments)
        taxDocuments = taxDocumentsDecoded
        let deviceConfigurationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.DeviceConfiguration.self, forKey: .deviceConfiguration)
        deviceConfiguration = deviceConfigurationDecoded
        let remoteManagementDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.RemoteManagement.self, forKey: .remoteManagement)
        remoteManagement = remoteManagementDecoded
        let longTermPricingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .longTermPricingId)
        longTermPricingId = longTermPricingIdDecoded
        let onDeviceServiceConfigurationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.OnDeviceServiceConfiguration.self, forKey: .onDeviceServiceConfiguration)
        onDeviceServiceConfiguration = onDeviceServiceConfigurationDecoded
    }
}

extension SnowballClientTypes {
    /// Contains information about a specific job including shipping information, job status, and other important metadata. This information is returned as a part of the response syntax of the DescribeJob action.
    public struct JobMetadata: Swift.Equatable {
        /// The ID for the address that you want the Snow device shipped to.
        public var addressId: Swift.String?
        /// The 39-character ID for the cluster, for example CID123e4567-e89b-12d3-a456-426655440000.
        public var clusterId: Swift.String?
        /// The creation date for this job.
        public var creationDate: ClientRuntime.Date?
        /// A value that defines the real-time status of a Snow device's data transfer while the device is at Amazon Web Services. This data is only available while a job has a JobState value of InProgress, for both import and export jobs.
        public var dataTransferProgress: SnowballClientTypes.DataTransfer?
        /// The description of the job, provided at job creation.
        public var description: Swift.String?
        /// The container for SnowconeDeviceConfiguration.
        public var deviceConfiguration: SnowballClientTypes.DeviceConfiguration?
        /// The ID of the address that you want a job shipped to, after it will be shipped to its primary address. This field is not supported in most regions.
        public var forwardingAddressId: Swift.String?
        /// The automatically generated ID for a job, for example JID123e4567-e89b-12d3-a456-426655440000.
        public var jobId: Swift.String?
        /// Links to Amazon S3 presigned URLs for the job report and logs. For import jobs, the PDF job report becomes available at the end of the import process. For export jobs, your job report typically becomes available while the Snow device for your job part is being delivered to you.
        public var jobLogInfo: SnowballClientTypes.JobLogs?
        /// The current status of the jobs.
        public var jobState: SnowballClientTypes.JobState?
        /// The type of job.
        public var jobType: SnowballClientTypes.JobType?
        /// The Amazon Resource Name (ARN) for the Key Management Service (KMS) key associated with this job. This ARN was created using the [CreateKey](https://docs.aws.amazon.com/kms/latest/APIReference/API_CreateKey.html) API action in KMS.
        public var kmsKeyARN: Swift.String?
        /// The ID of the long-term pricing type for the device.
        public var longTermPricingId: Swift.String?
        /// The Amazon Simple Notification Service (Amazon SNS) notification settings associated with a specific job. The Notification object is returned as a part of the response syntax of the DescribeJob action in the JobMetadata data type.
        public var notification: SnowballClientTypes.Notification?
        /// Represents metadata and configuration settings for services on an Amazon Web Services Snow Family device.
        public var onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration?
        /// Allows you to securely operate and manage Snowcone devices remotely from outside of your internal network. When set to INSTALLED_AUTOSTART, remote management will automatically be available when the device arrives at your location. Otherwise, you need to use the Snowball Client to manage the device.
        public var remoteManagement: SnowballClientTypes.RemoteManagement?
        /// An array of S3Resource objects. Each S3Resource object represents an Amazon S3 bucket that your transferred data will be exported from or imported into.
        public var resources: SnowballClientTypes.JobResource?
        /// The role ARN associated with this job. This ARN was created using the [CreateRole](https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html) API action in Identity and Access Management.
        public var roleARN: Swift.String?
        /// A job's shipping information, including inbound and outbound tracking numbers and shipping speed options.
        public var shippingDetails: SnowballClientTypes.ShippingDetails?
        /// The Snow device capacity preference for this job, specified at job creation. In US regions, you can choose between 50 TB and 80 TB Snowballs. All other regions use 80 TB capacity Snowballs. For more information, see "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide or "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide.
        public var snowballCapacityPreference: SnowballClientTypes.SnowballCapacity?
        /// The type of device used with this job.
        public var snowballType: SnowballClientTypes.SnowballType?
        /// The metadata associated with the tax documents required in your Amazon Web Services Region.
        public var taxDocuments: SnowballClientTypes.TaxDocuments?

        public init (
            addressId: Swift.String? = nil,
            clusterId: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            dataTransferProgress: SnowballClientTypes.DataTransfer? = nil,
            description: Swift.String? = nil,
            deviceConfiguration: SnowballClientTypes.DeviceConfiguration? = nil,
            forwardingAddressId: Swift.String? = nil,
            jobId: Swift.String? = nil,
            jobLogInfo: SnowballClientTypes.JobLogs? = nil,
            jobState: SnowballClientTypes.JobState? = nil,
            jobType: SnowballClientTypes.JobType? = nil,
            kmsKeyARN: Swift.String? = nil,
            longTermPricingId: Swift.String? = nil,
            notification: SnowballClientTypes.Notification? = nil,
            onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration? = nil,
            remoteManagement: SnowballClientTypes.RemoteManagement? = nil,
            resources: SnowballClientTypes.JobResource? = nil,
            roleARN: Swift.String? = nil,
            shippingDetails: SnowballClientTypes.ShippingDetails? = nil,
            snowballCapacityPreference: SnowballClientTypes.SnowballCapacity? = nil,
            snowballType: SnowballClientTypes.SnowballType? = nil,
            taxDocuments: SnowballClientTypes.TaxDocuments? = nil
        )
        {
            self.addressId = addressId
            self.clusterId = clusterId
            self.creationDate = creationDate
            self.dataTransferProgress = dataTransferProgress
            self.description = description
            self.deviceConfiguration = deviceConfiguration
            self.forwardingAddressId = forwardingAddressId
            self.jobId = jobId
            self.jobLogInfo = jobLogInfo
            self.jobState = jobState
            self.jobType = jobType
            self.kmsKeyARN = kmsKeyARN
            self.longTermPricingId = longTermPricingId
            self.notification = notification
            self.onDeviceServiceConfiguration = onDeviceServiceConfiguration
            self.remoteManagement = remoteManagement
            self.resources = resources
            self.roleARN = roleARN
            self.shippingDetails = shippingDetails
            self.snowballCapacityPreference = snowballCapacityPreference
            self.snowballType = snowballType
            self.taxDocuments = taxDocuments
        }
    }

}

extension SnowballClientTypes.JobResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2AmiResources = "Ec2AmiResources"
        case lambdaResources = "LambdaResources"
        case s3Resources = "S3Resources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ec2AmiResources = ec2AmiResources {
            var ec2AmiResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2AmiResources)
            for ec2amiresource0 in ec2AmiResources {
                try ec2AmiResourcesContainer.encode(ec2amiresource0)
            }
        }
        if let lambdaResources = lambdaResources {
            var lambdaResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lambdaResources)
            for lambdaresource0 in lambdaResources {
                try lambdaResourcesContainer.encode(lambdaresource0)
            }
        }
        if let s3Resources = s3Resources {
            var s3ResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3Resources)
            for s3resource0 in s3Resources {
                try s3ResourcesContainer.encode(s3resource0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ResourcesContainer = try containerValues.decodeIfPresent([SnowballClientTypes.S3Resource?].self, forKey: .s3Resources)
        var s3ResourcesDecoded0:[SnowballClientTypes.S3Resource]? = nil
        if let s3ResourcesContainer = s3ResourcesContainer {
            s3ResourcesDecoded0 = [SnowballClientTypes.S3Resource]()
            for structure0 in s3ResourcesContainer {
                if let structure0 = structure0 {
                    s3ResourcesDecoded0?.append(structure0)
                }
            }
        }
        s3Resources = s3ResourcesDecoded0
        let lambdaResourcesContainer = try containerValues.decodeIfPresent([SnowballClientTypes.LambdaResource?].self, forKey: .lambdaResources)
        var lambdaResourcesDecoded0:[SnowballClientTypes.LambdaResource]? = nil
        if let lambdaResourcesContainer = lambdaResourcesContainer {
            lambdaResourcesDecoded0 = [SnowballClientTypes.LambdaResource]()
            for structure0 in lambdaResourcesContainer {
                if let structure0 = structure0 {
                    lambdaResourcesDecoded0?.append(structure0)
                }
            }
        }
        lambdaResources = lambdaResourcesDecoded0
        let ec2AmiResourcesContainer = try containerValues.decodeIfPresent([SnowballClientTypes.Ec2AmiResource?].self, forKey: .ec2AmiResources)
        var ec2AmiResourcesDecoded0:[SnowballClientTypes.Ec2AmiResource]? = nil
        if let ec2AmiResourcesContainer = ec2AmiResourcesContainer {
            ec2AmiResourcesDecoded0 = [SnowballClientTypes.Ec2AmiResource]()
            for structure0 in ec2AmiResourcesContainer {
                if let structure0 = structure0 {
                    ec2AmiResourcesDecoded0?.append(structure0)
                }
            }
        }
        ec2AmiResources = ec2AmiResourcesDecoded0
    }
}

extension SnowballClientTypes {
    /// Contains an array of Amazon Web Services resource objects. Each object represents an Amazon S3 bucket, an Lambda function, or an Amazon Machine Image (AMI) based on Amazon EC2 that is associated with a particular job.
    public struct JobResource: Swift.Equatable {
        /// The Amazon Machine Images (AMIs) associated with this job.
        public var ec2AmiResources: [SnowballClientTypes.Ec2AmiResource]?
        /// The Python-language Lambda functions for this job.
        public var lambdaResources: [SnowballClientTypes.LambdaResource]?
        /// An array of S3Resource objects.
        public var s3Resources: [SnowballClientTypes.S3Resource]?

        public init (
            ec2AmiResources: [SnowballClientTypes.Ec2AmiResource]? = nil,
            lambdaResources: [SnowballClientTypes.LambdaResource]? = nil,
            s3Resources: [SnowballClientTypes.S3Resource]? = nil
        )
        {
            self.ec2AmiResources = ec2AmiResources
            self.lambdaResources = lambdaResources
            self.s3Resources = s3Resources
        }
    }

}

extension SnowballClientTypes {
    public enum JobState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case complete
        case inProgress
        case inTransitToAws
        case inTransitToCustomer
        case listing
        case new
        case pending
        case preparingAppliance
        case preparingShipment
        case withAws
        case withAwsSortingFacility
        case withCustomer
        case sdkUnknown(Swift.String)

        public static var allCases: [JobState] {
            return [
                .cancelled,
                .complete,
                .inProgress,
                .inTransitToAws,
                .inTransitToCustomer,
                .listing,
                .new,
                .pending,
                .preparingAppliance,
                .preparingShipment,
                .withAws,
                .withAwsSortingFacility,
                .withCustomer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "Cancelled"
            case .complete: return "Complete"
            case .inProgress: return "InProgress"
            case .inTransitToAws: return "InTransitToAWS"
            case .inTransitToCustomer: return "InTransitToCustomer"
            case .listing: return "Listing"
            case .new: return "New"
            case .pending: return "Pending"
            case .preparingAppliance: return "PreparingAppliance"
            case .preparingShipment: return "PreparingShipment"
            case .withAws: return "WithAWS"
            case .withAwsSortingFacility: return "WithAWSSortingFacility"
            case .withCustomer: return "WithCustomer"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobState(rawValue: rawValue) ?? JobState.sdkUnknown(rawValue)
        }
    }
}

extension SnowballClientTypes {
    public enum JobType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case export
        case `import`
        case localUse
        case sdkUnknown(Swift.String)

        public static var allCases: [JobType] {
            return [
                .export,
                .import,
                .localUse,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .export: return "EXPORT"
            case .import: return "IMPORT"
            case .localUse: return "LOCAL_USE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobType(rawValue: rawValue) ?? JobType.sdkUnknown(rawValue)
        }
    }
}

extension KMSRequestFailedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: KMSRequestFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The provided Key Management Service key lacks the permissions to perform the specified [CreateJob] or [UpdateJob] action.
public struct KMSRequestFailedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct KMSRequestFailedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension KMSRequestFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnowballClientTypes.KeyRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beginMarker = "BeginMarker"
        case endMarker = "EndMarker"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beginMarker = self.beginMarker {
            try encodeContainer.encode(beginMarker, forKey: .beginMarker)
        }
        if let endMarker = self.endMarker {
            try encodeContainer.encode(endMarker, forKey: .endMarker)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let beginMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beginMarker)
        beginMarker = beginMarkerDecoded
        let endMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endMarker)
        endMarker = endMarkerDecoded
    }
}

extension SnowballClientTypes {
    /// Contains a key range. For export jobs, a S3Resource object can have an optional KeyRange value. The length of the range is defined at job creation, and has either an inclusive BeginMarker, an inclusive EndMarker, or both. Ranges are UTF-8 binary sorted.
    public struct KeyRange: Swift.Equatable {
        /// The key that starts an optional key range for an export job. Ranges are inclusive and UTF-8 binary sorted.
        public var beginMarker: Swift.String?
        /// The key that ends an optional key range for an export job. Ranges are inclusive and UTF-8 binary sorted.
        public var endMarker: Swift.String?

        public init (
            beginMarker: Swift.String? = nil,
            endMarker: Swift.String? = nil
        )
        {
            self.beginMarker = beginMarker
            self.endMarker = endMarker
        }
    }

}

extension SnowballClientTypes.LambdaResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTriggers = "EventTriggers"
        case lambdaArn = "LambdaArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventTriggers = eventTriggers {
            var eventTriggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventTriggers)
            for eventtriggerdefinition0 in eventTriggers {
                try eventTriggersContainer.encode(eventtriggerdefinition0)
            }
        }
        if let lambdaArn = self.lambdaArn {
            try encodeContainer.encode(lambdaArn, forKey: .lambdaArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaArn)
        lambdaArn = lambdaArnDecoded
        let eventTriggersContainer = try containerValues.decodeIfPresent([SnowballClientTypes.EventTriggerDefinition?].self, forKey: .eventTriggers)
        var eventTriggersDecoded0:[SnowballClientTypes.EventTriggerDefinition]? = nil
        if let eventTriggersContainer = eventTriggersContainer {
            eventTriggersDecoded0 = [SnowballClientTypes.EventTriggerDefinition]()
            for structure0 in eventTriggersContainer {
                if let structure0 = structure0 {
                    eventTriggersDecoded0?.append(structure0)
                }
            }
        }
        eventTriggers = eventTriggersDecoded0
    }
}

extension SnowballClientTypes {
    /// Identifies
    public struct LambdaResource: Swift.Equatable {
        /// The array of ARNs for [S3Resource] objects to trigger the [LambdaResource] objects associated with this job.
        public var eventTriggers: [SnowballClientTypes.EventTriggerDefinition]?
        /// An Amazon Resource Name (ARN) that represents an Lambda function to be triggered by PUT object actions on the associated local Amazon S3 resource.
        public var lambdaArn: Swift.String?

        public init (
            eventTriggers: [SnowballClientTypes.EventTriggerDefinition]? = nil,
            lambdaArn: Swift.String? = nil
        )
        {
            self.eventTriggers = eventTriggers
            self.lambdaArn = lambdaArn
        }
    }

}

extension ListClusterJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterId = "ClusterId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterId = self.clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListClusterJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListClusterJobsInput: Swift.Equatable {
    /// The 39-character ID for the cluster that you want to list, for example CID123e4567-e89b-12d3-a456-426655440000.
    /// This member is required.
    public var clusterId: Swift.String?
    /// The number of JobListEntry objects to return.
    public var maxResults: Swift.Int?
    /// HTTP requests are stateless. To identify what object comes "next" in the list of JobListEntry objects, you have the option of specifying NextToken as the starting point for your returned list.
    public var nextToken: Swift.String?

    public init (
        clusterId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterId = clusterId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListClusterJobsInputBody: Swift.Equatable {
    let clusterId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListClusterJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterId = "ClusterId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListClusterJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListClusterJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListClusterJobsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListClusterJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListClusterJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobListEntries = output.jobListEntries
            self.nextToken = output.nextToken
        } else {
            self.jobListEntries = nil
            self.nextToken = nil
        }
    }
}

public struct ListClusterJobsOutputResponse: Swift.Equatable {
    /// Each JobListEntry object contains a job's state, a job's ID, and a value that indicates whether the job is a job part, in the case of export jobs.
    public var jobListEntries: [SnowballClientTypes.JobListEntry]?
    /// HTTP requests are stateless. If you use the automatically generated NextToken value in your next ListClusterJobsResult call, your list of returned jobs will start from this point in the array.
    public var nextToken: Swift.String?

    public init (
        jobListEntries: [SnowballClientTypes.JobListEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobListEntries = jobListEntries
        self.nextToken = nextToken
    }
}

struct ListClusterJobsOutputResponseBody: Swift.Equatable {
    let jobListEntries: [SnowballClientTypes.JobListEntry]?
    let nextToken: Swift.String?
}

extension ListClusterJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobListEntries = "JobListEntries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobListEntriesContainer = try containerValues.decodeIfPresent([SnowballClientTypes.JobListEntry?].self, forKey: .jobListEntries)
        var jobListEntriesDecoded0:[SnowballClientTypes.JobListEntry]? = nil
        if let jobListEntriesContainer = jobListEntriesContainer {
            jobListEntriesDecoded0 = [SnowballClientTypes.JobListEntry]()
            for structure0 in jobListEntriesContainer {
                if let structure0 = structure0 {
                    jobListEntriesDecoded0?.append(structure0)
                }
            }
        }
        jobListEntries = jobListEntriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListClustersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListClustersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListClustersInput: Swift.Equatable {
    /// The number of ClusterListEntry objects to return.
    public var maxResults: Swift.Int?
    /// HTTP requests are stateless. To identify what object comes "next" in the list of ClusterListEntry objects, you have the option of specifying NextToken as the starting point for your returned list.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListClustersInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListClustersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListClustersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListClustersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListClustersOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListClustersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListClustersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterListEntries = output.clusterListEntries
            self.nextToken = output.nextToken
        } else {
            self.clusterListEntries = nil
            self.nextToken = nil
        }
    }
}

public struct ListClustersOutputResponse: Swift.Equatable {
    /// Each ClusterListEntry object contains a cluster's state, a cluster's ID, and other important status information.
    public var clusterListEntries: [SnowballClientTypes.ClusterListEntry]?
    /// HTTP requests are stateless. If you use the automatically generated NextToken value in your next ClusterListEntry call, your list of returned clusters will start from this point in the array.
    public var nextToken: Swift.String?

    public init (
        clusterListEntries: [SnowballClientTypes.ClusterListEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterListEntries = clusterListEntries
        self.nextToken = nextToken
    }
}

struct ListClustersOutputResponseBody: Swift.Equatable {
    let clusterListEntries: [SnowballClientTypes.ClusterListEntry]?
    let nextToken: Swift.String?
}

extension ListClustersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterListEntries = "ClusterListEntries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterListEntriesContainer = try containerValues.decodeIfPresent([SnowballClientTypes.ClusterListEntry?].self, forKey: .clusterListEntries)
        var clusterListEntriesDecoded0:[SnowballClientTypes.ClusterListEntry]? = nil
        if let clusterListEntriesContainer = clusterListEntriesContainer {
            clusterListEntriesDecoded0 = [SnowballClientTypes.ClusterListEntry]()
            for structure0 in clusterListEntriesContainer {
                if let structure0 = structure0 {
                    clusterListEntriesDecoded0?.append(structure0)
                }
            }
        }
        clusterListEntries = clusterListEntriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCompatibleImagesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListCompatibleImagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListCompatibleImagesInput: Swift.Equatable {
    /// The maximum number of results for the list of compatible images. Currently, a Snowball Edge device can store 10 AMIs.
    public var maxResults: Swift.Int?
    /// HTTP requests are stateless. To identify what object comes "next" in the list of compatible images, you can specify a value for NextToken as the starting point for your list of returned images.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCompatibleImagesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListCompatibleImagesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCompatibleImagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCompatibleImagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "Ec2RequestFailedException" : self = .ec2RequestFailedException(try Ec2RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListCompatibleImagesOutputError: Swift.Error, Swift.Equatable {
    case ec2RequestFailedException(Ec2RequestFailedException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCompatibleImagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListCompatibleImagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.compatibleImages = output.compatibleImages
            self.nextToken = output.nextToken
        } else {
            self.compatibleImages = nil
            self.nextToken = nil
        }
    }
}

public struct ListCompatibleImagesOutputResponse: Swift.Equatable {
    /// A JSON-formatted object that describes a compatible AMI, including the ID and name for a Snow device AMI.
    public var compatibleImages: [SnowballClientTypes.CompatibleImage]?
    /// Because HTTP requests are stateless, this is the starting point for your next list of returned images.
    public var nextToken: Swift.String?

    public init (
        compatibleImages: [SnowballClientTypes.CompatibleImage]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.compatibleImages = compatibleImages
        self.nextToken = nextToken
    }
}

struct ListCompatibleImagesOutputResponseBody: Swift.Equatable {
    let compatibleImages: [SnowballClientTypes.CompatibleImage]?
    let nextToken: Swift.String?
}

extension ListCompatibleImagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleImages = "CompatibleImages"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let compatibleImagesContainer = try containerValues.decodeIfPresent([SnowballClientTypes.CompatibleImage?].self, forKey: .compatibleImages)
        var compatibleImagesDecoded0:[SnowballClientTypes.CompatibleImage]? = nil
        if let compatibleImagesContainer = compatibleImagesContainer {
            compatibleImagesDecoded0 = [SnowballClientTypes.CompatibleImage]()
            for structure0 in compatibleImagesContainer {
                if let structure0 = structure0 {
                    compatibleImagesDecoded0?.append(structure0)
                }
            }
        }
        compatibleImages = compatibleImagesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListJobsInput: Swift.Equatable {
    /// The number of JobListEntry objects to return.
    public var maxResults: Swift.Int?
    /// HTTP requests are stateless. To identify what object comes "next" in the list of JobListEntry objects, you have the option of specifying NextToken as the starting point for your returned list.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListJobsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListJobsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobListEntries = output.jobListEntries
            self.nextToken = output.nextToken
        } else {
            self.jobListEntries = nil
            self.nextToken = nil
        }
    }
}

public struct ListJobsOutputResponse: Swift.Equatable {
    /// Each JobListEntry object contains a job's state, a job's ID, and a value that indicates whether the job is a job part, in the case of export jobs.
    public var jobListEntries: [SnowballClientTypes.JobListEntry]?
    /// HTTP requests are stateless. If you use this automatically generated NextToken value in your next ListJobs call, your returned JobListEntry objects will start from this point in the array.
    public var nextToken: Swift.String?

    public init (
        jobListEntries: [SnowballClientTypes.JobListEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobListEntries = jobListEntries
        self.nextToken = nextToken
    }
}

struct ListJobsOutputResponseBody: Swift.Equatable {
    let jobListEntries: [SnowballClientTypes.JobListEntry]?
    let nextToken: Swift.String?
}

extension ListJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobListEntries = "JobListEntries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobListEntriesContainer = try containerValues.decodeIfPresent([SnowballClientTypes.JobListEntry?].self, forKey: .jobListEntries)
        var jobListEntriesDecoded0:[SnowballClientTypes.JobListEntry]? = nil
        if let jobListEntriesContainer = jobListEntriesContainer {
            jobListEntriesDecoded0 = [SnowballClientTypes.JobListEntry]()
            for structure0 in jobListEntriesContainer {
                if let structure0 = structure0 {
                    jobListEntriesDecoded0?.append(structure0)
                }
            }
        }
        jobListEntries = jobListEntriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLongTermPricingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListLongTermPricingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListLongTermPricingInput: Swift.Equatable {
    /// The maximum number of ListLongTermPricing objects to return.
    public var maxResults: Swift.Int?
    /// Because HTTP requests are stateless, this is the starting point for your next list of ListLongTermPricing to return.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLongTermPricingInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListLongTermPricingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLongTermPricingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLongTermPricingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListLongTermPricingOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLongTermPricingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListLongTermPricingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.longTermPricingEntries = output.longTermPricingEntries
            self.nextToken = output.nextToken
        } else {
            self.longTermPricingEntries = nil
            self.nextToken = nil
        }
    }
}

public struct ListLongTermPricingOutputResponse: Swift.Equatable {
    /// Each LongTermPricingEntry object contains a status, ID, and other information about the LongTermPricing type.
    public var longTermPricingEntries: [SnowballClientTypes.LongTermPricingListEntry]?
    /// Because HTTP requests are stateless, this is the starting point for your next list of returned ListLongTermPricing list.
    public var nextToken: Swift.String?

    public init (
        longTermPricingEntries: [SnowballClientTypes.LongTermPricingListEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.longTermPricingEntries = longTermPricingEntries
        self.nextToken = nextToken
    }
}

struct ListLongTermPricingOutputResponseBody: Swift.Equatable {
    let longTermPricingEntries: [SnowballClientTypes.LongTermPricingListEntry]?
    let nextToken: Swift.String?
}

extension ListLongTermPricingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case longTermPricingEntries = "LongTermPricingEntries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let longTermPricingEntriesContainer = try containerValues.decodeIfPresent([SnowballClientTypes.LongTermPricingListEntry?].self, forKey: .longTermPricingEntries)
        var longTermPricingEntriesDecoded0:[SnowballClientTypes.LongTermPricingListEntry]? = nil
        if let longTermPricingEntriesContainer = longTermPricingEntriesContainer {
            longTermPricingEntriesDecoded0 = [SnowballClientTypes.LongTermPricingListEntry]()
            for structure0 in longTermPricingEntriesContainer {
                if let structure0 = structure0 {
                    longTermPricingEntriesDecoded0?.append(structure0)
                }
            }
        }
        longTermPricingEntries = longTermPricingEntriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListServiceVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dependentServices = "DependentServices"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceName = "ServiceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dependentServices = dependentServices {
            var dependentServicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dependentServices)
            for dependentservice0 in dependentServices {
                try dependentServicesContainer.encode(dependentservice0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName.rawValue, forKey: .serviceName)
        }
    }
}

extension ListServiceVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListServiceVersionsInput: Swift.Equatable {
    /// A list of names and versions of dependant services of the requested service.
    public var dependentServices: [SnowballClientTypes.DependentService]?
    /// The maximum number of ListServiceVersions objects to return.
    public var maxResults: Swift.Int?
    /// Because HTTP requests are stateless, this is the starting point for the next list of returned ListServiceVersionsRequest versions.
    public var nextToken: Swift.String?
    /// The name of the service for which you're requesting supported versions.
    /// This member is required.
    public var serviceName: SnowballClientTypes.ServiceName?

    public init (
        dependentServices: [SnowballClientTypes.DependentService]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceName: SnowballClientTypes.ServiceName? = nil
    )
    {
        self.dependentServices = dependentServices
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceName = serviceName
    }
}

struct ListServiceVersionsInputBody: Swift.Equatable {
    let serviceName: SnowballClientTypes.ServiceName?
    let dependentServices: [SnowballClientTypes.DependentService]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListServiceVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dependentServices = "DependentServices"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceName = "ServiceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ServiceName.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let dependentServicesContainer = try containerValues.decodeIfPresent([SnowballClientTypes.DependentService?].self, forKey: .dependentServices)
        var dependentServicesDecoded0:[SnowballClientTypes.DependentService]? = nil
        if let dependentServicesContainer = dependentServicesContainer {
            dependentServicesDecoded0 = [SnowballClientTypes.DependentService]()
            for structure0 in dependentServicesContainer {
                if let structure0 = structure0 {
                    dependentServicesDecoded0?.append(structure0)
                }
            }
        }
        dependentServices = dependentServicesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListServiceVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServiceVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListServiceVersionsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServiceVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListServiceVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dependentServices = output.dependentServices
            self.nextToken = output.nextToken
            self.serviceName = output.serviceName
            self.serviceVersions = output.serviceVersions
        } else {
            self.dependentServices = nil
            self.nextToken = nil
            self.serviceName = nil
            self.serviceVersions = nil
        }
    }
}

public struct ListServiceVersionsOutputResponse: Swift.Equatable {
    /// A list of names and versions of dependant services of the service for which the system provided supported versions.
    public var dependentServices: [SnowballClientTypes.DependentService]?
    /// Because HTTP requests are stateless, this is the starting point of the next list of returned ListServiceVersionsResult results.
    public var nextToken: Swift.String?
    /// The name of the service for which the system provided supported versions.
    /// This member is required.
    public var serviceName: SnowballClientTypes.ServiceName?
    /// A list of supported versions.
    /// This member is required.
    public var serviceVersions: [SnowballClientTypes.ServiceVersion]?

    public init (
        dependentServices: [SnowballClientTypes.DependentService]? = nil,
        nextToken: Swift.String? = nil,
        serviceName: SnowballClientTypes.ServiceName? = nil,
        serviceVersions: [SnowballClientTypes.ServiceVersion]? = nil
    )
    {
        self.dependentServices = dependentServices
        self.nextToken = nextToken
        self.serviceName = serviceName
        self.serviceVersions = serviceVersions
    }
}

struct ListServiceVersionsOutputResponseBody: Swift.Equatable {
    let serviceVersions: [SnowballClientTypes.ServiceVersion]?
    let serviceName: SnowballClientTypes.ServiceName?
    let dependentServices: [SnowballClientTypes.DependentService]?
    let nextToken: Swift.String?
}

extension ListServiceVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dependentServices = "DependentServices"
        case nextToken = "NextToken"
        case serviceName = "ServiceName"
        case serviceVersions = "ServiceVersions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceVersionsContainer = try containerValues.decodeIfPresent([SnowballClientTypes.ServiceVersion?].self, forKey: .serviceVersions)
        var serviceVersionsDecoded0:[SnowballClientTypes.ServiceVersion]? = nil
        if let serviceVersionsContainer = serviceVersionsContainer {
            serviceVersionsDecoded0 = [SnowballClientTypes.ServiceVersion]()
            for structure0 in serviceVersionsContainer {
                if let structure0 = structure0 {
                    serviceVersionsDecoded0?.append(structure0)
                }
            }
        }
        serviceVersions = serviceVersionsDecoded0
        let serviceNameDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ServiceName.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let dependentServicesContainer = try containerValues.decodeIfPresent([SnowballClientTypes.DependentService?].self, forKey: .dependentServices)
        var dependentServicesDecoded0:[SnowballClientTypes.DependentService]? = nil
        if let dependentServicesContainer = dependentServicesContainer {
            dependentServicesDecoded0 = [SnowballClientTypes.DependentService]()
            for structure0 in dependentServicesContainer {
                if let structure0 = structure0 {
                    dependentServicesDecoded0?.append(structure0)
                }
            }
        }
        dependentServices = dependentServicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension SnowballClientTypes.LongTermPricingListEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentActiveJob = "CurrentActiveJob"
        case isLongTermPricingAutoRenew = "IsLongTermPricingAutoRenew"
        case jobIds = "JobIds"
        case longTermPricingEndDate = "LongTermPricingEndDate"
        case longTermPricingId = "LongTermPricingId"
        case longTermPricingStartDate = "LongTermPricingStartDate"
        case longTermPricingStatus = "LongTermPricingStatus"
        case longTermPricingType = "LongTermPricingType"
        case replacementJob = "ReplacementJob"
        case snowballType = "SnowballType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentActiveJob = self.currentActiveJob {
            try encodeContainer.encode(currentActiveJob, forKey: .currentActiveJob)
        }
        if let isLongTermPricingAutoRenew = self.isLongTermPricingAutoRenew {
            try encodeContainer.encode(isLongTermPricingAutoRenew, forKey: .isLongTermPricingAutoRenew)
        }
        if let jobIds = jobIds {
            var jobIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .jobIds)
            for jobid0 in jobIds {
                try jobIdsContainer.encode(jobid0)
            }
        }
        if let longTermPricingEndDate = self.longTermPricingEndDate {
            try encodeContainer.encodeTimestamp(longTermPricingEndDate, format: .epochSeconds, forKey: .longTermPricingEndDate)
        }
        if let longTermPricingId = self.longTermPricingId {
            try encodeContainer.encode(longTermPricingId, forKey: .longTermPricingId)
        }
        if let longTermPricingStartDate = self.longTermPricingStartDate {
            try encodeContainer.encodeTimestamp(longTermPricingStartDate, format: .epochSeconds, forKey: .longTermPricingStartDate)
        }
        if let longTermPricingStatus = self.longTermPricingStatus {
            try encodeContainer.encode(longTermPricingStatus, forKey: .longTermPricingStatus)
        }
        if let longTermPricingType = self.longTermPricingType {
            try encodeContainer.encode(longTermPricingType.rawValue, forKey: .longTermPricingType)
        }
        if let replacementJob = self.replacementJob {
            try encodeContainer.encode(replacementJob, forKey: .replacementJob)
        }
        if let snowballType = self.snowballType {
            try encodeContainer.encode(snowballType.rawValue, forKey: .snowballType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let longTermPricingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .longTermPricingId)
        longTermPricingId = longTermPricingIdDecoded
        let longTermPricingEndDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .longTermPricingEndDate)
        longTermPricingEndDate = longTermPricingEndDateDecoded
        let longTermPricingStartDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .longTermPricingStartDate)
        longTermPricingStartDate = longTermPricingStartDateDecoded
        let longTermPricingTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.LongTermPricingType.self, forKey: .longTermPricingType)
        longTermPricingType = longTermPricingTypeDecoded
        let currentActiveJobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentActiveJob)
        currentActiveJob = currentActiveJobDecoded
        let replacementJobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replacementJob)
        replacementJob = replacementJobDecoded
        let isLongTermPricingAutoRenewDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isLongTermPricingAutoRenew)
        isLongTermPricingAutoRenew = isLongTermPricingAutoRenewDecoded
        let longTermPricingStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .longTermPricingStatus)
        longTermPricingStatus = longTermPricingStatusDecoded
        let snowballTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.SnowballType.self, forKey: .snowballType)
        snowballType = snowballTypeDecoded
        let jobIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .jobIds)
        var jobIdsDecoded0:[Swift.String]? = nil
        if let jobIdsContainer = jobIdsContainer {
            jobIdsDecoded0 = [Swift.String]()
            for string0 in jobIdsContainer {
                if let string0 = string0 {
                    jobIdsDecoded0?.append(string0)
                }
            }
        }
        jobIds = jobIdsDecoded0
    }
}

extension SnowballClientTypes {
    /// Each LongTermPricingListEntry object contains information about a long-term pricing type.
    public struct LongTermPricingListEntry: Swift.Equatable {
        /// The current active jobs on the device the long-term pricing type.
        public var currentActiveJob: Swift.String?
        /// If set to true, specifies that the current long-term pricing type for the device should be automatically renewed before the long-term pricing contract expires.
        public var isLongTermPricingAutoRenew: Swift.Bool?
        /// The IDs of the jobs that are associated with a long-term pricing type.
        public var jobIds: [Swift.String]?
        /// The end date the long-term pricing contract.
        public var longTermPricingEndDate: ClientRuntime.Date?
        /// The ID of the long-term pricing type for the device.
        public var longTermPricingId: Swift.String?
        /// The start date of the long-term pricing contract.
        public var longTermPricingStartDate: ClientRuntime.Date?
        /// The status of the long-term pricing type.
        public var longTermPricingStatus: Swift.String?
        /// The type of long-term pricing that was selected for the device.
        public var longTermPricingType: SnowballClientTypes.LongTermPricingType?
        /// A new device that replaces a device that is ordered with long-term pricing.
        public var replacementJob: Swift.String?
        /// The type of Snow Family devices associated with this long-term pricing job.
        public var snowballType: SnowballClientTypes.SnowballType?

        public init (
            currentActiveJob: Swift.String? = nil,
            isLongTermPricingAutoRenew: Swift.Bool? = nil,
            jobIds: [Swift.String]? = nil,
            longTermPricingEndDate: ClientRuntime.Date? = nil,
            longTermPricingId: Swift.String? = nil,
            longTermPricingStartDate: ClientRuntime.Date? = nil,
            longTermPricingStatus: Swift.String? = nil,
            longTermPricingType: SnowballClientTypes.LongTermPricingType? = nil,
            replacementJob: Swift.String? = nil,
            snowballType: SnowballClientTypes.SnowballType? = nil
        )
        {
            self.currentActiveJob = currentActiveJob
            self.isLongTermPricingAutoRenew = isLongTermPricingAutoRenew
            self.jobIds = jobIds
            self.longTermPricingEndDate = longTermPricingEndDate
            self.longTermPricingId = longTermPricingId
            self.longTermPricingStartDate = longTermPricingStartDate
            self.longTermPricingStatus = longTermPricingStatus
            self.longTermPricingType = longTermPricingType
            self.replacementJob = replacementJob
            self.snowballType = snowballType
        }
    }

}

extension SnowballClientTypes {
    public enum LongTermPricingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case oneYear
        case threeYear
        case sdkUnknown(Swift.String)

        public static var allCases: [LongTermPricingType] {
            return [
                .oneYear,
                .threeYear,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .oneYear: return "OneYear"
            case .threeYear: return "ThreeYear"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LongTermPricingType(rawValue: rawValue) ?? LongTermPricingType.sdkUnknown(rawValue)
        }
    }
}

extension SnowballClientTypes.NFSOnDeviceServiceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storageLimit = "StorageLimit"
        case storageUnit = "StorageUnit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if storageLimit != 0 {
            try encodeContainer.encode(storageLimit, forKey: .storageLimit)
        }
        if let storageUnit = self.storageUnit {
            try encodeContainer.encode(storageUnit.rawValue, forKey: .storageUnit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storageLimit) ?? 0
        storageLimit = storageLimitDecoded
        let storageUnitDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.StorageUnit.self, forKey: .storageUnit)
        storageUnit = storageUnitDecoded
    }
}

extension SnowballClientTypes {
    /// An object that represents the metadata and configuration settings for the NFS (Network File System) service on an Amazon Web Services Snow Family device.
    public struct NFSOnDeviceServiceConfiguration: Swift.Equatable {
        /// The maximum NFS storage for one Snow Family device.
        public var storageLimit: Swift.Int
        /// The scale unit of the NFS storage on the device. Valid values: TB.
        public var storageUnit: SnowballClientTypes.StorageUnit?

        public init (
            storageLimit: Swift.Int = 0,
            storageUnit: SnowballClientTypes.StorageUnit? = nil
        )
        {
            self.storageLimit = storageLimit
            self.storageUnit = storageUnit
        }
    }

}

extension SnowballClientTypes.Notification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobStatesToNotify = "JobStatesToNotify"
        case notifyAll = "NotifyAll"
        case snsTopicARN = "SnsTopicARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobStatesToNotify = jobStatesToNotify {
            var jobStatesToNotifyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .jobStatesToNotify)
            for jobstate0 in jobStatesToNotify {
                try jobStatesToNotifyContainer.encode(jobstate0.rawValue)
            }
        }
        if notifyAll != false {
            try encodeContainer.encode(notifyAll, forKey: .notifyAll)
        }
        if let snsTopicARN = self.snsTopicARN {
            try encodeContainer.encode(snsTopicARN, forKey: .snsTopicARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snsTopicARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicARN)
        snsTopicARN = snsTopicARNDecoded
        let jobStatesToNotifyContainer = try containerValues.decodeIfPresent([SnowballClientTypes.JobState?].self, forKey: .jobStatesToNotify)
        var jobStatesToNotifyDecoded0:[SnowballClientTypes.JobState]? = nil
        if let jobStatesToNotifyContainer = jobStatesToNotifyContainer {
            jobStatesToNotifyDecoded0 = [SnowballClientTypes.JobState]()
            for enum0 in jobStatesToNotifyContainer {
                if let enum0 = enum0 {
                    jobStatesToNotifyDecoded0?.append(enum0)
                }
            }
        }
        jobStatesToNotify = jobStatesToNotifyDecoded0
        let notifyAllDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .notifyAll) ?? false
        notifyAll = notifyAllDecoded
    }
}

extension SnowballClientTypes {
    /// The Amazon Simple Notification Service (Amazon SNS) notification settings associated with a specific job. The Notification object is returned as a part of the response syntax of the DescribeJob action in the JobMetadata data type. When the notification settings are defined during job creation, you can choose to notify based on a specific set of job states using the JobStatesToNotify array of strings, or you can specify that you want to have Amazon SNS notifications sent out for all job states with NotifyAll set to true.
    public struct Notification: Swift.Equatable {
        /// The list of job states that will trigger a notification for this job.
        public var jobStatesToNotify: [SnowballClientTypes.JobState]?
        /// Any change in job state will trigger a notification for this job.
        public var notifyAll: Swift.Bool
        /// The new SNS TopicArn that you want to associate with this job. You can create Amazon Resource Names (ARNs) for topics by using the [CreateTopic](https://docs.aws.amazon.com/sns/latest/api/API_CreateTopic.html) Amazon SNS API action. You can subscribe email addresses to an Amazon SNS topic through the Amazon Web Services Management Console, or by using the [Subscribe](https://docs.aws.amazon.com/sns/latest/api/API_Subscribe.html) Amazon Simple Notification Service (Amazon SNS) API action.
        public var snsTopicARN: Swift.String?

        public init (
            jobStatesToNotify: [SnowballClientTypes.JobState]? = nil,
            notifyAll: Swift.Bool = false,
            snsTopicARN: Swift.String? = nil
        )
        {
            self.jobStatesToNotify = jobStatesToNotify
            self.notifyAll = notifyAll
            self.snsTopicARN = snsTopicARN
        }
    }

}

extension SnowballClientTypes.OnDeviceServiceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eksOnDeviceService = "EKSOnDeviceService"
        case nfsOnDeviceService = "NFSOnDeviceService"
        case tgwOnDeviceService = "TGWOnDeviceService"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eksOnDeviceService = self.eksOnDeviceService {
            try encodeContainer.encode(eksOnDeviceService, forKey: .eksOnDeviceService)
        }
        if let nfsOnDeviceService = self.nfsOnDeviceService {
            try encodeContainer.encode(nfsOnDeviceService, forKey: .nfsOnDeviceService)
        }
        if let tgwOnDeviceService = self.tgwOnDeviceService {
            try encodeContainer.encode(tgwOnDeviceService, forKey: .tgwOnDeviceService)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nfsOnDeviceServiceDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.NFSOnDeviceServiceConfiguration.self, forKey: .nfsOnDeviceService)
        nfsOnDeviceService = nfsOnDeviceServiceDecoded
        let tgwOnDeviceServiceDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.TGWOnDeviceServiceConfiguration.self, forKey: .tgwOnDeviceService)
        tgwOnDeviceService = tgwOnDeviceServiceDecoded
        let eksOnDeviceServiceDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.EKSOnDeviceServiceConfiguration.self, forKey: .eksOnDeviceService)
        eksOnDeviceService = eksOnDeviceServiceDecoded
    }
}

extension SnowballClientTypes {
    /// An object that represents the metadata and configuration settings for services on an Amazon Web Services Snow Family device.
    public struct OnDeviceServiceConfiguration: Swift.Equatable {
        /// The configuration of EKS Anywhere on the Snow Family device.
        public var eksOnDeviceService: SnowballClientTypes.EKSOnDeviceServiceConfiguration?
        /// Represents the NFS (Network File System) service on a Snow Family device.
        public var nfsOnDeviceService: SnowballClientTypes.NFSOnDeviceServiceConfiguration?
        /// Represents the Storage Gateway service Tape Gateway type on a Snow Family device.
        public var tgwOnDeviceService: SnowballClientTypes.TGWOnDeviceServiceConfiguration?

        public init (
            eksOnDeviceService: SnowballClientTypes.EKSOnDeviceServiceConfiguration? = nil,
            nfsOnDeviceService: SnowballClientTypes.NFSOnDeviceServiceConfiguration? = nil,
            tgwOnDeviceService: SnowballClientTypes.TGWOnDeviceServiceConfiguration? = nil
        )
        {
            self.eksOnDeviceService = eksOnDeviceService
            self.nfsOnDeviceService = nfsOnDeviceService
            self.tgwOnDeviceService = tgwOnDeviceService
        }
    }

}

extension SnowballClientTypes {
    public enum RemoteManagement: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case installedAutostart
        case installedOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [RemoteManagement] {
            return [
                .installedAutostart,
                .installedOnly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .installedAutostart: return "INSTALLED_AUTOSTART"
            case .installedOnly: return "INSTALLED_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RemoteManagement(rawValue: rawValue) ?? RemoteManagement.sdkUnknown(rawValue)
        }
    }
}

extension ReturnShippingLabelAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ReturnShippingLabelAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You get this exception if you call CreateReturnShippingLabel and a valid return shipping label already exists. In this case, use DescribeReturnShippingLabel to get the URL.
public struct ReturnShippingLabelAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ReturnShippingLabelAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReturnShippingLabelAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnowballClientTypes.S3Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketArn = "BucketArn"
        case keyRange = "KeyRange"
        case targetOnDeviceServices = "TargetOnDeviceServices"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketArn = self.bucketArn {
            try encodeContainer.encode(bucketArn, forKey: .bucketArn)
        }
        if let keyRange = self.keyRange {
            try encodeContainer.encode(keyRange, forKey: .keyRange)
        }
        if let targetOnDeviceServices = targetOnDeviceServices {
            var targetOnDeviceServicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetOnDeviceServices)
            for targetondeviceservice0 in targetOnDeviceServices {
                try targetOnDeviceServicesContainer.encode(targetondeviceservice0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketArn)
        bucketArn = bucketArnDecoded
        let keyRangeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.KeyRange.self, forKey: .keyRange)
        keyRange = keyRangeDecoded
        let targetOnDeviceServicesContainer = try containerValues.decodeIfPresent([SnowballClientTypes.TargetOnDeviceService?].self, forKey: .targetOnDeviceServices)
        var targetOnDeviceServicesDecoded0:[SnowballClientTypes.TargetOnDeviceService]? = nil
        if let targetOnDeviceServicesContainer = targetOnDeviceServicesContainer {
            targetOnDeviceServicesDecoded0 = [SnowballClientTypes.TargetOnDeviceService]()
            for structure0 in targetOnDeviceServicesContainer {
                if let structure0 = structure0 {
                    targetOnDeviceServicesDecoded0?.append(structure0)
                }
            }
        }
        targetOnDeviceServices = targetOnDeviceServicesDecoded0
    }
}

extension SnowballClientTypes {
    /// Each S3Resource object represents an Amazon S3 bucket that your transferred data will be exported from or imported into. For export jobs, this object can have an optional KeyRange value. The length of the range is defined at job creation, and has either an inclusive BeginMarker, an inclusive EndMarker, or both. Ranges are UTF-8 binary sorted.
    public struct S3Resource: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of an Amazon S3 bucket.
        public var bucketArn: Swift.String?
        /// For export jobs, you can provide an optional KeyRange within a specific Amazon S3 bucket. The length of the range is defined at job creation, and has either an inclusive BeginMarker, an inclusive EndMarker, or both. Ranges are UTF-8 binary sorted.
        public var keyRange: SnowballClientTypes.KeyRange?
        /// Specifies the service or services on the Snow Family device that your transferred data will be exported from or imported into. Amazon Web Services Snow Family supports Amazon S3 and NFS (Network File System).
        public var targetOnDeviceServices: [SnowballClientTypes.TargetOnDeviceService]?

        public init (
            bucketArn: Swift.String? = nil,
            keyRange: SnowballClientTypes.KeyRange? = nil,
            targetOnDeviceServices: [SnowballClientTypes.TargetOnDeviceService]? = nil
        )
        {
            self.bucketArn = bucketArn
            self.keyRange = keyRange
            self.targetOnDeviceServices = targetOnDeviceServices
        }
    }

}

extension SnowballClientTypes {
    public enum ServiceName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case eksAnywhere
        case kubernetes
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceName] {
            return [
                .eksAnywhere,
                .kubernetes,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .eksAnywhere: return "EKS_ANYWHERE"
            case .kubernetes: return "KUBERNETES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceName(rawValue: rawValue) ?? ServiceName.sdkUnknown(rawValue)
        }
    }
}

extension SnowballClientTypes.ServiceVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension SnowballClientTypes {
    /// The version of the requested service.
    public struct ServiceVersion: Swift.Equatable {
        /// The version number of the requested service.
        public var version: Swift.String?

        public init (
            version: Swift.String? = nil
        )
        {
            self.version = version
        }
    }

}

extension SnowballClientTypes.Shipment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case trackingNumber = "TrackingNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let trackingNumber = self.trackingNumber {
            try encodeContainer.encode(trackingNumber, forKey: .trackingNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let trackingNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackingNumber)
        trackingNumber = trackingNumberDecoded
    }
}

extension SnowballClientTypes {
    /// The Status and TrackingNumber information for an inbound or outbound shipment.
    public struct Shipment: Swift.Equatable {
        /// Status information for a shipment.
        public var status: Swift.String?
        /// The tracking number for this job. Using this tracking number with your region's carrier's website, you can track a Snow device as the carrier transports it. For India, the carrier is Amazon Logistics. For all other regions, UPS is the carrier.
        public var trackingNumber: Swift.String?

        public init (
            status: Swift.String? = nil,
            trackingNumber: Swift.String? = nil
        )
        {
            self.status = status
            self.trackingNumber = trackingNumber
        }
    }

}

extension SnowballClientTypes {
    public enum ShipmentState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case received
        case returned
        case sdkUnknown(Swift.String)

        public static var allCases: [ShipmentState] {
            return [
                .received,
                .returned,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .received: return "RECEIVED"
            case .returned: return "RETURNED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShipmentState(rawValue: rawValue) ?? ShipmentState.sdkUnknown(rawValue)
        }
    }
}

extension SnowballClientTypes.ShippingDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inboundShipment = "InboundShipment"
        case outboundShipment = "OutboundShipment"
        case shippingOption = "ShippingOption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inboundShipment = self.inboundShipment {
            try encodeContainer.encode(inboundShipment, forKey: .inboundShipment)
        }
        if let outboundShipment = self.outboundShipment {
            try encodeContainer.encode(outboundShipment, forKey: .outboundShipment)
        }
        if let shippingOption = self.shippingOption {
            try encodeContainer.encode(shippingOption.rawValue, forKey: .shippingOption)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shippingOptionDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ShippingOption.self, forKey: .shippingOption)
        shippingOption = shippingOptionDecoded
        let inboundShipmentDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.Shipment.self, forKey: .inboundShipment)
        inboundShipment = inboundShipmentDecoded
        let outboundShipmentDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.Shipment.self, forKey: .outboundShipment)
        outboundShipment = outboundShipmentDecoded
    }
}

extension SnowballClientTypes {
    /// A job's shipping information, including inbound and outbound tracking numbers and shipping speed options.
    public struct ShippingDetails: Swift.Equatable {
        /// The Status and TrackingNumber values for a Snow device being returned to Amazon Web Services for a particular job.
        public var inboundShipment: SnowballClientTypes.Shipment?
        /// The Status and TrackingNumber values for a Snow device being delivered to the address that you specified for a particular job.
        public var outboundShipment: SnowballClientTypes.Shipment?
        /// The shipping speed for a particular job. This speed doesn't dictate how soon you'll get the Snow device from the job's creation date. This speed represents how quickly it moves to its destination while in transit. Regional shipping speeds are as follows:
        ///
        /// * In Australia, you have access to express shipping. Typically, Snow devices shipped express are delivered in about a day.
        ///
        /// * In the European Union (EU), you have access to express shipping. Typically, Snow devices shipped express are delivered in about a day. In addition, most countries in the EU have access to standard shipping, which typically takes less than a week, one way.
        ///
        /// * In India, Snow devices are delivered in one to seven days.
        ///
        /// * In the United States of America (US), you have access to one-day shipping and two-day shipping.
        public var shippingOption: SnowballClientTypes.ShippingOption?

        public init (
            inboundShipment: SnowballClientTypes.Shipment? = nil,
            outboundShipment: SnowballClientTypes.Shipment? = nil,
            shippingOption: SnowballClientTypes.ShippingOption? = nil
        )
        {
            self.inboundShipment = inboundShipment
            self.outboundShipment = outboundShipment
            self.shippingOption = shippingOption
        }
    }

}

extension SnowballClientTypes {
    public enum ShippingLabelStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [ShippingLabelStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded,
                .timedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .succeeded: return "Succeeded"
            case .timedOut: return "TimedOut"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShippingLabelStatus(rawValue: rawValue) ?? ShippingLabelStatus.sdkUnknown(rawValue)
        }
    }
}

extension SnowballClientTypes {
    public enum ShippingOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case express
        case nextDay
        case secondDay
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [ShippingOption] {
            return [
                .express,
                .nextDay,
                .secondDay,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .express: return "EXPRESS"
            case .nextDay: return "NEXT_DAY"
            case .secondDay: return "SECOND_DAY"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShippingOption(rawValue: rawValue) ?? ShippingOption.sdkUnknown(rawValue)
        }
    }
}

extension SnowballClientTypes {
    public enum SnowballCapacity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case noPreference
        case t100
        case t14
        case t32
        case t42
        case t50
        case t8
        case t80
        case t98
        case sdkUnknown(Swift.String)

        public static var allCases: [SnowballCapacity] {
            return [
                .noPreference,
                .t100,
                .t14,
                .t32,
                .t42,
                .t50,
                .t8,
                .t80,
                .t98,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .noPreference: return "NoPreference"
            case .t100: return "T100"
            case .t14: return "T14"
            case .t32: return "T32"
            case .t42: return "T42"
            case .t50: return "T50"
            case .t8: return "T8"
            case .t80: return "T80"
            case .t98: return "T98"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SnowballCapacity(rawValue: rawValue) ?? SnowballCapacity.sdkUnknown(rawValue)
        }
    }
}

extension SnowballClientTypes {
    public enum SnowballType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case edge
        case edgeC
        case edgeCg
        case edgeS
        case snc1Hdd
        case snc1Ssd
        case standard
        case v35c
        case sdkUnknown(Swift.String)

        public static var allCases: [SnowballType] {
            return [
                .edge,
                .edgeC,
                .edgeCg,
                .edgeS,
                .snc1Hdd,
                .snc1Ssd,
                .standard,
                .v35c,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .edge: return "EDGE"
            case .edgeC: return "EDGE_C"
            case .edgeCg: return "EDGE_CG"
            case .edgeS: return "EDGE_S"
            case .snc1Hdd: return "SNC1_HDD"
            case .snc1Ssd: return "SNC1_SSD"
            case .standard: return "STANDARD"
            case .v35c: return "V3_5C"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SnowballType(rawValue: rawValue) ?? SnowballType.sdkUnknown(rawValue)
        }
    }
}

extension SnowballClientTypes.SnowconeDeviceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case wirelessConnection = "WirelessConnection"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let wirelessConnection = self.wirelessConnection {
            try encodeContainer.encode(wirelessConnection, forKey: .wirelessConnection)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessConnectionDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.WirelessConnection.self, forKey: .wirelessConnection)
        wirelessConnection = wirelessConnectionDecoded
    }
}

extension SnowballClientTypes {
    /// Specifies the device configuration for an Snowcone job.
    public struct SnowconeDeviceConfiguration: Swift.Equatable {
        /// Configures the wireless connection for the Snowcone device.
        public var wirelessConnection: SnowballClientTypes.WirelessConnection?

        public init (
            wirelessConnection: SnowballClientTypes.WirelessConnection? = nil
        )
        {
            self.wirelessConnection = wirelessConnection
        }
    }

}

extension SnowballClientTypes {
    public enum StorageUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case tb
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageUnit] {
            return [
                .tb,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .tb: return "TB"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StorageUnit(rawValue: rawValue) ?? StorageUnit.sdkUnknown(rawValue)
        }
    }
}

extension SnowballClientTypes.TGWOnDeviceServiceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storageLimit = "StorageLimit"
        case storageUnit = "StorageUnit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if storageLimit != 0 {
            try encodeContainer.encode(storageLimit, forKey: .storageLimit)
        }
        if let storageUnit = self.storageUnit {
            try encodeContainer.encode(storageUnit.rawValue, forKey: .storageUnit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storageLimit) ?? 0
        storageLimit = storageLimitDecoded
        let storageUnitDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.StorageUnit.self, forKey: .storageUnit)
        storageUnit = storageUnitDecoded
    }
}

extension SnowballClientTypes {
    /// An object that represents the metadata and configuration settings for the Storage Gateway service Tape Gateway type on an Amazon Web Services Snow Family device.
    public struct TGWOnDeviceServiceConfiguration: Swift.Equatable {
        /// The maximum number of virtual tapes to store on one Snow Family device. Due to physical resource limitations, this value must be set to 80 for Snowball Edge.
        public var storageLimit: Swift.Int
        /// The scale unit of the virtual tapes on the device.
        public var storageUnit: SnowballClientTypes.StorageUnit?

        public init (
            storageLimit: Swift.Int = 0,
            storageUnit: SnowballClientTypes.StorageUnit? = nil
        )
        {
            self.storageLimit = storageLimit
            self.storageUnit = storageUnit
        }
    }

}

extension SnowballClientTypes.TargetOnDeviceService: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceName = "ServiceName"
        case transferOption = "TransferOption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName.rawValue, forKey: .serviceName)
        }
        if let transferOption = self.transferOption {
            try encodeContainer.encode(transferOption.rawValue, forKey: .transferOption)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.DeviceServiceName.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let transferOptionDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.TransferOption.self, forKey: .transferOption)
        transferOption = transferOptionDecoded
    }
}

extension SnowballClientTypes {
    /// An object that represents the service or services on the Snow Family device that your transferred data will be exported from or imported into. Amazon Web Services Snow Family supports Amazon S3 and NFS (Network File System).
    public struct TargetOnDeviceService: Swift.Equatable {
        /// Specifies the name of the service on the Snow Family device that your transferred data will be exported from or imported into.
        public var serviceName: SnowballClientTypes.DeviceServiceName?
        /// Specifies whether the data is being imported or exported. You can import or export the data, or use it locally on the device.
        public var transferOption: SnowballClientTypes.TransferOption?

        public init (
            serviceName: SnowballClientTypes.DeviceServiceName? = nil,
            transferOption: SnowballClientTypes.TransferOption? = nil
        )
        {
            self.serviceName = serviceName
            self.transferOption = transferOption
        }
    }

}

extension SnowballClientTypes.TaxDocuments: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ind = "IND"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ind = self.ind {
            try encodeContainer.encode(ind, forKey: .ind)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.INDTaxDocuments.self, forKey: .ind)
        ind = indDecoded
    }
}

extension SnowballClientTypes {
    /// The tax documents required in your Amazon Web Services Region.
    public struct TaxDocuments: Swift.Equatable {
        /// The tax documents required in Amazon Web Services Region in India.
        public var ind: SnowballClientTypes.INDTaxDocuments?

        public init (
            ind: SnowballClientTypes.INDTaxDocuments? = nil
        )
        {
            self.ind = ind
        }
    }

}

extension SnowballClientTypes {
    public enum TransferOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case export
        case `import`
        case localUse
        case sdkUnknown(Swift.String)

        public static var allCases: [TransferOption] {
            return [
                .export,
                .import,
                .localUse,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .export: return "EXPORT"
            case .import: return "IMPORT"
            case .localUse: return "LOCAL_USE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TransferOption(rawValue: rawValue) ?? TransferOption.sdkUnknown(rawValue)
        }
    }
}

extension UnsupportedAddressException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UnsupportedAddressExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The address is either outside the serviceable area for your region, or an error occurred. Check the address with your region's carrier and try again. If the issue persists, contact Amazon Web Services Support.
public struct UnsupportedAddressException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedAddressExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedAddressExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateClusterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
        case clusterId = "ClusterId"
        case description = "Description"
        case forwardingAddressId = "ForwardingAddressId"
        case notification = "Notification"
        case onDeviceServiceConfiguration = "OnDeviceServiceConfiguration"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingOption = "ShippingOption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressId = self.addressId {
            try encodeContainer.encode(addressId, forKey: .addressId)
        }
        if let clusterId = self.clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let forwardingAddressId = self.forwardingAddressId {
            try encodeContainer.encode(forwardingAddressId, forKey: .forwardingAddressId)
        }
        if let notification = self.notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let onDeviceServiceConfiguration = self.onDeviceServiceConfiguration {
            try encodeContainer.encode(onDeviceServiceConfiguration, forKey: .onDeviceServiceConfiguration)
        }
        if let resources = self.resources {
            try encodeContainer.encode(resources, forKey: .resources)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
        if let shippingOption = self.shippingOption {
            try encodeContainer.encode(shippingOption.rawValue, forKey: .shippingOption)
        }
    }
}

extension UpdateClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateClusterInput: Swift.Equatable {
    /// The ID of the updated [Address] object.
    public var addressId: Swift.String?
    /// The cluster ID of the cluster that you want to update, for example CID123e4567-e89b-12d3-a456-426655440000.
    /// This member is required.
    public var clusterId: Swift.String?
    /// The updated description of this cluster.
    public var description: Swift.String?
    /// The updated ID for the forwarding address for a cluster. This field is not supported in most regions.
    public var forwardingAddressId: Swift.String?
    /// The new or updated [Notification] object.
    public var notification: SnowballClientTypes.Notification?
    /// Specifies the service or services on the Snow Family device that your transferred data will be exported from or imported into. Amazon Web Services Snow Family device clusters support Amazon S3 and NFS (Network File System).
    public var onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration?
    /// The updated arrays of [JobResource] objects that can include updated [S3Resource] objects or [LambdaResource] objects.
    public var resources: SnowballClientTypes.JobResource?
    /// The new role Amazon Resource Name (ARN) that you want to associate with this cluster. To create a role ARN, use the [CreateRole](https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html) API action in Identity and Access Management (IAM).
    public var roleARN: Swift.String?
    /// The updated shipping option value of this cluster's [ShippingDetails] object.
    public var shippingOption: SnowballClientTypes.ShippingOption?

    public init (
        addressId: Swift.String? = nil,
        clusterId: Swift.String? = nil,
        description: Swift.String? = nil,
        forwardingAddressId: Swift.String? = nil,
        notification: SnowballClientTypes.Notification? = nil,
        onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration? = nil,
        resources: SnowballClientTypes.JobResource? = nil,
        roleARN: Swift.String? = nil,
        shippingOption: SnowballClientTypes.ShippingOption? = nil
    )
    {
        self.addressId = addressId
        self.clusterId = clusterId
        self.description = description
        self.forwardingAddressId = forwardingAddressId
        self.notification = notification
        self.onDeviceServiceConfiguration = onDeviceServiceConfiguration
        self.resources = resources
        self.roleARN = roleARN
        self.shippingOption = shippingOption
    }
}

struct UpdateClusterInputBody: Swift.Equatable {
    let clusterId: Swift.String?
    let roleARN: Swift.String?
    let description: Swift.String?
    let resources: SnowballClientTypes.JobResource?
    let onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration?
    let addressId: Swift.String?
    let shippingOption: SnowballClientTypes.ShippingOption?
    let notification: SnowballClientTypes.Notification?
    let forwardingAddressId: Swift.String?
}

extension UpdateClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
        case clusterId = "ClusterId"
        case description = "Description"
        case forwardingAddressId = "ForwardingAddressId"
        case notification = "Notification"
        case onDeviceServiceConfiguration = "OnDeviceServiceConfiguration"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingOption = "ShippingOption"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let resourcesDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobResource.self, forKey: .resources)
        resources = resourcesDecoded
        let onDeviceServiceConfigurationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.OnDeviceServiceConfiguration.self, forKey: .onDeviceServiceConfiguration)
        onDeviceServiceConfiguration = onDeviceServiceConfigurationDecoded
        let addressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressId)
        addressId = addressIdDecoded
        let shippingOptionDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ShippingOption.self, forKey: .shippingOption)
        shippingOption = shippingOptionDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
        let forwardingAddressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forwardingAddressId)
        forwardingAddressId = forwardingAddressIdDecoded
    }
}

extension UpdateClusterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateClusterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "Ec2RequestFailedException" : self = .ec2RequestFailedException(try Ec2RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputCombinationException" : self = .invalidInputCombinationException(try InvalidInputCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSRequestFailedException" : self = .kMSRequestFailedException(try KMSRequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateClusterOutputError: Swift.Error, Swift.Equatable {
    case ec2RequestFailedException(Ec2RequestFailedException)
    case invalidInputCombinationException(InvalidInputCombinationException)
    case invalidJobStateException(InvalidJobStateException)
    case invalidResourceException(InvalidResourceException)
    case kMSRequestFailedException(KMSRequestFailedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateClusterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateClusterOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
        case description = "Description"
        case forwardingAddressId = "ForwardingAddressId"
        case jobId = "JobId"
        case notification = "Notification"
        case onDeviceServiceConfiguration = "OnDeviceServiceConfiguration"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingOption = "ShippingOption"
        case snowballCapacityPreference = "SnowballCapacityPreference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressId = self.addressId {
            try encodeContainer.encode(addressId, forKey: .addressId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let forwardingAddressId = self.forwardingAddressId {
            try encodeContainer.encode(forwardingAddressId, forKey: .forwardingAddressId)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let notification = self.notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let onDeviceServiceConfiguration = self.onDeviceServiceConfiguration {
            try encodeContainer.encode(onDeviceServiceConfiguration, forKey: .onDeviceServiceConfiguration)
        }
        if let resources = self.resources {
            try encodeContainer.encode(resources, forKey: .resources)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
        if let shippingOption = self.shippingOption {
            try encodeContainer.encode(shippingOption.rawValue, forKey: .shippingOption)
        }
        if let snowballCapacityPreference = self.snowballCapacityPreference {
            try encodeContainer.encode(snowballCapacityPreference.rawValue, forKey: .snowballCapacityPreference)
        }
    }
}

extension UpdateJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateJobInput: Swift.Equatable {
    /// The ID of the updated [Address] object.
    public var addressId: Swift.String?
    /// The updated description of this job's [JobMetadata] object.
    public var description: Swift.String?
    /// The updated ID for the forwarding address for a job. This field is not supported in most regions.
    public var forwardingAddressId: Swift.String?
    /// The job ID of the job that you want to update, for example JID123e4567-e89b-12d3-a456-426655440000.
    /// This member is required.
    public var jobId: Swift.String?
    /// The new or updated [Notification] object.
    public var notification: SnowballClientTypes.Notification?
    /// Specifies the service or services on the Snow Family device that your transferred data will be exported from or imported into. Amazon Web Services Snow Family supports Amazon S3 and NFS (Network File System) and the Amazon Web Services Storage Gateway service Tape Gateway type.
    public var onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration?
    /// The updated JobResource object, or the updated [JobResource] object.
    public var resources: SnowballClientTypes.JobResource?
    /// The new role Amazon Resource Name (ARN) that you want to associate with this job. To create a role ARN, use the [CreateRole](https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html)Identity and Access Management (IAM) API action.
    public var roleARN: Swift.String?
    /// The updated shipping option value of this job's [ShippingDetails] object.
    public var shippingOption: SnowballClientTypes.ShippingOption?
    /// The updated SnowballCapacityPreference of this job's [JobMetadata] object. The 50 TB Snowballs are only available in the US regions. For more information, see "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide or "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide.
    public var snowballCapacityPreference: SnowballClientTypes.SnowballCapacity?

    public init (
        addressId: Swift.String? = nil,
        description: Swift.String? = nil,
        forwardingAddressId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        notification: SnowballClientTypes.Notification? = nil,
        onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration? = nil,
        resources: SnowballClientTypes.JobResource? = nil,
        roleARN: Swift.String? = nil,
        shippingOption: SnowballClientTypes.ShippingOption? = nil,
        snowballCapacityPreference: SnowballClientTypes.SnowballCapacity? = nil
    )
    {
        self.addressId = addressId
        self.description = description
        self.forwardingAddressId = forwardingAddressId
        self.jobId = jobId
        self.notification = notification
        self.onDeviceServiceConfiguration = onDeviceServiceConfiguration
        self.resources = resources
        self.roleARN = roleARN
        self.shippingOption = shippingOption
        self.snowballCapacityPreference = snowballCapacityPreference
    }
}

struct UpdateJobInputBody: Swift.Equatable {
    let jobId: Swift.String?
    let roleARN: Swift.String?
    let notification: SnowballClientTypes.Notification?
    let resources: SnowballClientTypes.JobResource?
    let onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration?
    let addressId: Swift.String?
    let shippingOption: SnowballClientTypes.ShippingOption?
    let description: Swift.String?
    let snowballCapacityPreference: SnowballClientTypes.SnowballCapacity?
    let forwardingAddressId: Swift.String?
}

extension UpdateJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
        case description = "Description"
        case forwardingAddressId = "ForwardingAddressId"
        case jobId = "JobId"
        case notification = "Notification"
        case onDeviceServiceConfiguration = "OnDeviceServiceConfiguration"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingOption = "ShippingOption"
        case snowballCapacityPreference = "SnowballCapacityPreference"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
        let resourcesDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobResource.self, forKey: .resources)
        resources = resourcesDecoded
        let onDeviceServiceConfigurationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.OnDeviceServiceConfiguration.self, forKey: .onDeviceServiceConfiguration)
        onDeviceServiceConfiguration = onDeviceServiceConfigurationDecoded
        let addressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressId)
        addressId = addressIdDecoded
        let shippingOptionDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ShippingOption.self, forKey: .shippingOption)
        shippingOption = shippingOptionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let snowballCapacityPreferenceDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.SnowballCapacity.self, forKey: .snowballCapacityPreference)
        snowballCapacityPreference = snowballCapacityPreferenceDecoded
        let forwardingAddressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forwardingAddressId)
        forwardingAddressId = forwardingAddressIdDecoded
    }
}

extension UpdateJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClusterLimitExceededException" : self = .clusterLimitExceededException(try ClusterLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Ec2RequestFailedException" : self = .ec2RequestFailedException(try Ec2RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputCombinationException" : self = .invalidInputCombinationException(try InvalidInputCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSRequestFailedException" : self = .kMSRequestFailedException(try KMSRequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateJobOutputError: Swift.Error, Swift.Equatable {
    case clusterLimitExceededException(ClusterLimitExceededException)
    case ec2RequestFailedException(Ec2RequestFailedException)
    case invalidInputCombinationException(InvalidInputCombinationException)
    case invalidJobStateException(InvalidJobStateException)
    case invalidResourceException(InvalidResourceException)
    case kMSRequestFailedException(KMSRequestFailedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateJobOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateJobShipmentStateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case shipmentState = "ShipmentState"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let shipmentState = self.shipmentState {
            try encodeContainer.encode(shipmentState.rawValue, forKey: .shipmentState)
        }
    }
}

extension UpdateJobShipmentStateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateJobShipmentStateInput: Swift.Equatable {
    /// The job ID of the job whose shipment date you want to update, for example JID123e4567-e89b-12d3-a456-426655440000.
    /// This member is required.
    public var jobId: Swift.String?
    /// The state of a device when it is being shipped. Set to RECEIVED when the device arrives at your location. Set to RETURNED when you have returned the device to Amazon Web Services.
    /// This member is required.
    public var shipmentState: SnowballClientTypes.ShipmentState?

    public init (
        jobId: Swift.String? = nil,
        shipmentState: SnowballClientTypes.ShipmentState? = nil
    )
    {
        self.jobId = jobId
        self.shipmentState = shipmentState
    }
}

struct UpdateJobShipmentStateInputBody: Swift.Equatable {
    let jobId: Swift.String?
    let shipmentState: SnowballClientTypes.ShipmentState?
}

extension UpdateJobShipmentStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case shipmentState = "ShipmentState"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let shipmentStateDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ShipmentState.self, forKey: .shipmentState)
        shipmentState = shipmentStateDecoded
    }
}

extension UpdateJobShipmentStateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateJobShipmentStateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateJobShipmentStateOutputError: Swift.Error, Swift.Equatable {
    case invalidJobStateException(InvalidJobStateException)
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateJobShipmentStateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateJobShipmentStateOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateLongTermPricingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isLongTermPricingAutoRenew = "IsLongTermPricingAutoRenew"
        case longTermPricingId = "LongTermPricingId"
        case replacementJob = "ReplacementJob"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isLongTermPricingAutoRenew = self.isLongTermPricingAutoRenew {
            try encodeContainer.encode(isLongTermPricingAutoRenew, forKey: .isLongTermPricingAutoRenew)
        }
        if let longTermPricingId = self.longTermPricingId {
            try encodeContainer.encode(longTermPricingId, forKey: .longTermPricingId)
        }
        if let replacementJob = self.replacementJob {
            try encodeContainer.encode(replacementJob, forKey: .replacementJob)
        }
    }
}

extension UpdateLongTermPricingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateLongTermPricingInput: Swift.Equatable {
    /// If set to true, specifies that the current long-term pricing type for the device should be automatically renewed before the long-term pricing contract expires.
    public var isLongTermPricingAutoRenew: Swift.Bool?
    /// The ID of the long-term pricing type for the device.
    /// This member is required.
    public var longTermPricingId: Swift.String?
    /// Specifies that a device that is ordered with long-term pricing should be replaced with a new device.
    public var replacementJob: Swift.String?

    public init (
        isLongTermPricingAutoRenew: Swift.Bool? = nil,
        longTermPricingId: Swift.String? = nil,
        replacementJob: Swift.String? = nil
    )
    {
        self.isLongTermPricingAutoRenew = isLongTermPricingAutoRenew
        self.longTermPricingId = longTermPricingId
        self.replacementJob = replacementJob
    }
}

struct UpdateLongTermPricingInputBody: Swift.Equatable {
    let longTermPricingId: Swift.String?
    let replacementJob: Swift.String?
    let isLongTermPricingAutoRenew: Swift.Bool?
}

extension UpdateLongTermPricingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isLongTermPricingAutoRenew = "IsLongTermPricingAutoRenew"
        case longTermPricingId = "LongTermPricingId"
        case replacementJob = "ReplacementJob"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let longTermPricingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .longTermPricingId)
        longTermPricingId = longTermPricingIdDecoded
        let replacementJobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replacementJob)
        replacementJob = replacementJobDecoded
        let isLongTermPricingAutoRenewDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isLongTermPricingAutoRenew)
        isLongTermPricingAutoRenew = isLongTermPricingAutoRenewDecoded
    }
}

extension UpdateLongTermPricingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLongTermPricingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateLongTermPricingOutputError: Swift.Error, Swift.Equatable {
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLongTermPricingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateLongTermPricingOutputResponse: Swift.Equatable {

    public init () { }
}

extension SnowballClientTypes.WirelessConnection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isWifiEnabled = "IsWifiEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isWifiEnabled != false {
            try encodeContainer.encode(isWifiEnabled, forKey: .isWifiEnabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isWifiEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isWifiEnabled) ?? false
        isWifiEnabled = isWifiEnabledDecoded
    }
}

extension SnowballClientTypes {
    /// Configures the wireless connection on an Snowcone device.
    public struct WirelessConnection: Swift.Equatable {
        /// Enables the Wi-Fi adapter on an Snowcone device.
        public var isWifiEnabled: Swift.Bool

        public init (
            isWifiEnabled: Swift.Bool = false
        )
        {
            self.isWifiEnabled = isWifiEnabled
        }
    }

}
