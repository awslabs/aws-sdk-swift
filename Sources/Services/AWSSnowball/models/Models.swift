// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension SnowballClientTypes.Address: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
        case city = "City"
        case company = "Company"
        case country = "Country"
        case isRestricted = "IsRestricted"
        case landmark = "Landmark"
        case name = "Name"
        case phoneNumber = "PhoneNumber"
        case postalCode = "PostalCode"
        case prefectureOrDistrict = "PrefectureOrDistrict"
        case stateOrProvince = "StateOrProvince"
        case street1 = "Street1"
        case street2 = "Street2"
        case street3 = "Street3"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressId = self.addressId {
            try encodeContainer.encode(addressId, forKey: .addressId)
        }
        if let city = self.city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let company = self.company {
            try encodeContainer.encode(company, forKey: .company)
        }
        if let country = self.country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if isRestricted != false {
            try encodeContainer.encode(isRestricted, forKey: .isRestricted)
        }
        if let landmark = self.landmark {
            try encodeContainer.encode(landmark, forKey: .landmark)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let phoneNumber = self.phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let postalCode = self.postalCode {
            try encodeContainer.encode(postalCode, forKey: .postalCode)
        }
        if let prefectureOrDistrict = self.prefectureOrDistrict {
            try encodeContainer.encode(prefectureOrDistrict, forKey: .prefectureOrDistrict)
        }
        if let stateOrProvince = self.stateOrProvince {
            try encodeContainer.encode(stateOrProvince, forKey: .stateOrProvince)
        }
        if let street1 = self.street1 {
            try encodeContainer.encode(street1, forKey: .street1)
        }
        if let street2 = self.street2 {
            try encodeContainer.encode(street2, forKey: .street2)
        }
        if let street3 = self.street3 {
            try encodeContainer.encode(street3, forKey: .street3)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressId)
        addressId = addressIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let companyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .company)
        company = companyDecoded
        let street1Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .street1)
        street1 = street1Decoded
        let street2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .street2)
        street2 = street2Decoded
        let street3Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .street3)
        street3 = street3Decoded
        let cityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .city)
        city = cityDecoded
        let stateOrProvinceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateOrProvince)
        stateOrProvince = stateOrProvinceDecoded
        let prefectureOrDistrictDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefectureOrDistrict)
        prefectureOrDistrict = prefectureOrDistrictDecoded
        let landmarkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .landmark)
        landmark = landmarkDecoded
        let countryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .country)
        country = countryDecoded
        let postalCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .postalCode)
        postalCode = postalCodeDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let isRestrictedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isRestricted) ?? false
        isRestricted = isRestrictedDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.AddressType.self, forKey: .type)
        type = typeDecoded
    }
}

extension SnowballClientTypes {
    /// The address that you want the Snow device(s) associated with a specific job to be shipped to. Addresses are validated at the time of creation. The address you provide must be located within the serviceable area of your region. Although no individual elements of the Address are required, if the address is invalid or unsupported, then an exception is thrown.
    public struct Address: Swift.Equatable {
        /// The unique ID for an address.
        public var addressId: Swift.String?
        /// The city in an address that a Snow device is to be delivered to.
        public var city: Swift.String?
        /// The name of the company to receive a Snow device at an address.
        public var company: Swift.String?
        /// The country in an address that a Snow device is to be delivered to.
        public var country: Swift.String?
        /// If the address you are creating is a primary address, then set this option to true. This field is not supported in most regions.
        public var isRestricted: Swift.Bool
        /// This field is no longer used and the value is ignored.
        public var landmark: Swift.String?
        /// The name of a person to receive a Snow device at an address.
        public var name: Swift.String?
        /// The phone number associated with an address that a Snow device is to be delivered to.
        public var phoneNumber: Swift.String?
        /// The postal code in an address that a Snow device is to be delivered to.
        public var postalCode: Swift.String?
        /// This field is no longer used and the value is ignored.
        public var prefectureOrDistrict: Swift.String?
        /// The state or province in an address that a Snow device is to be delivered to.
        public var stateOrProvince: Swift.String?
        /// The first line in a street address that a Snow device is to be delivered to.
        public var street1: Swift.String?
        /// The second line in a street address that a Snow device is to be delivered to.
        public var street2: Swift.String?
        /// The third line in a street address that a Snow device is to be delivered to.
        public var street3: Swift.String?
        /// Differentiates between delivery address and pickup address in the customer account. Provided at job creation.
        public var type: SnowballClientTypes.AddressType?

        public init(
            addressId: Swift.String? = nil,
            city: Swift.String? = nil,
            company: Swift.String? = nil,
            country: Swift.String? = nil,
            isRestricted: Swift.Bool = false,
            landmark: Swift.String? = nil,
            name: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            prefectureOrDistrict: Swift.String? = nil,
            stateOrProvince: Swift.String? = nil,
            street1: Swift.String? = nil,
            street2: Swift.String? = nil,
            street3: Swift.String? = nil,
            type: SnowballClientTypes.AddressType? = nil
        )
        {
            self.addressId = addressId
            self.city = city
            self.company = company
            self.country = country
            self.isRestricted = isRestricted
            self.landmark = landmark
            self.name = name
            self.phoneNumber = phoneNumber
            self.postalCode = postalCode
            self.prefectureOrDistrict = prefectureOrDistrict
            self.stateOrProvince = stateOrProvince
            self.street1 = street1
            self.street2 = street2
            self.street3 = street3
            self.type = type
        }
    }

}

extension SnowballClientTypes {
    public enum AddressType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsShip
        case custPickup
        case sdkUnknown(Swift.String)

        public static var allCases: [AddressType] {
            return [
                .awsShip,
                .custPickup,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsShip: return "AWS_SHIP"
            case .custPickup: return "CUST_PICKUP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AddressType(rawValue: rawValue) ?? AddressType.sdkUnknown(rawValue)
        }
    }
}

extension CancelClusterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterId = "ClusterId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterId = self.clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
    }
}

extension CancelClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CancelClusterInput: Swift.Equatable {
    /// The 39-character ID for the cluster that you want to cancel, for example CID123e4567-e89b-12d3-a456-426655440000.
    /// This member is required.
    public var clusterId: Swift.String?

    public init(
        clusterId: Swift.String? = nil
    )
    {
        self.clusterId = clusterId
    }
}

struct CancelClusterInputBody: Swift.Equatable {
    let clusterId: Swift.String?
}

extension CancelClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterId = "ClusterId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
    }
}

extension CancelClusterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CancelClusterOutput: Swift.Equatable {

    public init() { }
}

enum CancelClusterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidJobStateException": return try await InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceException": return try await InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSRequestFailedException": return try await KMSRequestFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CancelJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension CancelJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CancelJobInput: Swift.Equatable {
    /// The 39-character job ID for the job that you want to cancel, for example JID123e4567-e89b-12d3-a456-426655440000.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct CancelJobInputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension CancelJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension CancelJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CancelJobOutput: Swift.Equatable {

    public init() { }
}

enum CancelJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidJobStateException": return try await InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceException": return try await InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSRequestFailedException": return try await KMSRequestFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ClusterLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ClusterLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Job creation failed. Currently, clusters support five nodes. If you have fewer than five nodes for your cluster and you have more nodes to create for this cluster, try again and create jobs until your cluster has exactly five nodes.
public struct ClusterLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ClusterLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ClusterLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ClusterLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnowballClientTypes.ClusterListEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterId = "ClusterId"
        case clusterState = "ClusterState"
        case creationDate = "CreationDate"
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterId = self.clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let clusterState = self.clusterState {
            try encodeContainer.encode(clusterState.rawValue, forKey: .clusterState)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let clusterStateDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ClusterState.self, forKey: .clusterState)
        clusterState = clusterStateDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension SnowballClientTypes {
    /// Contains a cluster's state, a cluster's ID, and other important information.
    public struct ClusterListEntry: Swift.Equatable {
        /// The 39-character ID for the cluster that you want to list, for example CID123e4567-e89b-12d3-a456-426655440000.
        public var clusterId: Swift.String?
        /// The current state of this cluster. For information about the state of a specific node, see [JobListEntry$JobState].
        public var clusterState: SnowballClientTypes.ClusterState?
        /// The creation date for this cluster.
        public var creationDate: ClientRuntime.Date?
        /// Defines an optional description of the cluster, for example Environmental Data Cluster-01.
        public var description: Swift.String?

        public init(
            clusterId: Swift.String? = nil,
            clusterState: SnowballClientTypes.ClusterState? = nil,
            creationDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil
        )
        {
            self.clusterId = clusterId
            self.clusterState = clusterState
            self.creationDate = creationDate
            self.description = description
        }
    }

}

extension SnowballClientTypes.ClusterMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
        case clusterId = "ClusterId"
        case clusterState = "ClusterState"
        case creationDate = "CreationDate"
        case description = "Description"
        case forwardingAddressId = "ForwardingAddressId"
        case jobType = "JobType"
        case kmsKeyARN = "KmsKeyARN"
        case notification = "Notification"
        case onDeviceServiceConfiguration = "OnDeviceServiceConfiguration"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingOption = "ShippingOption"
        case snowballType = "SnowballType"
        case taxDocuments = "TaxDocuments"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressId = self.addressId {
            try encodeContainer.encode(addressId, forKey: .addressId)
        }
        if let clusterId = self.clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let clusterState = self.clusterState {
            try encodeContainer.encode(clusterState.rawValue, forKey: .clusterState)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let forwardingAddressId = self.forwardingAddressId {
            try encodeContainer.encode(forwardingAddressId, forKey: .forwardingAddressId)
        }
        if let jobType = self.jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
        if let kmsKeyARN = self.kmsKeyARN {
            try encodeContainer.encode(kmsKeyARN, forKey: .kmsKeyARN)
        }
        if let notification = self.notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let onDeviceServiceConfiguration = self.onDeviceServiceConfiguration {
            try encodeContainer.encode(onDeviceServiceConfiguration, forKey: .onDeviceServiceConfiguration)
        }
        if let resources = self.resources {
            try encodeContainer.encode(resources, forKey: .resources)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
        if let shippingOption = self.shippingOption {
            try encodeContainer.encode(shippingOption.rawValue, forKey: .shippingOption)
        }
        if let snowballType = self.snowballType {
            try encodeContainer.encode(snowballType.rawValue, forKey: .snowballType)
        }
        if let taxDocuments = self.taxDocuments {
            try encodeContainer.encode(taxDocuments, forKey: .taxDocuments)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let kmsKeyARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyARN)
        kmsKeyARN = kmsKeyARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        let clusterStateDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ClusterState.self, forKey: .clusterState)
        clusterState = clusterStateDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let snowballTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.SnowballType.self, forKey: .snowballType)
        snowballType = snowballTypeDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let resourcesDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobResource.self, forKey: .resources)
        resources = resourcesDecoded
        let addressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressId)
        addressId = addressIdDecoded
        let shippingOptionDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ShippingOption.self, forKey: .shippingOption)
        shippingOption = shippingOptionDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
        let forwardingAddressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forwardingAddressId)
        forwardingAddressId = forwardingAddressIdDecoded
        let taxDocumentsDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.TaxDocuments.self, forKey: .taxDocuments)
        taxDocuments = taxDocumentsDecoded
        let onDeviceServiceConfigurationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.OnDeviceServiceConfiguration.self, forKey: .onDeviceServiceConfiguration)
        onDeviceServiceConfiguration = onDeviceServiceConfigurationDecoded
    }
}

extension SnowballClientTypes {
    /// Contains metadata about a specific cluster.
    public struct ClusterMetadata: Swift.Equatable {
        /// The automatically generated ID for a specific address.
        public var addressId: Swift.String?
        /// The automatically generated ID for a cluster.
        public var clusterId: Swift.String?
        /// The current status of the cluster.
        public var clusterState: SnowballClientTypes.ClusterState?
        /// The creation date for this cluster.
        public var creationDate: ClientRuntime.Date?
        /// The optional description of the cluster.
        public var description: Swift.String?
        /// The ID of the address that you want a cluster shipped to, after it will be shipped to its primary address. This field is not supported in most regions.
        public var forwardingAddressId: Swift.String?
        /// The type of job for this cluster. Currently, the only job type supported for clusters is LOCAL_USE.
        public var jobType: SnowballClientTypes.JobType?
        /// The KmsKeyARN Amazon Resource Name (ARN) associated with this cluster. This ARN was created using the [CreateKey](https://docs.aws.amazon.com/kms/latest/APIReference/API_CreateKey.html) API action in Key Management Service (KMS.
        public var kmsKeyARN: Swift.String?
        /// The Amazon Simple Notification Service (Amazon SNS) notification settings for this cluster.
        public var notification: SnowballClientTypes.Notification?
        /// Represents metadata and configuration settings for services on an Amazon Web Services Snow Family device.
        public var onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration?
        /// The arrays of [JobResource] objects that can include updated [S3Resource] objects or [LambdaResource] objects.
        public var resources: SnowballClientTypes.JobResource?
        /// The role ARN associated with this cluster. This ARN was created using the [CreateRole](https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html) API action in Identity and Access Management (IAM).
        public var roleARN: Swift.String?
        /// The shipping speed for each node in this cluster. This speed doesn't dictate how soon you'll get each device, rather it represents how quickly each device moves to its destination while in transit. Regional shipping speeds are as follows:
        ///
        /// * In Australia, you have access to express shipping. Typically, devices shipped express are delivered in about a day.
        ///
        /// * In the European Union (EU), you have access to express shipping. Typically, Snow devices shipped express are delivered in about a day. In addition, most countries in the EU have access to standard shipping, which typically takes less than a week, one way.
        ///
        /// * In India, Snow devices are delivered in one to seven days.
        ///
        /// * In the US, you have access to one-day shipping and two-day shipping.
        public var shippingOption: SnowballClientTypes.ShippingOption?
        /// The type of Snowcone device to use for this cluster. For cluster jobs, Amazon Web Services Snow Family currently supports only the EDGE device type.
        public var snowballType: SnowballClientTypes.SnowballType?
        /// The tax documents required in your Amazon Web Services Region.
        public var taxDocuments: SnowballClientTypes.TaxDocuments?

        public init(
            addressId: Swift.String? = nil,
            clusterId: Swift.String? = nil,
            clusterState: SnowballClientTypes.ClusterState? = nil,
            creationDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            forwardingAddressId: Swift.String? = nil,
            jobType: SnowballClientTypes.JobType? = nil,
            kmsKeyARN: Swift.String? = nil,
            notification: SnowballClientTypes.Notification? = nil,
            onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration? = nil,
            resources: SnowballClientTypes.JobResource? = nil,
            roleARN: Swift.String? = nil,
            shippingOption: SnowballClientTypes.ShippingOption? = nil,
            snowballType: SnowballClientTypes.SnowballType? = nil,
            taxDocuments: SnowballClientTypes.TaxDocuments? = nil
        )
        {
            self.addressId = addressId
            self.clusterId = clusterId
            self.clusterState = clusterState
            self.creationDate = creationDate
            self.description = description
            self.forwardingAddressId = forwardingAddressId
            self.jobType = jobType
            self.kmsKeyARN = kmsKeyARN
            self.notification = notification
            self.onDeviceServiceConfiguration = onDeviceServiceConfiguration
            self.resources = resources
            self.roleARN = roleARN
            self.shippingOption = shippingOption
            self.snowballType = snowballType
            self.taxDocuments = taxDocuments
        }
    }

}

extension SnowballClientTypes {
    public enum ClusterState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awaitingQuorum
        case cancelled
        case complete
        case inUse
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ClusterState] {
            return [
                .awaitingQuorum,
                .cancelled,
                .complete,
                .inUse,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awaitingQuorum: return "AwaitingQuorum"
            case .cancelled: return "Cancelled"
            case .complete: return "Complete"
            case .inUse: return "InUse"
            case .pending: return "Pending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ClusterState(rawValue: rawValue) ?? ClusterState.sdkUnknown(rawValue)
        }
    }
}

extension SnowballClientTypes.CompatibleImage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amiId = "AmiId"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amiId = self.amiId {
            try encodeContainer.encode(amiId, forKey: .amiId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amiId)
        amiId = amiIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension SnowballClientTypes {
    /// A JSON-formatted object that describes a compatible Amazon Machine Image (AMI), including the ID and name for a Snow device AMI. This AMI is compatible with the device's physical hardware requirements, and it should be able to be run in an SBE1 instance on the device.
    public struct CompatibleImage: Swift.Equatable {
        /// The unique identifier for an individual Snow device AMI.
        public var amiId: Swift.String?
        /// The optional name of a compatible image.
        public var name: Swift.String?

        public init(
            amiId: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.amiId = amiId
            self.name = name
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.conflictResource = output.conflictResource
            self.properties.message = output.message
        } else {
            self.properties.conflictResource = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You get this exception when you call CreateReturnShippingLabel more than once when other requests are not completed.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// You get this resource when you call CreateReturnShippingLabel more than once when other requests are not completed. .
        public internal(set) var conflictResource: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        conflictResource: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.conflictResource = conflictResource
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let conflictResource: Swift.String?
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conflictResource = "ConflictResource"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conflictResourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conflictResource)
        conflictResource = conflictResourceDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateAddressInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = self.address {
            try encodeContainer.encode(address, forKey: .address)
        }
    }
}

extension CreateAddressInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAddressInput: Swift.Equatable {
    /// The address that you want the Snow device shipped to.
    /// This member is required.
    public var address: SnowballClientTypes.Address?

    public init(
        address: SnowballClientTypes.Address? = nil
    )
    {
        self.address = address
    }
}

struct CreateAddressInputBody: Swift.Equatable {
    let address: SnowballClientTypes.Address?
}

extension CreateAddressInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.Address.self, forKey: .address)
        address = addressDecoded
    }
}

extension CreateAddressOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAddressOutputBody = try responseDecoder.decode(responseBody: data)
            self.addressId = output.addressId
        } else {
            self.addressId = nil
        }
    }
}

public struct CreateAddressOutput: Swift.Equatable {
    /// The automatically generated ID for a specific address. You'll use this ID when you create a job to specify which address you want the Snow device for that job shipped to.
    public var addressId: Swift.String?

    public init(
        addressId: Swift.String? = nil
    )
    {
        self.addressId = addressId
    }
}

struct CreateAddressOutputBody: Swift.Equatable {
    let addressId: Swift.String?
}

extension CreateAddressOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressId)
        addressId = addressIdDecoded
    }
}

enum CreateAddressOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidAddressException": return try await InvalidAddressException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedAddressException": return try await UnsupportedAddressException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateClusterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
        case description = "Description"
        case forceCreateJobs = "ForceCreateJobs"
        case forwardingAddressId = "ForwardingAddressId"
        case initialClusterSize = "InitialClusterSize"
        case jobType = "JobType"
        case kmsKeyARN = "KmsKeyARN"
        case longTermPricingIds = "LongTermPricingIds"
        case notification = "Notification"
        case onDeviceServiceConfiguration = "OnDeviceServiceConfiguration"
        case remoteManagement = "RemoteManagement"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingOption = "ShippingOption"
        case snowballCapacityPreference = "SnowballCapacityPreference"
        case snowballType = "SnowballType"
        case taxDocuments = "TaxDocuments"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressId = self.addressId {
            try encodeContainer.encode(addressId, forKey: .addressId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let forceCreateJobs = self.forceCreateJobs {
            try encodeContainer.encode(forceCreateJobs, forKey: .forceCreateJobs)
        }
        if let forwardingAddressId = self.forwardingAddressId {
            try encodeContainer.encode(forwardingAddressId, forKey: .forwardingAddressId)
        }
        if let initialClusterSize = self.initialClusterSize {
            try encodeContainer.encode(initialClusterSize, forKey: .initialClusterSize)
        }
        if let jobType = self.jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
        if let kmsKeyARN = self.kmsKeyARN {
            try encodeContainer.encode(kmsKeyARN, forKey: .kmsKeyARN)
        }
        if let longTermPricingIds = longTermPricingIds {
            var longTermPricingIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .longTermPricingIds)
            for longtermpricingid0 in longTermPricingIds {
                try longTermPricingIdsContainer.encode(longtermpricingid0)
            }
        }
        if let notification = self.notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let onDeviceServiceConfiguration = self.onDeviceServiceConfiguration {
            try encodeContainer.encode(onDeviceServiceConfiguration, forKey: .onDeviceServiceConfiguration)
        }
        if let remoteManagement = self.remoteManagement {
            try encodeContainer.encode(remoteManagement.rawValue, forKey: .remoteManagement)
        }
        if let resources = self.resources {
            try encodeContainer.encode(resources, forKey: .resources)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
        if let shippingOption = self.shippingOption {
            try encodeContainer.encode(shippingOption.rawValue, forKey: .shippingOption)
        }
        if let snowballCapacityPreference = self.snowballCapacityPreference {
            try encodeContainer.encode(snowballCapacityPreference.rawValue, forKey: .snowballCapacityPreference)
        }
        if let snowballType = self.snowballType {
            try encodeContainer.encode(snowballType.rawValue, forKey: .snowballType)
        }
        if let taxDocuments = self.taxDocuments {
            try encodeContainer.encode(taxDocuments, forKey: .taxDocuments)
        }
    }
}

extension CreateClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateClusterInput: Swift.Equatable {
    /// The ID for the address that you want the cluster shipped to.
    /// This member is required.
    public var addressId: Swift.String?
    /// An optional description of this specific cluster, for example Environmental Data Cluster-01.
    public var description: Swift.String?
    /// Force to create cluster when user attempts to overprovision or underprovision a cluster. A cluster is overprovisioned or underprovisioned if the initial size of the cluster is more (overprovisioned) or less (underprovisioned) than what needed to meet capacity requirement specified with OnDeviceServiceConfiguration.
    public var forceCreateJobs: Swift.Bool?
    /// The forwarding address ID for a cluster. This field is not supported in most regions.
    public var forwardingAddressId: Swift.String?
    /// If provided, each job will be automatically created and associated with the new cluster. If not provided, will be treated as 0.
    public var initialClusterSize: Swift.Int?
    /// The type of job for this cluster. Currently, the only job type supported for clusters is LOCAL_USE. For more information, see "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide or "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide.
    /// This member is required.
    public var jobType: SnowballClientTypes.JobType?
    /// The KmsKeyARN value that you want to associate with this cluster. KmsKeyARN values are created by using the [CreateKey](https://docs.aws.amazon.com/kms/latest/APIReference/API_CreateKey.html) API action in Key Management Service (KMS).
    public var kmsKeyARN: Swift.String?
    /// Lists long-term pricing id that will be used to associate with jobs automatically created for the new cluster.
    public var longTermPricingIds: [Swift.String]?
    /// The Amazon Simple Notification Service (Amazon SNS) notification settings for this cluster.
    public var notification: SnowballClientTypes.Notification?
    /// Specifies the service or services on the Snow Family device that your transferred data will be exported from or imported into. Amazon Web Services Snow Family device clusters support Amazon S3 and NFS (Network File System).
    public var onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration?
    /// Allows you to securely operate and manage Snow devices in a cluster remotely from outside of your internal network. When set to INSTALLED_AUTOSTART, remote management will automatically be available when the device arrives at your location. Otherwise, you need to use the Snowball Client to manage the device.
    public var remoteManagement: SnowballClientTypes.RemoteManagement?
    /// The resources associated with the cluster job. These resources include Amazon S3 buckets and optional Lambda functions written in the Python language.
    public var resources: SnowballClientTypes.JobResource?
    /// The RoleARN that you want to associate with this cluster. RoleArn values are created by using the [CreateRole](https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html) API action in Identity and Access Management (IAM).
    public var roleARN: Swift.String?
    /// The shipping speed for each node in this cluster. This speed doesn't dictate how soon you'll get each Snowball Edge device, rather it represents how quickly each device moves to its destination while in transit. Regional shipping speeds are as follows:
    ///
    /// * In Australia, you have access to express shipping. Typically, Snow devices shipped express are delivered in about a day.
    ///
    /// * In the European Union (EU), you have access to express shipping. Typically, Snow devices shipped express are delivered in about a day. In addition, most countries in the EU have access to standard shipping, which typically takes less than a week, one way.
    ///
    /// * In India, Snow devices are delivered in one to seven days.
    ///
    /// * In the United States of America (US), you have access to one-day shipping and two-day shipping.
    ///
    ///
    ///
    ///
    /// * In Australia, you have access to express shipping. Typically, devices shipped express are delivered in about a day.
    ///
    /// * In the European Union (EU), you have access to express shipping. Typically, Snow devices shipped express are delivered in about a day. In addition, most countries in the EU have access to standard shipping, which typically takes less than a week, one way.
    ///
    /// * In India, Snow devices are delivered in one to seven days.
    ///
    /// * In the US, you have access to one-day shipping and two-day shipping.
    /// This member is required.
    public var shippingOption: SnowballClientTypes.ShippingOption?
    /// If your job is being created in one of the US regions, you have the option of specifying what size Snow device you'd like for this job. In all other regions, Snowballs come with 80 TB in storage capacity. For more information, see "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide or "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide.
    public var snowballCapacityPreference: SnowballClientTypes.SnowballCapacity?
    /// The type of Snow Family devices to use for this cluster. For cluster jobs, Amazon Web Services Snow Family currently supports only the EDGE device type. For more information, see "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide or "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide.
    /// This member is required.
    public var snowballType: SnowballClientTypes.SnowballType?
    /// The tax documents required in your Amazon Web Services Region.
    public var taxDocuments: SnowballClientTypes.TaxDocuments?

    public init(
        addressId: Swift.String? = nil,
        description: Swift.String? = nil,
        forceCreateJobs: Swift.Bool? = nil,
        forwardingAddressId: Swift.String? = nil,
        initialClusterSize: Swift.Int? = nil,
        jobType: SnowballClientTypes.JobType? = nil,
        kmsKeyARN: Swift.String? = nil,
        longTermPricingIds: [Swift.String]? = nil,
        notification: SnowballClientTypes.Notification? = nil,
        onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration? = nil,
        remoteManagement: SnowballClientTypes.RemoteManagement? = nil,
        resources: SnowballClientTypes.JobResource? = nil,
        roleARN: Swift.String? = nil,
        shippingOption: SnowballClientTypes.ShippingOption? = nil,
        snowballCapacityPreference: SnowballClientTypes.SnowballCapacity? = nil,
        snowballType: SnowballClientTypes.SnowballType? = nil,
        taxDocuments: SnowballClientTypes.TaxDocuments? = nil
    )
    {
        self.addressId = addressId
        self.description = description
        self.forceCreateJobs = forceCreateJobs
        self.forwardingAddressId = forwardingAddressId
        self.initialClusterSize = initialClusterSize
        self.jobType = jobType
        self.kmsKeyARN = kmsKeyARN
        self.longTermPricingIds = longTermPricingIds
        self.notification = notification
        self.onDeviceServiceConfiguration = onDeviceServiceConfiguration
        self.remoteManagement = remoteManagement
        self.resources = resources
        self.roleARN = roleARN
        self.shippingOption = shippingOption
        self.snowballCapacityPreference = snowballCapacityPreference
        self.snowballType = snowballType
        self.taxDocuments = taxDocuments
    }
}

struct CreateClusterInputBody: Swift.Equatable {
    let jobType: SnowballClientTypes.JobType?
    let resources: SnowballClientTypes.JobResource?
    let onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration?
    let description: Swift.String?
    let addressId: Swift.String?
    let kmsKeyARN: Swift.String?
    let roleARN: Swift.String?
    let snowballType: SnowballClientTypes.SnowballType?
    let shippingOption: SnowballClientTypes.ShippingOption?
    let notification: SnowballClientTypes.Notification?
    let forwardingAddressId: Swift.String?
    let taxDocuments: SnowballClientTypes.TaxDocuments?
    let remoteManagement: SnowballClientTypes.RemoteManagement?
    let initialClusterSize: Swift.Int?
    let forceCreateJobs: Swift.Bool?
    let longTermPricingIds: [Swift.String]?
    let snowballCapacityPreference: SnowballClientTypes.SnowballCapacity?
}

extension CreateClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
        case description = "Description"
        case forceCreateJobs = "ForceCreateJobs"
        case forwardingAddressId = "ForwardingAddressId"
        case initialClusterSize = "InitialClusterSize"
        case jobType = "JobType"
        case kmsKeyARN = "KmsKeyARN"
        case longTermPricingIds = "LongTermPricingIds"
        case notification = "Notification"
        case onDeviceServiceConfiguration = "OnDeviceServiceConfiguration"
        case remoteManagement = "RemoteManagement"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingOption = "ShippingOption"
        case snowballCapacityPreference = "SnowballCapacityPreference"
        case snowballType = "SnowballType"
        case taxDocuments = "TaxDocuments"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let resourcesDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobResource.self, forKey: .resources)
        resources = resourcesDecoded
        let onDeviceServiceConfigurationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.OnDeviceServiceConfiguration.self, forKey: .onDeviceServiceConfiguration)
        onDeviceServiceConfiguration = onDeviceServiceConfigurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let addressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressId)
        addressId = addressIdDecoded
        let kmsKeyARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyARN)
        kmsKeyARN = kmsKeyARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        let snowballTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.SnowballType.self, forKey: .snowballType)
        snowballType = snowballTypeDecoded
        let shippingOptionDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ShippingOption.self, forKey: .shippingOption)
        shippingOption = shippingOptionDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
        let forwardingAddressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forwardingAddressId)
        forwardingAddressId = forwardingAddressIdDecoded
        let taxDocumentsDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.TaxDocuments.self, forKey: .taxDocuments)
        taxDocuments = taxDocumentsDecoded
        let remoteManagementDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.RemoteManagement.self, forKey: .remoteManagement)
        remoteManagement = remoteManagementDecoded
        let initialClusterSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .initialClusterSize)
        initialClusterSize = initialClusterSizeDecoded
        let forceCreateJobsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceCreateJobs)
        forceCreateJobs = forceCreateJobsDecoded
        let longTermPricingIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .longTermPricingIds)
        var longTermPricingIdsDecoded0:[Swift.String]? = nil
        if let longTermPricingIdsContainer = longTermPricingIdsContainer {
            longTermPricingIdsDecoded0 = [Swift.String]()
            for string0 in longTermPricingIdsContainer {
                if let string0 = string0 {
                    longTermPricingIdsDecoded0?.append(string0)
                }
            }
        }
        longTermPricingIds = longTermPricingIdsDecoded0
        let snowballCapacityPreferenceDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.SnowballCapacity.self, forKey: .snowballCapacityPreference)
        snowballCapacityPreference = snowballCapacityPreferenceDecoded
    }
}

extension CreateClusterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateClusterOutputBody = try responseDecoder.decode(responseBody: data)
            self.clusterId = output.clusterId
            self.jobListEntries = output.jobListEntries
        } else {
            self.clusterId = nil
            self.jobListEntries = nil
        }
    }
}

public struct CreateClusterOutput: Swift.Equatable {
    /// The automatically generated ID for a cluster.
    public var clusterId: Swift.String?
    /// List of jobs created for this cluster. For syntax, see [ListJobsResult$JobListEntries](http://amazonaws.com/snowball/latest/api-reference/API_ListJobs.html#API_ListJobs_ResponseSyntax) in this guide.
    public var jobListEntries: [SnowballClientTypes.JobListEntry]?

    public init(
        clusterId: Swift.String? = nil,
        jobListEntries: [SnowballClientTypes.JobListEntry]? = nil
    )
    {
        self.clusterId = clusterId
        self.jobListEntries = jobListEntries
    }
}

struct CreateClusterOutputBody: Swift.Equatable {
    let clusterId: Swift.String?
    let jobListEntries: [SnowballClientTypes.JobListEntry]?
}

extension CreateClusterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterId = "ClusterId"
        case jobListEntries = "JobListEntries"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let jobListEntriesContainer = try containerValues.decodeIfPresent([SnowballClientTypes.JobListEntry?].self, forKey: .jobListEntries)
        var jobListEntriesDecoded0:[SnowballClientTypes.JobListEntry]? = nil
        if let jobListEntriesContainer = jobListEntriesContainer {
            jobListEntriesDecoded0 = [SnowballClientTypes.JobListEntry]()
            for structure0 in jobListEntriesContainer {
                if let structure0 = structure0 {
                    jobListEntriesDecoded0?.append(structure0)
                }
            }
        }
        jobListEntries = jobListEntriesDecoded0
    }
}

enum CreateClusterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "Ec2RequestFailedException": return try await Ec2RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputCombinationException": return try await InvalidInputCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceException": return try await InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSRequestFailedException": return try await KMSRequestFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
        case clusterId = "ClusterId"
        case description = "Description"
        case deviceConfiguration = "DeviceConfiguration"
        case forwardingAddressId = "ForwardingAddressId"
        case impactLevel = "ImpactLevel"
        case jobType = "JobType"
        case kmsKeyARN = "KmsKeyARN"
        case longTermPricingId = "LongTermPricingId"
        case notification = "Notification"
        case onDeviceServiceConfiguration = "OnDeviceServiceConfiguration"
        case pickupDetails = "PickupDetails"
        case remoteManagement = "RemoteManagement"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingOption = "ShippingOption"
        case snowballCapacityPreference = "SnowballCapacityPreference"
        case snowballType = "SnowballType"
        case taxDocuments = "TaxDocuments"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressId = self.addressId {
            try encodeContainer.encode(addressId, forKey: .addressId)
        }
        if let clusterId = self.clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceConfiguration = self.deviceConfiguration {
            try encodeContainer.encode(deviceConfiguration, forKey: .deviceConfiguration)
        }
        if let forwardingAddressId = self.forwardingAddressId {
            try encodeContainer.encode(forwardingAddressId, forKey: .forwardingAddressId)
        }
        if let impactLevel = self.impactLevel {
            try encodeContainer.encode(impactLevel.rawValue, forKey: .impactLevel)
        }
        if let jobType = self.jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
        if let kmsKeyARN = self.kmsKeyARN {
            try encodeContainer.encode(kmsKeyARN, forKey: .kmsKeyARN)
        }
        if let longTermPricingId = self.longTermPricingId {
            try encodeContainer.encode(longTermPricingId, forKey: .longTermPricingId)
        }
        if let notification = self.notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let onDeviceServiceConfiguration = self.onDeviceServiceConfiguration {
            try encodeContainer.encode(onDeviceServiceConfiguration, forKey: .onDeviceServiceConfiguration)
        }
        if let pickupDetails = self.pickupDetails {
            try encodeContainer.encode(pickupDetails, forKey: .pickupDetails)
        }
        if let remoteManagement = self.remoteManagement {
            try encodeContainer.encode(remoteManagement.rawValue, forKey: .remoteManagement)
        }
        if let resources = self.resources {
            try encodeContainer.encode(resources, forKey: .resources)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
        if let shippingOption = self.shippingOption {
            try encodeContainer.encode(shippingOption.rawValue, forKey: .shippingOption)
        }
        if let snowballCapacityPreference = self.snowballCapacityPreference {
            try encodeContainer.encode(snowballCapacityPreference.rawValue, forKey: .snowballCapacityPreference)
        }
        if let snowballType = self.snowballType {
            try encodeContainer.encode(snowballType.rawValue, forKey: .snowballType)
        }
        if let taxDocuments = self.taxDocuments {
            try encodeContainer.encode(taxDocuments, forKey: .taxDocuments)
        }
    }
}

extension CreateJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateJobInput: Swift.Equatable {
    /// The ID for the address that you want the Snow device shipped to.
    public var addressId: Swift.String?
    /// The ID of a cluster. If you're creating a job for a node in a cluster, you need to provide only this clusterId value. The other job attributes are inherited from the cluster.
    public var clusterId: Swift.String?
    /// Defines an optional description of this specific job, for example Important Photos 2016-08-11.
    public var description: Swift.String?
    /// Defines the device configuration for an Snowcone job. For more information, see "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide or "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide.
    public var deviceConfiguration: SnowballClientTypes.DeviceConfiguration?
    /// The forwarding address ID for a job. This field is not supported in most Regions.
    public var forwardingAddressId: Swift.String?
    /// The highest impact level of data that will be stored or processed on the device, provided at job creation.
    public var impactLevel: SnowballClientTypes.ImpactLevel?
    /// Defines the type of job that you're creating.
    public var jobType: SnowballClientTypes.JobType?
    /// The KmsKeyARN that you want to associate with this job. KmsKeyARNs are created using the [CreateKey](https://docs.aws.amazon.com/kms/latest/APIReference/API_CreateKey.html) Key Management Service (KMS) API action.
    public var kmsKeyARN: Swift.String?
    /// The ID of the long-term pricing type for the device.
    public var longTermPricingId: Swift.String?
    /// Defines the Amazon Simple Notification Service (Amazon SNS) notification settings for this job.
    public var notification: SnowballClientTypes.Notification?
    /// Specifies the service or services on the Snow Family device that your transferred data will be exported from or imported into. Amazon Web Services Snow Family supports Amazon S3 and NFS (Network File System) and the Amazon Web Services Storage Gateway service Tape Gateway type.
    public var onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration?
    /// Information identifying the person picking up the device.
    public var pickupDetails: SnowballClientTypes.PickupDetails?
    /// Allows you to securely operate and manage Snowcone devices remotely from outside of your internal network. When set to INSTALLED_AUTOSTART, remote management will automatically be available when the device arrives at your location. Otherwise, you need to use the Snowball Edge client to manage the device. When set to NOT_INSTALLED, remote management will not be available on the device.
    public var remoteManagement: SnowballClientTypes.RemoteManagement?
    /// Defines the Amazon S3 buckets associated with this job. With IMPORT jobs, you specify the bucket or buckets that your transferred data will be imported into. With EXPORT jobs, you specify the bucket or buckets that your transferred data will be exported from. Optionally, you can also specify a KeyRange value. If you choose to export a range, you define the length of the range by providing either an inclusive BeginMarker value, an inclusive EndMarker value, or both. Ranges are UTF-8 binary sorted.
    public var resources: SnowballClientTypes.JobResource?
    /// The RoleARN that you want to associate with this job. RoleArns are created using the [CreateRole](https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html) Identity and Access Management (IAM) API action.
    public var roleARN: Swift.String?
    /// The shipping speed for this job. This speed doesn't dictate how soon you'll get the Snow device, rather it represents how quickly the Snow device moves to its destination while in transit. Regional shipping speeds are as follows:
    ///
    /// * In Australia, you have access to express shipping. Typically, Snow devices shipped express are delivered in about a day.
    ///
    /// * In the European Union (EU), you have access to express shipping. Typically, Snow devices shipped express are delivered in about a day. In addition, most countries in the EU have access to standard shipping, which typically takes less than a week, one way.
    ///
    /// * In India, Snow devices are delivered in one to seven days.
    ///
    /// * In the US, you have access to one-day shipping and two-day shipping.
    public var shippingOption: SnowballClientTypes.ShippingOption?
    /// If your job is being created in one of the US regions, you have the option of specifying what size Snow device you'd like for this job. In all other regions, Snowballs come with 80 TB in storage capacity. For more information, see "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide or "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide.
    public var snowballCapacityPreference: SnowballClientTypes.SnowballCapacity?
    /// The type of Snow Family devices to use for this job. For cluster jobs, Amazon Web Services Snow Family currently supports only the EDGE device type. The type of Amazon Web Services Snow device to use for this job. Currently, the only supported device type for cluster jobs is EDGE. For more information, see [Snowball Edge Device Options](https://docs.aws.amazon.com/snowball/latest/developer-guide/device-differences.html) in the Snowball Edge Developer Guide. For more information, see "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide or "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide.
    public var snowballType: SnowballClientTypes.SnowballType?
    /// The tax documents required in your Amazon Web Services Region.
    public var taxDocuments: SnowballClientTypes.TaxDocuments?

    public init(
        addressId: Swift.String? = nil,
        clusterId: Swift.String? = nil,
        description: Swift.String? = nil,
        deviceConfiguration: SnowballClientTypes.DeviceConfiguration? = nil,
        forwardingAddressId: Swift.String? = nil,
        impactLevel: SnowballClientTypes.ImpactLevel? = nil,
        jobType: SnowballClientTypes.JobType? = nil,
        kmsKeyARN: Swift.String? = nil,
        longTermPricingId: Swift.String? = nil,
        notification: SnowballClientTypes.Notification? = nil,
        onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration? = nil,
        pickupDetails: SnowballClientTypes.PickupDetails? = nil,
        remoteManagement: SnowballClientTypes.RemoteManagement? = nil,
        resources: SnowballClientTypes.JobResource? = nil,
        roleARN: Swift.String? = nil,
        shippingOption: SnowballClientTypes.ShippingOption? = nil,
        snowballCapacityPreference: SnowballClientTypes.SnowballCapacity? = nil,
        snowballType: SnowballClientTypes.SnowballType? = nil,
        taxDocuments: SnowballClientTypes.TaxDocuments? = nil
    )
    {
        self.addressId = addressId
        self.clusterId = clusterId
        self.description = description
        self.deviceConfiguration = deviceConfiguration
        self.forwardingAddressId = forwardingAddressId
        self.impactLevel = impactLevel
        self.jobType = jobType
        self.kmsKeyARN = kmsKeyARN
        self.longTermPricingId = longTermPricingId
        self.notification = notification
        self.onDeviceServiceConfiguration = onDeviceServiceConfiguration
        self.pickupDetails = pickupDetails
        self.remoteManagement = remoteManagement
        self.resources = resources
        self.roleARN = roleARN
        self.shippingOption = shippingOption
        self.snowballCapacityPreference = snowballCapacityPreference
        self.snowballType = snowballType
        self.taxDocuments = taxDocuments
    }
}

struct CreateJobInputBody: Swift.Equatable {
    let jobType: SnowballClientTypes.JobType?
    let resources: SnowballClientTypes.JobResource?
    let onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration?
    let description: Swift.String?
    let addressId: Swift.String?
    let kmsKeyARN: Swift.String?
    let roleARN: Swift.String?
    let snowballCapacityPreference: SnowballClientTypes.SnowballCapacity?
    let shippingOption: SnowballClientTypes.ShippingOption?
    let notification: SnowballClientTypes.Notification?
    let clusterId: Swift.String?
    let snowballType: SnowballClientTypes.SnowballType?
    let forwardingAddressId: Swift.String?
    let taxDocuments: SnowballClientTypes.TaxDocuments?
    let deviceConfiguration: SnowballClientTypes.DeviceConfiguration?
    let remoteManagement: SnowballClientTypes.RemoteManagement?
    let longTermPricingId: Swift.String?
    let impactLevel: SnowballClientTypes.ImpactLevel?
    let pickupDetails: SnowballClientTypes.PickupDetails?
}

extension CreateJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
        case clusterId = "ClusterId"
        case description = "Description"
        case deviceConfiguration = "DeviceConfiguration"
        case forwardingAddressId = "ForwardingAddressId"
        case impactLevel = "ImpactLevel"
        case jobType = "JobType"
        case kmsKeyARN = "KmsKeyARN"
        case longTermPricingId = "LongTermPricingId"
        case notification = "Notification"
        case onDeviceServiceConfiguration = "OnDeviceServiceConfiguration"
        case pickupDetails = "PickupDetails"
        case remoteManagement = "RemoteManagement"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingOption = "ShippingOption"
        case snowballCapacityPreference = "SnowballCapacityPreference"
        case snowballType = "SnowballType"
        case taxDocuments = "TaxDocuments"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let resourcesDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobResource.self, forKey: .resources)
        resources = resourcesDecoded
        let onDeviceServiceConfigurationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.OnDeviceServiceConfiguration.self, forKey: .onDeviceServiceConfiguration)
        onDeviceServiceConfiguration = onDeviceServiceConfigurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let addressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressId)
        addressId = addressIdDecoded
        let kmsKeyARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyARN)
        kmsKeyARN = kmsKeyARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        let snowballCapacityPreferenceDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.SnowballCapacity.self, forKey: .snowballCapacityPreference)
        snowballCapacityPreference = snowballCapacityPreferenceDecoded
        let shippingOptionDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ShippingOption.self, forKey: .shippingOption)
        shippingOption = shippingOptionDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let snowballTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.SnowballType.self, forKey: .snowballType)
        snowballType = snowballTypeDecoded
        let forwardingAddressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forwardingAddressId)
        forwardingAddressId = forwardingAddressIdDecoded
        let taxDocumentsDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.TaxDocuments.self, forKey: .taxDocuments)
        taxDocuments = taxDocumentsDecoded
        let deviceConfigurationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.DeviceConfiguration.self, forKey: .deviceConfiguration)
        deviceConfiguration = deviceConfigurationDecoded
        let remoteManagementDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.RemoteManagement.self, forKey: .remoteManagement)
        remoteManagement = remoteManagementDecoded
        let longTermPricingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .longTermPricingId)
        longTermPricingId = longTermPricingIdDecoded
        let impactLevelDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ImpactLevel.self, forKey: .impactLevel)
        impactLevel = impactLevelDecoded
        let pickupDetailsDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.PickupDetails.self, forKey: .pickupDetails)
        pickupDetails = pickupDetailsDecoded
    }
}

extension CreateJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct CreateJobOutput: Swift.Equatable {
    /// The automatically generated ID for a job, for example JID123e4567-e89b-12d3-a456-426655440000.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct CreateJobOutputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension CreateJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

enum CreateJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClusterLimitExceededException": return try await ClusterLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "Ec2RequestFailedException": return try await Ec2RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputCombinationException": return try await InvalidInputCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceException": return try await InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSRequestFailedException": return try await KMSRequestFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateLongTermPricingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isLongTermPricingAutoRenew = "IsLongTermPricingAutoRenew"
        case longTermPricingType = "LongTermPricingType"
        case snowballType = "SnowballType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isLongTermPricingAutoRenew = self.isLongTermPricingAutoRenew {
            try encodeContainer.encode(isLongTermPricingAutoRenew, forKey: .isLongTermPricingAutoRenew)
        }
        if let longTermPricingType = self.longTermPricingType {
            try encodeContainer.encode(longTermPricingType.rawValue, forKey: .longTermPricingType)
        }
        if let snowballType = self.snowballType {
            try encodeContainer.encode(snowballType.rawValue, forKey: .snowballType)
        }
    }
}

extension CreateLongTermPricingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateLongTermPricingInput: Swift.Equatable {
    /// Specifies whether the current long-term pricing type for the device should be renewed.
    public var isLongTermPricingAutoRenew: Swift.Bool?
    /// The type of long-term pricing option you want for the device, either 1-year or 3-year long-term pricing.
    /// This member is required.
    public var longTermPricingType: SnowballClientTypes.LongTermPricingType?
    /// The type of Snow Family devices to use for the long-term pricing job.
    /// This member is required.
    public var snowballType: SnowballClientTypes.SnowballType?

    public init(
        isLongTermPricingAutoRenew: Swift.Bool? = nil,
        longTermPricingType: SnowballClientTypes.LongTermPricingType? = nil,
        snowballType: SnowballClientTypes.SnowballType? = nil
    )
    {
        self.isLongTermPricingAutoRenew = isLongTermPricingAutoRenew
        self.longTermPricingType = longTermPricingType
        self.snowballType = snowballType
    }
}

struct CreateLongTermPricingInputBody: Swift.Equatable {
    let longTermPricingType: SnowballClientTypes.LongTermPricingType?
    let isLongTermPricingAutoRenew: Swift.Bool?
    let snowballType: SnowballClientTypes.SnowballType?
}

extension CreateLongTermPricingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isLongTermPricingAutoRenew = "IsLongTermPricingAutoRenew"
        case longTermPricingType = "LongTermPricingType"
        case snowballType = "SnowballType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let longTermPricingTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.LongTermPricingType.self, forKey: .longTermPricingType)
        longTermPricingType = longTermPricingTypeDecoded
        let isLongTermPricingAutoRenewDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isLongTermPricingAutoRenew)
        isLongTermPricingAutoRenew = isLongTermPricingAutoRenewDecoded
        let snowballTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.SnowballType.self, forKey: .snowballType)
        snowballType = snowballTypeDecoded
    }
}

extension CreateLongTermPricingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateLongTermPricingOutputBody = try responseDecoder.decode(responseBody: data)
            self.longTermPricingId = output.longTermPricingId
        } else {
            self.longTermPricingId = nil
        }
    }
}

public struct CreateLongTermPricingOutput: Swift.Equatable {
    /// The ID of the long-term pricing type for the device.
    public var longTermPricingId: Swift.String?

    public init(
        longTermPricingId: Swift.String? = nil
    )
    {
        self.longTermPricingId = longTermPricingId
    }
}

struct CreateLongTermPricingOutputBody: Swift.Equatable {
    let longTermPricingId: Swift.String?
}

extension CreateLongTermPricingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case longTermPricingId = "LongTermPricingId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let longTermPricingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .longTermPricingId)
        longTermPricingId = longTermPricingIdDecoded
    }
}

enum CreateLongTermPricingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidResourceException": return try await InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateReturnShippingLabelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case shippingOption = "ShippingOption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let shippingOption = self.shippingOption {
            try encodeContainer.encode(shippingOption.rawValue, forKey: .shippingOption)
        }
    }
}

extension CreateReturnShippingLabelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateReturnShippingLabelInput: Swift.Equatable {
    /// The ID for a job that you want to create the return shipping label for; for example, JID123e4567-e89b-12d3-a456-426655440000.
    /// This member is required.
    public var jobId: Swift.String?
    /// The shipping speed for a particular job. This speed doesn't dictate how soon the device is returned to Amazon Web Services. This speed represents how quickly it moves to its destination while in transit. Regional shipping speeds are as follows:
    public var shippingOption: SnowballClientTypes.ShippingOption?

    public init(
        jobId: Swift.String? = nil,
        shippingOption: SnowballClientTypes.ShippingOption? = nil
    )
    {
        self.jobId = jobId
        self.shippingOption = shippingOption
    }
}

struct CreateReturnShippingLabelInputBody: Swift.Equatable {
    let jobId: Swift.String?
    let shippingOption: SnowballClientTypes.ShippingOption?
}

extension CreateReturnShippingLabelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case shippingOption = "ShippingOption"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let shippingOptionDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ShippingOption.self, forKey: .shippingOption)
        shippingOption = shippingOptionDecoded
    }
}

extension CreateReturnShippingLabelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateReturnShippingLabelOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct CreateReturnShippingLabelOutput: Swift.Equatable {
    /// The status information of the task on a Snow device that is being returned to Amazon Web Services.
    public var status: SnowballClientTypes.ShippingLabelStatus?

    public init(
        status: SnowballClientTypes.ShippingLabelStatus? = nil
    )
    {
        self.status = status
    }
}

struct CreateReturnShippingLabelOutputBody: Swift.Equatable {
    let status: SnowballClientTypes.ShippingLabelStatus?
}

extension CreateReturnShippingLabelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ShippingLabelStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum CreateReturnShippingLabelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputCombinationException": return try await InvalidInputCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidJobStateException": return try await InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceException": return try await InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReturnShippingLabelAlreadyExistsException": return try await ReturnShippingLabelAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SnowballClientTypes.DataTransfer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bytesTransferred = "BytesTransferred"
        case objectsTransferred = "ObjectsTransferred"
        case totalBytes = "TotalBytes"
        case totalObjects = "TotalObjects"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if bytesTransferred != 0 {
            try encodeContainer.encode(bytesTransferred, forKey: .bytesTransferred)
        }
        if objectsTransferred != 0 {
            try encodeContainer.encode(objectsTransferred, forKey: .objectsTransferred)
        }
        if totalBytes != 0 {
            try encodeContainer.encode(totalBytes, forKey: .totalBytes)
        }
        if totalObjects != 0 {
            try encodeContainer.encode(totalObjects, forKey: .totalObjects)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bytesTransferredDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bytesTransferred) ?? 0
        bytesTransferred = bytesTransferredDecoded
        let objectsTransferredDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .objectsTransferred) ?? 0
        objectsTransferred = objectsTransferredDecoded
        let totalBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalBytes) ?? 0
        totalBytes = totalBytesDecoded
        let totalObjectsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalObjects) ?? 0
        totalObjects = totalObjectsDecoded
    }
}

extension SnowballClientTypes {
    /// Defines the real-time status of a Snow device's data transfer while the device is at Amazon Web Services. This data is only available while a job has a JobState value of InProgress, for both import and export jobs.
    public struct DataTransfer: Swift.Equatable {
        /// The number of bytes transferred between a Snow device and Amazon S3.
        public var bytesTransferred: Swift.Int
        /// The number of objects transferred between a Snow device and Amazon S3.
        public var objectsTransferred: Swift.Int
        /// The total bytes of data for a transfer between a Snow device and Amazon S3. This value is set to 0 (zero) until all the keys that will be transferred have been listed.
        public var totalBytes: Swift.Int
        /// The total number of objects for a transfer between a Snow device and Amazon S3. This value is set to 0 (zero) until all the keys that will be transferred have been listed.
        public var totalObjects: Swift.Int

        public init(
            bytesTransferred: Swift.Int = 0,
            objectsTransferred: Swift.Int = 0,
            totalBytes: Swift.Int = 0,
            totalObjects: Swift.Int = 0
        )
        {
            self.bytesTransferred = bytesTransferred
            self.objectsTransferred = objectsTransferred
            self.totalBytes = totalBytes
            self.totalObjects = totalObjects
        }
    }

}

extension SnowballClientTypes.DependentService: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceName = "ServiceName"
        case serviceVersion = "ServiceVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName.rawValue, forKey: .serviceName)
        }
        if let serviceVersion = self.serviceVersion {
            try encodeContainer.encode(serviceVersion, forKey: .serviceVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ServiceName.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceVersionDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ServiceVersion.self, forKey: .serviceVersion)
        serviceVersion = serviceVersionDecoded
    }
}

extension SnowballClientTypes {
    /// The name and version of the service dependant on the requested service.
    public struct DependentService: Swift.Equatable {
        /// The name of the dependent service.
        public var serviceName: SnowballClientTypes.ServiceName?
        /// The version of the dependent service.
        public var serviceVersion: SnowballClientTypes.ServiceVersion?

        public init(
            serviceName: SnowballClientTypes.ServiceName? = nil,
            serviceVersion: SnowballClientTypes.ServiceVersion? = nil
        )
        {
            self.serviceName = serviceName
            self.serviceVersion = serviceVersion
        }
    }

}

extension DescribeAddressInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressId = self.addressId {
            try encodeContainer.encode(addressId, forKey: .addressId)
        }
    }
}

extension DescribeAddressInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAddressInput: Swift.Equatable {
    /// The automatically generated ID for a specific address.
    /// This member is required.
    public var addressId: Swift.String?

    public init(
        addressId: Swift.String? = nil
    )
    {
        self.addressId = addressId
    }
}

struct DescribeAddressInputBody: Swift.Equatable {
    let addressId: Swift.String?
}

extension DescribeAddressInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressId)
        addressId = addressIdDecoded
    }
}

extension DescribeAddressOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAddressOutputBody = try responseDecoder.decode(responseBody: data)
            self.address = output.address
        } else {
            self.address = nil
        }
    }
}

public struct DescribeAddressOutput: Swift.Equatable {
    /// The address that you want the Snow device(s) associated with a specific job to be shipped to.
    public var address: SnowballClientTypes.Address?

    public init(
        address: SnowballClientTypes.Address? = nil
    )
    {
        self.address = address
    }
}

struct DescribeAddressOutputBody: Swift.Equatable {
    let address: SnowballClientTypes.Address?
}

extension DescribeAddressOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.Address.self, forKey: .address)
        address = addressDecoded
    }
}

enum DescribeAddressOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidResourceException": return try await InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAddressesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeAddressesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAddressesInput: Swift.Equatable {
    /// The number of ADDRESS objects to return.
    public var maxResults: Swift.Int?
    /// HTTP requests are stateless. To identify what object comes "next" in the list of ADDRESS objects, you have the option of specifying a value for NextToken as the starting point for your list of returned addresses.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAddressesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeAddressesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAddressesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAddressesOutputBody = try responseDecoder.decode(responseBody: data)
            self.addresses = output.addresses
            self.nextToken = output.nextToken
        } else {
            self.addresses = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAddressesOutput: Swift.Equatable {
    /// The Snow device shipping addresses that were created for this account.
    public var addresses: [SnowballClientTypes.Address]?
    /// HTTP requests are stateless. If you use the automatically generated NextToken value in your next DescribeAddresses call, your list of returned addresses will start from this point in the array.
    public var nextToken: Swift.String?

    public init(
        addresses: [SnowballClientTypes.Address]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.addresses = addresses
        self.nextToken = nextToken
    }
}

struct DescribeAddressesOutputBody: Swift.Equatable {
    let addresses: [SnowballClientTypes.Address]?
    let nextToken: Swift.String?
}

extension DescribeAddressesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addresses = "Addresses"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressesContainer = try containerValues.decodeIfPresent([SnowballClientTypes.Address?].self, forKey: .addresses)
        var addressesDecoded0:[SnowballClientTypes.Address]? = nil
        if let addressesContainer = addressesContainer {
            addressesDecoded0 = [SnowballClientTypes.Address]()
            for structure0 in addressesContainer {
                if let structure0 = structure0 {
                    addressesDecoded0?.append(structure0)
                }
            }
        }
        addresses = addressesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeAddressesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceException": return try await InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeClusterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterId = "ClusterId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterId = self.clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
    }
}

extension DescribeClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeClusterInput: Swift.Equatable {
    /// The automatically generated ID for a cluster.
    /// This member is required.
    public var clusterId: Swift.String?

    public init(
        clusterId: Swift.String? = nil
    )
    {
        self.clusterId = clusterId
    }
}

struct DescribeClusterInputBody: Swift.Equatable {
    let clusterId: Swift.String?
}

extension DescribeClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterId = "ClusterId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
    }
}

extension DescribeClusterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeClusterOutputBody = try responseDecoder.decode(responseBody: data)
            self.clusterMetadata = output.clusterMetadata
        } else {
            self.clusterMetadata = nil
        }
    }
}

public struct DescribeClusterOutput: Swift.Equatable {
    /// Information about a specific cluster, including shipping information, cluster status, and other important metadata.
    public var clusterMetadata: SnowballClientTypes.ClusterMetadata?

    public init(
        clusterMetadata: SnowballClientTypes.ClusterMetadata? = nil
    )
    {
        self.clusterMetadata = clusterMetadata
    }
}

struct DescribeClusterOutputBody: Swift.Equatable {
    let clusterMetadata: SnowballClientTypes.ClusterMetadata?
}

extension DescribeClusterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterMetadata = "ClusterMetadata"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterMetadataDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ClusterMetadata.self, forKey: .clusterMetadata)
        clusterMetadata = clusterMetadataDecoded
    }
}

enum DescribeClusterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidResourceException": return try await InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension DescribeJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeJobInput: Swift.Equatable {
    /// The automatically generated ID for a job, for example JID123e4567-e89b-12d3-a456-426655440000.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeJobInputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension DescribeJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobMetadata = output.jobMetadata
            self.subJobMetadata = output.subJobMetadata
        } else {
            self.jobMetadata = nil
            self.subJobMetadata = nil
        }
    }
}

public struct DescribeJobOutput: Swift.Equatable {
    /// Information about a specific job, including shipping information, job status, and other important metadata.
    public var jobMetadata: SnowballClientTypes.JobMetadata?
    /// Information about a specific job part (in the case of an export job), including shipping information, job status, and other important metadata.
    public var subJobMetadata: [SnowballClientTypes.JobMetadata]?

    public init(
        jobMetadata: SnowballClientTypes.JobMetadata? = nil,
        subJobMetadata: [SnowballClientTypes.JobMetadata]? = nil
    )
    {
        self.jobMetadata = jobMetadata
        self.subJobMetadata = subJobMetadata
    }
}

struct DescribeJobOutputBody: Swift.Equatable {
    let jobMetadata: SnowballClientTypes.JobMetadata?
    let subJobMetadata: [SnowballClientTypes.JobMetadata]?
}

extension DescribeJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobMetadata = "JobMetadata"
        case subJobMetadata = "SubJobMetadata"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobMetadataDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobMetadata.self, forKey: .jobMetadata)
        jobMetadata = jobMetadataDecoded
        let subJobMetadataContainer = try containerValues.decodeIfPresent([SnowballClientTypes.JobMetadata?].self, forKey: .subJobMetadata)
        var subJobMetadataDecoded0:[SnowballClientTypes.JobMetadata]? = nil
        if let subJobMetadataContainer = subJobMetadataContainer {
            subJobMetadataDecoded0 = [SnowballClientTypes.JobMetadata]()
            for structure0 in subJobMetadataContainer {
                if let structure0 = structure0 {
                    subJobMetadataDecoded0?.append(structure0)
                }
            }
        }
        subJobMetadata = subJobMetadataDecoded0
    }
}

enum DescribeJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidResourceException": return try await InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeReturnShippingLabelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension DescribeReturnShippingLabelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeReturnShippingLabelInput: Swift.Equatable {
    /// The automatically generated ID for a job, for example JID123e4567-e89b-12d3-a456-426655440000.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeReturnShippingLabelInputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension DescribeReturnShippingLabelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeReturnShippingLabelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeReturnShippingLabelOutputBody = try responseDecoder.decode(responseBody: data)
            self.expirationDate = output.expirationDate
            self.returnShippingLabelURI = output.returnShippingLabelURI
            self.status = output.status
        } else {
            self.expirationDate = nil
            self.returnShippingLabelURI = nil
            self.status = nil
        }
    }
}

public struct DescribeReturnShippingLabelOutput: Swift.Equatable {
    /// The expiration date of the current return shipping label.
    public var expirationDate: ClientRuntime.Date?
    /// The pre-signed Amazon S3 URI used to download the return shipping label.
    public var returnShippingLabelURI: Swift.String?
    /// The status information of the task on a Snow device that is being returned to Amazon Web Services.
    public var status: SnowballClientTypes.ShippingLabelStatus?

    public init(
        expirationDate: ClientRuntime.Date? = nil,
        returnShippingLabelURI: Swift.String? = nil,
        status: SnowballClientTypes.ShippingLabelStatus? = nil
    )
    {
        self.expirationDate = expirationDate
        self.returnShippingLabelURI = returnShippingLabelURI
        self.status = status
    }
}

struct DescribeReturnShippingLabelOutputBody: Swift.Equatable {
    let status: SnowballClientTypes.ShippingLabelStatus?
    let expirationDate: ClientRuntime.Date?
    let returnShippingLabelURI: Swift.String?
}

extension DescribeReturnShippingLabelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expirationDate = "ExpirationDate"
        case returnShippingLabelURI = "ReturnShippingLabelURI"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ShippingLabelStatus.self, forKey: .status)
        status = statusDecoded
        let expirationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
        let returnShippingLabelURIDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .returnShippingLabelURI)
        returnShippingLabelURI = returnShippingLabelURIDecoded
    }
}

enum DescribeReturnShippingLabelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidJobStateException": return try await InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceException": return try await InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SnowballClientTypes.DeviceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snowconeDeviceConfiguration = "SnowconeDeviceConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snowconeDeviceConfiguration = self.snowconeDeviceConfiguration {
            try encodeContainer.encode(snowconeDeviceConfiguration, forKey: .snowconeDeviceConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snowconeDeviceConfigurationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.SnowconeDeviceConfiguration.self, forKey: .snowconeDeviceConfiguration)
        snowconeDeviceConfiguration = snowconeDeviceConfigurationDecoded
    }
}

extension SnowballClientTypes {
    /// The container for SnowconeDeviceConfiguration.
    public struct DeviceConfiguration: Swift.Equatable {
        /// Returns information about the device configuration for an Snowcone job.
        public var snowconeDeviceConfiguration: SnowballClientTypes.SnowconeDeviceConfiguration?

        public init(
            snowconeDeviceConfiguration: SnowballClientTypes.SnowconeDeviceConfiguration? = nil
        )
        {
            self.snowconeDeviceConfiguration = snowconeDeviceConfiguration
        }
    }

}

extension SnowballClientTypes {
    public enum DeviceServiceName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case nfsOnDeviceService
        case s3OnDeviceService
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceServiceName] {
            return [
                .nfsOnDeviceService,
                .s3OnDeviceService,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .nfsOnDeviceService: return "NFS_ON_DEVICE_SERVICE"
            case .s3OnDeviceService: return "S3_ON_DEVICE_SERVICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceServiceName(rawValue: rawValue) ?? DeviceServiceName.sdkUnknown(rawValue)
        }
    }
}

extension SnowballClientTypes.EKSOnDeviceServiceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eksAnywhereVersion = "EKSAnywhereVersion"
        case kubernetesVersion = "KubernetesVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eksAnywhereVersion = self.eksAnywhereVersion {
            try encodeContainer.encode(eksAnywhereVersion, forKey: .eksAnywhereVersion)
        }
        if let kubernetesVersion = self.kubernetesVersion {
            try encodeContainer.encode(kubernetesVersion, forKey: .kubernetesVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kubernetesVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kubernetesVersion)
        kubernetesVersion = kubernetesVersionDecoded
        let eksAnywhereVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eksAnywhereVersion)
        eksAnywhereVersion = eksAnywhereVersionDecoded
    }
}

extension SnowballClientTypes {
    /// An object representing the metadata and configuration settings of EKS Anywhere on the Snow Family device.
    public struct EKSOnDeviceServiceConfiguration: Swift.Equatable {
        /// The version of EKS Anywhere on the Snow Family device.
        public var eksAnywhereVersion: Swift.String?
        /// The Kubernetes version for EKS Anywhere on the Snow Family device.
        public var kubernetesVersion: Swift.String?

        public init(
            eksAnywhereVersion: Swift.String? = nil,
            kubernetesVersion: Swift.String? = nil
        )
        {
            self.eksAnywhereVersion = eksAnywhereVersion
            self.kubernetesVersion = kubernetesVersion
        }
    }

}

extension SnowballClientTypes.Ec2AmiResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amiId = "AmiId"
        case snowballAmiId = "SnowballAmiId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amiId = self.amiId {
            try encodeContainer.encode(amiId, forKey: .amiId)
        }
        if let snowballAmiId = self.snowballAmiId {
            try encodeContainer.encode(snowballAmiId, forKey: .snowballAmiId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amiId)
        amiId = amiIdDecoded
        let snowballAmiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snowballAmiId)
        snowballAmiId = snowballAmiIdDecoded
    }
}

extension SnowballClientTypes {
    /// A JSON-formatted object that contains the IDs for an Amazon Machine Image (AMI), including the Amazon EC2-compatible AMI ID and the Snow device AMI ID. Each AMI has these two IDs to simplify identifying the AMI in both the Amazon Web Services Cloud and on the device.
    public struct Ec2AmiResource: Swift.Equatable {
        /// The ID of the AMI in Amazon EC2.
        /// This member is required.
        public var amiId: Swift.String?
        /// The ID of the AMI on the Snow device.
        public var snowballAmiId: Swift.String?

        public init(
            amiId: Swift.String? = nil,
            snowballAmiId: Swift.String? = nil
        )
        {
            self.amiId = amiId
            self.snowballAmiId = snowballAmiId
        }
    }

}

extension Ec2RequestFailedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: Ec2RequestFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your user lacks the necessary Amazon EC2 permissions to perform the attempted action.
public struct Ec2RequestFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "Ec2RequestFailedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct Ec2RequestFailedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension Ec2RequestFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnowballClientTypes.EventTriggerDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventResourceARN = "EventResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventResourceARN = self.eventResourceARN {
            try encodeContainer.encode(eventResourceARN, forKey: .eventResourceARN)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventResourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventResourceARN)
        eventResourceARN = eventResourceARNDecoded
    }
}

extension SnowballClientTypes {
    /// The container for the [EventTriggerDefinition$EventResourceARN].
    public struct EventTriggerDefinition: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for any local Amazon S3 resource that is an Lambda function's event trigger associated with this job.
        public var eventResourceARN: Swift.String?

        public init(
            eventResourceARN: Swift.String? = nil
        )
        {
            self.eventResourceARN = eventResourceARN
        }
    }

}

extension GetJobManifestInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension GetJobManifestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetJobManifestInput: Swift.Equatable {
    /// The ID for a job that you want to get the manifest file for, for example JID123e4567-e89b-12d3-a456-426655440000.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct GetJobManifestInputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension GetJobManifestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension GetJobManifestOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetJobManifestOutputBody = try responseDecoder.decode(responseBody: data)
            self.manifestURI = output.manifestURI
        } else {
            self.manifestURI = nil
        }
    }
}

public struct GetJobManifestOutput: Swift.Equatable {
    /// The Amazon S3 presigned URL for the manifest file associated with the specified JobId value.
    public var manifestURI: Swift.String?

    public init(
        manifestURI: Swift.String? = nil
    )
    {
        self.manifestURI = manifestURI
    }
}

struct GetJobManifestOutputBody: Swift.Equatable {
    let manifestURI: Swift.String?
}

extension GetJobManifestOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case manifestURI = "ManifestURI"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manifestURIDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestURI)
        manifestURI = manifestURIDecoded
    }
}

enum GetJobManifestOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidJobStateException": return try await InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceException": return try await InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetJobUnlockCodeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension GetJobUnlockCodeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetJobUnlockCodeInput: Swift.Equatable {
    /// The ID for the job that you want to get the UnlockCode value for, for example JID123e4567-e89b-12d3-a456-426655440000.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct GetJobUnlockCodeInputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension GetJobUnlockCodeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension GetJobUnlockCodeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetJobUnlockCodeOutputBody = try responseDecoder.decode(responseBody: data)
            self.unlockCode = output.unlockCode
        } else {
            self.unlockCode = nil
        }
    }
}

public struct GetJobUnlockCodeOutput: Swift.Equatable {
    /// The UnlockCode value for the specified job. The UnlockCode value can be accessed for up to 360 days after the job has been created.
    public var unlockCode: Swift.String?

    public init(
        unlockCode: Swift.String? = nil
    )
    {
        self.unlockCode = unlockCode
    }
}

struct GetJobUnlockCodeOutputBody: Swift.Equatable {
    let unlockCode: Swift.String?
}

extension GetJobUnlockCodeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unlockCode = "UnlockCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unlockCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unlockCode)
        unlockCode = unlockCodeDecoded
    }
}

enum GetJobUnlockCodeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidJobStateException": return try await InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceException": return try await InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSnowballUsageInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetSnowballUsageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSnowballUsageInput: Swift.Equatable {

    public init() { }
}

struct GetSnowballUsageInputBody: Swift.Equatable {
}

extension GetSnowballUsageInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSnowballUsageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSnowballUsageOutputBody = try responseDecoder.decode(responseBody: data)
            self.snowballLimit = output.snowballLimit
            self.snowballsInUse = output.snowballsInUse
        } else {
            self.snowballLimit = nil
            self.snowballsInUse = nil
        }
    }
}

public struct GetSnowballUsageOutput: Swift.Equatable {
    /// The service limit for number of Snow devices this account can have at once. The default service limit is 1 (one).
    public var snowballLimit: Swift.Int?
    /// The number of Snow devices that this account is currently using.
    public var snowballsInUse: Swift.Int?

    public init(
        snowballLimit: Swift.Int? = nil,
        snowballsInUse: Swift.Int? = nil
    )
    {
        self.snowballLimit = snowballLimit
        self.snowballsInUse = snowballsInUse
    }
}

struct GetSnowballUsageOutputBody: Swift.Equatable {
    let snowballLimit: Swift.Int?
    let snowballsInUse: Swift.Int?
}

extension GetSnowballUsageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case snowballLimit = "SnowballLimit"
        case snowballsInUse = "SnowballsInUse"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snowballLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .snowballLimit)
        snowballLimit = snowballLimitDecoded
        let snowballsInUseDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .snowballsInUse)
        snowballsInUse = snowballsInUseDecoded
    }
}

enum GetSnowballUsageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSoftwareUpdatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension GetSoftwareUpdatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSoftwareUpdatesInput: Swift.Equatable {
    /// The ID for a job that you want to get the software update file for, for example JID123e4567-e89b-12d3-a456-426655440000.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct GetSoftwareUpdatesInputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension GetSoftwareUpdatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension GetSoftwareUpdatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSoftwareUpdatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.updatesURI = output.updatesURI
        } else {
            self.updatesURI = nil
        }
    }
}

public struct GetSoftwareUpdatesOutput: Swift.Equatable {
    /// The Amazon S3 presigned URL for the update file associated with the specified JobId value. The software update will be available for 2 days after this request is made. To access an update after the 2 days have passed, you'll have to make another call to GetSoftwareUpdates.
    public var updatesURI: Swift.String?

    public init(
        updatesURI: Swift.String? = nil
    )
    {
        self.updatesURI = updatesURI
    }
}

struct GetSoftwareUpdatesOutputBody: Swift.Equatable {
    let updatesURI: Swift.String?
}

extension GetSoftwareUpdatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updatesURI = "UpdatesURI"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updatesURIDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatesURI)
        updatesURI = updatesURIDecoded
    }
}

enum GetSoftwareUpdatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidJobStateException": return try await InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceException": return try await InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SnowballClientTypes.INDTaxDocuments: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gstin = "GSTIN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gstin = self.gstin {
            try encodeContainer.encode(gstin, forKey: .gstin)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gstinDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gstin)
        gstin = gstinDecoded
    }
}

extension SnowballClientTypes {
    /// The tax documents required in Amazon Web Services Region in India.
    public struct INDTaxDocuments: Swift.Equatable {
        /// The Goods and Services Tax (GST) documents required in Amazon Web Services Region in India.
        public var gstin: Swift.String?

        public init(
            gstin: Swift.String? = nil
        )
        {
            self.gstin = gstin
        }
    }

}

extension SnowballClientTypes {
    public enum ImpactLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case il2
        case il4
        case il5
        case il6
        case il99
        case sdkUnknown(Swift.String)

        public static var allCases: [ImpactLevel] {
            return [
                .il2,
                .il4,
                .il5,
                .il6,
                .il99,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .il2: return "IL2"
            case .il4: return "IL4"
            case .il5: return "IL5"
            case .il6: return "IL6"
            case .il99: return "IL99"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImpactLevel(rawValue: rawValue) ?? ImpactLevel.sdkUnknown(rawValue)
        }
    }
}

extension InvalidAddressException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidAddressExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The address provided was invalid. Check the address with your region's carrier, and try again.
public struct InvalidAddressException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidAddressException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidAddressExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidAddressExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInputCombinationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidInputCombinationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Job or cluster creation failed. One or more inputs were invalid. Confirm that the [CreateClusterRequest$SnowballType] value supports your [CreateJobRequest$JobType], and try again.
public struct InvalidInputCombinationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidInputCombinationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidInputCombinationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidInputCombinationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidJobStateException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidJobStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The action can't be performed because the job's current state doesn't allow that action to be performed.
public struct InvalidJobStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidJobStateException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidJobStateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidJobStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The NextToken string was altered unexpectedly, and the operation has stopped. Run the operation without changing the NextToken string, and try again.
public struct InvalidNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextTokenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourceException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidResourceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource can't be found. Check the information you provided in your last request, and try again.
public struct InvalidResourceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The provided resource value is invalid.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResourceException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceType = resourceType
    }
}

struct InvalidResourceExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: Swift.String?
}

extension InvalidResourceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension SnowballClientTypes.JobListEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "CreationDate"
        case description = "Description"
        case isMaster = "IsMaster"
        case jobId = "JobId"
        case jobState = "JobState"
        case jobType = "JobType"
        case snowballType = "SnowballType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if isMaster != false {
            try encodeContainer.encode(isMaster, forKey: .isMaster)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobState = self.jobState {
            try encodeContainer.encode(jobState.rawValue, forKey: .jobState)
        }
        if let jobType = self.jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
        if let snowballType = self.snowballType {
            try encodeContainer.encode(snowballType.rawValue, forKey: .snowballType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStateDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobState.self, forKey: .jobState)
        jobState = jobStateDecoded
        let isMasterDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isMaster) ?? false
        isMaster = isMasterDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let snowballTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.SnowballType.self, forKey: .snowballType)
        snowballType = snowballTypeDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension SnowballClientTypes {
    /// Each JobListEntry object contains a job's state, a job's ID, and a value that indicates whether the job is a job part, in the case of an export job.
    public struct JobListEntry: Swift.Equatable {
        /// The creation date for this job.
        public var creationDate: ClientRuntime.Date?
        /// The optional description of this specific job, for example Important Photos 2016-08-11.
        public var description: Swift.String?
        /// A value that indicates that this job is a main job. A main job represents a successful request to create an export job. Main jobs aren't associated with any Snowballs. Instead, each main job will have at least one job part, and each job part is associated with a Snowball. It might take some time before the job parts associated with a particular main job are listed, because they are created after the main job is created.
        public var isMaster: Swift.Bool
        /// The automatically generated ID for a job, for example JID123e4567-e89b-12d3-a456-426655440000.
        public var jobId: Swift.String?
        /// The current state of this job.
        public var jobState: SnowballClientTypes.JobState?
        /// The type of job.
        public var jobType: SnowballClientTypes.JobType?
        /// The type of device used with this job.
        public var snowballType: SnowballClientTypes.SnowballType?

        public init(
            creationDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            isMaster: Swift.Bool = false,
            jobId: Swift.String? = nil,
            jobState: SnowballClientTypes.JobState? = nil,
            jobType: SnowballClientTypes.JobType? = nil,
            snowballType: SnowballClientTypes.SnowballType? = nil
        )
        {
            self.creationDate = creationDate
            self.description = description
            self.isMaster = isMaster
            self.jobId = jobId
            self.jobState = jobState
            self.jobType = jobType
            self.snowballType = snowballType
        }
    }

}

extension SnowballClientTypes.JobLogs: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobCompletionReportURI = "JobCompletionReportURI"
        case jobFailureLogURI = "JobFailureLogURI"
        case jobSuccessLogURI = "JobSuccessLogURI"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobCompletionReportURI = self.jobCompletionReportURI {
            try encodeContainer.encode(jobCompletionReportURI, forKey: .jobCompletionReportURI)
        }
        if let jobFailureLogURI = self.jobFailureLogURI {
            try encodeContainer.encode(jobFailureLogURI, forKey: .jobFailureLogURI)
        }
        if let jobSuccessLogURI = self.jobSuccessLogURI {
            try encodeContainer.encode(jobSuccessLogURI, forKey: .jobSuccessLogURI)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobCompletionReportURIDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobCompletionReportURI)
        jobCompletionReportURI = jobCompletionReportURIDecoded
        let jobSuccessLogURIDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobSuccessLogURI)
        jobSuccessLogURI = jobSuccessLogURIDecoded
        let jobFailureLogURIDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobFailureLogURI)
        jobFailureLogURI = jobFailureLogURIDecoded
    }
}

extension SnowballClientTypes {
    /// Contains job logs. Whenever a Snow device is used to import data into or export data out of Amazon S3, you'll have the option of downloading a PDF job report. Job logs are returned as a part of the response syntax of the DescribeJob action in the JobMetadata data type. The job logs can be accessed for up to 60 minutes after this request has been made. To access any of the job logs after 60 minutes have passed, you'll have to make another call to the DescribeJob action. For import jobs, the PDF job report becomes available at the end of the import process. For export jobs, your job report typically becomes available while the Snow device for your job part is being delivered to you. The job report provides you insight into the state of your Amazon S3 data transfer. The report includes details about your job or job part for your records. For deeper visibility into the status of your transferred objects, you can look at the two associated logs: a success log and a failure log. The logs are saved in comma-separated value (CSV) format, and the name of each log includes the ID of the job or job part that the log describes.
    public struct JobLogs: Swift.Equatable {
        /// A link to an Amazon S3 presigned URL where the job completion report is located.
        public var jobCompletionReportURI: Swift.String?
        /// A link to an Amazon S3 presigned URL where the job failure log is located.
        public var jobFailureLogURI: Swift.String?
        /// A link to an Amazon S3 presigned URL where the job success log is located.
        public var jobSuccessLogURI: Swift.String?

        public init(
            jobCompletionReportURI: Swift.String? = nil,
            jobFailureLogURI: Swift.String? = nil,
            jobSuccessLogURI: Swift.String? = nil
        )
        {
            self.jobCompletionReportURI = jobCompletionReportURI
            self.jobFailureLogURI = jobFailureLogURI
            self.jobSuccessLogURI = jobSuccessLogURI
        }
    }

}

extension SnowballClientTypes.JobMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
        case clusterId = "ClusterId"
        case creationDate = "CreationDate"
        case dataTransferProgress = "DataTransferProgress"
        case description = "Description"
        case deviceConfiguration = "DeviceConfiguration"
        case forwardingAddressId = "ForwardingAddressId"
        case impactLevel = "ImpactLevel"
        case jobId = "JobId"
        case jobLogInfo = "JobLogInfo"
        case jobState = "JobState"
        case jobType = "JobType"
        case kmsKeyARN = "KmsKeyARN"
        case longTermPricingId = "LongTermPricingId"
        case notification = "Notification"
        case onDeviceServiceConfiguration = "OnDeviceServiceConfiguration"
        case pickupDetails = "PickupDetails"
        case remoteManagement = "RemoteManagement"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingDetails = "ShippingDetails"
        case snowballCapacityPreference = "SnowballCapacityPreference"
        case snowballId = "SnowballId"
        case snowballType = "SnowballType"
        case taxDocuments = "TaxDocuments"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressId = self.addressId {
            try encodeContainer.encode(addressId, forKey: .addressId)
        }
        if let clusterId = self.clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let dataTransferProgress = self.dataTransferProgress {
            try encodeContainer.encode(dataTransferProgress, forKey: .dataTransferProgress)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceConfiguration = self.deviceConfiguration {
            try encodeContainer.encode(deviceConfiguration, forKey: .deviceConfiguration)
        }
        if let forwardingAddressId = self.forwardingAddressId {
            try encodeContainer.encode(forwardingAddressId, forKey: .forwardingAddressId)
        }
        if let impactLevel = self.impactLevel {
            try encodeContainer.encode(impactLevel.rawValue, forKey: .impactLevel)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobLogInfo = self.jobLogInfo {
            try encodeContainer.encode(jobLogInfo, forKey: .jobLogInfo)
        }
        if let jobState = self.jobState {
            try encodeContainer.encode(jobState.rawValue, forKey: .jobState)
        }
        if let jobType = self.jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
        if let kmsKeyARN = self.kmsKeyARN {
            try encodeContainer.encode(kmsKeyARN, forKey: .kmsKeyARN)
        }
        if let longTermPricingId = self.longTermPricingId {
            try encodeContainer.encode(longTermPricingId, forKey: .longTermPricingId)
        }
        if let notification = self.notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let onDeviceServiceConfiguration = self.onDeviceServiceConfiguration {
            try encodeContainer.encode(onDeviceServiceConfiguration, forKey: .onDeviceServiceConfiguration)
        }
        if let pickupDetails = self.pickupDetails {
            try encodeContainer.encode(pickupDetails, forKey: .pickupDetails)
        }
        if let remoteManagement = self.remoteManagement {
            try encodeContainer.encode(remoteManagement.rawValue, forKey: .remoteManagement)
        }
        if let resources = self.resources {
            try encodeContainer.encode(resources, forKey: .resources)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
        if let shippingDetails = self.shippingDetails {
            try encodeContainer.encode(shippingDetails, forKey: .shippingDetails)
        }
        if let snowballCapacityPreference = self.snowballCapacityPreference {
            try encodeContainer.encode(snowballCapacityPreference.rawValue, forKey: .snowballCapacityPreference)
        }
        if let snowballId = self.snowballId {
            try encodeContainer.encode(snowballId, forKey: .snowballId)
        }
        if let snowballType = self.snowballType {
            try encodeContainer.encode(snowballType.rawValue, forKey: .snowballType)
        }
        if let taxDocuments = self.taxDocuments {
            try encodeContainer.encode(taxDocuments, forKey: .taxDocuments)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStateDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobState.self, forKey: .jobState)
        jobState = jobStateDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let snowballTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.SnowballType.self, forKey: .snowballType)
        snowballType = snowballTypeDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let resourcesDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobResource.self, forKey: .resources)
        resources = resourcesDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let kmsKeyARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyARN)
        kmsKeyARN = kmsKeyARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        let addressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressId)
        addressId = addressIdDecoded
        let shippingDetailsDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ShippingDetails.self, forKey: .shippingDetails)
        shippingDetails = shippingDetailsDecoded
        let snowballCapacityPreferenceDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.SnowballCapacity.self, forKey: .snowballCapacityPreference)
        snowballCapacityPreference = snowballCapacityPreferenceDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
        let dataTransferProgressDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.DataTransfer.self, forKey: .dataTransferProgress)
        dataTransferProgress = dataTransferProgressDecoded
        let jobLogInfoDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobLogs.self, forKey: .jobLogInfo)
        jobLogInfo = jobLogInfoDecoded
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let forwardingAddressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forwardingAddressId)
        forwardingAddressId = forwardingAddressIdDecoded
        let taxDocumentsDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.TaxDocuments.self, forKey: .taxDocuments)
        taxDocuments = taxDocumentsDecoded
        let deviceConfigurationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.DeviceConfiguration.self, forKey: .deviceConfiguration)
        deviceConfiguration = deviceConfigurationDecoded
        let remoteManagementDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.RemoteManagement.self, forKey: .remoteManagement)
        remoteManagement = remoteManagementDecoded
        let longTermPricingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .longTermPricingId)
        longTermPricingId = longTermPricingIdDecoded
        let onDeviceServiceConfigurationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.OnDeviceServiceConfiguration.self, forKey: .onDeviceServiceConfiguration)
        onDeviceServiceConfiguration = onDeviceServiceConfigurationDecoded
        let impactLevelDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ImpactLevel.self, forKey: .impactLevel)
        impactLevel = impactLevelDecoded
        let pickupDetailsDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.PickupDetails.self, forKey: .pickupDetails)
        pickupDetails = pickupDetailsDecoded
        let snowballIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snowballId)
        snowballId = snowballIdDecoded
    }
}

extension SnowballClientTypes {
    /// Contains information about a specific job including shipping information, job status, and other important metadata. This information is returned as a part of the response syntax of the DescribeJob action.
    public struct JobMetadata: Swift.Equatable {
        /// The ID for the address that you want the Snow device shipped to.
        public var addressId: Swift.String?
        /// The 39-character ID for the cluster, for example CID123e4567-e89b-12d3-a456-426655440000.
        public var clusterId: Swift.String?
        /// The creation date for this job.
        public var creationDate: ClientRuntime.Date?
        /// A value that defines the real-time status of a Snow device's data transfer while the device is at Amazon Web Services. This data is only available while a job has a JobState value of InProgress, for both import and export jobs.
        public var dataTransferProgress: SnowballClientTypes.DataTransfer?
        /// The description of the job, provided at job creation.
        public var description: Swift.String?
        /// The container for SnowconeDeviceConfiguration.
        public var deviceConfiguration: SnowballClientTypes.DeviceConfiguration?
        /// The ID of the address that you want a job shipped to, after it will be shipped to its primary address. This field is not supported in most regions.
        public var forwardingAddressId: Swift.String?
        /// The highest impact level of data that will be stored or processed on the device, provided at job creation.
        public var impactLevel: SnowballClientTypes.ImpactLevel?
        /// The automatically generated ID for a job, for example JID123e4567-e89b-12d3-a456-426655440000.
        public var jobId: Swift.String?
        /// Links to Amazon S3 presigned URLs for the job report and logs. For import jobs, the PDF job report becomes available at the end of the import process. For export jobs, your job report typically becomes available while the Snow device for your job part is being delivered to you.
        public var jobLogInfo: SnowballClientTypes.JobLogs?
        /// The current status of the jobs.
        public var jobState: SnowballClientTypes.JobState?
        /// The type of job.
        public var jobType: SnowballClientTypes.JobType?
        /// The Amazon Resource Name (ARN) for the Key Management Service (KMS) key associated with this job. This ARN was created using the [CreateKey](https://docs.aws.amazon.com/kms/latest/APIReference/API_CreateKey.html) API action in KMS.
        public var kmsKeyARN: Swift.String?
        /// The ID of the long-term pricing type for the device.
        public var longTermPricingId: Swift.String?
        /// The Amazon Simple Notification Service (Amazon SNS) notification settings associated with a specific job. The Notification object is returned as a part of the response syntax of the DescribeJob action in the JobMetadata data type.
        public var notification: SnowballClientTypes.Notification?
        /// Represents metadata and configuration settings for services on an Amazon Web Services Snow Family device.
        public var onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration?
        /// Information identifying the person picking up the device.
        public var pickupDetails: SnowballClientTypes.PickupDetails?
        /// Allows you to securely operate and manage Snowcone devices remotely from outside of your internal network. When set to INSTALLED_AUTOSTART, remote management will automatically be available when the device arrives at your location. Otherwise, you need to use the Snowball Client to manage the device.
        public var remoteManagement: SnowballClientTypes.RemoteManagement?
        /// An array of S3Resource objects. Each S3Resource object represents an Amazon S3 bucket that your transferred data will be exported from or imported into.
        public var resources: SnowballClientTypes.JobResource?
        /// The role ARN associated with this job. This ARN was created using the [CreateRole](https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html) API action in Identity and Access Management.
        public var roleARN: Swift.String?
        /// A job's shipping information, including inbound and outbound tracking numbers and shipping speed options.
        public var shippingDetails: SnowballClientTypes.ShippingDetails?
        /// The Snow device capacity preference for this job, specified at job creation. In US regions, you can choose between 50 TB and 80 TB Snowballs. All other regions use 80 TB capacity Snowballs. For more information, see "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide or "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide.
        public var snowballCapacityPreference: SnowballClientTypes.SnowballCapacity?
        /// Unique ID associated with a device.
        public var snowballId: Swift.String?
        /// The type of device used with this job.
        public var snowballType: SnowballClientTypes.SnowballType?
        /// The metadata associated with the tax documents required in your Amazon Web Services Region.
        public var taxDocuments: SnowballClientTypes.TaxDocuments?

        public init(
            addressId: Swift.String? = nil,
            clusterId: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            dataTransferProgress: SnowballClientTypes.DataTransfer? = nil,
            description: Swift.String? = nil,
            deviceConfiguration: SnowballClientTypes.DeviceConfiguration? = nil,
            forwardingAddressId: Swift.String? = nil,
            impactLevel: SnowballClientTypes.ImpactLevel? = nil,
            jobId: Swift.String? = nil,
            jobLogInfo: SnowballClientTypes.JobLogs? = nil,
            jobState: SnowballClientTypes.JobState? = nil,
            jobType: SnowballClientTypes.JobType? = nil,
            kmsKeyARN: Swift.String? = nil,
            longTermPricingId: Swift.String? = nil,
            notification: SnowballClientTypes.Notification? = nil,
            onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration? = nil,
            pickupDetails: SnowballClientTypes.PickupDetails? = nil,
            remoteManagement: SnowballClientTypes.RemoteManagement? = nil,
            resources: SnowballClientTypes.JobResource? = nil,
            roleARN: Swift.String? = nil,
            shippingDetails: SnowballClientTypes.ShippingDetails? = nil,
            snowballCapacityPreference: SnowballClientTypes.SnowballCapacity? = nil,
            snowballId: Swift.String? = nil,
            snowballType: SnowballClientTypes.SnowballType? = nil,
            taxDocuments: SnowballClientTypes.TaxDocuments? = nil
        )
        {
            self.addressId = addressId
            self.clusterId = clusterId
            self.creationDate = creationDate
            self.dataTransferProgress = dataTransferProgress
            self.description = description
            self.deviceConfiguration = deviceConfiguration
            self.forwardingAddressId = forwardingAddressId
            self.impactLevel = impactLevel
            self.jobId = jobId
            self.jobLogInfo = jobLogInfo
            self.jobState = jobState
            self.jobType = jobType
            self.kmsKeyARN = kmsKeyARN
            self.longTermPricingId = longTermPricingId
            self.notification = notification
            self.onDeviceServiceConfiguration = onDeviceServiceConfiguration
            self.pickupDetails = pickupDetails
            self.remoteManagement = remoteManagement
            self.resources = resources
            self.roleARN = roleARN
            self.shippingDetails = shippingDetails
            self.snowballCapacityPreference = snowballCapacityPreference
            self.snowballId = snowballId
            self.snowballType = snowballType
            self.taxDocuments = taxDocuments
        }
    }

}

extension SnowballClientTypes.JobResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2AmiResources = "Ec2AmiResources"
        case lambdaResources = "LambdaResources"
        case s3Resources = "S3Resources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ec2AmiResources = ec2AmiResources {
            var ec2AmiResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2AmiResources)
            for ec2amiresource0 in ec2AmiResources {
                try ec2AmiResourcesContainer.encode(ec2amiresource0)
            }
        }
        if let lambdaResources = lambdaResources {
            var lambdaResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lambdaResources)
            for lambdaresource0 in lambdaResources {
                try lambdaResourcesContainer.encode(lambdaresource0)
            }
        }
        if let s3Resources = s3Resources {
            var s3ResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3Resources)
            for s3resource0 in s3Resources {
                try s3ResourcesContainer.encode(s3resource0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ResourcesContainer = try containerValues.decodeIfPresent([SnowballClientTypes.S3Resource?].self, forKey: .s3Resources)
        var s3ResourcesDecoded0:[SnowballClientTypes.S3Resource]? = nil
        if let s3ResourcesContainer = s3ResourcesContainer {
            s3ResourcesDecoded0 = [SnowballClientTypes.S3Resource]()
            for structure0 in s3ResourcesContainer {
                if let structure0 = structure0 {
                    s3ResourcesDecoded0?.append(structure0)
                }
            }
        }
        s3Resources = s3ResourcesDecoded0
        let lambdaResourcesContainer = try containerValues.decodeIfPresent([SnowballClientTypes.LambdaResource?].self, forKey: .lambdaResources)
        var lambdaResourcesDecoded0:[SnowballClientTypes.LambdaResource]? = nil
        if let lambdaResourcesContainer = lambdaResourcesContainer {
            lambdaResourcesDecoded0 = [SnowballClientTypes.LambdaResource]()
            for structure0 in lambdaResourcesContainer {
                if let structure0 = structure0 {
                    lambdaResourcesDecoded0?.append(structure0)
                }
            }
        }
        lambdaResources = lambdaResourcesDecoded0
        let ec2AmiResourcesContainer = try containerValues.decodeIfPresent([SnowballClientTypes.Ec2AmiResource?].self, forKey: .ec2AmiResources)
        var ec2AmiResourcesDecoded0:[SnowballClientTypes.Ec2AmiResource]? = nil
        if let ec2AmiResourcesContainer = ec2AmiResourcesContainer {
            ec2AmiResourcesDecoded0 = [SnowballClientTypes.Ec2AmiResource]()
            for structure0 in ec2AmiResourcesContainer {
                if let structure0 = structure0 {
                    ec2AmiResourcesDecoded0?.append(structure0)
                }
            }
        }
        ec2AmiResources = ec2AmiResourcesDecoded0
    }
}

extension SnowballClientTypes {
    /// Contains an array of Amazon Web Services resource objects. Each object represents an Amazon S3 bucket, an Lambda function, or an Amazon Machine Image (AMI) based on Amazon EC2 that is associated with a particular job.
    public struct JobResource: Swift.Equatable {
        /// The Amazon Machine Images (AMIs) associated with this job.
        public var ec2AmiResources: [SnowballClientTypes.Ec2AmiResource]?
        /// The Python-language Lambda functions for this job.
        public var lambdaResources: [SnowballClientTypes.LambdaResource]?
        /// An array of S3Resource objects.
        public var s3Resources: [SnowballClientTypes.S3Resource]?

        public init(
            ec2AmiResources: [SnowballClientTypes.Ec2AmiResource]? = nil,
            lambdaResources: [SnowballClientTypes.LambdaResource]? = nil,
            s3Resources: [SnowballClientTypes.S3Resource]? = nil
        )
        {
            self.ec2AmiResources = ec2AmiResources
            self.lambdaResources = lambdaResources
            self.s3Resources = s3Resources
        }
    }

}

extension SnowballClientTypes {
    public enum JobState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case complete
        case inProgress
        case inTransitToAws
        case inTransitToCustomer
        case listing
        case new
        case pending
        case preparingAppliance
        case preparingShipment
        case withAws
        case withAwsSortingFacility
        case withCustomer
        case sdkUnknown(Swift.String)

        public static var allCases: [JobState] {
            return [
                .cancelled,
                .complete,
                .inProgress,
                .inTransitToAws,
                .inTransitToCustomer,
                .listing,
                .new,
                .pending,
                .preparingAppliance,
                .preparingShipment,
                .withAws,
                .withAwsSortingFacility,
                .withCustomer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "Cancelled"
            case .complete: return "Complete"
            case .inProgress: return "InProgress"
            case .inTransitToAws: return "InTransitToAWS"
            case .inTransitToCustomer: return "InTransitToCustomer"
            case .listing: return "Listing"
            case .new: return "New"
            case .pending: return "Pending"
            case .preparingAppliance: return "PreparingAppliance"
            case .preparingShipment: return "PreparingShipment"
            case .withAws: return "WithAWS"
            case .withAwsSortingFacility: return "WithAWSSortingFacility"
            case .withCustomer: return "WithCustomer"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobState(rawValue: rawValue) ?? JobState.sdkUnknown(rawValue)
        }
    }
}

extension SnowballClientTypes {
    public enum JobType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case export
        case `import`
        case localUse
        case sdkUnknown(Swift.String)

        public static var allCases: [JobType] {
            return [
                .export,
                .import,
                .localUse,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .export: return "EXPORT"
            case .import: return "IMPORT"
            case .localUse: return "LOCAL_USE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobType(rawValue: rawValue) ?? JobType.sdkUnknown(rawValue)
        }
    }
}

extension KMSRequestFailedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: KMSRequestFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The provided Key Management Service key lacks the permissions to perform the specified [CreateJob] or [UpdateJob] action.
public struct KMSRequestFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSRequestFailedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct KMSRequestFailedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension KMSRequestFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnowballClientTypes.KeyRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beginMarker = "BeginMarker"
        case endMarker = "EndMarker"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beginMarker = self.beginMarker {
            try encodeContainer.encode(beginMarker, forKey: .beginMarker)
        }
        if let endMarker = self.endMarker {
            try encodeContainer.encode(endMarker, forKey: .endMarker)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let beginMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .beginMarker)
        beginMarker = beginMarkerDecoded
        let endMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endMarker)
        endMarker = endMarkerDecoded
    }
}

extension SnowballClientTypes {
    /// Contains a key range. For export jobs, a S3Resource object can have an optional KeyRange value. The length of the range is defined at job creation, and has either an inclusive BeginMarker, an inclusive EndMarker, or both. Ranges are UTF-8 binary sorted.
    public struct KeyRange: Swift.Equatable {
        /// The key that starts an optional key range for an export job. Ranges are inclusive and UTF-8 binary sorted.
        public var beginMarker: Swift.String?
        /// The key that ends an optional key range for an export job. Ranges are inclusive and UTF-8 binary sorted.
        public var endMarker: Swift.String?

        public init(
            beginMarker: Swift.String? = nil,
            endMarker: Swift.String? = nil
        )
        {
            self.beginMarker = beginMarker
            self.endMarker = endMarker
        }
    }

}

extension SnowballClientTypes.LambdaResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTriggers = "EventTriggers"
        case lambdaArn = "LambdaArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventTriggers = eventTriggers {
            var eventTriggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventTriggers)
            for eventtriggerdefinition0 in eventTriggers {
                try eventTriggersContainer.encode(eventtriggerdefinition0)
            }
        }
        if let lambdaArn = self.lambdaArn {
            try encodeContainer.encode(lambdaArn, forKey: .lambdaArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaArn)
        lambdaArn = lambdaArnDecoded
        let eventTriggersContainer = try containerValues.decodeIfPresent([SnowballClientTypes.EventTriggerDefinition?].self, forKey: .eventTriggers)
        var eventTriggersDecoded0:[SnowballClientTypes.EventTriggerDefinition]? = nil
        if let eventTriggersContainer = eventTriggersContainer {
            eventTriggersDecoded0 = [SnowballClientTypes.EventTriggerDefinition]()
            for structure0 in eventTriggersContainer {
                if let structure0 = structure0 {
                    eventTriggersDecoded0?.append(structure0)
                }
            }
        }
        eventTriggers = eventTriggersDecoded0
    }
}

extension SnowballClientTypes {
    /// Identifies
    public struct LambdaResource: Swift.Equatable {
        /// The array of ARNs for [S3Resource] objects to trigger the [LambdaResource] objects associated with this job.
        public var eventTriggers: [SnowballClientTypes.EventTriggerDefinition]?
        /// An Amazon Resource Name (ARN) that represents an Lambda function to be triggered by PUT object actions on the associated local Amazon S3 resource.
        public var lambdaArn: Swift.String?

        public init(
            eventTriggers: [SnowballClientTypes.EventTriggerDefinition]? = nil,
            lambdaArn: Swift.String? = nil
        )
        {
            self.eventTriggers = eventTriggers
            self.lambdaArn = lambdaArn
        }
    }

}

extension ListClusterJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterId = "ClusterId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterId = self.clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListClusterJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListClusterJobsInput: Swift.Equatable {
    /// The 39-character ID for the cluster that you want to list, for example CID123e4567-e89b-12d3-a456-426655440000.
    /// This member is required.
    public var clusterId: Swift.String?
    /// The number of JobListEntry objects to return.
    public var maxResults: Swift.Int?
    /// HTTP requests are stateless. To identify what object comes "next" in the list of JobListEntry objects, you have the option of specifying NextToken as the starting point for your returned list.
    public var nextToken: Swift.String?

    public init(
        clusterId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterId = clusterId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListClusterJobsInputBody: Swift.Equatable {
    let clusterId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListClusterJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterId = "ClusterId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListClusterJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListClusterJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobListEntries = output.jobListEntries
            self.nextToken = output.nextToken
        } else {
            self.jobListEntries = nil
            self.nextToken = nil
        }
    }
}

public struct ListClusterJobsOutput: Swift.Equatable {
    /// Each JobListEntry object contains a job's state, a job's ID, and a value that indicates whether the job is a job part, in the case of export jobs.
    public var jobListEntries: [SnowballClientTypes.JobListEntry]?
    /// HTTP requests are stateless. If you use the automatically generated NextToken value in your next ListClusterJobsResult call, your list of returned jobs will start from this point in the array.
    public var nextToken: Swift.String?

    public init(
        jobListEntries: [SnowballClientTypes.JobListEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobListEntries = jobListEntries
        self.nextToken = nextToken
    }
}

struct ListClusterJobsOutputBody: Swift.Equatable {
    let jobListEntries: [SnowballClientTypes.JobListEntry]?
    let nextToken: Swift.String?
}

extension ListClusterJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobListEntries = "JobListEntries"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobListEntriesContainer = try containerValues.decodeIfPresent([SnowballClientTypes.JobListEntry?].self, forKey: .jobListEntries)
        var jobListEntriesDecoded0:[SnowballClientTypes.JobListEntry]? = nil
        if let jobListEntriesContainer = jobListEntriesContainer {
            jobListEntriesDecoded0 = [SnowballClientTypes.JobListEntry]()
            for structure0 in jobListEntriesContainer {
                if let structure0 = structure0 {
                    jobListEntriesDecoded0?.append(structure0)
                }
            }
        }
        jobListEntries = jobListEntriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListClusterJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceException": return try await InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListClustersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListClustersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListClustersInput: Swift.Equatable {
    /// The number of ClusterListEntry objects to return.
    public var maxResults: Swift.Int?
    /// HTTP requests are stateless. To identify what object comes "next" in the list of ClusterListEntry objects, you have the option of specifying NextToken as the starting point for your returned list.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListClustersInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListClustersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListClustersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListClustersOutputBody = try responseDecoder.decode(responseBody: data)
            self.clusterListEntries = output.clusterListEntries
            self.nextToken = output.nextToken
        } else {
            self.clusterListEntries = nil
            self.nextToken = nil
        }
    }
}

public struct ListClustersOutput: Swift.Equatable {
    /// Each ClusterListEntry object contains a cluster's state, a cluster's ID, and other important status information.
    public var clusterListEntries: [SnowballClientTypes.ClusterListEntry]?
    /// HTTP requests are stateless. If you use the automatically generated NextToken value in your next ClusterListEntry call, your list of returned clusters will start from this point in the array.
    public var nextToken: Swift.String?

    public init(
        clusterListEntries: [SnowballClientTypes.ClusterListEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterListEntries = clusterListEntries
        self.nextToken = nextToken
    }
}

struct ListClustersOutputBody: Swift.Equatable {
    let clusterListEntries: [SnowballClientTypes.ClusterListEntry]?
    let nextToken: Swift.String?
}

extension ListClustersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clusterListEntries = "ClusterListEntries"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterListEntriesContainer = try containerValues.decodeIfPresent([SnowballClientTypes.ClusterListEntry?].self, forKey: .clusterListEntries)
        var clusterListEntriesDecoded0:[SnowballClientTypes.ClusterListEntry]? = nil
        if let clusterListEntriesContainer = clusterListEntriesContainer {
            clusterListEntriesDecoded0 = [SnowballClientTypes.ClusterListEntry]()
            for structure0 in clusterListEntriesContainer {
                if let structure0 = structure0 {
                    clusterListEntriesDecoded0?.append(structure0)
                }
            }
        }
        clusterListEntries = clusterListEntriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListClustersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCompatibleImagesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListCompatibleImagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListCompatibleImagesInput: Swift.Equatable {
    /// The maximum number of results for the list of compatible images. Currently, a Snowball Edge device can store 10 AMIs.
    public var maxResults: Swift.Int?
    /// HTTP requests are stateless. To identify what object comes "next" in the list of compatible images, you can specify a value for NextToken as the starting point for your list of returned images.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCompatibleImagesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListCompatibleImagesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCompatibleImagesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCompatibleImagesOutputBody = try responseDecoder.decode(responseBody: data)
            self.compatibleImages = output.compatibleImages
            self.nextToken = output.nextToken
        } else {
            self.compatibleImages = nil
            self.nextToken = nil
        }
    }
}

public struct ListCompatibleImagesOutput: Swift.Equatable {
    /// A JSON-formatted object that describes a compatible AMI, including the ID and name for a Snow device AMI.
    public var compatibleImages: [SnowballClientTypes.CompatibleImage]?
    /// Because HTTP requests are stateless, this is the starting point for your next list of returned images.
    public var nextToken: Swift.String?

    public init(
        compatibleImages: [SnowballClientTypes.CompatibleImage]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.compatibleImages = compatibleImages
        self.nextToken = nextToken
    }
}

struct ListCompatibleImagesOutputBody: Swift.Equatable {
    let compatibleImages: [SnowballClientTypes.CompatibleImage]?
    let nextToken: Swift.String?
}

extension ListCompatibleImagesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compatibleImages = "CompatibleImages"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let compatibleImagesContainer = try containerValues.decodeIfPresent([SnowballClientTypes.CompatibleImage?].self, forKey: .compatibleImages)
        var compatibleImagesDecoded0:[SnowballClientTypes.CompatibleImage]? = nil
        if let compatibleImagesContainer = compatibleImagesContainer {
            compatibleImagesDecoded0 = [SnowballClientTypes.CompatibleImage]()
            for structure0 in compatibleImagesContainer {
                if let structure0 = structure0 {
                    compatibleImagesDecoded0?.append(structure0)
                }
            }
        }
        compatibleImages = compatibleImagesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCompatibleImagesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "Ec2RequestFailedException": return try await Ec2RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListJobsInput: Swift.Equatable {
    /// The number of JobListEntry objects to return.
    public var maxResults: Swift.Int?
    /// HTTP requests are stateless. To identify what object comes "next" in the list of JobListEntry objects, you have the option of specifying NextToken as the starting point for your returned list.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListJobsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobListEntries = output.jobListEntries
            self.nextToken = output.nextToken
        } else {
            self.jobListEntries = nil
            self.nextToken = nil
        }
    }
}

public struct ListJobsOutput: Swift.Equatable {
    /// Each JobListEntry object contains a job's state, a job's ID, and a value that indicates whether the job is a job part, in the case of export jobs.
    public var jobListEntries: [SnowballClientTypes.JobListEntry]?
    /// HTTP requests are stateless. If you use this automatically generated NextToken value in your next ListJobs call, your returned JobListEntry objects will start from this point in the array.
    public var nextToken: Swift.String?

    public init(
        jobListEntries: [SnowballClientTypes.JobListEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobListEntries = jobListEntries
        self.nextToken = nextToken
    }
}

struct ListJobsOutputBody: Swift.Equatable {
    let jobListEntries: [SnowballClientTypes.JobListEntry]?
    let nextToken: Swift.String?
}

extension ListJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobListEntries = "JobListEntries"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobListEntriesContainer = try containerValues.decodeIfPresent([SnowballClientTypes.JobListEntry?].self, forKey: .jobListEntries)
        var jobListEntriesDecoded0:[SnowballClientTypes.JobListEntry]? = nil
        if let jobListEntriesContainer = jobListEntriesContainer {
            jobListEntriesDecoded0 = [SnowballClientTypes.JobListEntry]()
            for structure0 in jobListEntriesContainer {
                if let structure0 = structure0 {
                    jobListEntriesDecoded0?.append(structure0)
                }
            }
        }
        jobListEntries = jobListEntriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLongTermPricingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListLongTermPricingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListLongTermPricingInput: Swift.Equatable {
    /// The maximum number of ListLongTermPricing objects to return.
    public var maxResults: Swift.Int?
    /// Because HTTP requests are stateless, this is the starting point for your next list of ListLongTermPricing to return.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLongTermPricingInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListLongTermPricingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLongTermPricingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLongTermPricingOutputBody = try responseDecoder.decode(responseBody: data)
            self.longTermPricingEntries = output.longTermPricingEntries
            self.nextToken = output.nextToken
        } else {
            self.longTermPricingEntries = nil
            self.nextToken = nil
        }
    }
}

public struct ListLongTermPricingOutput: Swift.Equatable {
    /// Each LongTermPricingEntry object contains a status, ID, and other information about the LongTermPricing type.
    public var longTermPricingEntries: [SnowballClientTypes.LongTermPricingListEntry]?
    /// Because HTTP requests are stateless, this is the starting point for your next list of returned ListLongTermPricing list.
    public var nextToken: Swift.String?

    public init(
        longTermPricingEntries: [SnowballClientTypes.LongTermPricingListEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.longTermPricingEntries = longTermPricingEntries
        self.nextToken = nextToken
    }
}

struct ListLongTermPricingOutputBody: Swift.Equatable {
    let longTermPricingEntries: [SnowballClientTypes.LongTermPricingListEntry]?
    let nextToken: Swift.String?
}

extension ListLongTermPricingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case longTermPricingEntries = "LongTermPricingEntries"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let longTermPricingEntriesContainer = try containerValues.decodeIfPresent([SnowballClientTypes.LongTermPricingListEntry?].self, forKey: .longTermPricingEntries)
        var longTermPricingEntriesDecoded0:[SnowballClientTypes.LongTermPricingListEntry]? = nil
        if let longTermPricingEntriesContainer = longTermPricingEntriesContainer {
            longTermPricingEntriesDecoded0 = [SnowballClientTypes.LongTermPricingListEntry]()
            for structure0 in longTermPricingEntriesContainer {
                if let structure0 = structure0 {
                    longTermPricingEntriesDecoded0?.append(structure0)
                }
            }
        }
        longTermPricingEntries = longTermPricingEntriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLongTermPricingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceException": return try await InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPickupLocationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListPickupLocationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPickupLocationsInput: Swift.Equatable {
    /// The maximum number of locations to list per page.
    public var maxResults: Swift.Int?
    /// HTTP requests are stateless. To identify what object comes "next" in the list of ListPickupLocationsRequest objects, you have the option of specifying NextToken as the starting point for your returned list.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPickupLocationsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListPickupLocationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPickupLocationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPickupLocationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.addresses = output.addresses
            self.nextToken = output.nextToken
        } else {
            self.addresses = nil
            self.nextToken = nil
        }
    }
}

public struct ListPickupLocationsOutput: Swift.Equatable {
    /// Information about the address of pickup locations.
    public var addresses: [SnowballClientTypes.Address]?
    /// HTTP requests are stateless. To identify what object comes "next" in the list of ListPickupLocationsResult objects, you have the option of specifying NextToken as the starting point for your returned list.
    public var nextToken: Swift.String?

    public init(
        addresses: [SnowballClientTypes.Address]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.addresses = addresses
        self.nextToken = nextToken
    }
}

struct ListPickupLocationsOutputBody: Swift.Equatable {
    let addresses: [SnowballClientTypes.Address]?
    let nextToken: Swift.String?
}

extension ListPickupLocationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addresses = "Addresses"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressesContainer = try containerValues.decodeIfPresent([SnowballClientTypes.Address?].self, forKey: .addresses)
        var addressesDecoded0:[SnowballClientTypes.Address]? = nil
        if let addressesContainer = addressesContainer {
            addressesDecoded0 = [SnowballClientTypes.Address]()
            for structure0 in addressesContainer {
                if let structure0 = structure0 {
                    addressesDecoded0?.append(structure0)
                }
            }
        }
        addresses = addressesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPickupLocationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidResourceException": return try await InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListServiceVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dependentServices = "DependentServices"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceName = "ServiceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dependentServices = dependentServices {
            var dependentServicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dependentServices)
            for dependentservice0 in dependentServices {
                try dependentServicesContainer.encode(dependentservice0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName.rawValue, forKey: .serviceName)
        }
    }
}

extension ListServiceVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListServiceVersionsInput: Swift.Equatable {
    /// A list of names and versions of dependant services of the requested service.
    public var dependentServices: [SnowballClientTypes.DependentService]?
    /// The maximum number of ListServiceVersions objects to return.
    public var maxResults: Swift.Int?
    /// Because HTTP requests are stateless, this is the starting point for the next list of returned ListServiceVersionsRequest versions.
    public var nextToken: Swift.String?
    /// The name of the service for which you're requesting supported versions.
    /// This member is required.
    public var serviceName: SnowballClientTypes.ServiceName?

    public init(
        dependentServices: [SnowballClientTypes.DependentService]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceName: SnowballClientTypes.ServiceName? = nil
    )
    {
        self.dependentServices = dependentServices
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceName = serviceName
    }
}

struct ListServiceVersionsInputBody: Swift.Equatable {
    let serviceName: SnowballClientTypes.ServiceName?
    let dependentServices: [SnowballClientTypes.DependentService]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListServiceVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dependentServices = "DependentServices"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceName = "ServiceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ServiceName.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let dependentServicesContainer = try containerValues.decodeIfPresent([SnowballClientTypes.DependentService?].self, forKey: .dependentServices)
        var dependentServicesDecoded0:[SnowballClientTypes.DependentService]? = nil
        if let dependentServicesContainer = dependentServicesContainer {
            dependentServicesDecoded0 = [SnowballClientTypes.DependentService]()
            for structure0 in dependentServicesContainer {
                if let structure0 = structure0 {
                    dependentServicesDecoded0?.append(structure0)
                }
            }
        }
        dependentServices = dependentServicesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListServiceVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListServiceVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.dependentServices = output.dependentServices
            self.nextToken = output.nextToken
            self.serviceName = output.serviceName
            self.serviceVersions = output.serviceVersions
        } else {
            self.dependentServices = nil
            self.nextToken = nil
            self.serviceName = nil
            self.serviceVersions = nil
        }
    }
}

public struct ListServiceVersionsOutput: Swift.Equatable {
    /// A list of names and versions of dependant services of the service for which the system provided supported versions.
    public var dependentServices: [SnowballClientTypes.DependentService]?
    /// Because HTTP requests are stateless, this is the starting point of the next list of returned ListServiceVersionsResult results.
    public var nextToken: Swift.String?
    /// The name of the service for which the system provided supported versions.
    /// This member is required.
    public var serviceName: SnowballClientTypes.ServiceName?
    /// A list of supported versions.
    /// This member is required.
    public var serviceVersions: [SnowballClientTypes.ServiceVersion]?

    public init(
        dependentServices: [SnowballClientTypes.DependentService]? = nil,
        nextToken: Swift.String? = nil,
        serviceName: SnowballClientTypes.ServiceName? = nil,
        serviceVersions: [SnowballClientTypes.ServiceVersion]? = nil
    )
    {
        self.dependentServices = dependentServices
        self.nextToken = nextToken
        self.serviceName = serviceName
        self.serviceVersions = serviceVersions
    }
}

struct ListServiceVersionsOutputBody: Swift.Equatable {
    let serviceVersions: [SnowballClientTypes.ServiceVersion]?
    let serviceName: SnowballClientTypes.ServiceName?
    let dependentServices: [SnowballClientTypes.DependentService]?
    let nextToken: Swift.String?
}

extension ListServiceVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dependentServices = "DependentServices"
        case nextToken = "NextToken"
        case serviceName = "ServiceName"
        case serviceVersions = "ServiceVersions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceVersionsContainer = try containerValues.decodeIfPresent([SnowballClientTypes.ServiceVersion?].self, forKey: .serviceVersions)
        var serviceVersionsDecoded0:[SnowballClientTypes.ServiceVersion]? = nil
        if let serviceVersionsContainer = serviceVersionsContainer {
            serviceVersionsDecoded0 = [SnowballClientTypes.ServiceVersion]()
            for structure0 in serviceVersionsContainer {
                if let structure0 = structure0 {
                    serviceVersionsDecoded0?.append(structure0)
                }
            }
        }
        serviceVersions = serviceVersionsDecoded0
        let serviceNameDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ServiceName.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let dependentServicesContainer = try containerValues.decodeIfPresent([SnowballClientTypes.DependentService?].self, forKey: .dependentServices)
        var dependentServicesDecoded0:[SnowballClientTypes.DependentService]? = nil
        if let dependentServicesContainer = dependentServicesContainer {
            dependentServicesDecoded0 = [SnowballClientTypes.DependentService]()
            for structure0 in dependentServicesContainer {
                if let structure0 = structure0 {
                    dependentServicesDecoded0?.append(structure0)
                }
            }
        }
        dependentServices = dependentServicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListServiceVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceException": return try await InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SnowballClientTypes.LongTermPricingListEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentActiveJob = "CurrentActiveJob"
        case isLongTermPricingAutoRenew = "IsLongTermPricingAutoRenew"
        case jobIds = "JobIds"
        case longTermPricingEndDate = "LongTermPricingEndDate"
        case longTermPricingId = "LongTermPricingId"
        case longTermPricingStartDate = "LongTermPricingStartDate"
        case longTermPricingStatus = "LongTermPricingStatus"
        case longTermPricingType = "LongTermPricingType"
        case replacementJob = "ReplacementJob"
        case snowballType = "SnowballType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentActiveJob = self.currentActiveJob {
            try encodeContainer.encode(currentActiveJob, forKey: .currentActiveJob)
        }
        if let isLongTermPricingAutoRenew = self.isLongTermPricingAutoRenew {
            try encodeContainer.encode(isLongTermPricingAutoRenew, forKey: .isLongTermPricingAutoRenew)
        }
        if let jobIds = jobIds {
            var jobIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .jobIds)
            for jobid0 in jobIds {
                try jobIdsContainer.encode(jobid0)
            }
        }
        if let longTermPricingEndDate = self.longTermPricingEndDate {
            try encodeContainer.encodeTimestamp(longTermPricingEndDate, format: .epochSeconds, forKey: .longTermPricingEndDate)
        }
        if let longTermPricingId = self.longTermPricingId {
            try encodeContainer.encode(longTermPricingId, forKey: .longTermPricingId)
        }
        if let longTermPricingStartDate = self.longTermPricingStartDate {
            try encodeContainer.encodeTimestamp(longTermPricingStartDate, format: .epochSeconds, forKey: .longTermPricingStartDate)
        }
        if let longTermPricingStatus = self.longTermPricingStatus {
            try encodeContainer.encode(longTermPricingStatus, forKey: .longTermPricingStatus)
        }
        if let longTermPricingType = self.longTermPricingType {
            try encodeContainer.encode(longTermPricingType.rawValue, forKey: .longTermPricingType)
        }
        if let replacementJob = self.replacementJob {
            try encodeContainer.encode(replacementJob, forKey: .replacementJob)
        }
        if let snowballType = self.snowballType {
            try encodeContainer.encode(snowballType.rawValue, forKey: .snowballType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let longTermPricingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .longTermPricingId)
        longTermPricingId = longTermPricingIdDecoded
        let longTermPricingEndDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .longTermPricingEndDate)
        longTermPricingEndDate = longTermPricingEndDateDecoded
        let longTermPricingStartDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .longTermPricingStartDate)
        longTermPricingStartDate = longTermPricingStartDateDecoded
        let longTermPricingTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.LongTermPricingType.self, forKey: .longTermPricingType)
        longTermPricingType = longTermPricingTypeDecoded
        let currentActiveJobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentActiveJob)
        currentActiveJob = currentActiveJobDecoded
        let replacementJobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replacementJob)
        replacementJob = replacementJobDecoded
        let isLongTermPricingAutoRenewDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isLongTermPricingAutoRenew)
        isLongTermPricingAutoRenew = isLongTermPricingAutoRenewDecoded
        let longTermPricingStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .longTermPricingStatus)
        longTermPricingStatus = longTermPricingStatusDecoded
        let snowballTypeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.SnowballType.self, forKey: .snowballType)
        snowballType = snowballTypeDecoded
        let jobIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .jobIds)
        var jobIdsDecoded0:[Swift.String]? = nil
        if let jobIdsContainer = jobIdsContainer {
            jobIdsDecoded0 = [Swift.String]()
            for string0 in jobIdsContainer {
                if let string0 = string0 {
                    jobIdsDecoded0?.append(string0)
                }
            }
        }
        jobIds = jobIdsDecoded0
    }
}

extension SnowballClientTypes {
    /// Each LongTermPricingListEntry object contains information about a long-term pricing type.
    public struct LongTermPricingListEntry: Swift.Equatable {
        /// The current active jobs on the device the long-term pricing type.
        public var currentActiveJob: Swift.String?
        /// If set to true, specifies that the current long-term pricing type for the device should be automatically renewed before the long-term pricing contract expires.
        public var isLongTermPricingAutoRenew: Swift.Bool?
        /// The IDs of the jobs that are associated with a long-term pricing type.
        public var jobIds: [Swift.String]?
        /// The end date the long-term pricing contract.
        public var longTermPricingEndDate: ClientRuntime.Date?
        /// The ID of the long-term pricing type for the device.
        public var longTermPricingId: Swift.String?
        /// The start date of the long-term pricing contract.
        public var longTermPricingStartDate: ClientRuntime.Date?
        /// The status of the long-term pricing type.
        public var longTermPricingStatus: Swift.String?
        /// The type of long-term pricing that was selected for the device.
        public var longTermPricingType: SnowballClientTypes.LongTermPricingType?
        /// A new device that replaces a device that is ordered with long-term pricing.
        public var replacementJob: Swift.String?
        /// The type of Snow Family devices associated with this long-term pricing job.
        public var snowballType: SnowballClientTypes.SnowballType?

        public init(
            currentActiveJob: Swift.String? = nil,
            isLongTermPricingAutoRenew: Swift.Bool? = nil,
            jobIds: [Swift.String]? = nil,
            longTermPricingEndDate: ClientRuntime.Date? = nil,
            longTermPricingId: Swift.String? = nil,
            longTermPricingStartDate: ClientRuntime.Date? = nil,
            longTermPricingStatus: Swift.String? = nil,
            longTermPricingType: SnowballClientTypes.LongTermPricingType? = nil,
            replacementJob: Swift.String? = nil,
            snowballType: SnowballClientTypes.SnowballType? = nil
        )
        {
            self.currentActiveJob = currentActiveJob
            self.isLongTermPricingAutoRenew = isLongTermPricingAutoRenew
            self.jobIds = jobIds
            self.longTermPricingEndDate = longTermPricingEndDate
            self.longTermPricingId = longTermPricingId
            self.longTermPricingStartDate = longTermPricingStartDate
            self.longTermPricingStatus = longTermPricingStatus
            self.longTermPricingType = longTermPricingType
            self.replacementJob = replacementJob
            self.snowballType = snowballType
        }
    }

}

extension SnowballClientTypes {
    public enum LongTermPricingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case oneMonth
        case oneYear
        case threeYear
        case sdkUnknown(Swift.String)

        public static var allCases: [LongTermPricingType] {
            return [
                .oneMonth,
                .oneYear,
                .threeYear,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .oneMonth: return "OneMonth"
            case .oneYear: return "OneYear"
            case .threeYear: return "ThreeYear"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LongTermPricingType(rawValue: rawValue) ?? LongTermPricingType.sdkUnknown(rawValue)
        }
    }
}

extension SnowballClientTypes.NFSOnDeviceServiceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storageLimit = "StorageLimit"
        case storageUnit = "StorageUnit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if storageLimit != 0 {
            try encodeContainer.encode(storageLimit, forKey: .storageLimit)
        }
        if let storageUnit = self.storageUnit {
            try encodeContainer.encode(storageUnit.rawValue, forKey: .storageUnit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storageLimit) ?? 0
        storageLimit = storageLimitDecoded
        let storageUnitDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.StorageUnit.self, forKey: .storageUnit)
        storageUnit = storageUnitDecoded
    }
}

extension SnowballClientTypes {
    /// An object that represents the metadata and configuration settings for the NFS (Network File System) service on an Amazon Web Services Snow Family device.
    public struct NFSOnDeviceServiceConfiguration: Swift.Equatable {
        /// The maximum NFS storage for one Snow Family device.
        public var storageLimit: Swift.Int
        /// The scale unit of the NFS storage on the device. Valid values: TB.
        public var storageUnit: SnowballClientTypes.StorageUnit?

        public init(
            storageLimit: Swift.Int = 0,
            storageUnit: SnowballClientTypes.StorageUnit? = nil
        )
        {
            self.storageLimit = storageLimit
            self.storageUnit = storageUnit
        }
    }

}

extension SnowballClientTypes.Notification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devicePickupSnsTopicARN = "DevicePickupSnsTopicARN"
        case jobStatesToNotify = "JobStatesToNotify"
        case notifyAll = "NotifyAll"
        case snsTopicARN = "SnsTopicARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devicePickupSnsTopicARN = self.devicePickupSnsTopicARN {
            try encodeContainer.encode(devicePickupSnsTopicARN, forKey: .devicePickupSnsTopicARN)
        }
        if let jobStatesToNotify = jobStatesToNotify {
            var jobStatesToNotifyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .jobStatesToNotify)
            for jobstate0 in jobStatesToNotify {
                try jobStatesToNotifyContainer.encode(jobstate0.rawValue)
            }
        }
        if notifyAll != false {
            try encodeContainer.encode(notifyAll, forKey: .notifyAll)
        }
        if let snsTopicARN = self.snsTopicARN {
            try encodeContainer.encode(snsTopicARN, forKey: .snsTopicARN)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snsTopicARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicARN)
        snsTopicARN = snsTopicARNDecoded
        let jobStatesToNotifyContainer = try containerValues.decodeIfPresent([SnowballClientTypes.JobState?].self, forKey: .jobStatesToNotify)
        var jobStatesToNotifyDecoded0:[SnowballClientTypes.JobState]? = nil
        if let jobStatesToNotifyContainer = jobStatesToNotifyContainer {
            jobStatesToNotifyDecoded0 = [SnowballClientTypes.JobState]()
            for enum0 in jobStatesToNotifyContainer {
                if let enum0 = enum0 {
                    jobStatesToNotifyDecoded0?.append(enum0)
                }
            }
        }
        jobStatesToNotify = jobStatesToNotifyDecoded0
        let notifyAllDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .notifyAll) ?? false
        notifyAll = notifyAllDecoded
        let devicePickupSnsTopicARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .devicePickupSnsTopicARN)
        devicePickupSnsTopicARN = devicePickupSnsTopicARNDecoded
    }
}

extension SnowballClientTypes {
    /// The Amazon Simple Notification Service (Amazon SNS) notification settings associated with a specific job. The Notification object is returned as a part of the response syntax of the DescribeJob action in the JobMetadata data type. When the notification settings are defined during job creation, you can choose to notify based on a specific set of job states using the JobStatesToNotify array of strings, or you can specify that you want to have Amazon SNS notifications sent out for all job states with NotifyAll set to true.
    public struct Notification: Swift.Equatable {
        /// Used to send SNS notifications for the person picking up the device (identified during job creation).
        public var devicePickupSnsTopicARN: Swift.String?
        /// The list of job states that will trigger a notification for this job.
        public var jobStatesToNotify: [SnowballClientTypes.JobState]?
        /// Any change in job state will trigger a notification for this job.
        public var notifyAll: Swift.Bool
        /// The new SNS TopicArn that you want to associate with this job. You can create Amazon Resource Names (ARNs) for topics by using the [CreateTopic](https://docs.aws.amazon.com/sns/latest/api/API_CreateTopic.html) Amazon SNS API action. You can subscribe email addresses to an Amazon SNS topic through the Amazon Web Services Management Console, or by using the [Subscribe](https://docs.aws.amazon.com/sns/latest/api/API_Subscribe.html) Amazon Simple Notification Service (Amazon SNS) API action.
        public var snsTopicARN: Swift.String?

        public init(
            devicePickupSnsTopicARN: Swift.String? = nil,
            jobStatesToNotify: [SnowballClientTypes.JobState]? = nil,
            notifyAll: Swift.Bool = false,
            snsTopicARN: Swift.String? = nil
        )
        {
            self.devicePickupSnsTopicARN = devicePickupSnsTopicARN
            self.jobStatesToNotify = jobStatesToNotify
            self.notifyAll = notifyAll
            self.snsTopicARN = snsTopicARN
        }
    }

}

extension SnowballClientTypes.OnDeviceServiceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eksOnDeviceService = "EKSOnDeviceService"
        case nfsOnDeviceService = "NFSOnDeviceService"
        case s3OnDeviceService = "S3OnDeviceService"
        case tgwOnDeviceService = "TGWOnDeviceService"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eksOnDeviceService = self.eksOnDeviceService {
            try encodeContainer.encode(eksOnDeviceService, forKey: .eksOnDeviceService)
        }
        if let nfsOnDeviceService = self.nfsOnDeviceService {
            try encodeContainer.encode(nfsOnDeviceService, forKey: .nfsOnDeviceService)
        }
        if let s3OnDeviceService = self.s3OnDeviceService {
            try encodeContainer.encode(s3OnDeviceService, forKey: .s3OnDeviceService)
        }
        if let tgwOnDeviceService = self.tgwOnDeviceService {
            try encodeContainer.encode(tgwOnDeviceService, forKey: .tgwOnDeviceService)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nfsOnDeviceServiceDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.NFSOnDeviceServiceConfiguration.self, forKey: .nfsOnDeviceService)
        nfsOnDeviceService = nfsOnDeviceServiceDecoded
        let tgwOnDeviceServiceDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.TGWOnDeviceServiceConfiguration.self, forKey: .tgwOnDeviceService)
        tgwOnDeviceService = tgwOnDeviceServiceDecoded
        let eksOnDeviceServiceDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.EKSOnDeviceServiceConfiguration.self, forKey: .eksOnDeviceService)
        eksOnDeviceService = eksOnDeviceServiceDecoded
        let s3OnDeviceServiceDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.S3OnDeviceServiceConfiguration.self, forKey: .s3OnDeviceService)
        s3OnDeviceService = s3OnDeviceServiceDecoded
    }
}

extension SnowballClientTypes {
    /// An object that represents the metadata and configuration settings for services on an Amazon Web Services Snow Family device.
    public struct OnDeviceServiceConfiguration: Swift.Equatable {
        /// The configuration of EKS Anywhere on the Snow Family device.
        public var eksOnDeviceService: SnowballClientTypes.EKSOnDeviceServiceConfiguration?
        /// Represents the NFS (Network File System) service on a Snow Family device.
        public var nfsOnDeviceService: SnowballClientTypes.NFSOnDeviceServiceConfiguration?
        /// Configuration for Amazon S3 compatible storage on Snow family devices.
        public var s3OnDeviceService: SnowballClientTypes.S3OnDeviceServiceConfiguration?
        /// Represents the Storage Gateway service Tape Gateway type on a Snow Family device.
        public var tgwOnDeviceService: SnowballClientTypes.TGWOnDeviceServiceConfiguration?

        public init(
            eksOnDeviceService: SnowballClientTypes.EKSOnDeviceServiceConfiguration? = nil,
            nfsOnDeviceService: SnowballClientTypes.NFSOnDeviceServiceConfiguration? = nil,
            s3OnDeviceService: SnowballClientTypes.S3OnDeviceServiceConfiguration? = nil,
            tgwOnDeviceService: SnowballClientTypes.TGWOnDeviceServiceConfiguration? = nil
        )
        {
            self.eksOnDeviceService = eksOnDeviceService
            self.nfsOnDeviceService = nfsOnDeviceService
            self.s3OnDeviceService = s3OnDeviceService
            self.tgwOnDeviceService = tgwOnDeviceService
        }
    }

}

extension SnowballClientTypes.PickupDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devicePickupId = "DevicePickupId"
        case email = "Email"
        case identificationExpirationDate = "IdentificationExpirationDate"
        case identificationIssuingOrg = "IdentificationIssuingOrg"
        case identificationNumber = "IdentificationNumber"
        case name = "Name"
        case phoneNumber = "PhoneNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devicePickupId = self.devicePickupId {
            try encodeContainer.encode(devicePickupId, forKey: .devicePickupId)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let identificationExpirationDate = self.identificationExpirationDate {
            try encodeContainer.encodeTimestamp(identificationExpirationDate, format: .epochSeconds, forKey: .identificationExpirationDate)
        }
        if let identificationIssuingOrg = self.identificationIssuingOrg {
            try encodeContainer.encode(identificationIssuingOrg, forKey: .identificationIssuingOrg)
        }
        if let identificationNumber = self.identificationNumber {
            try encodeContainer.encode(identificationNumber, forKey: .identificationNumber)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let phoneNumber = self.phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let identificationNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identificationNumber)
        identificationNumber = identificationNumberDecoded
        let identificationExpirationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .identificationExpirationDate)
        identificationExpirationDate = identificationExpirationDateDecoded
        let identificationIssuingOrgDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identificationIssuingOrg)
        identificationIssuingOrg = identificationIssuingOrgDecoded
        let devicePickupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .devicePickupId)
        devicePickupId = devicePickupIdDecoded
    }
}

extension SnowballClientTypes.PickupDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PickupDetails(devicePickupId: \(Swift.String(describing: devicePickupId)), identificationExpirationDate: \(Swift.String(describing: identificationExpirationDate)), identificationIssuingOrg: \(Swift.String(describing: identificationIssuingOrg)), identificationNumber: \(Swift.String(describing: identificationNumber)), name: \(Swift.String(describing: name)), email: \"CONTENT_REDACTED\", phoneNumber: \"CONTENT_REDACTED\")"}
}

extension SnowballClientTypes {
    /// Information identifying the person picking up the device.
    public struct PickupDetails: Swift.Equatable {
        /// The unique ID for a device that will be picked up.
        public var devicePickupId: Swift.String?
        /// The email address of the person picking up the device.
        public var email: Swift.String?
        /// Expiration date of the credential identifying the person picking up the device.
        public var identificationExpirationDate: ClientRuntime.Date?
        /// Organization that issued the credential identifying the person picking up the device.
        public var identificationIssuingOrg: Swift.String?
        /// The number on the credential identifying the person picking up the device.
        public var identificationNumber: Swift.String?
        /// The name of the person picking up the device.
        public var name: Swift.String?
        /// The phone number of the person picking up the device.
        public var phoneNumber: Swift.String?

        public init(
            devicePickupId: Swift.String? = nil,
            email: Swift.String? = nil,
            identificationExpirationDate: ClientRuntime.Date? = nil,
            identificationIssuingOrg: Swift.String? = nil,
            identificationNumber: Swift.String? = nil,
            name: Swift.String? = nil,
            phoneNumber: Swift.String? = nil
        )
        {
            self.devicePickupId = devicePickupId
            self.email = email
            self.identificationExpirationDate = identificationExpirationDate
            self.identificationIssuingOrg = identificationIssuingOrg
            self.identificationNumber = identificationNumber
            self.name = name
            self.phoneNumber = phoneNumber
        }
    }

}

extension SnowballClientTypes {
    public enum RemoteManagement: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case installedAutostart
        case installedOnly
        case notInstalled
        case sdkUnknown(Swift.String)

        public static var allCases: [RemoteManagement] {
            return [
                .installedAutostart,
                .installedOnly,
                .notInstalled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .installedAutostart: return "INSTALLED_AUTOSTART"
            case .installedOnly: return "INSTALLED_ONLY"
            case .notInstalled: return "NOT_INSTALLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RemoteManagement(rawValue: rawValue) ?? RemoteManagement.sdkUnknown(rawValue)
        }
    }
}

extension ReturnShippingLabelAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ReturnShippingLabelAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You get this exception if you call CreateReturnShippingLabel and a valid return shipping label already exists. In this case, use DescribeReturnShippingLabel to get the URL.
public struct ReturnShippingLabelAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReturnShippingLabelAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ReturnShippingLabelAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReturnShippingLabelAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnowballClientTypes.S3OnDeviceServiceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case faultTolerance = "FaultTolerance"
        case serviceSize = "ServiceSize"
        case storageLimit = "StorageLimit"
        case storageUnit = "StorageUnit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let faultTolerance = self.faultTolerance {
            try encodeContainer.encode(faultTolerance, forKey: .faultTolerance)
        }
        if let serviceSize = self.serviceSize {
            try encodeContainer.encode(serviceSize, forKey: .serviceSize)
        }
        if let storageLimit = self.storageLimit {
            try encodeContainer.encode(storageLimit, forKey: .storageLimit)
        }
        if let storageUnit = self.storageUnit {
            try encodeContainer.encode(storageUnit.rawValue, forKey: .storageUnit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageLimitDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .storageLimit)
        storageLimit = storageLimitDecoded
        let storageUnitDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.StorageUnit.self, forKey: .storageUnit)
        storageUnit = storageUnitDecoded
        let serviceSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .serviceSize)
        serviceSize = serviceSizeDecoded
        let faultToleranceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .faultTolerance)
        faultTolerance = faultToleranceDecoded
    }
}

extension SnowballClientTypes {
    /// Amazon S3 compatible storage on Snow family devices configuration items.
    public struct S3OnDeviceServiceConfiguration: Swift.Equatable {
        /// >Fault tolerance level of the cluster. This indicates the number of nodes that can go down without degrading the performance of the cluster. This additional input helps when the specified StorageLimit matches more than one Amazon S3 compatible storage on Snow family devices service configuration.
        public var faultTolerance: Swift.Int?
        /// Applicable when creating a cluster. Specifies how many nodes are needed for Amazon S3 compatible storage on Snow family devices. If specified, the other input can be omitted.
        public var serviceSize: Swift.Int?
        /// If the specified storage limit value matches storage limit of one of the defined configurations, that configuration will be used. If the specified storage limit value does not match any defined configuration, the request will fail. If more than one configuration has the same storage limit as specified, the other input need to be provided.
        public var storageLimit: Swift.Double?
        /// Storage unit. Currently the only supported unit is TB.
        public var storageUnit: SnowballClientTypes.StorageUnit?

        public init(
            faultTolerance: Swift.Int? = nil,
            serviceSize: Swift.Int? = nil,
            storageLimit: Swift.Double? = nil,
            storageUnit: SnowballClientTypes.StorageUnit? = nil
        )
        {
            self.faultTolerance = faultTolerance
            self.serviceSize = serviceSize
            self.storageLimit = storageLimit
            self.storageUnit = storageUnit
        }
    }

}

extension SnowballClientTypes.S3Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketArn = "BucketArn"
        case keyRange = "KeyRange"
        case targetOnDeviceServices = "TargetOnDeviceServices"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketArn = self.bucketArn {
            try encodeContainer.encode(bucketArn, forKey: .bucketArn)
        }
        if let keyRange = self.keyRange {
            try encodeContainer.encode(keyRange, forKey: .keyRange)
        }
        if let targetOnDeviceServices = targetOnDeviceServices {
            var targetOnDeviceServicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetOnDeviceServices)
            for targetondeviceservice0 in targetOnDeviceServices {
                try targetOnDeviceServicesContainer.encode(targetondeviceservice0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketArn)
        bucketArn = bucketArnDecoded
        let keyRangeDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.KeyRange.self, forKey: .keyRange)
        keyRange = keyRangeDecoded
        let targetOnDeviceServicesContainer = try containerValues.decodeIfPresent([SnowballClientTypes.TargetOnDeviceService?].self, forKey: .targetOnDeviceServices)
        var targetOnDeviceServicesDecoded0:[SnowballClientTypes.TargetOnDeviceService]? = nil
        if let targetOnDeviceServicesContainer = targetOnDeviceServicesContainer {
            targetOnDeviceServicesDecoded0 = [SnowballClientTypes.TargetOnDeviceService]()
            for structure0 in targetOnDeviceServicesContainer {
                if let structure0 = structure0 {
                    targetOnDeviceServicesDecoded0?.append(structure0)
                }
            }
        }
        targetOnDeviceServices = targetOnDeviceServicesDecoded0
    }
}

extension SnowballClientTypes {
    /// Each S3Resource object represents an Amazon S3 bucket that your transferred data will be exported from or imported into. For export jobs, this object can have an optional KeyRange value. The length of the range is defined at job creation, and has either an inclusive BeginMarker, an inclusive EndMarker, or both. Ranges are UTF-8 binary sorted.
    public struct S3Resource: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of an Amazon S3 bucket.
        public var bucketArn: Swift.String?
        /// For export jobs, you can provide an optional KeyRange within a specific Amazon S3 bucket. The length of the range is defined at job creation, and has either an inclusive BeginMarker, an inclusive EndMarker, or both. Ranges are UTF-8 binary sorted.
        public var keyRange: SnowballClientTypes.KeyRange?
        /// Specifies the service or services on the Snow Family device that your transferred data will be exported from or imported into. Amazon Web Services Snow Family supports Amazon S3 and NFS (Network File System).
        public var targetOnDeviceServices: [SnowballClientTypes.TargetOnDeviceService]?

        public init(
            bucketArn: Swift.String? = nil,
            keyRange: SnowballClientTypes.KeyRange? = nil,
            targetOnDeviceServices: [SnowballClientTypes.TargetOnDeviceService]? = nil
        )
        {
            self.bucketArn = bucketArn
            self.keyRange = keyRange
            self.targetOnDeviceServices = targetOnDeviceServices
        }
    }

}

extension SnowballClientTypes {
    public enum ServiceName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case eksAnywhere
        case kubernetes
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceName] {
            return [
                .eksAnywhere,
                .kubernetes,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .eksAnywhere: return "EKS_ANYWHERE"
            case .kubernetes: return "KUBERNETES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceName(rawValue: rawValue) ?? ServiceName.sdkUnknown(rawValue)
        }
    }
}

extension SnowballClientTypes.ServiceVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension SnowballClientTypes {
    /// The version of the requested service.
    public struct ServiceVersion: Swift.Equatable {
        /// The version number of the requested service.
        public var version: Swift.String?

        public init(
            version: Swift.String? = nil
        )
        {
            self.version = version
        }
    }

}

extension SnowballClientTypes.Shipment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case trackingNumber = "TrackingNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let trackingNumber = self.trackingNumber {
            try encodeContainer.encode(trackingNumber, forKey: .trackingNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let trackingNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trackingNumber)
        trackingNumber = trackingNumberDecoded
    }
}

extension SnowballClientTypes {
    /// The Status and TrackingNumber information for an inbound or outbound shipment.
    public struct Shipment: Swift.Equatable {
        /// Status information for a shipment.
        public var status: Swift.String?
        /// The tracking number for this job. Using this tracking number with your region's carrier's website, you can track a Snow device as the carrier transports it. For India, the carrier is Amazon Logistics. For all other regions, UPS is the carrier.
        public var trackingNumber: Swift.String?

        public init(
            status: Swift.String? = nil,
            trackingNumber: Swift.String? = nil
        )
        {
            self.status = status
            self.trackingNumber = trackingNumber
        }
    }

}

extension SnowballClientTypes {
    public enum ShipmentState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case received
        case returned
        case sdkUnknown(Swift.String)

        public static var allCases: [ShipmentState] {
            return [
                .received,
                .returned,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .received: return "RECEIVED"
            case .returned: return "RETURNED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShipmentState(rawValue: rawValue) ?? ShipmentState.sdkUnknown(rawValue)
        }
    }
}

extension SnowballClientTypes.ShippingDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inboundShipment = "InboundShipment"
        case outboundShipment = "OutboundShipment"
        case shippingOption = "ShippingOption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inboundShipment = self.inboundShipment {
            try encodeContainer.encode(inboundShipment, forKey: .inboundShipment)
        }
        if let outboundShipment = self.outboundShipment {
            try encodeContainer.encode(outboundShipment, forKey: .outboundShipment)
        }
        if let shippingOption = self.shippingOption {
            try encodeContainer.encode(shippingOption.rawValue, forKey: .shippingOption)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shippingOptionDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ShippingOption.self, forKey: .shippingOption)
        shippingOption = shippingOptionDecoded
        let inboundShipmentDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.Shipment.self, forKey: .inboundShipment)
        inboundShipment = inboundShipmentDecoded
        let outboundShipmentDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.Shipment.self, forKey: .outboundShipment)
        outboundShipment = outboundShipmentDecoded
    }
}

extension SnowballClientTypes {
    /// A job's shipping information, including inbound and outbound tracking numbers and shipping speed options.
    public struct ShippingDetails: Swift.Equatable {
        /// The Status and TrackingNumber values for a Snow device being returned to Amazon Web Services for a particular job.
        public var inboundShipment: SnowballClientTypes.Shipment?
        /// The Status and TrackingNumber values for a Snow device being delivered to the address that you specified for a particular job.
        public var outboundShipment: SnowballClientTypes.Shipment?
        /// The shipping speed for a particular job. This speed doesn't dictate how soon you'll get the Snow device from the job's creation date. This speed represents how quickly it moves to its destination while in transit. Regional shipping speeds are as follows:
        ///
        /// * In Australia, you have access to express shipping. Typically, Snow devices shipped express are delivered in about a day.
        ///
        /// * In the European Union (EU), you have access to express shipping. Typically, Snow devices shipped express are delivered in about a day. In addition, most countries in the EU have access to standard shipping, which typically takes less than a week, one way.
        ///
        /// * In India, Snow devices are delivered in one to seven days.
        ///
        /// * In the United States of America (US), you have access to one-day shipping and two-day shipping.
        public var shippingOption: SnowballClientTypes.ShippingOption?

        public init(
            inboundShipment: SnowballClientTypes.Shipment? = nil,
            outboundShipment: SnowballClientTypes.Shipment? = nil,
            shippingOption: SnowballClientTypes.ShippingOption? = nil
        )
        {
            self.inboundShipment = inboundShipment
            self.outboundShipment = outboundShipment
            self.shippingOption = shippingOption
        }
    }

}

extension SnowballClientTypes {
    public enum ShippingLabelStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [ShippingLabelStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded,
                .timedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .succeeded: return "Succeeded"
            case .timedOut: return "TimedOut"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShippingLabelStatus(rawValue: rawValue) ?? ShippingLabelStatus.sdkUnknown(rawValue)
        }
    }
}

extension SnowballClientTypes {
    public enum ShippingOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case express
        case nextDay
        case secondDay
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [ShippingOption] {
            return [
                .express,
                .nextDay,
                .secondDay,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .express: return "EXPRESS"
            case .nextDay: return "NEXT_DAY"
            case .secondDay: return "SECOND_DAY"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShippingOption(rawValue: rawValue) ?? ShippingOption.sdkUnknown(rawValue)
        }
    }
}

extension SnowballClientTypes {
    public enum SnowballCapacity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case noPreference
        case t100
        case t13
        case t14
        case t240
        case t32
        case t42
        case t50
        case t8
        case t80
        case t98
        case sdkUnknown(Swift.String)

        public static var allCases: [SnowballCapacity] {
            return [
                .noPreference,
                .t100,
                .t13,
                .t14,
                .t240,
                .t32,
                .t42,
                .t50,
                .t8,
                .t80,
                .t98,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .noPreference: return "NoPreference"
            case .t100: return "T100"
            case .t13: return "T13"
            case .t14: return "T14"
            case .t240: return "T240"
            case .t32: return "T32"
            case .t42: return "T42"
            case .t50: return "T50"
            case .t8: return "T8"
            case .t80: return "T80"
            case .t98: return "T98"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SnowballCapacity(rawValue: rawValue) ?? SnowballCapacity.sdkUnknown(rawValue)
        }
    }
}

extension SnowballClientTypes {
    public enum SnowballType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case edge
        case edgeC
        case edgeCg
        case edgeS
        case rack5uC
        case snc1Hdd
        case snc1Ssd
        case standard
        case v35c
        case v35s
        case sdkUnknown(Swift.String)

        public static var allCases: [SnowballType] {
            return [
                .edge,
                .edgeC,
                .edgeCg,
                .edgeS,
                .rack5uC,
                .snc1Hdd,
                .snc1Ssd,
                .standard,
                .v35c,
                .v35s,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .edge: return "EDGE"
            case .edgeC: return "EDGE_C"
            case .edgeCg: return "EDGE_CG"
            case .edgeS: return "EDGE_S"
            case .rack5uC: return "RACK_5U_C"
            case .snc1Hdd: return "SNC1_HDD"
            case .snc1Ssd: return "SNC1_SSD"
            case .standard: return "STANDARD"
            case .v35c: return "V3_5C"
            case .v35s: return "V3_5S"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SnowballType(rawValue: rawValue) ?? SnowballType.sdkUnknown(rawValue)
        }
    }
}

extension SnowballClientTypes.SnowconeDeviceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case wirelessConnection = "WirelessConnection"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let wirelessConnection = self.wirelessConnection {
            try encodeContainer.encode(wirelessConnection, forKey: .wirelessConnection)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessConnectionDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.WirelessConnection.self, forKey: .wirelessConnection)
        wirelessConnection = wirelessConnectionDecoded
    }
}

extension SnowballClientTypes {
    /// Specifies the device configuration for an Snowcone job.
    public struct SnowconeDeviceConfiguration: Swift.Equatable {
        /// Configures the wireless connection for the Snowcone device.
        public var wirelessConnection: SnowballClientTypes.WirelessConnection?

        public init(
            wirelessConnection: SnowballClientTypes.WirelessConnection? = nil
        )
        {
            self.wirelessConnection = wirelessConnection
        }
    }

}

extension SnowballClientTypes {
    public enum StorageUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case tb
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageUnit] {
            return [
                .tb,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .tb: return "TB"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StorageUnit(rawValue: rawValue) ?? StorageUnit.sdkUnknown(rawValue)
        }
    }
}

extension SnowballClientTypes.TGWOnDeviceServiceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storageLimit = "StorageLimit"
        case storageUnit = "StorageUnit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if storageLimit != 0 {
            try encodeContainer.encode(storageLimit, forKey: .storageLimit)
        }
        if let storageUnit = self.storageUnit {
            try encodeContainer.encode(storageUnit.rawValue, forKey: .storageUnit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storageLimit) ?? 0
        storageLimit = storageLimitDecoded
        let storageUnitDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.StorageUnit.self, forKey: .storageUnit)
        storageUnit = storageUnitDecoded
    }
}

extension SnowballClientTypes {
    /// An object that represents the metadata and configuration settings for the Storage Gateway service Tape Gateway type on an Amazon Web Services Snow Family device.
    public struct TGWOnDeviceServiceConfiguration: Swift.Equatable {
        /// The maximum number of virtual tapes to store on one Snow Family device. Due to physical resource limitations, this value must be set to 80 for Snowball Edge.
        public var storageLimit: Swift.Int
        /// The scale unit of the virtual tapes on the device.
        public var storageUnit: SnowballClientTypes.StorageUnit?

        public init(
            storageLimit: Swift.Int = 0,
            storageUnit: SnowballClientTypes.StorageUnit? = nil
        )
        {
            self.storageLimit = storageLimit
            self.storageUnit = storageUnit
        }
    }

}

extension SnowballClientTypes.TargetOnDeviceService: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceName = "ServiceName"
        case transferOption = "TransferOption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName.rawValue, forKey: .serviceName)
        }
        if let transferOption = self.transferOption {
            try encodeContainer.encode(transferOption.rawValue, forKey: .transferOption)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.DeviceServiceName.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let transferOptionDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.TransferOption.self, forKey: .transferOption)
        transferOption = transferOptionDecoded
    }
}

extension SnowballClientTypes {
    /// An object that represents the service or services on the Snow Family device that your transferred data will be exported from or imported into. Amazon Web Services Snow Family supports Amazon S3 and NFS (Network File System).
    public struct TargetOnDeviceService: Swift.Equatable {
        /// Specifies the name of the service on the Snow Family device that your transferred data will be exported from or imported into.
        public var serviceName: SnowballClientTypes.DeviceServiceName?
        /// Specifies whether the data is being imported or exported. You can import or export the data, or use it locally on the device.
        public var transferOption: SnowballClientTypes.TransferOption?

        public init(
            serviceName: SnowballClientTypes.DeviceServiceName? = nil,
            transferOption: SnowballClientTypes.TransferOption? = nil
        )
        {
            self.serviceName = serviceName
            self.transferOption = transferOption
        }
    }

}

extension SnowballClientTypes.TaxDocuments: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ind = "IND"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ind = self.ind {
            try encodeContainer.encode(ind, forKey: .ind)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let indDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.INDTaxDocuments.self, forKey: .ind)
        ind = indDecoded
    }
}

extension SnowballClientTypes {
    /// The tax documents required in your Amazon Web Services Region.
    public struct TaxDocuments: Swift.Equatable {
        /// The tax documents required in Amazon Web Services Region in India.
        public var ind: SnowballClientTypes.INDTaxDocuments?

        public init(
            ind: SnowballClientTypes.INDTaxDocuments? = nil
        )
        {
            self.ind = ind
        }
    }

}

extension SnowballClientTypes {
    public enum TransferOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case export
        case `import`
        case localUse
        case sdkUnknown(Swift.String)

        public static var allCases: [TransferOption] {
            return [
                .export,
                .import,
                .localUse,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .export: return "EXPORT"
            case .import: return "IMPORT"
            case .localUse: return "LOCAL_USE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TransferOption(rawValue: rawValue) ?? TransferOption.sdkUnknown(rawValue)
        }
    }
}

extension UnsupportedAddressException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnsupportedAddressExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The address is either outside the serviceable area for your region, or an error occurred. Check the address with your region's carrier and try again. If the issue persists, contact Amazon Web Services Support.
public struct UnsupportedAddressException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedAddressException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnsupportedAddressExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedAddressExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateClusterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
        case clusterId = "ClusterId"
        case description = "Description"
        case forwardingAddressId = "ForwardingAddressId"
        case notification = "Notification"
        case onDeviceServiceConfiguration = "OnDeviceServiceConfiguration"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingOption = "ShippingOption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressId = self.addressId {
            try encodeContainer.encode(addressId, forKey: .addressId)
        }
        if let clusterId = self.clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let forwardingAddressId = self.forwardingAddressId {
            try encodeContainer.encode(forwardingAddressId, forKey: .forwardingAddressId)
        }
        if let notification = self.notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let onDeviceServiceConfiguration = self.onDeviceServiceConfiguration {
            try encodeContainer.encode(onDeviceServiceConfiguration, forKey: .onDeviceServiceConfiguration)
        }
        if let resources = self.resources {
            try encodeContainer.encode(resources, forKey: .resources)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
        if let shippingOption = self.shippingOption {
            try encodeContainer.encode(shippingOption.rawValue, forKey: .shippingOption)
        }
    }
}

extension UpdateClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateClusterInput: Swift.Equatable {
    /// The ID of the updated [Address] object.
    public var addressId: Swift.String?
    /// The cluster ID of the cluster that you want to update, for example CID123e4567-e89b-12d3-a456-426655440000.
    /// This member is required.
    public var clusterId: Swift.String?
    /// The updated description of this cluster.
    public var description: Swift.String?
    /// The updated ID for the forwarding address for a cluster. This field is not supported in most regions.
    public var forwardingAddressId: Swift.String?
    /// The new or updated [Notification] object.
    public var notification: SnowballClientTypes.Notification?
    /// Specifies the service or services on the Snow Family device that your transferred data will be exported from or imported into. Amazon Web Services Snow Family device clusters support Amazon S3 and NFS (Network File System).
    public var onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration?
    /// The updated arrays of [JobResource] objects that can include updated [S3Resource] objects or [LambdaResource] objects.
    public var resources: SnowballClientTypes.JobResource?
    /// The new role Amazon Resource Name (ARN) that you want to associate with this cluster. To create a role ARN, use the [CreateRole](https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html) API action in Identity and Access Management (IAM).
    public var roleARN: Swift.String?
    /// The updated shipping option value of this cluster's [ShippingDetails] object.
    public var shippingOption: SnowballClientTypes.ShippingOption?

    public init(
        addressId: Swift.String? = nil,
        clusterId: Swift.String? = nil,
        description: Swift.String? = nil,
        forwardingAddressId: Swift.String? = nil,
        notification: SnowballClientTypes.Notification? = nil,
        onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration? = nil,
        resources: SnowballClientTypes.JobResource? = nil,
        roleARN: Swift.String? = nil,
        shippingOption: SnowballClientTypes.ShippingOption? = nil
    )
    {
        self.addressId = addressId
        self.clusterId = clusterId
        self.description = description
        self.forwardingAddressId = forwardingAddressId
        self.notification = notification
        self.onDeviceServiceConfiguration = onDeviceServiceConfiguration
        self.resources = resources
        self.roleARN = roleARN
        self.shippingOption = shippingOption
    }
}

struct UpdateClusterInputBody: Swift.Equatable {
    let clusterId: Swift.String?
    let roleARN: Swift.String?
    let description: Swift.String?
    let resources: SnowballClientTypes.JobResource?
    let onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration?
    let addressId: Swift.String?
    let shippingOption: SnowballClientTypes.ShippingOption?
    let notification: SnowballClientTypes.Notification?
    let forwardingAddressId: Swift.String?
}

extension UpdateClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
        case clusterId = "ClusterId"
        case description = "Description"
        case forwardingAddressId = "ForwardingAddressId"
        case notification = "Notification"
        case onDeviceServiceConfiguration = "OnDeviceServiceConfiguration"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingOption = "ShippingOption"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let resourcesDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobResource.self, forKey: .resources)
        resources = resourcesDecoded
        let onDeviceServiceConfigurationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.OnDeviceServiceConfiguration.self, forKey: .onDeviceServiceConfiguration)
        onDeviceServiceConfiguration = onDeviceServiceConfigurationDecoded
        let addressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressId)
        addressId = addressIdDecoded
        let shippingOptionDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ShippingOption.self, forKey: .shippingOption)
        shippingOption = shippingOptionDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
        let forwardingAddressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forwardingAddressId)
        forwardingAddressId = forwardingAddressIdDecoded
    }
}

extension UpdateClusterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateClusterOutput: Swift.Equatable {

    public init() { }
}

enum UpdateClusterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "Ec2RequestFailedException": return try await Ec2RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputCombinationException": return try await InvalidInputCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidJobStateException": return try await InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceException": return try await InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSRequestFailedException": return try await KMSRequestFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
        case description = "Description"
        case forwardingAddressId = "ForwardingAddressId"
        case jobId = "JobId"
        case notification = "Notification"
        case onDeviceServiceConfiguration = "OnDeviceServiceConfiguration"
        case pickupDetails = "PickupDetails"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingOption = "ShippingOption"
        case snowballCapacityPreference = "SnowballCapacityPreference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressId = self.addressId {
            try encodeContainer.encode(addressId, forKey: .addressId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let forwardingAddressId = self.forwardingAddressId {
            try encodeContainer.encode(forwardingAddressId, forKey: .forwardingAddressId)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let notification = self.notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let onDeviceServiceConfiguration = self.onDeviceServiceConfiguration {
            try encodeContainer.encode(onDeviceServiceConfiguration, forKey: .onDeviceServiceConfiguration)
        }
        if let pickupDetails = self.pickupDetails {
            try encodeContainer.encode(pickupDetails, forKey: .pickupDetails)
        }
        if let resources = self.resources {
            try encodeContainer.encode(resources, forKey: .resources)
        }
        if let roleARN = self.roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
        if let shippingOption = self.shippingOption {
            try encodeContainer.encode(shippingOption.rawValue, forKey: .shippingOption)
        }
        if let snowballCapacityPreference = self.snowballCapacityPreference {
            try encodeContainer.encode(snowballCapacityPreference.rawValue, forKey: .snowballCapacityPreference)
        }
    }
}

extension UpdateJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateJobInput: Swift.Equatable {
    /// The ID of the updated [Address] object.
    public var addressId: Swift.String?
    /// The updated description of this job's [JobMetadata] object.
    public var description: Swift.String?
    /// The updated ID for the forwarding address for a job. This field is not supported in most regions.
    public var forwardingAddressId: Swift.String?
    /// The job ID of the job that you want to update, for example JID123e4567-e89b-12d3-a456-426655440000.
    /// This member is required.
    public var jobId: Swift.String?
    /// The new or updated [Notification] object.
    public var notification: SnowballClientTypes.Notification?
    /// Specifies the service or services on the Snow Family device that your transferred data will be exported from or imported into. Amazon Web Services Snow Family supports Amazon S3 and NFS (Network File System) and the Amazon Web Services Storage Gateway service Tape Gateway type.
    public var onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration?
    /// Information identifying the person picking up the device.
    public var pickupDetails: SnowballClientTypes.PickupDetails?
    /// The updated JobResource object, or the updated [JobResource] object.
    public var resources: SnowballClientTypes.JobResource?
    /// The new role Amazon Resource Name (ARN) that you want to associate with this job. To create a role ARN, use the [CreateRole](https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html)Identity and Access Management (IAM) API action.
    public var roleARN: Swift.String?
    /// The updated shipping option value of this job's [ShippingDetails] object.
    public var shippingOption: SnowballClientTypes.ShippingOption?
    /// The updated SnowballCapacityPreference of this job's [JobMetadata] object. The 50 TB Snowballs are only available in the US regions. For more information, see "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide or "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide.
    public var snowballCapacityPreference: SnowballClientTypes.SnowballCapacity?

    public init(
        addressId: Swift.String? = nil,
        description: Swift.String? = nil,
        forwardingAddressId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        notification: SnowballClientTypes.Notification? = nil,
        onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration? = nil,
        pickupDetails: SnowballClientTypes.PickupDetails? = nil,
        resources: SnowballClientTypes.JobResource? = nil,
        roleARN: Swift.String? = nil,
        shippingOption: SnowballClientTypes.ShippingOption? = nil,
        snowballCapacityPreference: SnowballClientTypes.SnowballCapacity? = nil
    )
    {
        self.addressId = addressId
        self.description = description
        self.forwardingAddressId = forwardingAddressId
        self.jobId = jobId
        self.notification = notification
        self.onDeviceServiceConfiguration = onDeviceServiceConfiguration
        self.pickupDetails = pickupDetails
        self.resources = resources
        self.roleARN = roleARN
        self.shippingOption = shippingOption
        self.snowballCapacityPreference = snowballCapacityPreference
    }
}

struct UpdateJobInputBody: Swift.Equatable {
    let jobId: Swift.String?
    let roleARN: Swift.String?
    let notification: SnowballClientTypes.Notification?
    let resources: SnowballClientTypes.JobResource?
    let onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration?
    let addressId: Swift.String?
    let shippingOption: SnowballClientTypes.ShippingOption?
    let description: Swift.String?
    let snowballCapacityPreference: SnowballClientTypes.SnowballCapacity?
    let forwardingAddressId: Swift.String?
    let pickupDetails: SnowballClientTypes.PickupDetails?
}

extension UpdateJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressId = "AddressId"
        case description = "Description"
        case forwardingAddressId = "ForwardingAddressId"
        case jobId = "JobId"
        case notification = "Notification"
        case onDeviceServiceConfiguration = "OnDeviceServiceConfiguration"
        case pickupDetails = "PickupDetails"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingOption = "ShippingOption"
        case snowballCapacityPreference = "SnowballCapacityPreference"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
        let resourcesDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.JobResource.self, forKey: .resources)
        resources = resourcesDecoded
        let onDeviceServiceConfigurationDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.OnDeviceServiceConfiguration.self, forKey: .onDeviceServiceConfiguration)
        onDeviceServiceConfiguration = onDeviceServiceConfigurationDecoded
        let addressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressId)
        addressId = addressIdDecoded
        let shippingOptionDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ShippingOption.self, forKey: .shippingOption)
        shippingOption = shippingOptionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let snowballCapacityPreferenceDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.SnowballCapacity.self, forKey: .snowballCapacityPreference)
        snowballCapacityPreference = snowballCapacityPreferenceDecoded
        let forwardingAddressIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .forwardingAddressId)
        forwardingAddressId = forwardingAddressIdDecoded
        let pickupDetailsDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.PickupDetails.self, forKey: .pickupDetails)
        pickupDetails = pickupDetailsDecoded
    }
}

extension UpdateJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateJobOutput: Swift.Equatable {

    public init() { }
}

enum UpdateJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClusterLimitExceededException": return try await ClusterLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "Ec2RequestFailedException": return try await Ec2RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidInputCombinationException": return try await InvalidInputCombinationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidJobStateException": return try await InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceException": return try await InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KMSRequestFailedException": return try await KMSRequestFailedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateJobShipmentStateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case shipmentState = "ShipmentState"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let shipmentState = self.shipmentState {
            try encodeContainer.encode(shipmentState.rawValue, forKey: .shipmentState)
        }
    }
}

extension UpdateJobShipmentStateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateJobShipmentStateInput: Swift.Equatable {
    /// The job ID of the job whose shipment date you want to update, for example JID123e4567-e89b-12d3-a456-426655440000.
    /// This member is required.
    public var jobId: Swift.String?
    /// The state of a device when it is being shipped. Set to RECEIVED when the device arrives at your location. Set to RETURNED when you have returned the device to Amazon Web Services.
    /// This member is required.
    public var shipmentState: SnowballClientTypes.ShipmentState?

    public init(
        jobId: Swift.String? = nil,
        shipmentState: SnowballClientTypes.ShipmentState? = nil
    )
    {
        self.jobId = jobId
        self.shipmentState = shipmentState
    }
}

struct UpdateJobShipmentStateInputBody: Swift.Equatable {
    let jobId: Swift.String?
    let shipmentState: SnowballClientTypes.ShipmentState?
}

extension UpdateJobShipmentStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case shipmentState = "ShipmentState"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let shipmentStateDecoded = try containerValues.decodeIfPresent(SnowballClientTypes.ShipmentState.self, forKey: .shipmentState)
        shipmentState = shipmentStateDecoded
    }
}

extension UpdateJobShipmentStateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateJobShipmentStateOutput: Swift.Equatable {

    public init() { }
}

enum UpdateJobShipmentStateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidJobStateException": return try await InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceException": return try await InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateLongTermPricingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isLongTermPricingAutoRenew = "IsLongTermPricingAutoRenew"
        case longTermPricingId = "LongTermPricingId"
        case replacementJob = "ReplacementJob"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isLongTermPricingAutoRenew = self.isLongTermPricingAutoRenew {
            try encodeContainer.encode(isLongTermPricingAutoRenew, forKey: .isLongTermPricingAutoRenew)
        }
        if let longTermPricingId = self.longTermPricingId {
            try encodeContainer.encode(longTermPricingId, forKey: .longTermPricingId)
        }
        if let replacementJob = self.replacementJob {
            try encodeContainer.encode(replacementJob, forKey: .replacementJob)
        }
    }
}

extension UpdateLongTermPricingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateLongTermPricingInput: Swift.Equatable {
    /// If set to true, specifies that the current long-term pricing type for the device should be automatically renewed before the long-term pricing contract expires.
    public var isLongTermPricingAutoRenew: Swift.Bool?
    /// The ID of the long-term pricing type for the device.
    /// This member is required.
    public var longTermPricingId: Swift.String?
    /// Specifies that a device that is ordered with long-term pricing should be replaced with a new device.
    public var replacementJob: Swift.String?

    public init(
        isLongTermPricingAutoRenew: Swift.Bool? = nil,
        longTermPricingId: Swift.String? = nil,
        replacementJob: Swift.String? = nil
    )
    {
        self.isLongTermPricingAutoRenew = isLongTermPricingAutoRenew
        self.longTermPricingId = longTermPricingId
        self.replacementJob = replacementJob
    }
}

struct UpdateLongTermPricingInputBody: Swift.Equatable {
    let longTermPricingId: Swift.String?
    let replacementJob: Swift.String?
    let isLongTermPricingAutoRenew: Swift.Bool?
}

extension UpdateLongTermPricingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isLongTermPricingAutoRenew = "IsLongTermPricingAutoRenew"
        case longTermPricingId = "LongTermPricingId"
        case replacementJob = "ReplacementJob"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let longTermPricingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .longTermPricingId)
        longTermPricingId = longTermPricingIdDecoded
        let replacementJobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replacementJob)
        replacementJob = replacementJobDecoded
        let isLongTermPricingAutoRenewDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isLongTermPricingAutoRenew)
        isLongTermPricingAutoRenew = isLongTermPricingAutoRenewDecoded
    }
}

extension UpdateLongTermPricingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateLongTermPricingOutput: Swift.Equatable {

    public init() { }
}

enum UpdateLongTermPricingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidResourceException": return try await InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SnowballClientTypes.WirelessConnection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isWifiEnabled = "IsWifiEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isWifiEnabled != false {
            try encodeContainer.encode(isWifiEnabled, forKey: .isWifiEnabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isWifiEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isWifiEnabled) ?? false
        isWifiEnabled = isWifiEnabledDecoded
    }
}

extension SnowballClientTypes {
    /// Configures the wireless connection on an Snowcone device.
    public struct WirelessConnection: Swift.Equatable {
        /// Enables the Wi-Fi adapter on an Snowcone device.
        public var isWifiEnabled: Swift.Bool

        public init(
            isWifiEnabled: Swift.Bool = false
        )
        {
            self.isWifiEnabled = isWifiEnabled
        }
    }

}
