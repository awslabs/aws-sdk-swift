//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

extension SnowballClientTypes {

    public enum AddressType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsShip
        case custPickup
        case sdkUnknown(Swift.String)

        public static var allCases: [AddressType] {
            return [
                .awsShip,
                .custPickup
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsShip: return "AWS_SHIP"
            case .custPickup: return "CUST_PICKUP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SnowballClientTypes {

    /// The address that you want the Snow device(s) associated with a specific job to be shipped to. Addresses are validated at the time of creation. The address you provide must be located within the serviceable area of your region. Although no individual elements of the Address are required, if the address is invalid or unsupported, then an exception is thrown.
    public struct Address: Swift.Sendable {
        /// The unique ID for an address.
        public var addressId: Swift.String?
        /// The city in an address that a Snow device is to be delivered to.
        public var city: Swift.String?
        /// The name of the company to receive a Snow device at an address.
        public var company: Swift.String?
        /// The country in an address that a Snow device is to be delivered to.
        public var country: Swift.String?
        /// If the address you are creating is a primary address, then set this option to true. This field is not supported in most regions.
        public var isRestricted: Swift.Bool
        /// This field is no longer used and the value is ignored.
        public var landmark: Swift.String?
        /// The name of a person to receive a Snow device at an address.
        public var name: Swift.String?
        /// The phone number associated with an address that a Snow device is to be delivered to.
        public var phoneNumber: Swift.String?
        /// The postal code in an address that a Snow device is to be delivered to.
        public var postalCode: Swift.String?
        /// This field is no longer used and the value is ignored.
        public var prefectureOrDistrict: Swift.String?
        /// The state or province in an address that a Snow device is to be delivered to.
        public var stateOrProvince: Swift.String?
        /// The first line in a street address that a Snow device is to be delivered to.
        public var street1: Swift.String?
        /// The second line in a street address that a Snow device is to be delivered to.
        public var street2: Swift.String?
        /// The third line in a street address that a Snow device is to be delivered to.
        public var street3: Swift.String?
        /// Differentiates between delivery address and pickup address in the customer account. Provided at job creation.
        public var type: SnowballClientTypes.AddressType?

        public init(
            addressId: Swift.String? = nil,
            city: Swift.String? = nil,
            company: Swift.String? = nil,
            country: Swift.String? = nil,
            isRestricted: Swift.Bool = false,
            landmark: Swift.String? = nil,
            name: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            postalCode: Swift.String? = nil,
            prefectureOrDistrict: Swift.String? = nil,
            stateOrProvince: Swift.String? = nil,
            street1: Swift.String? = nil,
            street2: Swift.String? = nil,
            street3: Swift.String? = nil,
            type: SnowballClientTypes.AddressType? = nil
        )
        {
            self.addressId = addressId
            self.city = city
            self.company = company
            self.country = country
            self.isRestricted = isRestricted
            self.landmark = landmark
            self.name = name
            self.phoneNumber = phoneNumber
            self.postalCode = postalCode
            self.prefectureOrDistrict = prefectureOrDistrict
            self.stateOrProvince = stateOrProvince
            self.street1 = street1
            self.street2 = street2
            self.street3 = street3
            self.type = type
        }
    }
}

/// The action can't be performed because the job's current state doesn't allow that action to be performed.
public struct InvalidJobStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidJobStateException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified resource can't be found. Check the information you provided in your last request, and try again.
public struct InvalidResourceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The provided resource value is invalid.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResourceException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceType = resourceType
    }
}

/// The provided Key Management Service key lacks the permissions to perform the specified [CreateJob] or [UpdateJob] action.
public struct KMSRequestFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSRequestFailedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CancelClusterInput: Swift.Sendable {
    /// The 39-character ID for the cluster that you want to cancel, for example CID123e4567-e89b-12d3-a456-426655440000.
    /// This member is required.
    public var clusterId: Swift.String?

    public init(
        clusterId: Swift.String? = nil
    )
    {
        self.clusterId = clusterId
    }
}

public struct CancelClusterOutput: Swift.Sendable {

    public init() { }
}

public struct CancelJobInput: Swift.Sendable {
    /// The 39-character job ID for the job that you want to cancel, for example JID123e4567-e89b-12d3-a456-426655440000.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

public struct CancelJobOutput: Swift.Sendable {

    public init() { }
}

/// The address provided was invalid. Check the address with your region's carrier, and try again.
public struct InvalidAddressException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidAddressException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The address is either outside the serviceable area for your region, or an error occurred. Check the address with your region's carrier and try again. If the issue persists, contact Amazon Web Services Support.
public struct UnsupportedAddressException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedAddressException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateAddressInput: Swift.Sendable {
    /// The address that you want the Snow device shipped to.
    /// This member is required.
    public var address: SnowballClientTypes.Address?

    public init(
        address: SnowballClientTypes.Address? = nil
    )
    {
        self.address = address
    }
}

public struct CreateAddressOutput: Swift.Sendable {
    /// The automatically generated ID for a specific address. You'll use this ID when you create a job to specify which address you want the Snow device for that job shipped to.
    public var addressId: Swift.String?

    public init(
        addressId: Swift.String? = nil
    )
    {
        self.addressId = addressId
    }
}

/// Your user lacks the necessary Amazon EC2 permissions to perform the attempted action.
public struct Ec2RequestFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "Ec2RequestFailedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Job or cluster creation failed. One or more inputs were invalid. Confirm that the [CreateClusterRequest$SnowballType] value supports your [CreateJobRequest$JobType], and try again.
public struct InvalidInputCombinationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidInputCombinationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SnowballClientTypes {

    public enum JobType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case export
        case `import`
        case localUse
        case sdkUnknown(Swift.String)

        public static var allCases: [JobType] {
            return [
                .export,
                .import,
                .localUse
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .export: return "EXPORT"
            case .import: return "IMPORT"
            case .localUse: return "LOCAL_USE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SnowballClientTypes {

    public enum JobState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case complete
        case inProgress
        case inTransitToAws
        case inTransitToCustomer
        case listing
        case new
        case pending
        case preparingAppliance
        case preparingShipment
        case withAws
        case withAwsSortingFacility
        case withCustomer
        case sdkUnknown(Swift.String)

        public static var allCases: [JobState] {
            return [
                .cancelled,
                .complete,
                .inProgress,
                .inTransitToAws,
                .inTransitToCustomer,
                .listing,
                .new,
                .pending,
                .preparingAppliance,
                .preparingShipment,
                .withAws,
                .withAwsSortingFacility,
                .withCustomer
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "Cancelled"
            case .complete: return "Complete"
            case .inProgress: return "InProgress"
            case .inTransitToAws: return "InTransitToAWS"
            case .inTransitToCustomer: return "InTransitToCustomer"
            case .listing: return "Listing"
            case .new: return "New"
            case .pending: return "Pending"
            case .preparingAppliance: return "PreparingAppliance"
            case .preparingShipment: return "PreparingShipment"
            case .withAws: return "WithAWS"
            case .withAwsSortingFacility: return "WithAWSSortingFacility"
            case .withCustomer: return "WithCustomer"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SnowballClientTypes {

    /// The Amazon Simple Notification Service (Amazon SNS) notification settings associated with a specific job. The Notification object is returned as a part of the response syntax of the DescribeJob action in the JobMetadata data type. When the notification settings are defined during job creation, you can choose to notify based on a specific set of job states using the JobStatesToNotify array of strings, or you can specify that you want to have Amazon SNS notifications sent out for all job states with NotifyAll set to true.
    public struct Notification: Swift.Sendable {
        /// Used to send SNS notifications for the person picking up the device (identified during job creation).
        public var devicePickupSnsTopicARN: Swift.String?
        /// The list of job states that will trigger a notification for this job.
        public var jobStatesToNotify: [SnowballClientTypes.JobState]?
        /// Any change in job state will trigger a notification for this job.
        public var notifyAll: Swift.Bool
        /// The new SNS TopicArn that you want to associate with this job. You can create Amazon Resource Names (ARNs) for topics by using the [CreateTopic](https://docs.aws.amazon.com/sns/latest/api/API_CreateTopic.html) Amazon SNS API action. You can subscribe email addresses to an Amazon SNS topic through the Amazon Web Services Management Console, or by using the [Subscribe](https://docs.aws.amazon.com/sns/latest/api/API_Subscribe.html) Amazon Simple Notification Service (Amazon SNS) API action.
        public var snsTopicARN: Swift.String?

        public init(
            devicePickupSnsTopicARN: Swift.String? = nil,
            jobStatesToNotify: [SnowballClientTypes.JobState]? = nil,
            notifyAll: Swift.Bool = false,
            snsTopicARN: Swift.String? = nil
        )
        {
            self.devicePickupSnsTopicARN = devicePickupSnsTopicARN
            self.jobStatesToNotify = jobStatesToNotify
            self.notifyAll = notifyAll
            self.snsTopicARN = snsTopicARN
        }
    }
}

extension SnowballClientTypes {

    /// An object representing the metadata and configuration settings of EKS Anywhere on the Snow Family device.
    public struct EKSOnDeviceServiceConfiguration: Swift.Sendable {
        /// The optional version of EKS Anywhere on the Snow Family device.
        public var eksAnywhereVersion: Swift.String?
        /// The Kubernetes version for EKS Anywhere on the Snow Family device.
        public var kubernetesVersion: Swift.String?

        public init(
            eksAnywhereVersion: Swift.String? = nil,
            kubernetesVersion: Swift.String? = nil
        )
        {
            self.eksAnywhereVersion = eksAnywhereVersion
            self.kubernetesVersion = kubernetesVersion
        }
    }
}

extension SnowballClientTypes {

    public enum StorageUnit: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case tb
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageUnit] {
            return [
                .tb
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .tb: return "TB"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SnowballClientTypes {

    /// An object that represents the metadata and configuration settings for the NFS (Network File System) service on an Amazon Web Services Snow Family device.
    public struct NFSOnDeviceServiceConfiguration: Swift.Sendable {
        /// The maximum NFS storage for one Snow Family device.
        public var storageLimit: Swift.Int
        /// The scale unit of the NFS storage on the device. Valid values: TB.
        public var storageUnit: SnowballClientTypes.StorageUnit?

        public init(
            storageLimit: Swift.Int = 0,
            storageUnit: SnowballClientTypes.StorageUnit? = nil
        )
        {
            self.storageLimit = storageLimit
            self.storageUnit = storageUnit
        }
    }
}

extension SnowballClientTypes {

    /// Amazon S3 compatible storage on Snow family devices configuration items.
    public struct S3OnDeviceServiceConfiguration: Swift.Sendable {
        /// >Fault tolerance level of the cluster. This indicates the number of nodes that can go down without degrading the performance of the cluster. This additional input helps when the specified StorageLimit matches more than one Amazon S3 compatible storage on Snow family devices service configuration.
        public var faultTolerance: Swift.Int?
        /// Applicable when creating a cluster. Specifies how many nodes are needed for Amazon S3 compatible storage on Snow family devices. If specified, the other input can be omitted.
        public var serviceSize: Swift.Int?
        /// If the specified storage limit value matches storage limit of one of the defined configurations, that configuration will be used. If the specified storage limit value does not match any defined configuration, the request will fail. If more than one configuration has the same storage limit as specified, the other input need to be provided.
        public var storageLimit: Swift.Double?
        /// Storage unit. Currently the only supported unit is TB.
        public var storageUnit: SnowballClientTypes.StorageUnit?

        public init(
            faultTolerance: Swift.Int? = nil,
            serviceSize: Swift.Int? = nil,
            storageLimit: Swift.Double? = nil,
            storageUnit: SnowballClientTypes.StorageUnit? = nil
        )
        {
            self.faultTolerance = faultTolerance
            self.serviceSize = serviceSize
            self.storageLimit = storageLimit
            self.storageUnit = storageUnit
        }
    }
}

extension SnowballClientTypes {

    /// An object that represents the metadata and configuration settings for the Storage Gateway service Tape Gateway type on an Amazon Web Services Snow Family device.
    public struct TGWOnDeviceServiceConfiguration: Swift.Sendable {
        /// The maximum number of virtual tapes to store on one Snow Family device. Due to physical resource limitations, this value must be set to 80 for Snowball Edge.
        public var storageLimit: Swift.Int
        /// The scale unit of the virtual tapes on the device.
        public var storageUnit: SnowballClientTypes.StorageUnit?

        public init(
            storageLimit: Swift.Int = 0,
            storageUnit: SnowballClientTypes.StorageUnit? = nil
        )
        {
            self.storageLimit = storageLimit
            self.storageUnit = storageUnit
        }
    }
}

extension SnowballClientTypes {

    /// An object that represents the metadata and configuration settings for services on an Amazon Web Services Snow Family device.
    public struct OnDeviceServiceConfiguration: Swift.Sendable {
        /// The configuration of EKS Anywhere on the Snow Family device.
        public var eksOnDeviceService: SnowballClientTypes.EKSOnDeviceServiceConfiguration?
        /// Represents the NFS (Network File System) service on a Snow Family device.
        public var nfsOnDeviceService: SnowballClientTypes.NFSOnDeviceServiceConfiguration?
        /// Configuration for Amazon S3 compatible storage on Snow family devices.
        public var s3OnDeviceService: SnowballClientTypes.S3OnDeviceServiceConfiguration?
        /// Represents the Storage Gateway service Tape Gateway type on a Snow Family device.
        public var tgwOnDeviceService: SnowballClientTypes.TGWOnDeviceServiceConfiguration?

        public init(
            eksOnDeviceService: SnowballClientTypes.EKSOnDeviceServiceConfiguration? = nil,
            nfsOnDeviceService: SnowballClientTypes.NFSOnDeviceServiceConfiguration? = nil,
            s3OnDeviceService: SnowballClientTypes.S3OnDeviceServiceConfiguration? = nil,
            tgwOnDeviceService: SnowballClientTypes.TGWOnDeviceServiceConfiguration? = nil
        )
        {
            self.eksOnDeviceService = eksOnDeviceService
            self.nfsOnDeviceService = nfsOnDeviceService
            self.s3OnDeviceService = s3OnDeviceService
            self.tgwOnDeviceService = tgwOnDeviceService
        }
    }
}

extension SnowballClientTypes {

    public enum RemoteManagement: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case installedAutostart
        case installedOnly
        case notInstalled
        case sdkUnknown(Swift.String)

        public static var allCases: [RemoteManagement] {
            return [
                .installedAutostart,
                .installedOnly,
                .notInstalled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .installedAutostart: return "INSTALLED_AUTOSTART"
            case .installedOnly: return "INSTALLED_ONLY"
            case .notInstalled: return "NOT_INSTALLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SnowballClientTypes {

    /// A JSON-formatted object that contains the IDs for an Amazon Machine Image (AMI), including the Amazon EC2-compatible AMI ID and the Snow device AMI ID. Each AMI has these two IDs to simplify identifying the AMI in both the Amazon Web Services Cloud and on the device.
    public struct Ec2AmiResource: Swift.Sendable {
        /// The ID of the AMI in Amazon EC2.
        /// This member is required.
        public var amiId: Swift.String?
        /// The ID of the AMI on the Snow device.
        public var snowballAmiId: Swift.String?

        public init(
            amiId: Swift.String? = nil,
            snowballAmiId: Swift.String? = nil
        )
        {
            self.amiId = amiId
            self.snowballAmiId = snowballAmiId
        }
    }
}

extension SnowballClientTypes {

    /// The container for the [EventTriggerDefinition$EventResourceARN].
    public struct EventTriggerDefinition: Swift.Sendable {
        /// The Amazon Resource Name (ARN) for any local Amazon S3 resource that is an Lambda function's event trigger associated with this job.
        public var eventResourceARN: Swift.String?

        public init(
            eventResourceARN: Swift.String? = nil
        )
        {
            self.eventResourceARN = eventResourceARN
        }
    }
}

extension SnowballClientTypes {

    /// Identifies
    public struct LambdaResource: Swift.Sendable {
        /// The array of ARNs for [S3Resource] objects to trigger the [LambdaResource] objects associated with this job.
        public var eventTriggers: [SnowballClientTypes.EventTriggerDefinition]?
        /// An Amazon Resource Name (ARN) that represents an Lambda function to be triggered by PUT object actions on the associated local Amazon S3 resource.
        public var lambdaArn: Swift.String?

        public init(
            eventTriggers: [SnowballClientTypes.EventTriggerDefinition]? = nil,
            lambdaArn: Swift.String? = nil
        )
        {
            self.eventTriggers = eventTriggers
            self.lambdaArn = lambdaArn
        }
    }
}

extension SnowballClientTypes {

    /// Contains a key range. For export jobs, a S3Resource object can have an optional KeyRange value. The length of the range is defined at job creation, and has either an inclusive BeginMarker, an inclusive EndMarker, or both. Ranges are UTF-8 binary sorted.
    public struct KeyRange: Swift.Sendable {
        /// The key that starts an optional key range for an export job. Ranges are inclusive and UTF-8 binary sorted.
        public var beginMarker: Swift.String?
        /// The key that ends an optional key range for an export job. Ranges are inclusive and UTF-8 binary sorted.
        public var endMarker: Swift.String?

        public init(
            beginMarker: Swift.String? = nil,
            endMarker: Swift.String? = nil
        )
        {
            self.beginMarker = beginMarker
            self.endMarker = endMarker
        }
    }
}

extension SnowballClientTypes {

    public enum DeviceServiceName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case nfsOnDeviceService
        case s3OnDeviceService
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceServiceName] {
            return [
                .nfsOnDeviceService,
                .s3OnDeviceService
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .nfsOnDeviceService: return "NFS_ON_DEVICE_SERVICE"
            case .s3OnDeviceService: return "S3_ON_DEVICE_SERVICE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SnowballClientTypes {

    public enum TransferOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case export
        case `import`
        case localUse
        case sdkUnknown(Swift.String)

        public static var allCases: [TransferOption] {
            return [
                .export,
                .import,
                .localUse
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .export: return "EXPORT"
            case .import: return "IMPORT"
            case .localUse: return "LOCAL_USE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SnowballClientTypes {

    /// An object that represents the service or services on the Snow Family device that your transferred data will be exported from or imported into. Amazon Web Services Snow Family supports Amazon S3 and NFS (Network File System).
    public struct TargetOnDeviceService: Swift.Sendable {
        /// Specifies the name of the service on the Snow Family device that your transferred data will be exported from or imported into.
        public var serviceName: SnowballClientTypes.DeviceServiceName?
        /// Specifies whether the data is being imported or exported. You can import or export the data, or use it locally on the device.
        public var transferOption: SnowballClientTypes.TransferOption?

        public init(
            serviceName: SnowballClientTypes.DeviceServiceName? = nil,
            transferOption: SnowballClientTypes.TransferOption? = nil
        )
        {
            self.serviceName = serviceName
            self.transferOption = transferOption
        }
    }
}

extension SnowballClientTypes {

    /// Each S3Resource object represents an Amazon S3 bucket that your transferred data will be exported from or imported into. For export jobs, this object can have an optional KeyRange value. The length of the range is defined at job creation, and has either an inclusive BeginMarker, an inclusive EndMarker, or both. Ranges are UTF-8 binary sorted.
    public struct S3Resource: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of an Amazon S3 bucket.
        public var bucketArn: Swift.String?
        /// For export jobs, you can provide an optional KeyRange within a specific Amazon S3 bucket. The length of the range is defined at job creation, and has either an inclusive BeginMarker, an inclusive EndMarker, or both. Ranges are UTF-8 binary sorted.
        public var keyRange: SnowballClientTypes.KeyRange?
        /// Specifies the service or services on the Snow Family device that your transferred data will be exported from or imported into. Amazon Web Services Snow Family supports Amazon S3 and NFS (Network File System).
        public var targetOnDeviceServices: [SnowballClientTypes.TargetOnDeviceService]?

        public init(
            bucketArn: Swift.String? = nil,
            keyRange: SnowballClientTypes.KeyRange? = nil,
            targetOnDeviceServices: [SnowballClientTypes.TargetOnDeviceService]? = nil
        )
        {
            self.bucketArn = bucketArn
            self.keyRange = keyRange
            self.targetOnDeviceServices = targetOnDeviceServices
        }
    }
}

extension SnowballClientTypes {

    /// Contains an array of Amazon Web Services resource objects. Each object represents an Amazon S3 bucket, an Lambda function, or an Amazon Machine Image (AMI) based on Amazon EC2 that is associated with a particular job.
    public struct JobResource: Swift.Sendable {
        /// The Amazon Machine Images (AMIs) associated with this job.
        public var ec2AmiResources: [SnowballClientTypes.Ec2AmiResource]?
        /// The Python-language Lambda functions for this job.
        public var lambdaResources: [SnowballClientTypes.LambdaResource]?
        /// An array of S3Resource objects.
        public var s3Resources: [SnowballClientTypes.S3Resource]?

        public init(
            ec2AmiResources: [SnowballClientTypes.Ec2AmiResource]? = nil,
            lambdaResources: [SnowballClientTypes.LambdaResource]? = nil,
            s3Resources: [SnowballClientTypes.S3Resource]? = nil
        )
        {
            self.ec2AmiResources = ec2AmiResources
            self.lambdaResources = lambdaResources
            self.s3Resources = s3Resources
        }
    }
}

extension SnowballClientTypes {

    public enum ShippingOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case express
        case nextDay
        case secondDay
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [ShippingOption] {
            return [
                .express,
                .nextDay,
                .secondDay,
                .standard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .express: return "EXPRESS"
            case .nextDay: return "NEXT_DAY"
            case .secondDay: return "SECOND_DAY"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SnowballClientTypes {

    public enum SnowballCapacity: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case noPreference
        case t100
        case t13
        case t14
        case t240
        case t32
        case t42
        case t50
        case t8
        case t80
        case t98
        case sdkUnknown(Swift.String)

        public static var allCases: [SnowballCapacity] {
            return [
                .noPreference,
                .t100,
                .t13,
                .t14,
                .t240,
                .t32,
                .t42,
                .t50,
                .t8,
                .t80,
                .t98
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .noPreference: return "NoPreference"
            case .t100: return "T100"
            case .t13: return "T13"
            case .t14: return "T14"
            case .t240: return "T240"
            case .t32: return "T32"
            case .t42: return "T42"
            case .t50: return "T50"
            case .t8: return "T8"
            case .t80: return "T80"
            case .t98: return "T98"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SnowballClientTypes {

    public enum SnowballType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case edge
        case edgeC
        case edgeCg
        case edgeS
        case rack5uC
        case snc1Hdd
        case snc1Ssd
        case standard
        case v35c
        case v35s
        case sdkUnknown(Swift.String)

        public static var allCases: [SnowballType] {
            return [
                .edge,
                .edgeC,
                .edgeCg,
                .edgeS,
                .rack5uC,
                .snc1Hdd,
                .snc1Ssd,
                .standard,
                .v35c,
                .v35s
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .edge: return "EDGE"
            case .edgeC: return "EDGE_C"
            case .edgeCg: return "EDGE_CG"
            case .edgeS: return "EDGE_S"
            case .rack5uC: return "RACK_5U_C"
            case .snc1Hdd: return "SNC1_HDD"
            case .snc1Ssd: return "SNC1_SSD"
            case .standard: return "STANDARD"
            case .v35c: return "V3_5C"
            case .v35s: return "V3_5S"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SnowballClientTypes {

    /// The tax documents required in Amazon Web Services Region in India.
    public struct INDTaxDocuments: Swift.Sendable {
        /// The Goods and Services Tax (GST) documents required in Amazon Web Services Region in India.
        public var gstin: Swift.String?

        public init(
            gstin: Swift.String? = nil
        )
        {
            self.gstin = gstin
        }
    }
}

extension SnowballClientTypes {

    /// The tax documents required in your Amazon Web Services Region.
    public struct TaxDocuments: Swift.Sendable {
        /// The tax documents required in Amazon Web Services Region in India.
        public var ind: SnowballClientTypes.INDTaxDocuments?

        public init(
            ind: SnowballClientTypes.INDTaxDocuments? = nil
        )
        {
            self.ind = ind
        }
    }
}

public struct CreateClusterInput: Swift.Sendable {
    /// The ID for the address that you want the cluster shipped to.
    /// This member is required.
    public var addressId: Swift.String?
    /// An optional description of this specific cluster, for example Environmental Data Cluster-01.
    public var description: Swift.String?
    /// Force to create cluster when user attempts to overprovision or underprovision a cluster. A cluster is overprovisioned or underprovisioned if the initial size of the cluster is more (overprovisioned) or less (underprovisioned) than what needed to meet capacity requirement specified with OnDeviceServiceConfiguration.
    public var forceCreateJobs: Swift.Bool?
    /// The forwarding address ID for a cluster. This field is not supported in most regions.
    public var forwardingAddressId: Swift.String?
    /// If provided, each job will be automatically created and associated with the new cluster. If not provided, will be treated as 0.
    public var initialClusterSize: Swift.Int?
    /// The type of job for this cluster. Currently, the only job type supported for clusters is LOCAL_USE. For more information, see "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide or "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide.
    /// This member is required.
    public var jobType: SnowballClientTypes.JobType?
    /// The KmsKeyARN value that you want to associate with this cluster. KmsKeyARN values are created by using the [CreateKey](https://docs.aws.amazon.com/kms/latest/APIReference/API_CreateKey.html) API action in Key Management Service (KMS).
    public var kmsKeyARN: Swift.String?
    /// Lists long-term pricing id that will be used to associate with jobs automatically created for the new cluster.
    public var longTermPricingIds: [Swift.String]?
    /// The Amazon Simple Notification Service (Amazon SNS) notification settings for this cluster.
    public var notification: SnowballClientTypes.Notification?
    /// Specifies the service or services on the Snow Family device that your transferred data will be exported from or imported into. Amazon Web Services Snow Family device clusters support Amazon S3 and NFS (Network File System).
    public var onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration?
    /// Allows you to securely operate and manage Snow devices in a cluster remotely from outside of your internal network. When set to INSTALLED_AUTOSTART, remote management will automatically be available when the device arrives at your location. Otherwise, you need to use the Snowball Client to manage the device.
    public var remoteManagement: SnowballClientTypes.RemoteManagement?
    /// The resources associated with the cluster job. These resources include Amazon S3 buckets and optional Lambda functions written in the Python language.
    public var resources: SnowballClientTypes.JobResource?
    /// The RoleARN that you want to associate with this cluster. RoleArn values are created by using the [CreateRole](https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html) API action in Identity and Access Management (IAM).
    public var roleARN: Swift.String?
    /// The shipping speed for each node in this cluster. This speed doesn't dictate how soon you'll get each Snowball Edge device, rather it represents how quickly each device moves to its destination while in transit. Regional shipping speeds are as follows:
    ///
    /// * In Australia, you have access to express shipping. Typically, Snow devices shipped express are delivered in about a day.
    ///
    /// * In the European Union (EU), you have access to express shipping. Typically, Snow devices shipped express are delivered in about a day. In addition, most countries in the EU have access to standard shipping, which typically takes less than a week, one way.
    ///
    /// * In India, Snow devices are delivered in one to seven days.
    ///
    /// * In the United States of America (US), you have access to one-day shipping and two-day shipping.
    ///
    ///
    ///
    ///
    /// * In Australia, you have access to express shipping. Typically, devices shipped express are delivered in about a day.
    ///
    /// * In the European Union (EU), you have access to express shipping. Typically, Snow devices shipped express are delivered in about a day. In addition, most countries in the EU have access to standard shipping, which typically takes less than a week, one way.
    ///
    /// * In India, Snow devices are delivered in one to seven days.
    ///
    /// * In the US, you have access to one-day shipping and two-day shipping.
    /// This member is required.
    public var shippingOption: SnowballClientTypes.ShippingOption?
    /// If your job is being created in one of the US regions, you have the option of specifying what size Snow device you'd like for this job. In all other regions, Snowballs come with 80 TB in storage capacity. For more information, see "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide or "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide.
    public var snowballCapacityPreference: SnowballClientTypes.SnowballCapacity?
    /// The type of Snow Family devices to use for this cluster. For cluster jobs, Amazon Web Services Snow Family currently supports only the EDGE device type. For more information, see "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide or "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide.
    /// This member is required.
    public var snowballType: SnowballClientTypes.SnowballType?
    /// The tax documents required in your Amazon Web Services Region.
    public var taxDocuments: SnowballClientTypes.TaxDocuments?

    public init(
        addressId: Swift.String? = nil,
        description: Swift.String? = nil,
        forceCreateJobs: Swift.Bool? = false,
        forwardingAddressId: Swift.String? = nil,
        initialClusterSize: Swift.Int? = nil,
        jobType: SnowballClientTypes.JobType? = nil,
        kmsKeyARN: Swift.String? = nil,
        longTermPricingIds: [Swift.String]? = nil,
        notification: SnowballClientTypes.Notification? = nil,
        onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration? = nil,
        remoteManagement: SnowballClientTypes.RemoteManagement? = nil,
        resources: SnowballClientTypes.JobResource? = nil,
        roleARN: Swift.String? = nil,
        shippingOption: SnowballClientTypes.ShippingOption? = nil,
        snowballCapacityPreference: SnowballClientTypes.SnowballCapacity? = nil,
        snowballType: SnowballClientTypes.SnowballType? = nil,
        taxDocuments: SnowballClientTypes.TaxDocuments? = nil
    )
    {
        self.addressId = addressId
        self.description = description
        self.forceCreateJobs = forceCreateJobs
        self.forwardingAddressId = forwardingAddressId
        self.initialClusterSize = initialClusterSize
        self.jobType = jobType
        self.kmsKeyARN = kmsKeyARN
        self.longTermPricingIds = longTermPricingIds
        self.notification = notification
        self.onDeviceServiceConfiguration = onDeviceServiceConfiguration
        self.remoteManagement = remoteManagement
        self.resources = resources
        self.roleARN = roleARN
        self.shippingOption = shippingOption
        self.snowballCapacityPreference = snowballCapacityPreference
        self.snowballType = snowballType
        self.taxDocuments = taxDocuments
    }
}

extension SnowballClientTypes {

    /// Each JobListEntry object contains a job's state, a job's ID, and a value that indicates whether the job is a job part, in the case of an export job.
    public struct JobListEntry: Swift.Sendable {
        /// The creation date for this job.
        public var creationDate: Foundation.Date?
        /// The optional description of this specific job, for example Important Photos 2016-08-11.
        public var description: Swift.String?
        /// A value that indicates that this job is a main job. A main job represents a successful request to create an export job. Main jobs aren't associated with any Snowballs. Instead, each main job will have at least one job part, and each job part is associated with a Snowball. It might take some time before the job parts associated with a particular main job are listed, because they are created after the main job is created.
        public var isMaster: Swift.Bool
        /// The automatically generated ID for a job, for example JID123e4567-e89b-12d3-a456-426655440000.
        public var jobId: Swift.String?
        /// The current state of this job.
        public var jobState: SnowballClientTypes.JobState?
        /// The type of job.
        public var jobType: SnowballClientTypes.JobType?
        /// The type of device used with this job.
        public var snowballType: SnowballClientTypes.SnowballType?

        public init(
            creationDate: Foundation.Date? = nil,
            description: Swift.String? = nil,
            isMaster: Swift.Bool = false,
            jobId: Swift.String? = nil,
            jobState: SnowballClientTypes.JobState? = nil,
            jobType: SnowballClientTypes.JobType? = nil,
            snowballType: SnowballClientTypes.SnowballType? = nil
        )
        {
            self.creationDate = creationDate
            self.description = description
            self.isMaster = isMaster
            self.jobId = jobId
            self.jobState = jobState
            self.jobType = jobType
            self.snowballType = snowballType
        }
    }
}

public struct CreateClusterOutput: Swift.Sendable {
    /// The automatically generated ID for a cluster.
    public var clusterId: Swift.String?
    /// List of jobs created for this cluster. For syntax, see [ListJobsResult$JobListEntries](http://amazonaws.com/snowball/latest/api-reference/API_ListJobs.html#API_ListJobs_ResponseSyntax) in this guide.
    public var jobListEntries: [SnowballClientTypes.JobListEntry]?

    public init(
        clusterId: Swift.String? = nil,
        jobListEntries: [SnowballClientTypes.JobListEntry]? = nil
    )
    {
        self.clusterId = clusterId
        self.jobListEntries = jobListEntries
    }
}

/// Job creation failed. Currently, clusters support five nodes. If you have fewer than five nodes for your cluster and you have more nodes to create for this cluster, try again and create jobs until your cluster has exactly five nodes.
public struct ClusterLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ClusterLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SnowballClientTypes {

    /// Configures the wireless connection on an Snowcone device.
    public struct WirelessConnection: Swift.Sendable {
        /// Enables the Wi-Fi adapter on an Snowcone device.
        public var isWifiEnabled: Swift.Bool

        public init(
            isWifiEnabled: Swift.Bool = false
        )
        {
            self.isWifiEnabled = isWifiEnabled
        }
    }
}

extension SnowballClientTypes {

    /// Specifies the device configuration for an Snowcone job.
    public struct SnowconeDeviceConfiguration: Swift.Sendable {
        /// Configures the wireless connection for the Snowcone device.
        public var wirelessConnection: SnowballClientTypes.WirelessConnection?

        public init(
            wirelessConnection: SnowballClientTypes.WirelessConnection? = nil
        )
        {
            self.wirelessConnection = wirelessConnection
        }
    }
}

extension SnowballClientTypes {

    /// The container for SnowconeDeviceConfiguration.
    public struct DeviceConfiguration: Swift.Sendable {
        /// Returns information about the device configuration for an Snowcone job.
        public var snowconeDeviceConfiguration: SnowballClientTypes.SnowconeDeviceConfiguration?

        public init(
            snowconeDeviceConfiguration: SnowballClientTypes.SnowconeDeviceConfiguration? = nil
        )
        {
            self.snowconeDeviceConfiguration = snowconeDeviceConfiguration
        }
    }
}

extension SnowballClientTypes {

    public enum ImpactLevel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case il2
        case il4
        case il5
        case il6
        case il99
        case sdkUnknown(Swift.String)

        public static var allCases: [ImpactLevel] {
            return [
                .il2,
                .il4,
                .il5,
                .il6,
                .il99
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .il2: return "IL2"
            case .il4: return "IL4"
            case .il5: return "IL5"
            case .il6: return "IL6"
            case .il99: return "IL99"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SnowballClientTypes {

    /// Information identifying the person picking up the device.
    public struct PickupDetails: Swift.Sendable {
        /// The unique ID for a device that will be picked up.
        public var devicePickupId: Swift.String?
        /// The email address of the person picking up the device.
        public var email: Swift.String?
        /// Expiration date of the credential identifying the person picking up the device.
        public var identificationExpirationDate: Foundation.Date?
        /// Organization that issued the credential identifying the person picking up the device.
        public var identificationIssuingOrg: Swift.String?
        /// The number on the credential identifying the person picking up the device.
        public var identificationNumber: Swift.String?
        /// The name of the person picking up the device.
        public var name: Swift.String?
        /// The phone number of the person picking up the device.
        public var phoneNumber: Swift.String?

        public init(
            devicePickupId: Swift.String? = nil,
            email: Swift.String? = nil,
            identificationExpirationDate: Foundation.Date? = nil,
            identificationIssuingOrg: Swift.String? = nil,
            identificationNumber: Swift.String? = nil,
            name: Swift.String? = nil,
            phoneNumber: Swift.String? = nil
        )
        {
            self.devicePickupId = devicePickupId
            self.email = email
            self.identificationExpirationDate = identificationExpirationDate
            self.identificationIssuingOrg = identificationIssuingOrg
            self.identificationNumber = identificationNumber
            self.name = name
            self.phoneNumber = phoneNumber
        }
    }
}

extension SnowballClientTypes.PickupDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PickupDetails(devicePickupId: \(Swift.String(describing: devicePickupId)), identificationExpirationDate: \(Swift.String(describing: identificationExpirationDate)), identificationIssuingOrg: \(Swift.String(describing: identificationIssuingOrg)), identificationNumber: \(Swift.String(describing: identificationNumber)), name: \(Swift.String(describing: name)), email: \"CONTENT_REDACTED\", phoneNumber: \"CONTENT_REDACTED\")"}
}

public struct CreateJobInput: Swift.Sendable {
    /// The ID for the address that you want the Snow device shipped to.
    public var addressId: Swift.String?
    /// The ID of a cluster. If you're creating a job for a node in a cluster, you need to provide only this clusterId value. The other job attributes are inherited from the cluster.
    public var clusterId: Swift.String?
    /// Defines an optional description of this specific job, for example Important Photos 2016-08-11.
    public var description: Swift.String?
    /// Defines the device configuration for an Snowcone job. For more information, see "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide or "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide.
    public var deviceConfiguration: SnowballClientTypes.DeviceConfiguration?
    /// The forwarding address ID for a job. This field is not supported in most Regions.
    public var forwardingAddressId: Swift.String?
    /// The highest impact level of data that will be stored or processed on the device, provided at job creation.
    public var impactLevel: SnowballClientTypes.ImpactLevel?
    /// Defines the type of job that you're creating.
    public var jobType: SnowballClientTypes.JobType?
    /// The KmsKeyARN that you want to associate with this job. KmsKeyARNs are created using the [CreateKey](https://docs.aws.amazon.com/kms/latest/APIReference/API_CreateKey.html) Key Management Service (KMS) API action.
    public var kmsKeyARN: Swift.String?
    /// The ID of the long-term pricing type for the device.
    public var longTermPricingId: Swift.String?
    /// Defines the Amazon Simple Notification Service (Amazon SNS) notification settings for this job.
    public var notification: SnowballClientTypes.Notification?
    /// Specifies the service or services on the Snow Family device that your transferred data will be exported from or imported into. Amazon Web Services Snow Family supports Amazon S3 and NFS (Network File System) and the Amazon Web Services Storage Gateway service Tape Gateway type.
    public var onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration?
    /// Information identifying the person picking up the device.
    public var pickupDetails: SnowballClientTypes.PickupDetails?
    /// Allows you to securely operate and manage Snowcone devices remotely from outside of your internal network. When set to INSTALLED_AUTOSTART, remote management will automatically be available when the device arrives at your location. Otherwise, you need to use the Snowball Edge client to manage the device. When set to NOT_INSTALLED, remote management will not be available on the device.
    public var remoteManagement: SnowballClientTypes.RemoteManagement?
    /// Defines the Amazon S3 buckets associated with this job. With IMPORT jobs, you specify the bucket or buckets that your transferred data will be imported into. With EXPORT jobs, you specify the bucket or buckets that your transferred data will be exported from. Optionally, you can also specify a KeyRange value. If you choose to export a range, you define the length of the range by providing either an inclusive BeginMarker value, an inclusive EndMarker value, or both. Ranges are UTF-8 binary sorted.
    public var resources: SnowballClientTypes.JobResource?
    /// The RoleARN that you want to associate with this job. RoleArns are created using the [CreateRole](https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html) Identity and Access Management (IAM) API action.
    public var roleARN: Swift.String?
    /// The shipping speed for this job. This speed doesn't dictate how soon you'll get the Snow device, rather it represents how quickly the Snow device moves to its destination while in transit. Regional shipping speeds are as follows:
    ///
    /// * In Australia, you have access to express shipping. Typically, Snow devices shipped express are delivered in about a day.
    ///
    /// * In the European Union (EU), you have access to express shipping. Typically, Snow devices shipped express are delivered in about a day. In addition, most countries in the EU have access to standard shipping, which typically takes less than a week, one way.
    ///
    /// * In India, Snow devices are delivered in one to seven days.
    ///
    /// * In the US, you have access to one-day shipping and two-day shipping.
    public var shippingOption: SnowballClientTypes.ShippingOption?
    /// If your job is being created in one of the US regions, you have the option of specifying what size Snow device you'd like for this job. In all other regions, Snowballs come with 80 TB in storage capacity. For more information, see "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide or "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide.
    public var snowballCapacityPreference: SnowballClientTypes.SnowballCapacity?
    /// The type of Snow Family devices to use for this job. For cluster jobs, Amazon Web Services Snow Family currently supports only the EDGE device type. The type of Amazon Web Services Snow device to use for this job. Currently, the only supported device type for cluster jobs is EDGE. For more information, see [Snowball Edge Device Options](https://docs.aws.amazon.com/snowball/latest/developer-guide/device-differences.html) in the Snowball Edge Developer Guide. For more information, see "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide or "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide.
    public var snowballType: SnowballClientTypes.SnowballType?
    /// The tax documents required in your Amazon Web Services Region.
    public var taxDocuments: SnowballClientTypes.TaxDocuments?

    public init(
        addressId: Swift.String? = nil,
        clusterId: Swift.String? = nil,
        description: Swift.String? = nil,
        deviceConfiguration: SnowballClientTypes.DeviceConfiguration? = nil,
        forwardingAddressId: Swift.String? = nil,
        impactLevel: SnowballClientTypes.ImpactLevel? = nil,
        jobType: SnowballClientTypes.JobType? = nil,
        kmsKeyARN: Swift.String? = nil,
        longTermPricingId: Swift.String? = nil,
        notification: SnowballClientTypes.Notification? = nil,
        onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration? = nil,
        pickupDetails: SnowballClientTypes.PickupDetails? = nil,
        remoteManagement: SnowballClientTypes.RemoteManagement? = nil,
        resources: SnowballClientTypes.JobResource? = nil,
        roleARN: Swift.String? = nil,
        shippingOption: SnowballClientTypes.ShippingOption? = nil,
        snowballCapacityPreference: SnowballClientTypes.SnowballCapacity? = nil,
        snowballType: SnowballClientTypes.SnowballType? = nil,
        taxDocuments: SnowballClientTypes.TaxDocuments? = nil
    )
    {
        self.addressId = addressId
        self.clusterId = clusterId
        self.description = description
        self.deviceConfiguration = deviceConfiguration
        self.forwardingAddressId = forwardingAddressId
        self.impactLevel = impactLevel
        self.jobType = jobType
        self.kmsKeyARN = kmsKeyARN
        self.longTermPricingId = longTermPricingId
        self.notification = notification
        self.onDeviceServiceConfiguration = onDeviceServiceConfiguration
        self.pickupDetails = pickupDetails
        self.remoteManagement = remoteManagement
        self.resources = resources
        self.roleARN = roleARN
        self.shippingOption = shippingOption
        self.snowballCapacityPreference = snowballCapacityPreference
        self.snowballType = snowballType
        self.taxDocuments = taxDocuments
    }
}

public struct CreateJobOutput: Swift.Sendable {
    /// The automatically generated ID for a job, for example JID123e4567-e89b-12d3-a456-426655440000.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

extension SnowballClientTypes {

    public enum LongTermPricingType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case oneMonth
        case oneYear
        case threeYear
        case sdkUnknown(Swift.String)

        public static var allCases: [LongTermPricingType] {
            return [
                .oneMonth,
                .oneYear,
                .threeYear
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .oneMonth: return "OneMonth"
            case .oneYear: return "OneYear"
            case .threeYear: return "ThreeYear"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateLongTermPricingInput: Swift.Sendable {
    /// Specifies whether the current long-term pricing type for the device should be renewed.
    public var isLongTermPricingAutoRenew: Swift.Bool?
    /// The type of long-term pricing option you want for the device, either 1-year or 3-year long-term pricing.
    /// This member is required.
    public var longTermPricingType: SnowballClientTypes.LongTermPricingType?
    /// The type of Snow Family devices to use for the long-term pricing job.
    /// This member is required.
    public var snowballType: SnowballClientTypes.SnowballType?

    public init(
        isLongTermPricingAutoRenew: Swift.Bool? = nil,
        longTermPricingType: SnowballClientTypes.LongTermPricingType? = nil,
        snowballType: SnowballClientTypes.SnowballType? = nil
    )
    {
        self.isLongTermPricingAutoRenew = isLongTermPricingAutoRenew
        self.longTermPricingType = longTermPricingType
        self.snowballType = snowballType
    }
}

public struct CreateLongTermPricingOutput: Swift.Sendable {
    /// The ID of the long-term pricing type for the device.
    public var longTermPricingId: Swift.String?

    public init(
        longTermPricingId: Swift.String? = nil
    )
    {
        self.longTermPricingId = longTermPricingId
    }
}

/// You get this exception when you call CreateReturnShippingLabel more than once when other requests are not completed.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// You get this resource when you call CreateReturnShippingLabel more than once when other requests are not completed. .
        public internal(set) var conflictResource: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        conflictResource: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.conflictResource = conflictResource
        self.properties.message = message
    }
}

/// You get this exception if you call CreateReturnShippingLabel and a valid return shipping label already exists. In this case, use DescribeReturnShippingLabel to get the URL.
public struct ReturnShippingLabelAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReturnShippingLabelAlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateReturnShippingLabelInput: Swift.Sendable {
    /// The ID for a job that you want to create the return shipping label for; for example, JID123e4567-e89b-12d3-a456-426655440000.
    /// This member is required.
    public var jobId: Swift.String?
    /// The shipping speed for a particular job. This speed doesn't dictate how soon the device is returned to Amazon Web Services. This speed represents how quickly it moves to its destination while in transit. Regional shipping speeds are as follows:
    public var shippingOption: SnowballClientTypes.ShippingOption?

    public init(
        jobId: Swift.String? = nil,
        shippingOption: SnowballClientTypes.ShippingOption? = nil
    )
    {
        self.jobId = jobId
        self.shippingOption = shippingOption
    }
}

extension SnowballClientTypes {

    public enum ShippingLabelStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [ShippingLabelStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded,
                .timedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .succeeded: return "Succeeded"
            case .timedOut: return "TimedOut"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateReturnShippingLabelOutput: Swift.Sendable {
    /// The status information of the task on a Snow device that is being returned to Amazon Web Services.
    public var status: SnowballClientTypes.ShippingLabelStatus?

    public init(
        status: SnowballClientTypes.ShippingLabelStatus? = nil
    )
    {
        self.status = status
    }
}

public struct DescribeAddressInput: Swift.Sendable {
    /// The automatically generated ID for a specific address.
    /// This member is required.
    public var addressId: Swift.String?

    public init(
        addressId: Swift.String? = nil
    )
    {
        self.addressId = addressId
    }
}

public struct DescribeAddressOutput: Swift.Sendable {
    /// The address that you want the Snow device(s) associated with a specific job to be shipped to.
    public var address: SnowballClientTypes.Address?

    public init(
        address: SnowballClientTypes.Address? = nil
    )
    {
        self.address = address
    }
}

/// The NextToken string was altered unexpectedly, and the operation has stopped. Run the operation without changing the NextToken string, and try again.
public struct InvalidNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextTokenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DescribeAddressesInput: Swift.Sendable {
    /// The number of ADDRESS objects to return.
    public var maxResults: Swift.Int?
    /// HTTP requests are stateless. To identify what object comes "next" in the list of ADDRESS objects, you have the option of specifying a value for NextToken as the starting point for your list of returned addresses.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct DescribeAddressesOutput: Swift.Sendable {
    /// The Snow device shipping addresses that were created for this account.
    public var addresses: [SnowballClientTypes.Address]?
    /// HTTP requests are stateless. If you use the automatically generated NextToken value in your next DescribeAddresses call, your list of returned addresses will start from this point in the array.
    public var nextToken: Swift.String?

    public init(
        addresses: [SnowballClientTypes.Address]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.addresses = addresses
        self.nextToken = nextToken
    }
}

public struct DescribeClusterInput: Swift.Sendable {
    /// The automatically generated ID for a cluster.
    /// This member is required.
    public var clusterId: Swift.String?

    public init(
        clusterId: Swift.String? = nil
    )
    {
        self.clusterId = clusterId
    }
}

extension SnowballClientTypes {

    public enum ClusterState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awaitingQuorum
        case cancelled
        case complete
        case inUse
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ClusterState] {
            return [
                .awaitingQuorum,
                .cancelled,
                .complete,
                .inUse,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awaitingQuorum: return "AwaitingQuorum"
            case .cancelled: return "Cancelled"
            case .complete: return "Complete"
            case .inUse: return "InUse"
            case .pending: return "Pending"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SnowballClientTypes {

    /// Contains metadata about a specific cluster.
    public struct ClusterMetadata: Swift.Sendable {
        /// The automatically generated ID for a specific address.
        public var addressId: Swift.String?
        /// The automatically generated ID for a cluster.
        public var clusterId: Swift.String?
        /// The current status of the cluster.
        public var clusterState: SnowballClientTypes.ClusterState?
        /// The creation date for this cluster.
        public var creationDate: Foundation.Date?
        /// The optional description of the cluster.
        public var description: Swift.String?
        /// The ID of the address that you want a cluster shipped to, after it will be shipped to its primary address. This field is not supported in most regions.
        public var forwardingAddressId: Swift.String?
        /// The type of job for this cluster. Currently, the only job type supported for clusters is LOCAL_USE.
        public var jobType: SnowballClientTypes.JobType?
        /// The KmsKeyARN Amazon Resource Name (ARN) associated with this cluster. This ARN was created using the [CreateKey](https://docs.aws.amazon.com/kms/latest/APIReference/API_CreateKey.html) API action in Key Management Service (KMS.
        public var kmsKeyARN: Swift.String?
        /// The Amazon Simple Notification Service (Amazon SNS) notification settings for this cluster.
        public var notification: SnowballClientTypes.Notification?
        /// Represents metadata and configuration settings for services on an Amazon Web Services Snow Family device.
        public var onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration?
        /// The arrays of [JobResource] objects that can include updated [S3Resource] objects or [LambdaResource] objects.
        public var resources: SnowballClientTypes.JobResource?
        /// The role ARN associated with this cluster. This ARN was created using the [CreateRole](https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html) API action in Identity and Access Management (IAM).
        public var roleARN: Swift.String?
        /// The shipping speed for each node in this cluster. This speed doesn't dictate how soon you'll get each device, rather it represents how quickly each device moves to its destination while in transit. Regional shipping speeds are as follows:
        ///
        /// * In Australia, you have access to express shipping. Typically, devices shipped express are delivered in about a day.
        ///
        /// * In the European Union (EU), you have access to express shipping. Typically, Snow devices shipped express are delivered in about a day. In addition, most countries in the EU have access to standard shipping, which typically takes less than a week, one way.
        ///
        /// * In India, Snow devices are delivered in one to seven days.
        ///
        /// * In the US, you have access to one-day shipping and two-day shipping.
        public var shippingOption: SnowballClientTypes.ShippingOption?
        /// The type of Snowcone device to use for this cluster. For cluster jobs, Amazon Web Services Snow Family currently supports only the EDGE device type.
        public var snowballType: SnowballClientTypes.SnowballType?
        /// The tax documents required in your Amazon Web Services Region.
        public var taxDocuments: SnowballClientTypes.TaxDocuments?

        public init(
            addressId: Swift.String? = nil,
            clusterId: Swift.String? = nil,
            clusterState: SnowballClientTypes.ClusterState? = nil,
            creationDate: Foundation.Date? = nil,
            description: Swift.String? = nil,
            forwardingAddressId: Swift.String? = nil,
            jobType: SnowballClientTypes.JobType? = nil,
            kmsKeyARN: Swift.String? = nil,
            notification: SnowballClientTypes.Notification? = nil,
            onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration? = nil,
            resources: SnowballClientTypes.JobResource? = nil,
            roleARN: Swift.String? = nil,
            shippingOption: SnowballClientTypes.ShippingOption? = nil,
            snowballType: SnowballClientTypes.SnowballType? = nil,
            taxDocuments: SnowballClientTypes.TaxDocuments? = nil
        )
        {
            self.addressId = addressId
            self.clusterId = clusterId
            self.clusterState = clusterState
            self.creationDate = creationDate
            self.description = description
            self.forwardingAddressId = forwardingAddressId
            self.jobType = jobType
            self.kmsKeyARN = kmsKeyARN
            self.notification = notification
            self.onDeviceServiceConfiguration = onDeviceServiceConfiguration
            self.resources = resources
            self.roleARN = roleARN
            self.shippingOption = shippingOption
            self.snowballType = snowballType
            self.taxDocuments = taxDocuments
        }
    }
}

public struct DescribeClusterOutput: Swift.Sendable {
    /// Information about a specific cluster, including shipping information, cluster status, and other important metadata.
    public var clusterMetadata: SnowballClientTypes.ClusterMetadata?

    public init(
        clusterMetadata: SnowballClientTypes.ClusterMetadata? = nil
    )
    {
        self.clusterMetadata = clusterMetadata
    }
}

public struct DescribeJobInput: Swift.Sendable {
    /// The automatically generated ID for a job, for example JID123e4567-e89b-12d3-a456-426655440000.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

extension SnowballClientTypes {

    /// Defines the real-time status of a Snow device's data transfer while the device is at Amazon Web Services. This data is only available while a job has a JobState value of InProgress, for both import and export jobs.
    public struct DataTransfer: Swift.Sendable {
        /// The number of bytes transferred between a Snow device and Amazon S3.
        public var bytesTransferred: Swift.Int
        /// The number of objects transferred between a Snow device and Amazon S3.
        public var objectsTransferred: Swift.Int
        /// The total bytes of data for a transfer between a Snow device and Amazon S3. This value is set to 0 (zero) until all the keys that will be transferred have been listed.
        public var totalBytes: Swift.Int
        /// The total number of objects for a transfer between a Snow device and Amazon S3. This value is set to 0 (zero) until all the keys that will be transferred have been listed.
        public var totalObjects: Swift.Int

        public init(
            bytesTransferred: Swift.Int = 0,
            objectsTransferred: Swift.Int = 0,
            totalBytes: Swift.Int = 0,
            totalObjects: Swift.Int = 0
        )
        {
            self.bytesTransferred = bytesTransferred
            self.objectsTransferred = objectsTransferred
            self.totalBytes = totalBytes
            self.totalObjects = totalObjects
        }
    }
}

extension SnowballClientTypes {

    /// Contains job logs. Whenever a Snow device is used to import data into or export data out of Amazon S3, you'll have the option of downloading a PDF job report. Job logs are returned as a part of the response syntax of the DescribeJob action in the JobMetadata data type. The job logs can be accessed for up to 60 minutes after this request has been made. To access any of the job logs after 60 minutes have passed, you'll have to make another call to the DescribeJob action. For import jobs, the PDF job report becomes available at the end of the import process. For export jobs, your job report typically becomes available while the Snow device for your job part is being delivered to you. The job report provides you insight into the state of your Amazon S3 data transfer. The report includes details about your job or job part for your records. For deeper visibility into the status of your transferred objects, you can look at the two associated logs: a success log and a failure log. The logs are saved in comma-separated value (CSV) format, and the name of each log includes the ID of the job or job part that the log describes.
    public struct JobLogs: Swift.Sendable {
        /// A link to an Amazon S3 presigned URL where the job completion report is located.
        public var jobCompletionReportURI: Swift.String?
        /// A link to an Amazon S3 presigned URL where the job failure log is located.
        public var jobFailureLogURI: Swift.String?
        /// A link to an Amazon S3 presigned URL where the job success log is located.
        public var jobSuccessLogURI: Swift.String?

        public init(
            jobCompletionReportURI: Swift.String? = nil,
            jobFailureLogURI: Swift.String? = nil,
            jobSuccessLogURI: Swift.String? = nil
        )
        {
            self.jobCompletionReportURI = jobCompletionReportURI
            self.jobFailureLogURI = jobFailureLogURI
            self.jobSuccessLogURI = jobSuccessLogURI
        }
    }
}

extension SnowballClientTypes {

    /// The Status and TrackingNumber information for an inbound or outbound shipment.
    public struct Shipment: Swift.Sendable {
        /// Status information for a shipment.
        public var status: Swift.String?
        /// The tracking number for this job. Using this tracking number with your region's carrier's website, you can track a Snow device as the carrier transports it. For India, the carrier is Amazon Logistics. For all other regions, UPS is the carrier.
        public var trackingNumber: Swift.String?

        public init(
            status: Swift.String? = nil,
            trackingNumber: Swift.String? = nil
        )
        {
            self.status = status
            self.trackingNumber = trackingNumber
        }
    }
}

extension SnowballClientTypes {

    /// A job's shipping information, including inbound and outbound tracking numbers and shipping speed options.
    public struct ShippingDetails: Swift.Sendable {
        /// The Status and TrackingNumber values for a Snow device being returned to Amazon Web Services for a particular job.
        public var inboundShipment: SnowballClientTypes.Shipment?
        /// The Status and TrackingNumber values for a Snow device being delivered to the address that you specified for a particular job.
        public var outboundShipment: SnowballClientTypes.Shipment?
        /// The shipping speed for a particular job. This speed doesn't dictate how soon you'll get the Snow device from the job's creation date. This speed represents how quickly it moves to its destination while in transit. Regional shipping speeds are as follows:
        ///
        /// * In Australia, you have access to express shipping. Typically, Snow devices shipped express are delivered in about a day.
        ///
        /// * In the European Union (EU), you have access to express shipping. Typically, Snow devices shipped express are delivered in about a day. In addition, most countries in the EU have access to standard shipping, which typically takes less than a week, one way.
        ///
        /// * In India, Snow devices are delivered in one to seven days.
        ///
        /// * In the United States of America (US), you have access to one-day shipping and two-day shipping.
        public var shippingOption: SnowballClientTypes.ShippingOption?

        public init(
            inboundShipment: SnowballClientTypes.Shipment? = nil,
            outboundShipment: SnowballClientTypes.Shipment? = nil,
            shippingOption: SnowballClientTypes.ShippingOption? = nil
        )
        {
            self.inboundShipment = inboundShipment
            self.outboundShipment = outboundShipment
            self.shippingOption = shippingOption
        }
    }
}

extension SnowballClientTypes {

    /// Contains information about a specific job including shipping information, job status, and other important metadata. This information is returned as a part of the response syntax of the DescribeJob action.
    public struct JobMetadata: Swift.Sendable {
        /// The ID for the address that you want the Snow device shipped to.
        public var addressId: Swift.String?
        /// The 39-character ID for the cluster, for example CID123e4567-e89b-12d3-a456-426655440000.
        public var clusterId: Swift.String?
        /// The creation date for this job.
        public var creationDate: Foundation.Date?
        /// A value that defines the real-time status of a Snow device's data transfer while the device is at Amazon Web Services. This data is only available while a job has a JobState value of InProgress, for both import and export jobs.
        public var dataTransferProgress: SnowballClientTypes.DataTransfer?
        /// The description of the job, provided at job creation.
        public var description: Swift.String?
        /// The container for SnowconeDeviceConfiguration.
        public var deviceConfiguration: SnowballClientTypes.DeviceConfiguration?
        /// The ID of the address that you want a job shipped to, after it will be shipped to its primary address. This field is not supported in most regions.
        public var forwardingAddressId: Swift.String?
        /// The highest impact level of data that will be stored or processed on the device, provided at job creation.
        public var impactLevel: SnowballClientTypes.ImpactLevel?
        /// The automatically generated ID for a job, for example JID123e4567-e89b-12d3-a456-426655440000.
        public var jobId: Swift.String?
        /// Links to Amazon S3 presigned URLs for the job report and logs. For import jobs, the PDF job report becomes available at the end of the import process. For export jobs, your job report typically becomes available while the Snow device for your job part is being delivered to you.
        public var jobLogInfo: SnowballClientTypes.JobLogs?
        /// The current status of the jobs.
        public var jobState: SnowballClientTypes.JobState?
        /// The type of job.
        public var jobType: SnowballClientTypes.JobType?
        /// The Amazon Resource Name (ARN) for the Key Management Service (KMS) key associated with this job. This ARN was created using the [CreateKey](https://docs.aws.amazon.com/kms/latest/APIReference/API_CreateKey.html) API action in KMS.
        public var kmsKeyARN: Swift.String?
        /// The ID of the long-term pricing type for the device.
        public var longTermPricingId: Swift.String?
        /// The Amazon Simple Notification Service (Amazon SNS) notification settings associated with a specific job. The Notification object is returned as a part of the response syntax of the DescribeJob action in the JobMetadata data type.
        public var notification: SnowballClientTypes.Notification?
        /// Represents metadata and configuration settings for services on an Amazon Web Services Snow Family device.
        public var onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration?
        /// Information identifying the person picking up the device.
        public var pickupDetails: SnowballClientTypes.PickupDetails?
        /// Allows you to securely operate and manage Snowcone devices remotely from outside of your internal network. When set to INSTALLED_AUTOSTART, remote management will automatically be available when the device arrives at your location. Otherwise, you need to use the Snowball Client to manage the device.
        public var remoteManagement: SnowballClientTypes.RemoteManagement?
        /// An array of S3Resource objects. Each S3Resource object represents an Amazon S3 bucket that your transferred data will be exported from or imported into.
        public var resources: SnowballClientTypes.JobResource?
        /// The role ARN associated with this job. This ARN was created using the [CreateRole](https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html) API action in Identity and Access Management.
        public var roleARN: Swift.String?
        /// A job's shipping information, including inbound and outbound tracking numbers and shipping speed options.
        public var shippingDetails: SnowballClientTypes.ShippingDetails?
        /// The Snow device capacity preference for this job, specified at job creation. In US regions, you can choose between 50 TB and 80 TB Snowballs. All other regions use 80 TB capacity Snowballs. For more information, see "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide or "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide.
        public var snowballCapacityPreference: SnowballClientTypes.SnowballCapacity?
        /// Unique ID associated with a device.
        public var snowballId: Swift.String?
        /// The type of device used with this job.
        public var snowballType: SnowballClientTypes.SnowballType?
        /// The metadata associated with the tax documents required in your Amazon Web Services Region.
        public var taxDocuments: SnowballClientTypes.TaxDocuments?

        public init(
            addressId: Swift.String? = nil,
            clusterId: Swift.String? = nil,
            creationDate: Foundation.Date? = nil,
            dataTransferProgress: SnowballClientTypes.DataTransfer? = nil,
            description: Swift.String? = nil,
            deviceConfiguration: SnowballClientTypes.DeviceConfiguration? = nil,
            forwardingAddressId: Swift.String? = nil,
            impactLevel: SnowballClientTypes.ImpactLevel? = nil,
            jobId: Swift.String? = nil,
            jobLogInfo: SnowballClientTypes.JobLogs? = nil,
            jobState: SnowballClientTypes.JobState? = nil,
            jobType: SnowballClientTypes.JobType? = nil,
            kmsKeyARN: Swift.String? = nil,
            longTermPricingId: Swift.String? = nil,
            notification: SnowballClientTypes.Notification? = nil,
            onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration? = nil,
            pickupDetails: SnowballClientTypes.PickupDetails? = nil,
            remoteManagement: SnowballClientTypes.RemoteManagement? = nil,
            resources: SnowballClientTypes.JobResource? = nil,
            roleARN: Swift.String? = nil,
            shippingDetails: SnowballClientTypes.ShippingDetails? = nil,
            snowballCapacityPreference: SnowballClientTypes.SnowballCapacity? = nil,
            snowballId: Swift.String? = nil,
            snowballType: SnowballClientTypes.SnowballType? = nil,
            taxDocuments: SnowballClientTypes.TaxDocuments? = nil
        )
        {
            self.addressId = addressId
            self.clusterId = clusterId
            self.creationDate = creationDate
            self.dataTransferProgress = dataTransferProgress
            self.description = description
            self.deviceConfiguration = deviceConfiguration
            self.forwardingAddressId = forwardingAddressId
            self.impactLevel = impactLevel
            self.jobId = jobId
            self.jobLogInfo = jobLogInfo
            self.jobState = jobState
            self.jobType = jobType
            self.kmsKeyARN = kmsKeyARN
            self.longTermPricingId = longTermPricingId
            self.notification = notification
            self.onDeviceServiceConfiguration = onDeviceServiceConfiguration
            self.pickupDetails = pickupDetails
            self.remoteManagement = remoteManagement
            self.resources = resources
            self.roleARN = roleARN
            self.shippingDetails = shippingDetails
            self.snowballCapacityPreference = snowballCapacityPreference
            self.snowballId = snowballId
            self.snowballType = snowballType
            self.taxDocuments = taxDocuments
        }
    }
}

public struct DescribeJobOutput: Swift.Sendable {
    /// Information about a specific job, including shipping information, job status, and other important metadata.
    public var jobMetadata: SnowballClientTypes.JobMetadata?
    /// Information about a specific job part (in the case of an export job), including shipping information, job status, and other important metadata.
    public var subJobMetadata: [SnowballClientTypes.JobMetadata]?

    public init(
        jobMetadata: SnowballClientTypes.JobMetadata? = nil,
        subJobMetadata: [SnowballClientTypes.JobMetadata]? = nil
    )
    {
        self.jobMetadata = jobMetadata
        self.subJobMetadata = subJobMetadata
    }
}

public struct DescribeReturnShippingLabelInput: Swift.Sendable {
    /// The automatically generated ID for a job, for example JID123e4567-e89b-12d3-a456-426655440000.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

public struct DescribeReturnShippingLabelOutput: Swift.Sendable {
    /// The expiration date of the current return shipping label.
    public var expirationDate: Foundation.Date?
    /// The pre-signed Amazon S3 URI used to download the return shipping label.
    public var returnShippingLabelURI: Swift.String?
    /// The status information of the task on a Snow device that is being returned to Amazon Web Services.
    public var status: SnowballClientTypes.ShippingLabelStatus?

    public init(
        expirationDate: Foundation.Date? = nil,
        returnShippingLabelURI: Swift.String? = nil,
        status: SnowballClientTypes.ShippingLabelStatus? = nil
    )
    {
        self.expirationDate = expirationDate
        self.returnShippingLabelURI = returnShippingLabelURI
        self.status = status
    }
}

public struct GetJobManifestInput: Swift.Sendable {
    /// The ID for a job that you want to get the manifest file for, for example JID123e4567-e89b-12d3-a456-426655440000.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

public struct GetJobManifestOutput: Swift.Sendable {
    /// The Amazon S3 presigned URL for the manifest file associated with the specified JobId value.
    public var manifestURI: Swift.String?

    public init(
        manifestURI: Swift.String? = nil
    )
    {
        self.manifestURI = manifestURI
    }
}

public struct GetJobUnlockCodeInput: Swift.Sendable {
    /// The ID for the job that you want to get the UnlockCode value for, for example JID123e4567-e89b-12d3-a456-426655440000.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

public struct GetJobUnlockCodeOutput: Swift.Sendable {
    /// The UnlockCode value for the specified job. The UnlockCode value can be accessed for up to 360 days after the job has been created.
    public var unlockCode: Swift.String?

    public init(
        unlockCode: Swift.String? = nil
    )
    {
        self.unlockCode = unlockCode
    }
}

public struct GetSnowballUsageInput: Swift.Sendable {

    public init() { }
}

public struct GetSnowballUsageOutput: Swift.Sendable {
    /// The service limit for number of Snow devices this account can have at once. The default service limit is 1 (one).
    public var snowballLimit: Swift.Int?
    /// The number of Snow devices that this account is currently using.
    public var snowballsInUse: Swift.Int?

    public init(
        snowballLimit: Swift.Int? = nil,
        snowballsInUse: Swift.Int? = nil
    )
    {
        self.snowballLimit = snowballLimit
        self.snowballsInUse = snowballsInUse
    }
}

public struct GetSoftwareUpdatesInput: Swift.Sendable {
    /// The ID for a job that you want to get the software update file for, for example JID123e4567-e89b-12d3-a456-426655440000.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

public struct GetSoftwareUpdatesOutput: Swift.Sendable {
    /// The Amazon S3 presigned URL for the update file associated with the specified JobId value. The software update will be available for 2 days after this request is made. To access an update after the 2 days have passed, you'll have to make another call to GetSoftwareUpdates.
    public var updatesURI: Swift.String?

    public init(
        updatesURI: Swift.String? = nil
    )
    {
        self.updatesURI = updatesURI
    }
}

public struct ListClusterJobsInput: Swift.Sendable {
    /// The 39-character ID for the cluster that you want to list, for example CID123e4567-e89b-12d3-a456-426655440000.
    /// This member is required.
    public var clusterId: Swift.String?
    /// The number of JobListEntry objects to return.
    public var maxResults: Swift.Int?
    /// HTTP requests are stateless. To identify what object comes "next" in the list of JobListEntry objects, you have the option of specifying NextToken as the starting point for your returned list.
    public var nextToken: Swift.String?

    public init(
        clusterId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterId = clusterId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListClusterJobsOutput: Swift.Sendable {
    /// Each JobListEntry object contains a job's state, a job's ID, and a value that indicates whether the job is a job part, in the case of export jobs.
    public var jobListEntries: [SnowballClientTypes.JobListEntry]?
    /// HTTP requests are stateless. If you use the automatically generated NextToken value in your next ListClusterJobsResult call, your list of returned jobs will start from this point in the array.
    public var nextToken: Swift.String?

    public init(
        jobListEntries: [SnowballClientTypes.JobListEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobListEntries = jobListEntries
        self.nextToken = nextToken
    }
}

public struct ListClustersInput: Swift.Sendable {
    /// The number of ClusterListEntry objects to return.
    public var maxResults: Swift.Int?
    /// HTTP requests are stateless. To identify what object comes "next" in the list of ClusterListEntry objects, you have the option of specifying NextToken as the starting point for your returned list.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SnowballClientTypes {

    /// Contains a cluster's state, a cluster's ID, and other important information.
    public struct ClusterListEntry: Swift.Sendable {
        /// The 39-character ID for the cluster that you want to list, for example CID123e4567-e89b-12d3-a456-426655440000.
        public var clusterId: Swift.String?
        /// The current state of this cluster. For information about the state of a specific node, see [JobListEntry$JobState].
        public var clusterState: SnowballClientTypes.ClusterState?
        /// The creation date for this cluster.
        public var creationDate: Foundation.Date?
        /// Defines an optional description of the cluster, for example Environmental Data Cluster-01.
        public var description: Swift.String?

        public init(
            clusterId: Swift.String? = nil,
            clusterState: SnowballClientTypes.ClusterState? = nil,
            creationDate: Foundation.Date? = nil,
            description: Swift.String? = nil
        )
        {
            self.clusterId = clusterId
            self.clusterState = clusterState
            self.creationDate = creationDate
            self.description = description
        }
    }
}

public struct ListClustersOutput: Swift.Sendable {
    /// Each ClusterListEntry object contains a cluster's state, a cluster's ID, and other important status information.
    public var clusterListEntries: [SnowballClientTypes.ClusterListEntry]?
    /// HTTP requests are stateless. If you use the automatically generated NextToken value in your next ClusterListEntry call, your list of returned clusters will start from this point in the array.
    public var nextToken: Swift.String?

    public init(
        clusterListEntries: [SnowballClientTypes.ClusterListEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterListEntries = clusterListEntries
        self.nextToken = nextToken
    }
}

public struct ListCompatibleImagesInput: Swift.Sendable {
    /// The maximum number of results for the list of compatible images. Currently, a Snowball Edge device can store 10 AMIs.
    public var maxResults: Swift.Int?
    /// HTTP requests are stateless. To identify what object comes "next" in the list of compatible images, you can specify a value for NextToken as the starting point for your list of returned images.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SnowballClientTypes {

    /// A JSON-formatted object that describes a compatible Amazon Machine Image (AMI), including the ID and name for a Snow device AMI. This AMI is compatible with the device's physical hardware requirements, and it should be able to be run in an SBE1 instance on the device.
    public struct CompatibleImage: Swift.Sendable {
        /// The unique identifier for an individual Snow device AMI.
        public var amiId: Swift.String?
        /// The optional name of a compatible image.
        public var name: Swift.String?

        public init(
            amiId: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.amiId = amiId
            self.name = name
        }
    }
}

public struct ListCompatibleImagesOutput: Swift.Sendable {
    /// A JSON-formatted object that describes a compatible AMI, including the ID and name for a Snow device AMI.
    public var compatibleImages: [SnowballClientTypes.CompatibleImage]?
    /// Because HTTP requests are stateless, this is the starting point for your next list of returned images.
    public var nextToken: Swift.String?

    public init(
        compatibleImages: [SnowballClientTypes.CompatibleImage]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.compatibleImages = compatibleImages
        self.nextToken = nextToken
    }
}

public struct ListJobsInput: Swift.Sendable {
    /// The number of JobListEntry objects to return.
    public var maxResults: Swift.Int?
    /// HTTP requests are stateless. To identify what object comes "next" in the list of JobListEntry objects, you have the option of specifying NextToken as the starting point for your returned list.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListJobsOutput: Swift.Sendable {
    /// Each JobListEntry object contains a job's state, a job's ID, and a value that indicates whether the job is a job part, in the case of export jobs.
    public var jobListEntries: [SnowballClientTypes.JobListEntry]?
    /// HTTP requests are stateless. If you use this automatically generated NextToken value in your next ListJobs call, your returned JobListEntry objects will start from this point in the array.
    public var nextToken: Swift.String?

    public init(
        jobListEntries: [SnowballClientTypes.JobListEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobListEntries = jobListEntries
        self.nextToken = nextToken
    }
}

public struct ListLongTermPricingInput: Swift.Sendable {
    /// The maximum number of ListLongTermPricing objects to return.
    public var maxResults: Swift.Int?
    /// Because HTTP requests are stateless, this is the starting point for your next list of ListLongTermPricing to return.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SnowballClientTypes {

    /// Each LongTermPricingListEntry object contains information about a long-term pricing type.
    public struct LongTermPricingListEntry: Swift.Sendable {
        /// The current active jobs on the device the long-term pricing type.
        public var currentActiveJob: Swift.String?
        /// If set to true, specifies that the current long-term pricing type for the device should be automatically renewed before the long-term pricing contract expires.
        public var isLongTermPricingAutoRenew: Swift.Bool?
        /// The IDs of the jobs that are associated with a long-term pricing type.
        public var jobIds: [Swift.String]?
        /// The end date the long-term pricing contract.
        public var longTermPricingEndDate: Foundation.Date?
        /// The ID of the long-term pricing type for the device.
        public var longTermPricingId: Swift.String?
        /// The start date of the long-term pricing contract.
        public var longTermPricingStartDate: Foundation.Date?
        /// The status of the long-term pricing type.
        public var longTermPricingStatus: Swift.String?
        /// The type of long-term pricing that was selected for the device.
        public var longTermPricingType: SnowballClientTypes.LongTermPricingType?
        /// A new device that replaces a device that is ordered with long-term pricing.
        public var replacementJob: Swift.String?
        /// The type of Snow Family devices associated with this long-term pricing job.
        public var snowballType: SnowballClientTypes.SnowballType?

        public init(
            currentActiveJob: Swift.String? = nil,
            isLongTermPricingAutoRenew: Swift.Bool? = nil,
            jobIds: [Swift.String]? = nil,
            longTermPricingEndDate: Foundation.Date? = nil,
            longTermPricingId: Swift.String? = nil,
            longTermPricingStartDate: Foundation.Date? = nil,
            longTermPricingStatus: Swift.String? = nil,
            longTermPricingType: SnowballClientTypes.LongTermPricingType? = nil,
            replacementJob: Swift.String? = nil,
            snowballType: SnowballClientTypes.SnowballType? = nil
        )
        {
            self.currentActiveJob = currentActiveJob
            self.isLongTermPricingAutoRenew = isLongTermPricingAutoRenew
            self.jobIds = jobIds
            self.longTermPricingEndDate = longTermPricingEndDate
            self.longTermPricingId = longTermPricingId
            self.longTermPricingStartDate = longTermPricingStartDate
            self.longTermPricingStatus = longTermPricingStatus
            self.longTermPricingType = longTermPricingType
            self.replacementJob = replacementJob
            self.snowballType = snowballType
        }
    }
}

public struct ListLongTermPricingOutput: Swift.Sendable {
    /// Each LongTermPricingEntry object contains a status, ID, and other information about the LongTermPricing type.
    public var longTermPricingEntries: [SnowballClientTypes.LongTermPricingListEntry]?
    /// Because HTTP requests are stateless, this is the starting point for your next list of returned ListLongTermPricing list.
    public var nextToken: Swift.String?

    public init(
        longTermPricingEntries: [SnowballClientTypes.LongTermPricingListEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.longTermPricingEntries = longTermPricingEntries
        self.nextToken = nextToken
    }
}

public struct ListPickupLocationsInput: Swift.Sendable {
    /// The maximum number of locations to list per page.
    public var maxResults: Swift.Int?
    /// HTTP requests are stateless. To identify what object comes "next" in the list of ListPickupLocationsRequest objects, you have the option of specifying NextToken as the starting point for your returned list.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListPickupLocationsOutput: Swift.Sendable {
    /// Information about the address of pickup locations.
    public var addresses: [SnowballClientTypes.Address]?
    /// HTTP requests are stateless. To identify what object comes "next" in the list of ListPickupLocationsResult objects, you have the option of specifying NextToken as the starting point for your returned list.
    public var nextToken: Swift.String?

    public init(
        addresses: [SnowballClientTypes.Address]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.addresses = addresses
        self.nextToken = nextToken
    }
}

extension SnowballClientTypes {

    public enum ServiceName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case eksAnywhere
        case kubernetes
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceName] {
            return [
                .eksAnywhere,
                .kubernetes
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .eksAnywhere: return "EKS_ANYWHERE"
            case .kubernetes: return "KUBERNETES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SnowballClientTypes {

    /// The version of the requested service.
    public struct ServiceVersion: Swift.Sendable {
        /// The version number of the requested service.
        public var version: Swift.String?

        public init(
            version: Swift.String? = nil
        )
        {
            self.version = version
        }
    }
}

extension SnowballClientTypes {

    /// The name and version of the service dependant on the requested service.
    public struct DependentService: Swift.Sendable {
        /// The name of the dependent service.
        public var serviceName: SnowballClientTypes.ServiceName?
        /// The version of the dependent service.
        public var serviceVersion: SnowballClientTypes.ServiceVersion?

        public init(
            serviceName: SnowballClientTypes.ServiceName? = nil,
            serviceVersion: SnowballClientTypes.ServiceVersion? = nil
        )
        {
            self.serviceName = serviceName
            self.serviceVersion = serviceVersion
        }
    }
}

public struct ListServiceVersionsInput: Swift.Sendable {
    /// A list of names and versions of dependant services of the requested service.
    public var dependentServices: [SnowballClientTypes.DependentService]?
    /// The maximum number of ListServiceVersions objects to return.
    public var maxResults: Swift.Int?
    /// Because HTTP requests are stateless, this is the starting point for the next list of returned ListServiceVersionsRequest versions.
    public var nextToken: Swift.String?
    /// The name of the service for which you're requesting supported versions.
    /// This member is required.
    public var serviceName: SnowballClientTypes.ServiceName?

    public init(
        dependentServices: [SnowballClientTypes.DependentService]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceName: SnowballClientTypes.ServiceName? = nil
    )
    {
        self.dependentServices = dependentServices
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceName = serviceName
    }
}

public struct ListServiceVersionsOutput: Swift.Sendable {
    /// A list of names and versions of dependant services of the service for which the system provided supported versions.
    public var dependentServices: [SnowballClientTypes.DependentService]?
    /// Because HTTP requests are stateless, this is the starting point of the next list of returned ListServiceVersionsResult results.
    public var nextToken: Swift.String?
    /// The name of the service for which the system provided supported versions.
    /// This member is required.
    public var serviceName: SnowballClientTypes.ServiceName?
    /// A list of supported versions.
    /// This member is required.
    public var serviceVersions: [SnowballClientTypes.ServiceVersion]?

    public init(
        dependentServices: [SnowballClientTypes.DependentService]? = nil,
        nextToken: Swift.String? = nil,
        serviceName: SnowballClientTypes.ServiceName? = nil,
        serviceVersions: [SnowballClientTypes.ServiceVersion]? = nil
    )
    {
        self.dependentServices = dependentServices
        self.nextToken = nextToken
        self.serviceName = serviceName
        self.serviceVersions = serviceVersions
    }
}

public struct UpdateClusterInput: Swift.Sendable {
    /// The ID of the updated [Address] object.
    public var addressId: Swift.String?
    /// The cluster ID of the cluster that you want to update, for example CID123e4567-e89b-12d3-a456-426655440000.
    /// This member is required.
    public var clusterId: Swift.String?
    /// The updated description of this cluster.
    public var description: Swift.String?
    /// The updated ID for the forwarding address for a cluster. This field is not supported in most regions.
    public var forwardingAddressId: Swift.String?
    /// The new or updated [Notification] object.
    public var notification: SnowballClientTypes.Notification?
    /// Specifies the service or services on the Snow Family device that your transferred data will be exported from or imported into. Amazon Web Services Snow Family device clusters support Amazon S3 and NFS (Network File System).
    public var onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration?
    /// The updated arrays of [JobResource] objects that can include updated [S3Resource] objects or [LambdaResource] objects.
    public var resources: SnowballClientTypes.JobResource?
    /// The new role Amazon Resource Name (ARN) that you want to associate with this cluster. To create a role ARN, use the [CreateRole](https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html) API action in Identity and Access Management (IAM).
    public var roleARN: Swift.String?
    /// The updated shipping option value of this cluster's [ShippingDetails] object.
    public var shippingOption: SnowballClientTypes.ShippingOption?

    public init(
        addressId: Swift.String? = nil,
        clusterId: Swift.String? = nil,
        description: Swift.String? = nil,
        forwardingAddressId: Swift.String? = nil,
        notification: SnowballClientTypes.Notification? = nil,
        onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration? = nil,
        resources: SnowballClientTypes.JobResource? = nil,
        roleARN: Swift.String? = nil,
        shippingOption: SnowballClientTypes.ShippingOption? = nil
    )
    {
        self.addressId = addressId
        self.clusterId = clusterId
        self.description = description
        self.forwardingAddressId = forwardingAddressId
        self.notification = notification
        self.onDeviceServiceConfiguration = onDeviceServiceConfiguration
        self.resources = resources
        self.roleARN = roleARN
        self.shippingOption = shippingOption
    }
}

public struct UpdateClusterOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateJobInput: Swift.Sendable {
    /// The ID of the updated [Address] object.
    public var addressId: Swift.String?
    /// The updated description of this job's [JobMetadata] object.
    public var description: Swift.String?
    /// The updated ID for the forwarding address for a job. This field is not supported in most regions.
    public var forwardingAddressId: Swift.String?
    /// The job ID of the job that you want to update, for example JID123e4567-e89b-12d3-a456-426655440000.
    /// This member is required.
    public var jobId: Swift.String?
    /// The new or updated [Notification] object.
    public var notification: SnowballClientTypes.Notification?
    /// Specifies the service or services on the Snow Family device that your transferred data will be exported from or imported into. Amazon Web Services Snow Family supports Amazon S3 and NFS (Network File System) and the Amazon Web Services Storage Gateway service Tape Gateway type.
    public var onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration?
    /// Information identifying the person picking up the device.
    public var pickupDetails: SnowballClientTypes.PickupDetails?
    /// The updated JobResource object, or the updated [JobResource] object.
    public var resources: SnowballClientTypes.JobResource?
    /// The new role Amazon Resource Name (ARN) that you want to associate with this job. To create a role ARN, use the [CreateRole](https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html)Identity and Access Management (IAM) API action.
    public var roleARN: Swift.String?
    /// The updated shipping option value of this job's [ShippingDetails] object.
    public var shippingOption: SnowballClientTypes.ShippingOption?
    /// The updated SnowballCapacityPreference of this job's [JobMetadata] object. The 50 TB Snowballs are only available in the US regions. For more information, see "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide or "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow Family Devices and Capacity) in the Snowcone User Guide.
    public var snowballCapacityPreference: SnowballClientTypes.SnowballCapacity?

    public init(
        addressId: Swift.String? = nil,
        description: Swift.String? = nil,
        forwardingAddressId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        notification: SnowballClientTypes.Notification? = nil,
        onDeviceServiceConfiguration: SnowballClientTypes.OnDeviceServiceConfiguration? = nil,
        pickupDetails: SnowballClientTypes.PickupDetails? = nil,
        resources: SnowballClientTypes.JobResource? = nil,
        roleARN: Swift.String? = nil,
        shippingOption: SnowballClientTypes.ShippingOption? = nil,
        snowballCapacityPreference: SnowballClientTypes.SnowballCapacity? = nil
    )
    {
        self.addressId = addressId
        self.description = description
        self.forwardingAddressId = forwardingAddressId
        self.jobId = jobId
        self.notification = notification
        self.onDeviceServiceConfiguration = onDeviceServiceConfiguration
        self.pickupDetails = pickupDetails
        self.resources = resources
        self.roleARN = roleARN
        self.shippingOption = shippingOption
        self.snowballCapacityPreference = snowballCapacityPreference
    }
}

public struct UpdateJobOutput: Swift.Sendable {

    public init() { }
}

extension SnowballClientTypes {

    public enum ShipmentState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case received
        case returned
        case sdkUnknown(Swift.String)

        public static var allCases: [ShipmentState] {
            return [
                .received,
                .returned
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .received: return "RECEIVED"
            case .returned: return "RETURNED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct UpdateJobShipmentStateInput: Swift.Sendable {
    /// The job ID of the job whose shipment date you want to update, for example JID123e4567-e89b-12d3-a456-426655440000.
    /// This member is required.
    public var jobId: Swift.String?
    /// The state of a device when it is being shipped. Set to RECEIVED when the device arrives at your location. Set to RETURNED when you have returned the device to Amazon Web Services.
    /// This member is required.
    public var shipmentState: SnowballClientTypes.ShipmentState?

    public init(
        jobId: Swift.String? = nil,
        shipmentState: SnowballClientTypes.ShipmentState? = nil
    )
    {
        self.jobId = jobId
        self.shipmentState = shipmentState
    }
}

public struct UpdateJobShipmentStateOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateLongTermPricingInput: Swift.Sendable {
    /// If set to true, specifies that the current long-term pricing type for the device should be automatically renewed before the long-term pricing contract expires.
    public var isLongTermPricingAutoRenew: Swift.Bool?
    /// The ID of the long-term pricing type for the device.
    /// This member is required.
    public var longTermPricingId: Swift.String?
    /// Specifies that a device that is ordered with long-term pricing should be replaced with a new device.
    public var replacementJob: Swift.String?

    public init(
        isLongTermPricingAutoRenew: Swift.Bool? = nil,
        longTermPricingId: Swift.String? = nil,
        replacementJob: Swift.String? = nil
    )
    {
        self.isLongTermPricingAutoRenew = isLongTermPricingAutoRenew
        self.longTermPricingId = longTermPricingId
        self.replacementJob = replacementJob
    }
}

public struct UpdateLongTermPricingOutput: Swift.Sendable {

    public init() { }
}

extension CancelClusterInput {

    static func urlPathProvider(_ value: CancelClusterInput) -> Swift.String? {
        return "/"
    }
}

extension CancelJobInput {

    static func urlPathProvider(_ value: CancelJobInput) -> Swift.String? {
        return "/"
    }
}

extension CreateAddressInput {

    static func urlPathProvider(_ value: CreateAddressInput) -> Swift.String? {
        return "/"
    }
}

extension CreateClusterInput {

    static func urlPathProvider(_ value: CreateClusterInput) -> Swift.String? {
        return "/"
    }
}

extension CreateJobInput {

    static func urlPathProvider(_ value: CreateJobInput) -> Swift.String? {
        return "/"
    }
}

extension CreateLongTermPricingInput {

    static func urlPathProvider(_ value: CreateLongTermPricingInput) -> Swift.String? {
        return "/"
    }
}

extension CreateReturnShippingLabelInput {

    static func urlPathProvider(_ value: CreateReturnShippingLabelInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAddressInput {

    static func urlPathProvider(_ value: DescribeAddressInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAddressesInput {

    static func urlPathProvider(_ value: DescribeAddressesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeClusterInput {

    static func urlPathProvider(_ value: DescribeClusterInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeJobInput {

    static func urlPathProvider(_ value: DescribeJobInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeReturnShippingLabelInput {

    static func urlPathProvider(_ value: DescribeReturnShippingLabelInput) -> Swift.String? {
        return "/"
    }
}

extension GetJobManifestInput {

    static func urlPathProvider(_ value: GetJobManifestInput) -> Swift.String? {
        return "/"
    }
}

extension GetJobUnlockCodeInput {

    static func urlPathProvider(_ value: GetJobUnlockCodeInput) -> Swift.String? {
        return "/"
    }
}

extension GetSnowballUsageInput {

    static func urlPathProvider(_ value: GetSnowballUsageInput) -> Swift.String? {
        return "/"
    }
}

extension GetSoftwareUpdatesInput {

    static func urlPathProvider(_ value: GetSoftwareUpdatesInput) -> Swift.String? {
        return "/"
    }
}

extension ListClusterJobsInput {

    static func urlPathProvider(_ value: ListClusterJobsInput) -> Swift.String? {
        return "/"
    }
}

extension ListClustersInput {

    static func urlPathProvider(_ value: ListClustersInput) -> Swift.String? {
        return "/"
    }
}

extension ListCompatibleImagesInput {

    static func urlPathProvider(_ value: ListCompatibleImagesInput) -> Swift.String? {
        return "/"
    }
}

extension ListJobsInput {

    static func urlPathProvider(_ value: ListJobsInput) -> Swift.String? {
        return "/"
    }
}

extension ListLongTermPricingInput {

    static func urlPathProvider(_ value: ListLongTermPricingInput) -> Swift.String? {
        return "/"
    }
}

extension ListPickupLocationsInput {

    static func urlPathProvider(_ value: ListPickupLocationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListServiceVersionsInput {

    static func urlPathProvider(_ value: ListServiceVersionsInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateClusterInput {

    static func urlPathProvider(_ value: UpdateClusterInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateJobInput {

    static func urlPathProvider(_ value: UpdateJobInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateJobShipmentStateInput {

    static func urlPathProvider(_ value: UpdateJobShipmentStateInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateLongTermPricingInput {

    static func urlPathProvider(_ value: UpdateLongTermPricingInput) -> Swift.String? {
        return "/"
    }
}

extension CancelClusterInput {

    static func write(value: CancelClusterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClusterId"].write(value.clusterId)
    }
}

extension CancelJobInput {

    static func write(value: CancelJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["JobId"].write(value.jobId)
    }
}

extension CreateAddressInput {

    static func write(value: CreateAddressInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Address"].write(value.address, with: SnowballClientTypes.Address.write(value:to:))
    }
}

extension CreateClusterInput {

    static func write(value: CreateClusterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddressId"].write(value.addressId)
        try writer["Description"].write(value.description)
        try writer["ForceCreateJobs"].write(value.forceCreateJobs)
        try writer["ForwardingAddressId"].write(value.forwardingAddressId)
        try writer["InitialClusterSize"].write(value.initialClusterSize)
        try writer["JobType"].write(value.jobType)
        try writer["KmsKeyARN"].write(value.kmsKeyARN)
        try writer["LongTermPricingIds"].writeList(value.longTermPricingIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Notification"].write(value.notification, with: SnowballClientTypes.Notification.write(value:to:))
        try writer["OnDeviceServiceConfiguration"].write(value.onDeviceServiceConfiguration, with: SnowballClientTypes.OnDeviceServiceConfiguration.write(value:to:))
        try writer["RemoteManagement"].write(value.remoteManagement)
        try writer["Resources"].write(value.resources, with: SnowballClientTypes.JobResource.write(value:to:))
        try writer["RoleARN"].write(value.roleARN)
        try writer["ShippingOption"].write(value.shippingOption)
        try writer["SnowballCapacityPreference"].write(value.snowballCapacityPreference)
        try writer["SnowballType"].write(value.snowballType)
        try writer["TaxDocuments"].write(value.taxDocuments, with: SnowballClientTypes.TaxDocuments.write(value:to:))
    }
}

extension CreateJobInput {

    static func write(value: CreateJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddressId"].write(value.addressId)
        try writer["ClusterId"].write(value.clusterId)
        try writer["Description"].write(value.description)
        try writer["DeviceConfiguration"].write(value.deviceConfiguration, with: SnowballClientTypes.DeviceConfiguration.write(value:to:))
        try writer["ForwardingAddressId"].write(value.forwardingAddressId)
        try writer["ImpactLevel"].write(value.impactLevel)
        try writer["JobType"].write(value.jobType)
        try writer["KmsKeyARN"].write(value.kmsKeyARN)
        try writer["LongTermPricingId"].write(value.longTermPricingId)
        try writer["Notification"].write(value.notification, with: SnowballClientTypes.Notification.write(value:to:))
        try writer["OnDeviceServiceConfiguration"].write(value.onDeviceServiceConfiguration, with: SnowballClientTypes.OnDeviceServiceConfiguration.write(value:to:))
        try writer["PickupDetails"].write(value.pickupDetails, with: SnowballClientTypes.PickupDetails.write(value:to:))
        try writer["RemoteManagement"].write(value.remoteManagement)
        try writer["Resources"].write(value.resources, with: SnowballClientTypes.JobResource.write(value:to:))
        try writer["RoleARN"].write(value.roleARN)
        try writer["ShippingOption"].write(value.shippingOption)
        try writer["SnowballCapacityPreference"].write(value.snowballCapacityPreference)
        try writer["SnowballType"].write(value.snowballType)
        try writer["TaxDocuments"].write(value.taxDocuments, with: SnowballClientTypes.TaxDocuments.write(value:to:))
    }
}

extension CreateLongTermPricingInput {

    static func write(value: CreateLongTermPricingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IsLongTermPricingAutoRenew"].write(value.isLongTermPricingAutoRenew)
        try writer["LongTermPricingType"].write(value.longTermPricingType)
        try writer["SnowballType"].write(value.snowballType)
    }
}

extension CreateReturnShippingLabelInput {

    static func write(value: CreateReturnShippingLabelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["JobId"].write(value.jobId)
        try writer["ShippingOption"].write(value.shippingOption)
    }
}

extension DescribeAddressInput {

    static func write(value: DescribeAddressInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddressId"].write(value.addressId)
    }
}

extension DescribeAddressesInput {

    static func write(value: DescribeAddressesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeClusterInput {

    static func write(value: DescribeClusterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClusterId"].write(value.clusterId)
    }
}

extension DescribeJobInput {

    static func write(value: DescribeJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["JobId"].write(value.jobId)
    }
}

extension DescribeReturnShippingLabelInput {

    static func write(value: DescribeReturnShippingLabelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["JobId"].write(value.jobId)
    }
}

extension GetJobManifestInput {

    static func write(value: GetJobManifestInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["JobId"].write(value.jobId)
    }
}

extension GetJobUnlockCodeInput {

    static func write(value: GetJobUnlockCodeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["JobId"].write(value.jobId)
    }
}

extension GetSnowballUsageInput {

    static func write(value: GetSnowballUsageInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetSoftwareUpdatesInput {

    static func write(value: GetSoftwareUpdatesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["JobId"].write(value.jobId)
    }
}

extension ListClusterJobsInput {

    static func write(value: ListClusterJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClusterId"].write(value.clusterId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListClustersInput {

    static func write(value: ListClustersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListCompatibleImagesInput {

    static func write(value: ListCompatibleImagesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListJobsInput {

    static func write(value: ListJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListLongTermPricingInput {

    static func write(value: ListLongTermPricingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListPickupLocationsInput {

    static func write(value: ListPickupLocationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListServiceVersionsInput {

    static func write(value: ListServiceVersionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DependentServices"].writeList(value.dependentServices, memberWritingClosure: SnowballClientTypes.DependentService.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ServiceName"].write(value.serviceName)
    }
}

extension UpdateClusterInput {

    static func write(value: UpdateClusterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddressId"].write(value.addressId)
        try writer["ClusterId"].write(value.clusterId)
        try writer["Description"].write(value.description)
        try writer["ForwardingAddressId"].write(value.forwardingAddressId)
        try writer["Notification"].write(value.notification, with: SnowballClientTypes.Notification.write(value:to:))
        try writer["OnDeviceServiceConfiguration"].write(value.onDeviceServiceConfiguration, with: SnowballClientTypes.OnDeviceServiceConfiguration.write(value:to:))
        try writer["Resources"].write(value.resources, with: SnowballClientTypes.JobResource.write(value:to:))
        try writer["RoleARN"].write(value.roleARN)
        try writer["ShippingOption"].write(value.shippingOption)
    }
}

extension UpdateJobInput {

    static func write(value: UpdateJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddressId"].write(value.addressId)
        try writer["Description"].write(value.description)
        try writer["ForwardingAddressId"].write(value.forwardingAddressId)
        try writer["JobId"].write(value.jobId)
        try writer["Notification"].write(value.notification, with: SnowballClientTypes.Notification.write(value:to:))
        try writer["OnDeviceServiceConfiguration"].write(value.onDeviceServiceConfiguration, with: SnowballClientTypes.OnDeviceServiceConfiguration.write(value:to:))
        try writer["PickupDetails"].write(value.pickupDetails, with: SnowballClientTypes.PickupDetails.write(value:to:))
        try writer["Resources"].write(value.resources, with: SnowballClientTypes.JobResource.write(value:to:))
        try writer["RoleARN"].write(value.roleARN)
        try writer["ShippingOption"].write(value.shippingOption)
        try writer["SnowballCapacityPreference"].write(value.snowballCapacityPreference)
    }
}

extension UpdateJobShipmentStateInput {

    static func write(value: UpdateJobShipmentStateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["JobId"].write(value.jobId)
        try writer["ShipmentState"].write(value.shipmentState)
    }
}

extension UpdateLongTermPricingInput {

    static func write(value: UpdateLongTermPricingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IsLongTermPricingAutoRenew"].write(value.isLongTermPricingAutoRenew)
        try writer["LongTermPricingId"].write(value.longTermPricingId)
        try writer["ReplacementJob"].write(value.replacementJob)
    }
}

extension CancelClusterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelClusterOutput {
        return CancelClusterOutput()
    }
}

extension CancelJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelJobOutput {
        return CancelJobOutput()
    }
}

extension CreateAddressOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAddressOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAddressOutput()
        value.addressId = try reader["AddressId"].readIfPresent()
        return value
    }
}

extension CreateClusterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateClusterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateClusterOutput()
        value.clusterId = try reader["ClusterId"].readIfPresent()
        value.jobListEntries = try reader["JobListEntries"].readListIfPresent(memberReadingClosure: SnowballClientTypes.JobListEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateJobOutput()
        value.jobId = try reader["JobId"].readIfPresent()
        return value
    }
}

extension CreateLongTermPricingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLongTermPricingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateLongTermPricingOutput()
        value.longTermPricingId = try reader["LongTermPricingId"].readIfPresent()
        return value
    }
}

extension CreateReturnShippingLabelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateReturnShippingLabelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateReturnShippingLabelOutput()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension DescribeAddressOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAddressOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAddressOutput()
        value.address = try reader["Address"].readIfPresent(with: SnowballClientTypes.Address.read(from:))
        return value
    }
}

extension DescribeAddressesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAddressesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAddressesOutput()
        value.addresses = try reader["Addresses"].readListIfPresent(memberReadingClosure: SnowballClientTypes.Address.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeClusterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeClusterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeClusterOutput()
        value.clusterMetadata = try reader["ClusterMetadata"].readIfPresent(with: SnowballClientTypes.ClusterMetadata.read(from:))
        return value
    }
}

extension DescribeJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeJobOutput()
        value.jobMetadata = try reader["JobMetadata"].readIfPresent(with: SnowballClientTypes.JobMetadata.read(from:))
        value.subJobMetadata = try reader["SubJobMetadata"].readListIfPresent(memberReadingClosure: SnowballClientTypes.JobMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeReturnShippingLabelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeReturnShippingLabelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeReturnShippingLabelOutput()
        value.expirationDate = try reader["ExpirationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.returnShippingLabelURI = try reader["ReturnShippingLabelURI"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension GetJobManifestOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetJobManifestOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetJobManifestOutput()
        value.manifestURI = try reader["ManifestURI"].readIfPresent()
        return value
    }
}

extension GetJobUnlockCodeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetJobUnlockCodeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetJobUnlockCodeOutput()
        value.unlockCode = try reader["UnlockCode"].readIfPresent()
        return value
    }
}

extension GetSnowballUsageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSnowballUsageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSnowballUsageOutput()
        value.snowballLimit = try reader["SnowballLimit"].readIfPresent()
        value.snowballsInUse = try reader["SnowballsInUse"].readIfPresent()
        return value
    }
}

extension GetSoftwareUpdatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSoftwareUpdatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSoftwareUpdatesOutput()
        value.updatesURI = try reader["UpdatesURI"].readIfPresent()
        return value
    }
}

extension ListClusterJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListClusterJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListClusterJobsOutput()
        value.jobListEntries = try reader["JobListEntries"].readListIfPresent(memberReadingClosure: SnowballClientTypes.JobListEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListClustersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListClustersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListClustersOutput()
        value.clusterListEntries = try reader["ClusterListEntries"].readListIfPresent(memberReadingClosure: SnowballClientTypes.ClusterListEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListCompatibleImagesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCompatibleImagesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCompatibleImagesOutput()
        value.compatibleImages = try reader["CompatibleImages"].readListIfPresent(memberReadingClosure: SnowballClientTypes.CompatibleImage.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListJobsOutput()
        value.jobListEntries = try reader["JobListEntries"].readListIfPresent(memberReadingClosure: SnowballClientTypes.JobListEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListLongTermPricingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLongTermPricingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLongTermPricingOutput()
        value.longTermPricingEntries = try reader["LongTermPricingEntries"].readListIfPresent(memberReadingClosure: SnowballClientTypes.LongTermPricingListEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListPickupLocationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPickupLocationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPickupLocationsOutput()
        value.addresses = try reader["Addresses"].readListIfPresent(memberReadingClosure: SnowballClientTypes.Address.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListServiceVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListServiceVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListServiceVersionsOutput()
        value.dependentServices = try reader["DependentServices"].readListIfPresent(memberReadingClosure: SnowballClientTypes.DependentService.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.serviceName = try reader["ServiceName"].readIfPresent() ?? .sdkUnknown("")
        value.serviceVersions = try reader["ServiceVersions"].readListIfPresent(memberReadingClosure: SnowballClientTypes.ServiceVersion.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension UpdateClusterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateClusterOutput {
        return UpdateClusterOutput()
    }
}

extension UpdateJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateJobOutput {
        return UpdateJobOutput()
    }
}

extension UpdateJobShipmentStateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateJobShipmentStateOutput {
        return UpdateJobShipmentStateOutput()
    }
}

extension UpdateLongTermPricingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateLongTermPricingOutput {
        return UpdateLongTermPricingOutput()
    }
}

enum CancelClusterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidJobStateException": return try InvalidJobStateException.makeError(baseError: baseError)
            case "InvalidResourceException": return try InvalidResourceException.makeError(baseError: baseError)
            case "KMSRequestFailedException": return try KMSRequestFailedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidJobStateException": return try InvalidJobStateException.makeError(baseError: baseError)
            case "InvalidResourceException": return try InvalidResourceException.makeError(baseError: baseError)
            case "KMSRequestFailedException": return try KMSRequestFailedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAddressOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidAddressException": return try InvalidAddressException.makeError(baseError: baseError)
            case "UnsupportedAddressException": return try UnsupportedAddressException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateClusterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "Ec2RequestFailedException": return try Ec2RequestFailedException.makeError(baseError: baseError)
            case "InvalidInputCombinationException": return try InvalidInputCombinationException.makeError(baseError: baseError)
            case "InvalidResourceException": return try InvalidResourceException.makeError(baseError: baseError)
            case "KMSRequestFailedException": return try KMSRequestFailedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ClusterLimitExceededException": return try ClusterLimitExceededException.makeError(baseError: baseError)
            case "Ec2RequestFailedException": return try Ec2RequestFailedException.makeError(baseError: baseError)
            case "InvalidInputCombinationException": return try InvalidInputCombinationException.makeError(baseError: baseError)
            case "InvalidResourceException": return try InvalidResourceException.makeError(baseError: baseError)
            case "KMSRequestFailedException": return try KMSRequestFailedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLongTermPricingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidResourceException": return try InvalidResourceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateReturnShippingLabelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InvalidInputCombinationException": return try InvalidInputCombinationException.makeError(baseError: baseError)
            case "InvalidJobStateException": return try InvalidJobStateException.makeError(baseError: baseError)
            case "InvalidResourceException": return try InvalidResourceException.makeError(baseError: baseError)
            case "ReturnShippingLabelAlreadyExistsException": return try ReturnShippingLabelAlreadyExistsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAddressOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidResourceException": return try InvalidResourceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAddressesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidResourceException": return try InvalidResourceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeClusterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidResourceException": return try InvalidResourceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidResourceException": return try InvalidResourceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeReturnShippingLabelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InvalidJobStateException": return try InvalidJobStateException.makeError(baseError: baseError)
            case "InvalidResourceException": return try InvalidResourceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetJobManifestOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidJobStateException": return try InvalidJobStateException.makeError(baseError: baseError)
            case "InvalidResourceException": return try InvalidResourceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetJobUnlockCodeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidJobStateException": return try InvalidJobStateException.makeError(baseError: baseError)
            case "InvalidResourceException": return try InvalidResourceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSnowballUsageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSoftwareUpdatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidJobStateException": return try InvalidJobStateException.makeError(baseError: baseError)
            case "InvalidResourceException": return try InvalidResourceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListClusterJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidResourceException": return try InvalidResourceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListClustersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCompatibleImagesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "Ec2RequestFailedException": return try Ec2RequestFailedException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLongTermPricingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidResourceException": return try InvalidResourceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPickupLocationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidResourceException": return try InvalidResourceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListServiceVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidResourceException": return try InvalidResourceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateClusterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "Ec2RequestFailedException": return try Ec2RequestFailedException.makeError(baseError: baseError)
            case "InvalidInputCombinationException": return try InvalidInputCombinationException.makeError(baseError: baseError)
            case "InvalidJobStateException": return try InvalidJobStateException.makeError(baseError: baseError)
            case "InvalidResourceException": return try InvalidResourceException.makeError(baseError: baseError)
            case "KMSRequestFailedException": return try KMSRequestFailedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ClusterLimitExceededException": return try ClusterLimitExceededException.makeError(baseError: baseError)
            case "Ec2RequestFailedException": return try Ec2RequestFailedException.makeError(baseError: baseError)
            case "InvalidInputCombinationException": return try InvalidInputCombinationException.makeError(baseError: baseError)
            case "InvalidJobStateException": return try InvalidJobStateException.makeError(baseError: baseError)
            case "InvalidResourceException": return try InvalidResourceException.makeError(baseError: baseError)
            case "KMSRequestFailedException": return try KMSRequestFailedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateJobShipmentStateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidJobStateException": return try InvalidJobStateException.makeError(baseError: baseError)
            case "InvalidResourceException": return try InvalidResourceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateLongTermPricingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidResourceException": return try InvalidResourceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension KMSRequestFailedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> KMSRequestFailedException {
        let reader = baseError.errorBodyReader
        var value = KMSRequestFailedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidJobStateException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidJobStateException {
        let reader = baseError.errorBodyReader
        var value = InvalidJobStateException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidResourceException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidResourceException {
        let reader = baseError.errorBodyReader
        var value = InvalidResourceException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.resourceType = try reader["ResourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnsupportedAddressException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> UnsupportedAddressException {
        let reader = baseError.errorBodyReader
        var value = UnsupportedAddressException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidAddressException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidAddressException {
        let reader = baseError.errorBodyReader
        var value = InvalidAddressException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension Ec2RequestFailedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> Ec2RequestFailedException {
        let reader = baseError.errorBodyReader
        var value = Ec2RequestFailedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidInputCombinationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidInputCombinationException {
        let reader = baseError.errorBodyReader
        var value = InvalidInputCombinationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ClusterLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ClusterLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = ClusterLimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ReturnShippingLabelAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ReturnShippingLabelAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = ReturnShippingLabelAlreadyExistsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.conflictResource = try reader["ConflictResource"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidNextTokenException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidNextTokenException {
        let reader = baseError.errorBodyReader
        var value = InvalidNextTokenException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SnowballClientTypes.JobListEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> SnowballClientTypes.JobListEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowballClientTypes.JobListEntry()
        value.jobId = try reader["JobId"].readIfPresent()
        value.jobState = try reader["JobState"].readIfPresent()
        value.isMaster = try reader["IsMaster"].readIfPresent() ?? false
        value.jobType = try reader["JobType"].readIfPresent()
        value.snowballType = try reader["SnowballType"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension SnowballClientTypes.Address {

    static func write(value: SnowballClientTypes.Address?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AddressId"].write(value.addressId)
        try writer["City"].write(value.city)
        try writer["Company"].write(value.company)
        try writer["Country"].write(value.country)
        try writer["IsRestricted"].write(value.isRestricted)
        try writer["Landmark"].write(value.landmark)
        try writer["Name"].write(value.name)
        try writer["PhoneNumber"].write(value.phoneNumber)
        try writer["PostalCode"].write(value.postalCode)
        try writer["PrefectureOrDistrict"].write(value.prefectureOrDistrict)
        try writer["StateOrProvince"].write(value.stateOrProvince)
        try writer["Street1"].write(value.street1)
        try writer["Street2"].write(value.street2)
        try writer["Street3"].write(value.street3)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SnowballClientTypes.Address {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowballClientTypes.Address()
        value.addressId = try reader["AddressId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.company = try reader["Company"].readIfPresent()
        value.street1 = try reader["Street1"].readIfPresent()
        value.street2 = try reader["Street2"].readIfPresent()
        value.street3 = try reader["Street3"].readIfPresent()
        value.city = try reader["City"].readIfPresent()
        value.stateOrProvince = try reader["StateOrProvince"].readIfPresent()
        value.prefectureOrDistrict = try reader["PrefectureOrDistrict"].readIfPresent()
        value.landmark = try reader["Landmark"].readIfPresent()
        value.country = try reader["Country"].readIfPresent()
        value.postalCode = try reader["PostalCode"].readIfPresent()
        value.phoneNumber = try reader["PhoneNumber"].readIfPresent()
        value.isRestricted = try reader["IsRestricted"].readIfPresent() ?? false
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension SnowballClientTypes.ClusterMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> SnowballClientTypes.ClusterMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowballClientTypes.ClusterMetadata()
        value.clusterId = try reader["ClusterId"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.kmsKeyARN = try reader["KmsKeyARN"].readIfPresent()
        value.roleARN = try reader["RoleARN"].readIfPresent()
        value.clusterState = try reader["ClusterState"].readIfPresent()
        value.jobType = try reader["JobType"].readIfPresent()
        value.snowballType = try reader["SnowballType"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.resources = try reader["Resources"].readIfPresent(with: SnowballClientTypes.JobResource.read(from:))
        value.addressId = try reader["AddressId"].readIfPresent()
        value.shippingOption = try reader["ShippingOption"].readIfPresent()
        value.notification = try reader["Notification"].readIfPresent(with: SnowballClientTypes.Notification.read(from:))
        value.forwardingAddressId = try reader["ForwardingAddressId"].readIfPresent()
        value.taxDocuments = try reader["TaxDocuments"].readIfPresent(with: SnowballClientTypes.TaxDocuments.read(from:))
        value.onDeviceServiceConfiguration = try reader["OnDeviceServiceConfiguration"].readIfPresent(with: SnowballClientTypes.OnDeviceServiceConfiguration.read(from:))
        return value
    }
}

extension SnowballClientTypes.OnDeviceServiceConfiguration {

    static func write(value: SnowballClientTypes.OnDeviceServiceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EKSOnDeviceService"].write(value.eksOnDeviceService, with: SnowballClientTypes.EKSOnDeviceServiceConfiguration.write(value:to:))
        try writer["NFSOnDeviceService"].write(value.nfsOnDeviceService, with: SnowballClientTypes.NFSOnDeviceServiceConfiguration.write(value:to:))
        try writer["S3OnDeviceService"].write(value.s3OnDeviceService, with: SnowballClientTypes.S3OnDeviceServiceConfiguration.write(value:to:))
        try writer["TGWOnDeviceService"].write(value.tgwOnDeviceService, with: SnowballClientTypes.TGWOnDeviceServiceConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SnowballClientTypes.OnDeviceServiceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowballClientTypes.OnDeviceServiceConfiguration()
        value.nfsOnDeviceService = try reader["NFSOnDeviceService"].readIfPresent(with: SnowballClientTypes.NFSOnDeviceServiceConfiguration.read(from:))
        value.tgwOnDeviceService = try reader["TGWOnDeviceService"].readIfPresent(with: SnowballClientTypes.TGWOnDeviceServiceConfiguration.read(from:))
        value.eksOnDeviceService = try reader["EKSOnDeviceService"].readIfPresent(with: SnowballClientTypes.EKSOnDeviceServiceConfiguration.read(from:))
        value.s3OnDeviceService = try reader["S3OnDeviceService"].readIfPresent(with: SnowballClientTypes.S3OnDeviceServiceConfiguration.read(from:))
        return value
    }
}

extension SnowballClientTypes.S3OnDeviceServiceConfiguration {

    static func write(value: SnowballClientTypes.S3OnDeviceServiceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FaultTolerance"].write(value.faultTolerance)
        try writer["ServiceSize"].write(value.serviceSize)
        try writer["StorageLimit"].write(value.storageLimit)
        try writer["StorageUnit"].write(value.storageUnit)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SnowballClientTypes.S3OnDeviceServiceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowballClientTypes.S3OnDeviceServiceConfiguration()
        value.storageLimit = try reader["StorageLimit"].readIfPresent()
        value.storageUnit = try reader["StorageUnit"].readIfPresent()
        value.serviceSize = try reader["ServiceSize"].readIfPresent()
        value.faultTolerance = try reader["FaultTolerance"].readIfPresent()
        return value
    }
}

extension SnowballClientTypes.EKSOnDeviceServiceConfiguration {

    static func write(value: SnowballClientTypes.EKSOnDeviceServiceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EKSAnywhereVersion"].write(value.eksAnywhereVersion)
        try writer["KubernetesVersion"].write(value.kubernetesVersion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SnowballClientTypes.EKSOnDeviceServiceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowballClientTypes.EKSOnDeviceServiceConfiguration()
        value.kubernetesVersion = try reader["KubernetesVersion"].readIfPresent()
        value.eksAnywhereVersion = try reader["EKSAnywhereVersion"].readIfPresent()
        return value
    }
}

extension SnowballClientTypes.TGWOnDeviceServiceConfiguration {

    static func write(value: SnowballClientTypes.TGWOnDeviceServiceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StorageLimit"].write(value.storageLimit)
        try writer["StorageUnit"].write(value.storageUnit)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SnowballClientTypes.TGWOnDeviceServiceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowballClientTypes.TGWOnDeviceServiceConfiguration()
        value.storageLimit = try reader["StorageLimit"].readIfPresent() ?? 0
        value.storageUnit = try reader["StorageUnit"].readIfPresent()
        return value
    }
}

extension SnowballClientTypes.NFSOnDeviceServiceConfiguration {

    static func write(value: SnowballClientTypes.NFSOnDeviceServiceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StorageLimit"].write(value.storageLimit)
        try writer["StorageUnit"].write(value.storageUnit)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SnowballClientTypes.NFSOnDeviceServiceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowballClientTypes.NFSOnDeviceServiceConfiguration()
        value.storageLimit = try reader["StorageLimit"].readIfPresent() ?? 0
        value.storageUnit = try reader["StorageUnit"].readIfPresent()
        return value
    }
}

extension SnowballClientTypes.TaxDocuments {

    static func write(value: SnowballClientTypes.TaxDocuments?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IND"].write(value.ind, with: SnowballClientTypes.INDTaxDocuments.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SnowballClientTypes.TaxDocuments {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowballClientTypes.TaxDocuments()
        value.ind = try reader["IND"].readIfPresent(with: SnowballClientTypes.INDTaxDocuments.read(from:))
        return value
    }
}

extension SnowballClientTypes.INDTaxDocuments {

    static func write(value: SnowballClientTypes.INDTaxDocuments?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GSTIN"].write(value.gstin)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SnowballClientTypes.INDTaxDocuments {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowballClientTypes.INDTaxDocuments()
        value.gstin = try reader["GSTIN"].readIfPresent()
        return value
    }
}

extension SnowballClientTypes.Notification {

    static func write(value: SnowballClientTypes.Notification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DevicePickupSnsTopicARN"].write(value.devicePickupSnsTopicARN)
        try writer["JobStatesToNotify"].writeList(value.jobStatesToNotify, memberWritingClosure: SmithyReadWrite.WritingClosureBox<SnowballClientTypes.JobState>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NotifyAll"].write(value.notifyAll)
        try writer["SnsTopicARN"].write(value.snsTopicARN)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SnowballClientTypes.Notification {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowballClientTypes.Notification()
        value.snsTopicARN = try reader["SnsTopicARN"].readIfPresent()
        value.jobStatesToNotify = try reader["JobStatesToNotify"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<SnowballClientTypes.JobState>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.notifyAll = try reader["NotifyAll"].readIfPresent() ?? false
        value.devicePickupSnsTopicARN = try reader["DevicePickupSnsTopicARN"].readIfPresent()
        return value
    }
}

extension SnowballClientTypes.JobResource {

    static func write(value: SnowballClientTypes.JobResource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Ec2AmiResources"].writeList(value.ec2AmiResources, memberWritingClosure: SnowballClientTypes.Ec2AmiResource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LambdaResources"].writeList(value.lambdaResources, memberWritingClosure: SnowballClientTypes.LambdaResource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["S3Resources"].writeList(value.s3Resources, memberWritingClosure: SnowballClientTypes.S3Resource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SnowballClientTypes.JobResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowballClientTypes.JobResource()
        value.s3Resources = try reader["S3Resources"].readListIfPresent(memberReadingClosure: SnowballClientTypes.S3Resource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lambdaResources = try reader["LambdaResources"].readListIfPresent(memberReadingClosure: SnowballClientTypes.LambdaResource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ec2AmiResources = try reader["Ec2AmiResources"].readListIfPresent(memberReadingClosure: SnowballClientTypes.Ec2AmiResource.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SnowballClientTypes.Ec2AmiResource {

    static func write(value: SnowballClientTypes.Ec2AmiResource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AmiId"].write(value.amiId)
        try writer["SnowballAmiId"].write(value.snowballAmiId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SnowballClientTypes.Ec2AmiResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowballClientTypes.Ec2AmiResource()
        value.amiId = try reader["AmiId"].readIfPresent() ?? ""
        value.snowballAmiId = try reader["SnowballAmiId"].readIfPresent()
        return value
    }
}

extension SnowballClientTypes.LambdaResource {

    static func write(value: SnowballClientTypes.LambdaResource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EventTriggers"].writeList(value.eventTriggers, memberWritingClosure: SnowballClientTypes.EventTriggerDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LambdaArn"].write(value.lambdaArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SnowballClientTypes.LambdaResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowballClientTypes.LambdaResource()
        value.lambdaArn = try reader["LambdaArn"].readIfPresent()
        value.eventTriggers = try reader["EventTriggers"].readListIfPresent(memberReadingClosure: SnowballClientTypes.EventTriggerDefinition.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SnowballClientTypes.EventTriggerDefinition {

    static func write(value: SnowballClientTypes.EventTriggerDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EventResourceARN"].write(value.eventResourceARN)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SnowballClientTypes.EventTriggerDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowballClientTypes.EventTriggerDefinition()
        value.eventResourceARN = try reader["EventResourceARN"].readIfPresent()
        return value
    }
}

extension SnowballClientTypes.S3Resource {

    static func write(value: SnowballClientTypes.S3Resource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BucketArn"].write(value.bucketArn)
        try writer["KeyRange"].write(value.keyRange, with: SnowballClientTypes.KeyRange.write(value:to:))
        try writer["TargetOnDeviceServices"].writeList(value.targetOnDeviceServices, memberWritingClosure: SnowballClientTypes.TargetOnDeviceService.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SnowballClientTypes.S3Resource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowballClientTypes.S3Resource()
        value.bucketArn = try reader["BucketArn"].readIfPresent()
        value.keyRange = try reader["KeyRange"].readIfPresent(with: SnowballClientTypes.KeyRange.read(from:))
        value.targetOnDeviceServices = try reader["TargetOnDeviceServices"].readListIfPresent(memberReadingClosure: SnowballClientTypes.TargetOnDeviceService.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SnowballClientTypes.TargetOnDeviceService {

    static func write(value: SnowballClientTypes.TargetOnDeviceService?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ServiceName"].write(value.serviceName)
        try writer["TransferOption"].write(value.transferOption)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SnowballClientTypes.TargetOnDeviceService {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowballClientTypes.TargetOnDeviceService()
        value.serviceName = try reader["ServiceName"].readIfPresent()
        value.transferOption = try reader["TransferOption"].readIfPresent()
        return value
    }
}

extension SnowballClientTypes.KeyRange {

    static func write(value: SnowballClientTypes.KeyRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BeginMarker"].write(value.beginMarker)
        try writer["EndMarker"].write(value.endMarker)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SnowballClientTypes.KeyRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowballClientTypes.KeyRange()
        value.beginMarker = try reader["BeginMarker"].readIfPresent()
        value.endMarker = try reader["EndMarker"].readIfPresent()
        return value
    }
}

extension SnowballClientTypes.JobMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> SnowballClientTypes.JobMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowballClientTypes.JobMetadata()
        value.jobId = try reader["JobId"].readIfPresent()
        value.jobState = try reader["JobState"].readIfPresent()
        value.jobType = try reader["JobType"].readIfPresent()
        value.snowballType = try reader["SnowballType"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.resources = try reader["Resources"].readIfPresent(with: SnowballClientTypes.JobResource.read(from:))
        value.description = try reader["Description"].readIfPresent()
        value.kmsKeyARN = try reader["KmsKeyARN"].readIfPresent()
        value.roleARN = try reader["RoleARN"].readIfPresent()
        value.addressId = try reader["AddressId"].readIfPresent()
        value.shippingDetails = try reader["ShippingDetails"].readIfPresent(with: SnowballClientTypes.ShippingDetails.read(from:))
        value.snowballCapacityPreference = try reader["SnowballCapacityPreference"].readIfPresent()
        value.notification = try reader["Notification"].readIfPresent(with: SnowballClientTypes.Notification.read(from:))
        value.dataTransferProgress = try reader["DataTransferProgress"].readIfPresent(with: SnowballClientTypes.DataTransfer.read(from:))
        value.jobLogInfo = try reader["JobLogInfo"].readIfPresent(with: SnowballClientTypes.JobLogs.read(from:))
        value.clusterId = try reader["ClusterId"].readIfPresent()
        value.forwardingAddressId = try reader["ForwardingAddressId"].readIfPresent()
        value.taxDocuments = try reader["TaxDocuments"].readIfPresent(with: SnowballClientTypes.TaxDocuments.read(from:))
        value.deviceConfiguration = try reader["DeviceConfiguration"].readIfPresent(with: SnowballClientTypes.DeviceConfiguration.read(from:))
        value.remoteManagement = try reader["RemoteManagement"].readIfPresent()
        value.longTermPricingId = try reader["LongTermPricingId"].readIfPresent()
        value.onDeviceServiceConfiguration = try reader["OnDeviceServiceConfiguration"].readIfPresent(with: SnowballClientTypes.OnDeviceServiceConfiguration.read(from:))
        value.impactLevel = try reader["ImpactLevel"].readIfPresent()
        value.pickupDetails = try reader["PickupDetails"].readIfPresent(with: SnowballClientTypes.PickupDetails.read(from:))
        value.snowballId = try reader["SnowballId"].readIfPresent()
        return value
    }
}

extension SnowballClientTypes.PickupDetails {

    static func write(value: SnowballClientTypes.PickupDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DevicePickupId"].write(value.devicePickupId)
        try writer["Email"].write(value.email)
        try writer["IdentificationExpirationDate"].writeTimestamp(value.identificationExpirationDate, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["IdentificationIssuingOrg"].write(value.identificationIssuingOrg)
        try writer["IdentificationNumber"].write(value.identificationNumber)
        try writer["Name"].write(value.name)
        try writer["PhoneNumber"].write(value.phoneNumber)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SnowballClientTypes.PickupDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowballClientTypes.PickupDetails()
        value.name = try reader["Name"].readIfPresent()
        value.phoneNumber = try reader["PhoneNumber"].readIfPresent()
        value.email = try reader["Email"].readIfPresent()
        value.identificationNumber = try reader["IdentificationNumber"].readIfPresent()
        value.identificationExpirationDate = try reader["IdentificationExpirationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.identificationIssuingOrg = try reader["IdentificationIssuingOrg"].readIfPresent()
        value.devicePickupId = try reader["DevicePickupId"].readIfPresent()
        return value
    }
}

extension SnowballClientTypes.DeviceConfiguration {

    static func write(value: SnowballClientTypes.DeviceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SnowconeDeviceConfiguration"].write(value.snowconeDeviceConfiguration, with: SnowballClientTypes.SnowconeDeviceConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SnowballClientTypes.DeviceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowballClientTypes.DeviceConfiguration()
        value.snowconeDeviceConfiguration = try reader["SnowconeDeviceConfiguration"].readIfPresent(with: SnowballClientTypes.SnowconeDeviceConfiguration.read(from:))
        return value
    }
}

extension SnowballClientTypes.SnowconeDeviceConfiguration {

    static func write(value: SnowballClientTypes.SnowconeDeviceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WirelessConnection"].write(value.wirelessConnection, with: SnowballClientTypes.WirelessConnection.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SnowballClientTypes.SnowconeDeviceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowballClientTypes.SnowconeDeviceConfiguration()
        value.wirelessConnection = try reader["WirelessConnection"].readIfPresent(with: SnowballClientTypes.WirelessConnection.read(from:))
        return value
    }
}

extension SnowballClientTypes.WirelessConnection {

    static func write(value: SnowballClientTypes.WirelessConnection?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IsWifiEnabled"].write(value.isWifiEnabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SnowballClientTypes.WirelessConnection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowballClientTypes.WirelessConnection()
        value.isWifiEnabled = try reader["IsWifiEnabled"].readIfPresent() ?? false
        return value
    }
}

extension SnowballClientTypes.JobLogs {

    static func read(from reader: SmithyJSON.Reader) throws -> SnowballClientTypes.JobLogs {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowballClientTypes.JobLogs()
        value.jobCompletionReportURI = try reader["JobCompletionReportURI"].readIfPresent()
        value.jobSuccessLogURI = try reader["JobSuccessLogURI"].readIfPresent()
        value.jobFailureLogURI = try reader["JobFailureLogURI"].readIfPresent()
        return value
    }
}

extension SnowballClientTypes.DataTransfer {

    static func read(from reader: SmithyJSON.Reader) throws -> SnowballClientTypes.DataTransfer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowballClientTypes.DataTransfer()
        value.bytesTransferred = try reader["BytesTransferred"].readIfPresent() ?? 0
        value.objectsTransferred = try reader["ObjectsTransferred"].readIfPresent() ?? 0
        value.totalBytes = try reader["TotalBytes"].readIfPresent() ?? 0
        value.totalObjects = try reader["TotalObjects"].readIfPresent() ?? 0
        return value
    }
}

extension SnowballClientTypes.ShippingDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SnowballClientTypes.ShippingDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowballClientTypes.ShippingDetails()
        value.shippingOption = try reader["ShippingOption"].readIfPresent()
        value.inboundShipment = try reader["InboundShipment"].readIfPresent(with: SnowballClientTypes.Shipment.read(from:))
        value.outboundShipment = try reader["OutboundShipment"].readIfPresent(with: SnowballClientTypes.Shipment.read(from:))
        return value
    }
}

extension SnowballClientTypes.Shipment {

    static func read(from reader: SmithyJSON.Reader) throws -> SnowballClientTypes.Shipment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowballClientTypes.Shipment()
        value.status = try reader["Status"].readIfPresent()
        value.trackingNumber = try reader["TrackingNumber"].readIfPresent()
        return value
    }
}

extension SnowballClientTypes.ClusterListEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> SnowballClientTypes.ClusterListEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowballClientTypes.ClusterListEntry()
        value.clusterId = try reader["ClusterId"].readIfPresent()
        value.clusterState = try reader["ClusterState"].readIfPresent()
        value.creationDate = try reader["CreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension SnowballClientTypes.CompatibleImage {

    static func read(from reader: SmithyJSON.Reader) throws -> SnowballClientTypes.CompatibleImage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowballClientTypes.CompatibleImage()
        value.amiId = try reader["AmiId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension SnowballClientTypes.LongTermPricingListEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> SnowballClientTypes.LongTermPricingListEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowballClientTypes.LongTermPricingListEntry()
        value.longTermPricingId = try reader["LongTermPricingId"].readIfPresent()
        value.longTermPricingEndDate = try reader["LongTermPricingEndDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.longTermPricingStartDate = try reader["LongTermPricingStartDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.longTermPricingType = try reader["LongTermPricingType"].readIfPresent()
        value.currentActiveJob = try reader["CurrentActiveJob"].readIfPresent()
        value.replacementJob = try reader["ReplacementJob"].readIfPresent()
        value.isLongTermPricingAutoRenew = try reader["IsLongTermPricingAutoRenew"].readIfPresent()
        value.longTermPricingStatus = try reader["LongTermPricingStatus"].readIfPresent()
        value.snowballType = try reader["SnowballType"].readIfPresent()
        value.jobIds = try reader["JobIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SnowballClientTypes.ServiceVersion {

    static func write(value: SnowballClientTypes.ServiceVersion?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Version"].write(value.version)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SnowballClientTypes.ServiceVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowballClientTypes.ServiceVersion()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension SnowballClientTypes.DependentService {

    static func write(value: SnowballClientTypes.DependentService?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ServiceName"].write(value.serviceName)
        try writer["ServiceVersion"].write(value.serviceVersion, with: SnowballClientTypes.ServiceVersion.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SnowballClientTypes.DependentService {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SnowballClientTypes.DependentService()
        value.serviceName = try reader["ServiceName"].readIfPresent()
        value.serviceVersion = try reader["ServiceVersion"].readIfPresent(with: SnowballClientTypes.ServiceVersion.read(from:))
        return value
    }
}

public enum SnowballClientTypes {}
