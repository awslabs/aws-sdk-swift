// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ComprehendMedicalClientTypes.Attribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beginOffset = "BeginOffset"
        case category = "Category"
        case endOffset = "EndOffset"
        case id = "Id"
        case relationshipScore = "RelationshipScore"
        case relationshipType = "RelationshipType"
        case score = "Score"
        case text = "Text"
        case traits = "Traits"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beginOffset = self.beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let category = self.category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let endOffset = self.endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let relationshipScore = self.relationshipScore {
            try encodeContainer.encode(relationshipScore, forKey: .relationshipScore)
        }
        if let relationshipType = self.relationshipType {
            try encodeContainer.encode(relationshipType.rawValue, forKey: .relationshipType)
        }
        if let score = self.score {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let traits = traits {
            var traitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .traits)
            for trait0 in traits {
                try traitsContainer.encode(trait0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.EntitySubType.self, forKey: .type)
        type = typeDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
        let relationshipScoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .relationshipScore)
        relationshipScore = relationshipScoreDecoded
        let relationshipTypeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.RelationshipType.self, forKey: .relationshipType)
        relationshipType = relationshipTypeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .id)
        id = idDecoded
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.EntityType.self, forKey: .category)
        category = categoryDecoded
        let traitsContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.Trait?].self, forKey: .traits)
        var traitsDecoded0:[ComprehendMedicalClientTypes.Trait]? = nil
        if let traitsContainer = traitsContainer {
            traitsDecoded0 = [ComprehendMedicalClientTypes.Trait]()
            for structure0 in traitsContainer {
                if let structure0 = structure0 {
                    traitsDecoded0?.append(structure0)
                }
            }
        }
        traits = traitsDecoded0
    }
}

extension ComprehendMedicalClientTypes {
    /// An extracted segment of the text that is an attribute of an entity, or otherwise related to an entity, such as the dosage of a medication taken. It contains information about the attribute such as id, begin and end offset within the input text, and the segment of the input text.
    public struct Attribute: Swift.Equatable {
        /// The 0-based character offset in the input text that shows where the attribute begins. The offset returns the UTF-8 code point in the string.
        public var beginOffset: Swift.Int?
        /// The category of attribute.
        public var category: ComprehendMedicalClientTypes.EntityType?
        /// The 0-based character offset in the input text that shows where the attribute ends. The offset returns the UTF-8 code point in the string.
        public var endOffset: Swift.Int?
        /// The numeric identifier for this attribute. This is a monotonically increasing id unique within this response rather than a global unique identifier.
        public var id: Swift.Int?
        /// The level of confidence that Amazon Comprehend Medical has that this attribute is correctly related to this entity.
        public var relationshipScore: Swift.Float?
        /// The type of relationship between the entity and attribute. Type for the relationship is OVERLAP, indicating that the entity occurred at the same time as the Date_Expression.
        public var relationshipType: ComprehendMedicalClientTypes.RelationshipType?
        /// The level of confidence that Amazon Comprehend Medical has that the segment of text is correctly recognized as an attribute.
        public var score: Swift.Float?
        /// The segment of input text extracted as this attribute.
        public var text: Swift.String?
        /// Contextual information for this attribute.
        public var traits: [ComprehendMedicalClientTypes.Trait]?
        /// The type of attribute.
        public var type: ComprehendMedicalClientTypes.EntitySubType?

        public init(
            beginOffset: Swift.Int? = nil,
            category: ComprehendMedicalClientTypes.EntityType? = nil,
            endOffset: Swift.Int? = nil,
            id: Swift.Int? = nil,
            relationshipScore: Swift.Float? = nil,
            relationshipType: ComprehendMedicalClientTypes.RelationshipType? = nil,
            score: Swift.Float? = nil,
            text: Swift.String? = nil,
            traits: [ComprehendMedicalClientTypes.Trait]? = nil,
            type: ComprehendMedicalClientTypes.EntitySubType? = nil
        )
        {
            self.beginOffset = beginOffset
            self.category = category
            self.endOffset = endOffset
            self.id = id
            self.relationshipScore = relationshipScore
            self.relationshipType = relationshipType
            self.score = score
            self.text = text
            self.traits = traits
            self.type = type
        }
    }

}

extension ComprehendMedicalClientTypes {
    public enum AttributeName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case diagnosis
        case future
        case hypothetical
        case lowConfidence
        case negation
        case pastHistory
        case pertainsToFamily
        case sign
        case symptom
        case sdkUnknown(Swift.String)

        public static var allCases: [AttributeName] {
            return [
                .diagnosis,
                .future,
                .hypothetical,
                .lowConfidence,
                .negation,
                .pastHistory,
                .pertainsToFamily,
                .sign,
                .symptom,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .diagnosis: return "DIAGNOSIS"
            case .future: return "FUTURE"
            case .hypothetical: return "HYPOTHETICAL"
            case .lowConfidence: return "LOW_CONFIDENCE"
            case .negation: return "NEGATION"
            case .pastHistory: return "PAST_HISTORY"
            case .pertainsToFamily: return "PERTAINS_TO_FAMILY"
            case .sign: return "SIGN"
            case .symptom: return "SYMPTOM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AttributeName(rawValue: rawValue) ?? AttributeName.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes.Characters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originalTextCharacters = "OriginalTextCharacters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let originalTextCharacters = self.originalTextCharacters {
            try encodeContainer.encode(originalTextCharacters, forKey: .originalTextCharacters)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originalTextCharactersDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .originalTextCharacters)
        originalTextCharacters = originalTextCharactersDecoded
    }
}

extension ComprehendMedicalClientTypes {
    /// The number of characters in the input text to be analyzed.
    public struct Characters: Swift.Equatable {
        /// The number of characters present in the input text document as processed by Amazon Comprehend Medical.
        public var originalTextCharacters: Swift.Int?

        public init(
            originalTextCharacters: Swift.Int? = nil
        )
        {
            self.originalTextCharacters = originalTextCharacters
        }
    }

}

extension ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case submitTimeAfter = "SubmitTimeAfter"
        case submitTimeBefore = "SubmitTimeBefore"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = self.jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let submitTimeAfter = self.submitTimeAfter {
            try encodeContainer.encodeTimestamp(submitTimeAfter, format: .epochSeconds, forKey: .submitTimeAfter)
        }
        if let submitTimeBefore = self.submitTimeBefore {
            try encodeContainer.encodeTimestamp(submitTimeBefore, format: .epochSeconds, forKey: .submitTimeBefore)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let submitTimeBeforeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .submitTimeBefore)
        submitTimeBefore = submitTimeBeforeDecoded
        let submitTimeAfterDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .submitTimeAfter)
        submitTimeAfter = submitTimeAfterDecoded
    }
}

extension ComprehendMedicalClientTypes {
    /// Provides information for filtering a list of detection jobs.
    public struct ComprehendMedicalAsyncJobFilter: Swift.Equatable {
        /// Filters on the name of the job.
        public var jobName: Swift.String?
        /// Filters the list of jobs based on job status. Returns only jobs with the specified status.
        public var jobStatus: ComprehendMedicalClientTypes.JobStatus?
        /// Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted after the specified time. Jobs are returned in descending order, newest to oldest.
        public var submitTimeAfter: ClientRuntime.Date?
        /// Filters the list of jobs based on the time that the job was submitted for processing. Returns only jobs submitted before the specified time. Jobs are returned in ascending order, oldest to newest.
        public var submitTimeBefore: ClientRuntime.Date?

        public init(
            jobName: Swift.String? = nil,
            jobStatus: ComprehendMedicalClientTypes.JobStatus? = nil,
            submitTimeAfter: ClientRuntime.Date? = nil,
            submitTimeBefore: ClientRuntime.Date? = nil
        )
        {
            self.jobName = jobName
            self.jobStatus = jobStatus
            self.submitTimeAfter = submitTimeAfter
            self.submitTimeBefore = submitTimeBefore
        }
    }

}

extension ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataAccessRoleArn = "DataAccessRoleArn"
        case endTime = "EndTime"
        case expirationTime = "ExpirationTime"
        case inputDataConfig = "InputDataConfig"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case kmsKey = "KMSKey"
        case languageCode = "LanguageCode"
        case manifestFilePath = "ManifestFilePath"
        case message = "Message"
        case modelVersion = "ModelVersion"
        case outputDataConfig = "OutputDataConfig"
        case submitTime = "SubmitTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRoleArn = self.dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let expirationTime = self.expirationTime {
            try encodeContainer.encodeTimestamp(expirationTime, format: .epochSeconds, forKey: .expirationTime)
        }
        if let inputDataConfig = self.inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = self.jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let manifestFilePath = self.manifestFilePath {
            try encodeContainer.encode(manifestFilePath, forKey: .manifestFilePath)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let modelVersion = self.modelVersion {
            try encodeContainer.encode(modelVersion, forKey: .modelVersion)
        }
        if let outputDataConfig = self.outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let submitTime = self.submitTime {
            try encodeContainer.encodeTimestamp(submitTime, format: .epochSeconds, forKey: .submitTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let submitTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .submitTime)
        submitTime = submitTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let expirationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let manifestFilePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manifestFilePath)
        manifestFilePath = manifestFilePathDecoded
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
        let modelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
    }
}

extension ComprehendMedicalClientTypes {
    /// Provides information about a detection job.
    public struct ComprehendMedicalAsyncJobProperties: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that gives Amazon Comprehend Medical read access to your input data.
        public var dataAccessRoleArn: Swift.String?
        /// The time that the detection job completed.
        public var endTime: ClientRuntime.Date?
        /// The date and time that job metadata is deleted from the server. Output files in your S3 bucket will not be deleted. After the metadata is deleted, the job will no longer appear in the results of the ListEntitiesDetectionV2Job or the ListPHIDetectionJobs operation.
        public var expirationTime: ClientRuntime.Date?
        /// The input data configuration that you supplied when you created the detection job.
        public var inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig?
        /// The identifier assigned to the detection job.
        public var jobId: Swift.String?
        /// The name that you assigned to the detection job.
        public var jobName: Swift.String?
        /// The current status of the detection job. If the status is FAILED, the Message field shows the reason for the failure.
        public var jobStatus: ComprehendMedicalClientTypes.JobStatus?
        /// The AWS Key Management Service key, if any, used to encrypt the output files.
        public var kmsKey: Swift.String?
        /// The language code of the input documents.
        public var languageCode: ComprehendMedicalClientTypes.LanguageCode?
        /// The path to the file that describes the results of a batch job.
        public var manifestFilePath: Swift.String?
        /// A description of the status of a job.
        public var message: Swift.String?
        /// The version of the model used to analyze the documents. The version number looks like X.X.X. You can use this information to track the model used for a particular batch of documents.
        public var modelVersion: Swift.String?
        /// The output data configuration that you supplied when you created the detection job.
        public var outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig?
        /// The time that the detection job was submitted for processing.
        public var submitTime: ClientRuntime.Date?

        public init(
            dataAccessRoleArn: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            expirationTime: ClientRuntime.Date? = nil,
            inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobStatus: ComprehendMedicalClientTypes.JobStatus? = nil,
            kmsKey: Swift.String? = nil,
            languageCode: ComprehendMedicalClientTypes.LanguageCode? = nil,
            manifestFilePath: Swift.String? = nil,
            message: Swift.String? = nil,
            modelVersion: Swift.String? = nil,
            outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig? = nil,
            submitTime: ClientRuntime.Date? = nil
        )
        {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.endTime = endTime
            self.expirationTime = expirationTime
            self.inputDataConfig = inputDataConfig
            self.jobId = jobId
            self.jobName = jobName
            self.jobStatus = jobStatus
            self.kmsKey = kmsKey
            self.languageCode = languageCode
            self.manifestFilePath = manifestFilePath
            self.message = message
            self.modelVersion = modelVersion
            self.outputDataConfig = outputDataConfig
            self.submitTime = submitTime
        }
    }

}

extension DescribeEntitiesDetectionV2JobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension DescribeEntitiesDetectionV2JobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEntitiesDetectionV2JobInput: Swift.Equatable {
    /// The identifier that Amazon Comprehend Medical generated for the job. The StartEntitiesDetectionV2Job operation returns this identifier in its response.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeEntitiesDetectionV2JobInputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension DescribeEntitiesDetectionV2JobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeEntitiesDetectionV2JobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEntitiesDetectionV2JobOutputBody = try responseDecoder.decode(responseBody: data)
            self.comprehendMedicalAsyncJobProperties = output.comprehendMedicalAsyncJobProperties
        } else {
            self.comprehendMedicalAsyncJobProperties = nil
        }
    }
}

public struct DescribeEntitiesDetectionV2JobOutput: Swift.Equatable {
    /// An object that contains the properties associated with a detection job.
    public var comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?

    public init(
        comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties? = nil
    )
    {
        self.comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobProperties
    }
}

struct DescribeEntitiesDetectionV2JobOutputBody: Swift.Equatable {
    let comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?
}

extension DescribeEntitiesDetectionV2JobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comprehendMedicalAsyncJobProperties = "ComprehendMedicalAsyncJobProperties"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comprehendMedicalAsyncJobPropertiesDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties.self, forKey: .comprehendMedicalAsyncJobProperties)
        comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobPropertiesDecoded
    }
}

enum DescribeEntitiesDetectionV2JobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeICD10CMInferenceJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension DescribeICD10CMInferenceJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeICD10CMInferenceJobInput: Swift.Equatable {
    /// The identifier that Amazon Comprehend Medical generated for the job. The StartICD10CMInferenceJob operation returns this identifier in its response.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeICD10CMInferenceJobInputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension DescribeICD10CMInferenceJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeICD10CMInferenceJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeICD10CMInferenceJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.comprehendMedicalAsyncJobProperties = output.comprehendMedicalAsyncJobProperties
        } else {
            self.comprehendMedicalAsyncJobProperties = nil
        }
    }
}

public struct DescribeICD10CMInferenceJobOutput: Swift.Equatable {
    /// An object that contains the properties associated with a detection job.
    public var comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?

    public init(
        comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties? = nil
    )
    {
        self.comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobProperties
    }
}

struct DescribeICD10CMInferenceJobOutputBody: Swift.Equatable {
    let comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?
}

extension DescribeICD10CMInferenceJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comprehendMedicalAsyncJobProperties = "ComprehendMedicalAsyncJobProperties"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comprehendMedicalAsyncJobPropertiesDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties.self, forKey: .comprehendMedicalAsyncJobProperties)
        comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobPropertiesDecoded
    }
}

enum DescribeICD10CMInferenceJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribePHIDetectionJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension DescribePHIDetectionJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribePHIDetectionJobInput: Swift.Equatable {
    /// The identifier that Amazon Comprehend Medical generated for the job. The StartPHIDetectionJob operation returns this identifier in its response.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribePHIDetectionJobInputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension DescribePHIDetectionJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribePHIDetectionJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribePHIDetectionJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.comprehendMedicalAsyncJobProperties = output.comprehendMedicalAsyncJobProperties
        } else {
            self.comprehendMedicalAsyncJobProperties = nil
        }
    }
}

public struct DescribePHIDetectionJobOutput: Swift.Equatable {
    /// An object that contains the properties associated with a detection job.
    public var comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?

    public init(
        comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties? = nil
    )
    {
        self.comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobProperties
    }
}

struct DescribePHIDetectionJobOutputBody: Swift.Equatable {
    let comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?
}

extension DescribePHIDetectionJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comprehendMedicalAsyncJobProperties = "ComprehendMedicalAsyncJobProperties"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comprehendMedicalAsyncJobPropertiesDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties.self, forKey: .comprehendMedicalAsyncJobProperties)
        comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobPropertiesDecoded
    }
}

enum DescribePHIDetectionJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeRxNormInferenceJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension DescribeRxNormInferenceJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeRxNormInferenceJobInput: Swift.Equatable {
    /// The identifier that Amazon Comprehend Medical generated for the job. The StartRxNormInferenceJob operation returns this identifier in its response.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeRxNormInferenceJobInputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension DescribeRxNormInferenceJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeRxNormInferenceJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRxNormInferenceJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.comprehendMedicalAsyncJobProperties = output.comprehendMedicalAsyncJobProperties
        } else {
            self.comprehendMedicalAsyncJobProperties = nil
        }
    }
}

public struct DescribeRxNormInferenceJobOutput: Swift.Equatable {
    /// An object that contains the properties associated with a detection job.
    public var comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?

    public init(
        comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties? = nil
    )
    {
        self.comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobProperties
    }
}

struct DescribeRxNormInferenceJobOutputBody: Swift.Equatable {
    let comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?
}

extension DescribeRxNormInferenceJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comprehendMedicalAsyncJobProperties = "ComprehendMedicalAsyncJobProperties"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comprehendMedicalAsyncJobPropertiesDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties.self, forKey: .comprehendMedicalAsyncJobProperties)
        comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobPropertiesDecoded
    }
}

enum DescribeRxNormInferenceJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeSNOMEDCTInferenceJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension DescribeSNOMEDCTInferenceJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeSNOMEDCTInferenceJobInput: Swift.Equatable {
    /// The identifier that Amazon Comprehend Medical generated for the job. The StartSNOMEDCTInferenceJob operation returns this identifier in its response.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeSNOMEDCTInferenceJobInputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension DescribeSNOMEDCTInferenceJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeSNOMEDCTInferenceJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSNOMEDCTInferenceJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.comprehendMedicalAsyncJobProperties = output.comprehendMedicalAsyncJobProperties
        } else {
            self.comprehendMedicalAsyncJobProperties = nil
        }
    }
}

public struct DescribeSNOMEDCTInferenceJobOutput: Swift.Equatable {
    /// Provides information about a detection job.
    public var comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?

    public init(
        comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties? = nil
    )
    {
        self.comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobProperties
    }
}

struct DescribeSNOMEDCTInferenceJobOutputBody: Swift.Equatable {
    let comprehendMedicalAsyncJobProperties: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?
}

extension DescribeSNOMEDCTInferenceJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comprehendMedicalAsyncJobProperties = "ComprehendMedicalAsyncJobProperties"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comprehendMedicalAsyncJobPropertiesDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties.self, forKey: .comprehendMedicalAsyncJobProperties)
        comprehendMedicalAsyncJobProperties = comprehendMedicalAsyncJobPropertiesDecoded
    }
}

enum DescribeSNOMEDCTInferenceJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DetectEntitiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

extension DetectEntitiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DetectEntitiesInput: Swift.Equatable {
    /// A UTF-8 text string containing the clinical content being examined for entities.
    /// This member is required.
    public var text: Swift.String?

    public init(
        text: Swift.String? = nil
    )
    {
        self.text = text
    }
}

struct DetectEntitiesInputBody: Swift.Equatable {
    let text: Swift.String?
}

extension DetectEntitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension DetectEntitiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DetectEntitiesOutputBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.modelVersion = output.modelVersion
            self.paginationToken = output.paginationToken
            self.unmappedAttributes = output.unmappedAttributes
        } else {
            self.entities = nil
            self.modelVersion = nil
            self.paginationToken = nil
            self.unmappedAttributes = nil
        }
    }
}

public struct DetectEntitiesOutput: Swift.Equatable {
    /// The collection of medical entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence that Amazon Comprehend Medical has in the detection and analysis. Attributes and traits of the entity are also returned.
    /// This member is required.
    public var entities: [ComprehendMedicalClientTypes.Entity]?
    /// The version of the model used to analyze the documents. The version number looks like X.X.X. You can use this information to track the model used for a particular batch of documents.
    /// This member is required.
    public var modelVersion: Swift.String?
    /// If the result of the previous request to DetectEntities was truncated, include the PaginationToken to fetch the next page of entities.
    public var paginationToken: Swift.String?
    /// Attributes extracted from the input text that we were unable to relate to an entity.
    public var unmappedAttributes: [ComprehendMedicalClientTypes.UnmappedAttribute]?

    public init(
        entities: [ComprehendMedicalClientTypes.Entity]? = nil,
        modelVersion: Swift.String? = nil,
        paginationToken: Swift.String? = nil,
        unmappedAttributes: [ComprehendMedicalClientTypes.UnmappedAttribute]? = nil
    )
    {
        self.entities = entities
        self.modelVersion = modelVersion
        self.paginationToken = paginationToken
        self.unmappedAttributes = unmappedAttributes
    }
}

struct DetectEntitiesOutputBody: Swift.Equatable {
    let entities: [ComprehendMedicalClientTypes.Entity]?
    let unmappedAttributes: [ComprehendMedicalClientTypes.UnmappedAttribute]?
    let paginationToken: Swift.String?
    let modelVersion: Swift.String?
}

extension DetectEntitiesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities = "Entities"
        case modelVersion = "ModelVersion"
        case paginationToken = "PaginationToken"
        case unmappedAttributes = "UnmappedAttributes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.Entity?].self, forKey: .entities)
        var entitiesDecoded0:[ComprehendMedicalClientTypes.Entity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [ComprehendMedicalClientTypes.Entity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let unmappedAttributesContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.UnmappedAttribute?].self, forKey: .unmappedAttributes)
        var unmappedAttributesDecoded0:[ComprehendMedicalClientTypes.UnmappedAttribute]? = nil
        if let unmappedAttributesContainer = unmappedAttributesContainer {
            unmappedAttributesDecoded0 = [ComprehendMedicalClientTypes.UnmappedAttribute]()
            for structure0 in unmappedAttributesContainer {
                if let structure0 = structure0 {
                    unmappedAttributesDecoded0?.append(structure0)
                }
            }
        }
        unmappedAttributes = unmappedAttributesDecoded0
        let paginationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
        let modelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
    }
}

enum DetectEntitiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidEncodingException": return try await InvalidEncodingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TextSizeLimitExceededException": return try await TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DetectEntitiesV2Input: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

extension DetectEntitiesV2Input: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DetectEntitiesV2Input: Swift.Equatable {
    /// A UTF-8 string containing the clinical content being examined for entities.
    /// This member is required.
    public var text: Swift.String?

    public init(
        text: Swift.String? = nil
    )
    {
        self.text = text
    }
}

struct DetectEntitiesV2InputBody: Swift.Equatable {
    let text: Swift.String?
}

extension DetectEntitiesV2InputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension DetectEntitiesV2Output: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DetectEntitiesV2OutputBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.modelVersion = output.modelVersion
            self.paginationToken = output.paginationToken
            self.unmappedAttributes = output.unmappedAttributes
        } else {
            self.entities = nil
            self.modelVersion = nil
            self.paginationToken = nil
            self.unmappedAttributes = nil
        }
    }
}

public struct DetectEntitiesV2Output: Swift.Equatable {
    /// The collection of medical entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence in the detection and analysis. Attributes and traits of the entity are also returned.
    /// This member is required.
    public var entities: [ComprehendMedicalClientTypes.Entity]?
    /// The version of the model used to analyze the documents. The version number looks like X.X.X. You can use this information to track the model used for a particular batch of documents.
    /// This member is required.
    public var modelVersion: Swift.String?
    /// If the result to the DetectEntitiesV2 operation was truncated, include the PaginationToken to fetch the next page of entities.
    public var paginationToken: Swift.String?
    /// Attributes extracted from the input text that couldn't be related to an entity.
    public var unmappedAttributes: [ComprehendMedicalClientTypes.UnmappedAttribute]?

    public init(
        entities: [ComprehendMedicalClientTypes.Entity]? = nil,
        modelVersion: Swift.String? = nil,
        paginationToken: Swift.String? = nil,
        unmappedAttributes: [ComprehendMedicalClientTypes.UnmappedAttribute]? = nil
    )
    {
        self.entities = entities
        self.modelVersion = modelVersion
        self.paginationToken = paginationToken
        self.unmappedAttributes = unmappedAttributes
    }
}

struct DetectEntitiesV2OutputBody: Swift.Equatable {
    let entities: [ComprehendMedicalClientTypes.Entity]?
    let unmappedAttributes: [ComprehendMedicalClientTypes.UnmappedAttribute]?
    let paginationToken: Swift.String?
    let modelVersion: Swift.String?
}

extension DetectEntitiesV2OutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities = "Entities"
        case modelVersion = "ModelVersion"
        case paginationToken = "PaginationToken"
        case unmappedAttributes = "UnmappedAttributes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.Entity?].self, forKey: .entities)
        var entitiesDecoded0:[ComprehendMedicalClientTypes.Entity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [ComprehendMedicalClientTypes.Entity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let unmappedAttributesContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.UnmappedAttribute?].self, forKey: .unmappedAttributes)
        var unmappedAttributesDecoded0:[ComprehendMedicalClientTypes.UnmappedAttribute]? = nil
        if let unmappedAttributesContainer = unmappedAttributesContainer {
            unmappedAttributesDecoded0 = [ComprehendMedicalClientTypes.UnmappedAttribute]()
            for structure0 in unmappedAttributesContainer {
                if let structure0 = structure0 {
                    unmappedAttributesDecoded0?.append(structure0)
                }
            }
        }
        unmappedAttributes = unmappedAttributesDecoded0
        let paginationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
        let modelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
    }
}

enum DetectEntitiesV2OutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidEncodingException": return try await InvalidEncodingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TextSizeLimitExceededException": return try await TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DetectPHIInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

extension DetectPHIInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DetectPHIInput: Swift.Equatable {
    /// A UTF-8 text string containing the clinical content being examined for PHI entities.
    /// This member is required.
    public var text: Swift.String?

    public init(
        text: Swift.String? = nil
    )
    {
        self.text = text
    }
}

struct DetectPHIInputBody: Swift.Equatable {
    let text: Swift.String?
}

extension DetectPHIInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension DetectPHIOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DetectPHIOutputBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.modelVersion = output.modelVersion
            self.paginationToken = output.paginationToken
        } else {
            self.entities = nil
            self.modelVersion = nil
            self.paginationToken = nil
        }
    }
}

public struct DetectPHIOutput: Swift.Equatable {
    /// The collection of PHI entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence that Amazon Comprehend Medical has in its detection.
    /// This member is required.
    public var entities: [ComprehendMedicalClientTypes.Entity]?
    /// The version of the model used to analyze the documents. The version number looks like X.X.X. You can use this information to track the model used for a particular batch of documents.
    /// This member is required.
    public var modelVersion: Swift.String?
    /// If the result of the previous request to DetectPHI was truncated, include the PaginationToken to fetch the next page of PHI entities.
    public var paginationToken: Swift.String?

    public init(
        entities: [ComprehendMedicalClientTypes.Entity]? = nil,
        modelVersion: Swift.String? = nil,
        paginationToken: Swift.String? = nil
    )
    {
        self.entities = entities
        self.modelVersion = modelVersion
        self.paginationToken = paginationToken
    }
}

struct DetectPHIOutputBody: Swift.Equatable {
    let entities: [ComprehendMedicalClientTypes.Entity]?
    let paginationToken: Swift.String?
    let modelVersion: Swift.String?
}

extension DetectPHIOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities = "Entities"
        case modelVersion = "ModelVersion"
        case paginationToken = "PaginationToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.Entity?].self, forKey: .entities)
        var entitiesDecoded0:[ComprehendMedicalClientTypes.Entity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [ComprehendMedicalClientTypes.Entity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let paginationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
        let modelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
    }
}

enum DetectPHIOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidEncodingException": return try await InvalidEncodingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TextSizeLimitExceededException": return try await TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ComprehendMedicalClientTypes.Entity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case beginOffset = "BeginOffset"
        case category = "Category"
        case endOffset = "EndOffset"
        case id = "Id"
        case score = "Score"
        case text = "Text"
        case traits = "Traits"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attribute0 in attributes {
                try attributesContainer.encode(attribute0)
            }
        }
        if let beginOffset = self.beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let category = self.category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let endOffset = self.endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let score = self.score {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let traits = traits {
            var traitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .traits)
            for trait0 in traits {
                try traitsContainer.encode(trait0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .id)
        id = idDecoded
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.EntityType.self, forKey: .category)
        category = categoryDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.EntitySubType.self, forKey: .type)
        type = typeDecoded
        let traitsContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.Trait?].self, forKey: .traits)
        var traitsDecoded0:[ComprehendMedicalClientTypes.Trait]? = nil
        if let traitsContainer = traitsContainer {
            traitsDecoded0 = [ComprehendMedicalClientTypes.Trait]()
            for structure0 in traitsContainer {
                if let structure0 = structure0 {
                    traitsDecoded0?.append(structure0)
                }
            }
        }
        traits = traitsDecoded0
        let attributesContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.Attribute?].self, forKey: .attributes)
        var attributesDecoded0:[ComprehendMedicalClientTypes.Attribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [ComprehendMedicalClientTypes.Attribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension ComprehendMedicalClientTypes {
    /// Provides information about an extracted medical entity.
    public struct Entity: Swift.Equatable {
        /// The extracted attributes that relate to this entity.
        public var attributes: [ComprehendMedicalClientTypes.Attribute]?
        /// The 0-based character offset in the input text that shows where the entity begins. The offset returns the UTF-8 code point in the string.
        public var beginOffset: Swift.Int?
        /// The category of the entity.
        public var category: ComprehendMedicalClientTypes.EntityType?
        /// The 0-based character offset in the input text that shows where the entity ends. The offset returns the UTF-8 code point in the string.
        public var endOffset: Swift.Int?
        /// The numeric identifier for the entity. This is a monotonically increasing id unique within this response rather than a global unique identifier.
        public var id: Swift.Int?
        /// The level of confidence that Amazon Comprehend Medical has in the accuracy of the detection.
        public var score: Swift.Float?
        /// The segment of input text extracted as this entity.
        public var text: Swift.String?
        /// Contextual information for the entity.
        public var traits: [ComprehendMedicalClientTypes.Trait]?
        /// Describes the specific type of entity with category of entities.
        public var type: ComprehendMedicalClientTypes.EntitySubType?

        public init(
            attributes: [ComprehendMedicalClientTypes.Attribute]? = nil,
            beginOffset: Swift.Int? = nil,
            category: ComprehendMedicalClientTypes.EntityType? = nil,
            endOffset: Swift.Int? = nil,
            id: Swift.Int? = nil,
            score: Swift.Float? = nil,
            text: Swift.String? = nil,
            traits: [ComprehendMedicalClientTypes.Trait]? = nil,
            type: ComprehendMedicalClientTypes.EntitySubType? = nil
        )
        {
            self.attributes = attributes
            self.beginOffset = beginOffset
            self.category = category
            self.endOffset = endOffset
            self.id = id
            self.score = score
            self.text = text
            self.traits = traits
            self.type = type
        }
    }

}

extension ComprehendMedicalClientTypes {
    public enum EntitySubType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acuity
        case address
        case age
        case alcoholConsumption
        case allergies
        case amount
        case brandName
        case contactPoint
        case date
        case direction
        case dosage
        case duration
        case dxName
        case email
        case form
        case frequency
        case gender
        case genericName
        case id
        case identifier
        case name
        case phoneOrFax
        case procedureName
        case profession
        case quality
        case quantity
        case raceEthnicity
        case rate
        case recDrugUse
        case routeOrMode
        case strength
        case systemOrganSite
        case testName
        case testUnit
        case testUnits
        case testValue
        case timeExpression
        case timeToDxName
        case timeToMedicationName
        case timeToProcedureName
        case timeToTestName
        case timeToTreatmentName
        case tobaccoUse
        case treatmentName
        case url
        case sdkUnknown(Swift.String)

        public static var allCases: [EntitySubType] {
            return [
                .acuity,
                .address,
                .age,
                .alcoholConsumption,
                .allergies,
                .amount,
                .brandName,
                .contactPoint,
                .date,
                .direction,
                .dosage,
                .duration,
                .dxName,
                .email,
                .form,
                .frequency,
                .gender,
                .genericName,
                .id,
                .identifier,
                .name,
                .phoneOrFax,
                .procedureName,
                .profession,
                .quality,
                .quantity,
                .raceEthnicity,
                .rate,
                .recDrugUse,
                .routeOrMode,
                .strength,
                .systemOrganSite,
                .testName,
                .testUnit,
                .testUnits,
                .testValue,
                .timeExpression,
                .timeToDxName,
                .timeToMedicationName,
                .timeToProcedureName,
                .timeToTestName,
                .timeToTreatmentName,
                .tobaccoUse,
                .treatmentName,
                .url,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acuity: return "ACUITY"
            case .address: return "ADDRESS"
            case .age: return "AGE"
            case .alcoholConsumption: return "ALCOHOL_CONSUMPTION"
            case .allergies: return "ALLERGIES"
            case .amount: return "AMOUNT"
            case .brandName: return "BRAND_NAME"
            case .contactPoint: return "CONTACT_POINT"
            case .date: return "DATE"
            case .direction: return "DIRECTION"
            case .dosage: return "DOSAGE"
            case .duration: return "DURATION"
            case .dxName: return "DX_NAME"
            case .email: return "EMAIL"
            case .form: return "FORM"
            case .frequency: return "FREQUENCY"
            case .gender: return "GENDER"
            case .genericName: return "GENERIC_NAME"
            case .id: return "ID"
            case .identifier: return "IDENTIFIER"
            case .name: return "NAME"
            case .phoneOrFax: return "PHONE_OR_FAX"
            case .procedureName: return "PROCEDURE_NAME"
            case .profession: return "PROFESSION"
            case .quality: return "QUALITY"
            case .quantity: return "QUANTITY"
            case .raceEthnicity: return "RACE_ETHNICITY"
            case .rate: return "RATE"
            case .recDrugUse: return "REC_DRUG_USE"
            case .routeOrMode: return "ROUTE_OR_MODE"
            case .strength: return "STRENGTH"
            case .systemOrganSite: return "SYSTEM_ORGAN_SITE"
            case .testName: return "TEST_NAME"
            case .testUnit: return "TEST_UNIT"
            case .testUnits: return "TEST_UNITS"
            case .testValue: return "TEST_VALUE"
            case .timeExpression: return "TIME_EXPRESSION"
            case .timeToDxName: return "TIME_TO_DX_NAME"
            case .timeToMedicationName: return "TIME_TO_MEDICATION_NAME"
            case .timeToProcedureName: return "TIME_TO_PROCEDURE_NAME"
            case .timeToTestName: return "TIME_TO_TEST_NAME"
            case .timeToTreatmentName: return "TIME_TO_TREATMENT_NAME"
            case .tobaccoUse: return "TOBACCO_USE"
            case .treatmentName: return "TREATMENT_NAME"
            case .url: return "URL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EntitySubType(rawValue: rawValue) ?? EntitySubType.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes {
    public enum EntityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case anatomy
        case behavioralEnvironmentalSocial
        case medicalCondition
        case medication
        case protectedHealthInformation
        case testTreatmentProcedure
        case timeExpression
        case sdkUnknown(Swift.String)

        public static var allCases: [EntityType] {
            return [
                .anatomy,
                .behavioralEnvironmentalSocial,
                .medicalCondition,
                .medication,
                .protectedHealthInformation,
                .testTreatmentProcedure,
                .timeExpression,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .anatomy: return "ANATOMY"
            case .behavioralEnvironmentalSocial: return "BEHAVIORAL_ENVIRONMENTAL_SOCIAL"
            case .medicalCondition: return "MEDICAL_CONDITION"
            case .medication: return "MEDICATION"
            case .protectedHealthInformation: return "PROTECTED_HEALTH_INFORMATION"
            case .testTreatmentProcedure: return "TEST_TREATMENT_PROCEDURE"
            case .timeExpression: return "TIME_EXPRESSION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EntityType(rawValue: rawValue) ?? EntityType.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes.ICD10CMAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beginOffset = "BeginOffset"
        case category = "Category"
        case endOffset = "EndOffset"
        case id = "Id"
        case relationshipScore = "RelationshipScore"
        case relationshipType = "RelationshipType"
        case score = "Score"
        case text = "Text"
        case traits = "Traits"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beginOffset = self.beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let category = self.category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let endOffset = self.endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let relationshipScore = self.relationshipScore {
            try encodeContainer.encode(relationshipScore, forKey: .relationshipScore)
        }
        if let relationshipType = self.relationshipType {
            try encodeContainer.encode(relationshipType.rawValue, forKey: .relationshipType)
        }
        if let score = self.score {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let traits = traits {
            var traitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .traits)
            for icd10cmtrait0 in traits {
                try traitsContainer.encode(icd10cmtrait0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ICD10CMAttributeType.self, forKey: .type)
        type = typeDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
        let relationshipScoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .relationshipScore)
        relationshipScore = relationshipScoreDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .id)
        id = idDecoded
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let traitsContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.ICD10CMTrait?].self, forKey: .traits)
        var traitsDecoded0:[ComprehendMedicalClientTypes.ICD10CMTrait]? = nil
        if let traitsContainer = traitsContainer {
            traitsDecoded0 = [ComprehendMedicalClientTypes.ICD10CMTrait]()
            for structure0 in traitsContainer {
                if let structure0 = structure0 {
                    traitsDecoded0?.append(structure0)
                }
            }
        }
        traits = traitsDecoded0
        let categoryDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ICD10CMEntityType.self, forKey: .category)
        category = categoryDecoded
        let relationshipTypeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ICD10CMRelationshipType.self, forKey: .relationshipType)
        relationshipType = relationshipTypeDecoded
    }
}

extension ComprehendMedicalClientTypes {
    /// The detected attributes that relate to an entity. This includes an extracted segment of the text that is an attribute of an entity, or otherwise related to an entity. InferICD10CM detects the following attributes: Direction, System, Organ or Site, and Acuity.
    public struct ICD10CMAttribute: Swift.Equatable {
        /// The 0-based character offset in the input text that shows where the attribute begins. The offset returns the UTF-8 code point in the string.
        public var beginOffset: Swift.Int?
        /// The category of attribute. Can be either of DX_NAME or TIME_EXPRESSION.
        public var category: ComprehendMedicalClientTypes.ICD10CMEntityType?
        /// The 0-based character offset in the input text that shows where the attribute ends. The offset returns the UTF-8 code point in the string.
        public var endOffset: Swift.Int?
        /// The numeric identifier for this attribute. This is a monotonically increasing id unique within this response rather than a global unique identifier.
        public var id: Swift.Int?
        /// The level of confidence that Amazon Comprehend Medical has that this attribute is correctly related to this entity.
        public var relationshipScore: Swift.Float?
        /// The type of relationship between the entity and attribute. Type for the relationship can be either of OVERLAP or SYSTEM_ORGAN_SITE.
        public var relationshipType: ComprehendMedicalClientTypes.ICD10CMRelationshipType?
        /// The level of confidence that Amazon Comprehend Medical has that the segment of text is correctly recognized as an attribute.
        public var score: Swift.Float?
        /// The segment of input text which contains the detected attribute.
        public var text: Swift.String?
        /// The contextual information for the attribute. The traits recognized by InferICD10CM are DIAGNOSIS, SIGN, SYMPTOM, and NEGATION.
        public var traits: [ComprehendMedicalClientTypes.ICD10CMTrait]?
        /// The type of attribute. InferICD10CM detects entities of the type DX_NAME.
        public var type: ComprehendMedicalClientTypes.ICD10CMAttributeType?

        public init(
            beginOffset: Swift.Int? = nil,
            category: ComprehendMedicalClientTypes.ICD10CMEntityType? = nil,
            endOffset: Swift.Int? = nil,
            id: Swift.Int? = nil,
            relationshipScore: Swift.Float? = nil,
            relationshipType: ComprehendMedicalClientTypes.ICD10CMRelationshipType? = nil,
            score: Swift.Float? = nil,
            text: Swift.String? = nil,
            traits: [ComprehendMedicalClientTypes.ICD10CMTrait]? = nil,
            type: ComprehendMedicalClientTypes.ICD10CMAttributeType? = nil
        )
        {
            self.beginOffset = beginOffset
            self.category = category
            self.endOffset = endOffset
            self.id = id
            self.relationshipScore = relationshipScore
            self.relationshipType = relationshipType
            self.score = score
            self.text = text
            self.traits = traits
            self.type = type
        }
    }

}

extension ComprehendMedicalClientTypes {
    public enum ICD10CMAttributeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acuity
        case direction
        case quality
        case quantity
        case systemOrganSite
        case timeExpression
        case timeToDxName
        case sdkUnknown(Swift.String)

        public static var allCases: [ICD10CMAttributeType] {
            return [
                .acuity,
                .direction,
                .quality,
                .quantity,
                .systemOrganSite,
                .timeExpression,
                .timeToDxName,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acuity: return "ACUITY"
            case .direction: return "DIRECTION"
            case .quality: return "QUALITY"
            case .quantity: return "QUANTITY"
            case .systemOrganSite: return "SYSTEM_ORGAN_SITE"
            case .timeExpression: return "TIME_EXPRESSION"
            case .timeToDxName: return "TIME_TO_DX_NAME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ICD10CMAttributeType(rawValue: rawValue) ?? ICD10CMAttributeType.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes.ICD10CMConcept: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case description = "Description"
        case score = "Score"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let score = self.score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
    }
}

extension ComprehendMedicalClientTypes {
    /// The ICD-10-CM concepts that the entity could refer to, along with a score indicating the likelihood of the match.
    public struct ICD10CMConcept: Swift.Equatable {
        /// The ICD-10-CM code that identifies the concept found in the knowledge base from the Centers for Disease Control.
        public var code: Swift.String?
        /// The long description of the ICD-10-CM code in the ontology.
        public var description: Swift.String?
        /// The level of confidence that Amazon Comprehend Medical has that the entity is accurately linked to an ICD-10-CM concept.
        public var score: Swift.Float?

        public init(
            code: Swift.String? = nil,
            description: Swift.String? = nil,
            score: Swift.Float? = nil
        )
        {
            self.code = code
            self.description = description
            self.score = score
        }
    }

}

extension ComprehendMedicalClientTypes.ICD10CMEntity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case beginOffset = "BeginOffset"
        case category = "Category"
        case endOffset = "EndOffset"
        case icd10CMConcepts = "ICD10CMConcepts"
        case id = "Id"
        case score = "Score"
        case text = "Text"
        case traits = "Traits"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for icd10cmattribute0 in attributes {
                try attributesContainer.encode(icd10cmattribute0)
            }
        }
        if let beginOffset = self.beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let category = self.category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let endOffset = self.endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
        if let icd10CMConcepts = icd10CMConcepts {
            var icd10CMConceptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .icd10CMConcepts)
            for icd10cmconcept0 in icd10CMConcepts {
                try icd10CMConceptsContainer.encode(icd10cmconcept0)
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let score = self.score {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let traits = traits {
            var traitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .traits)
            for icd10cmtrait0 in traits {
                try traitsContainer.encode(icd10cmtrait0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .id)
        id = idDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ICD10CMEntityCategory.self, forKey: .category)
        category = categoryDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ICD10CMEntityType.self, forKey: .type)
        type = typeDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
        let attributesContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.ICD10CMAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[ComprehendMedicalClientTypes.ICD10CMAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [ComprehendMedicalClientTypes.ICD10CMAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let traitsContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.ICD10CMTrait?].self, forKey: .traits)
        var traitsDecoded0:[ComprehendMedicalClientTypes.ICD10CMTrait]? = nil
        if let traitsContainer = traitsContainer {
            traitsDecoded0 = [ComprehendMedicalClientTypes.ICD10CMTrait]()
            for structure0 in traitsContainer {
                if let structure0 = structure0 {
                    traitsDecoded0?.append(structure0)
                }
            }
        }
        traits = traitsDecoded0
        let icd10CMConceptsContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.ICD10CMConcept?].self, forKey: .icd10CMConcepts)
        var icd10CMConceptsDecoded0:[ComprehendMedicalClientTypes.ICD10CMConcept]? = nil
        if let icd10CMConceptsContainer = icd10CMConceptsContainer {
            icd10CMConceptsDecoded0 = [ComprehendMedicalClientTypes.ICD10CMConcept]()
            for structure0 in icd10CMConceptsContainer {
                if let structure0 = structure0 {
                    icd10CMConceptsDecoded0?.append(structure0)
                }
            }
        }
        icd10CMConcepts = icd10CMConceptsDecoded0
    }
}

extension ComprehendMedicalClientTypes {
    /// The collection of medical entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence that Amazon Comprehend Medical has in the detection and analysis. Attributes and traits of the entity are also returned.
    public struct ICD10CMEntity: Swift.Equatable {
        /// The detected attributes that relate to the entity. An extracted segment of the text that is an attribute of an entity, or otherwise related to an entity, such as the nature of a medical condition.
        public var attributes: [ComprehendMedicalClientTypes.ICD10CMAttribute]?
        /// The 0-based character offset in the input text that shows where the entity begins. The offset returns the UTF-8 code point in the string.
        public var beginOffset: Swift.Int?
        /// The category of the entity. InferICD10CM detects entities in the MEDICAL_CONDITION category.
        public var category: ComprehendMedicalClientTypes.ICD10CMEntityCategory?
        /// The 0-based character offset in the input text that shows where the entity ends. The offset returns the UTF-8 code point in the string.
        public var endOffset: Swift.Int?
        /// The ICD-10-CM concepts that the entity could refer to, along with a score indicating the likelihood of the match.
        public var icd10CMConcepts: [ComprehendMedicalClientTypes.ICD10CMConcept]?
        /// The numeric identifier for the entity. This is a monotonically increasing id unique within this response rather than a global unique identifier.
        public var id: Swift.Int?
        /// The level of confidence that Amazon Comprehend Medical has in the accuracy of the detection.
        public var score: Swift.Float?
        /// The segment of input text that is matched to the detected entity.
        public var text: Swift.String?
        /// Provides Contextual information for the entity. The traits recognized by InferICD10CM are DIAGNOSIS, SIGN, SYMPTOM, and NEGATION.
        public var traits: [ComprehendMedicalClientTypes.ICD10CMTrait]?
        /// Describes the specific type of entity with category of entities. InferICD10CM detects entities of the type DX_NAME and TIME_EXPRESSION.
        public var type: ComprehendMedicalClientTypes.ICD10CMEntityType?

        public init(
            attributes: [ComprehendMedicalClientTypes.ICD10CMAttribute]? = nil,
            beginOffset: Swift.Int? = nil,
            category: ComprehendMedicalClientTypes.ICD10CMEntityCategory? = nil,
            endOffset: Swift.Int? = nil,
            icd10CMConcepts: [ComprehendMedicalClientTypes.ICD10CMConcept]? = nil,
            id: Swift.Int? = nil,
            score: Swift.Float? = nil,
            text: Swift.String? = nil,
            traits: [ComprehendMedicalClientTypes.ICD10CMTrait]? = nil,
            type: ComprehendMedicalClientTypes.ICD10CMEntityType? = nil
        )
        {
            self.attributes = attributes
            self.beginOffset = beginOffset
            self.category = category
            self.endOffset = endOffset
            self.icd10CMConcepts = icd10CMConcepts
            self.id = id
            self.score = score
            self.text = text
            self.traits = traits
            self.type = type
        }
    }

}

extension ComprehendMedicalClientTypes {
    public enum ICD10CMEntityCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case medicalCondition
        case sdkUnknown(Swift.String)

        public static var allCases: [ICD10CMEntityCategory] {
            return [
                .medicalCondition,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .medicalCondition: return "MEDICAL_CONDITION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ICD10CMEntityCategory(rawValue: rawValue) ?? ICD10CMEntityCategory.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes {
    public enum ICD10CMEntityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dxName
        case timeExpression
        case sdkUnknown(Swift.String)

        public static var allCases: [ICD10CMEntityType] {
            return [
                .dxName,
                .timeExpression,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dxName: return "DX_NAME"
            case .timeExpression: return "TIME_EXPRESSION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ICD10CMEntityType(rawValue: rawValue) ?? ICD10CMEntityType.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes {
    public enum ICD10CMRelationshipType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case overlap
        case quality
        case systemOrganSite
        case sdkUnknown(Swift.String)

        public static var allCases: [ICD10CMRelationshipType] {
            return [
                .overlap,
                .quality,
                .systemOrganSite,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .overlap: return "OVERLAP"
            case .quality: return "QUALITY"
            case .systemOrganSite: return "SYSTEM_ORGAN_SITE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ICD10CMRelationshipType(rawValue: rawValue) ?? ICD10CMRelationshipType.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes.ICD10CMTrait: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case score = "Score"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let score = self.score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ICD10CMTraitName.self, forKey: .name)
        name = nameDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
    }
}

extension ComprehendMedicalClientTypes {
    /// Contextual information for the entity. The traits recognized by InferICD10CM are DIAGNOSIS, SIGN, SYMPTOM, and NEGATION.
    public struct ICD10CMTrait: Swift.Equatable {
        /// Provides a name or contextual description about the trait.
        public var name: ComprehendMedicalClientTypes.ICD10CMTraitName?
        /// The level of confidence that Amazon Comprehend Medical has that the segment of text is correctly recognized as a trait.
        public var score: Swift.Float?

        public init(
            name: ComprehendMedicalClientTypes.ICD10CMTraitName? = nil,
            score: Swift.Float? = nil
        )
        {
            self.name = name
            self.score = score
        }
    }

}

extension ComprehendMedicalClientTypes {
    public enum ICD10CMTraitName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case diagnosis
        case hypothetical
        case lowConfidence
        case negation
        case pertainsToFamily
        case sign
        case symptom
        case sdkUnknown(Swift.String)

        public static var allCases: [ICD10CMTraitName] {
            return [
                .diagnosis,
                .hypothetical,
                .lowConfidence,
                .negation,
                .pertainsToFamily,
                .sign,
                .symptom,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .diagnosis: return "DIAGNOSIS"
            case .hypothetical: return "HYPOTHETICAL"
            case .lowConfidence: return "LOW_CONFIDENCE"
            case .negation: return "NEGATION"
            case .pertainsToFamily: return "PERTAINS_TO_FAMILY"
            case .sign: return "SIGN"
            case .symptom: return "SYMPTOM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ICD10CMTraitName(rawValue: rawValue) ?? ICD10CMTraitName.sdkUnknown(rawValue)
        }
    }
}

extension InferICD10CMInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

extension InferICD10CMInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct InferICD10CMInput: Swift.Equatable {
    /// The input text used for analysis.
    /// This member is required.
    public var text: Swift.String?

    public init(
        text: Swift.String? = nil
    )
    {
        self.text = text
    }
}

struct InferICD10CMInputBody: Swift.Equatable {
    let text: Swift.String?
}

extension InferICD10CMInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension InferICD10CMOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InferICD10CMOutputBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.modelVersion = output.modelVersion
            self.paginationToken = output.paginationToken
        } else {
            self.entities = nil
            self.modelVersion = nil
            self.paginationToken = nil
        }
    }
}

public struct InferICD10CMOutput: Swift.Equatable {
    /// The medical conditions detected in the text linked to ICD-10-CM concepts. If the action is successful, the service sends back an HTTP 200 response, as well as the entities detected.
    /// This member is required.
    public var entities: [ComprehendMedicalClientTypes.ICD10CMEntity]?
    /// The version of the model used to analyze the documents, in the format n.n.n You can use this information to track the model used for a particular batch of documents.
    public var modelVersion: Swift.String?
    /// If the result of the previous request to InferICD10CM was truncated, include the PaginationToken to fetch the next page of medical condition entities.
    public var paginationToken: Swift.String?

    public init(
        entities: [ComprehendMedicalClientTypes.ICD10CMEntity]? = nil,
        modelVersion: Swift.String? = nil,
        paginationToken: Swift.String? = nil
    )
    {
        self.entities = entities
        self.modelVersion = modelVersion
        self.paginationToken = paginationToken
    }
}

struct InferICD10CMOutputBody: Swift.Equatable {
    let entities: [ComprehendMedicalClientTypes.ICD10CMEntity]?
    let paginationToken: Swift.String?
    let modelVersion: Swift.String?
}

extension InferICD10CMOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities = "Entities"
        case modelVersion = "ModelVersion"
        case paginationToken = "PaginationToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.ICD10CMEntity?].self, forKey: .entities)
        var entitiesDecoded0:[ComprehendMedicalClientTypes.ICD10CMEntity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [ComprehendMedicalClientTypes.ICD10CMEntity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let paginationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
        let modelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
    }
}

enum InferICD10CMOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidEncodingException": return try await InvalidEncodingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TextSizeLimitExceededException": return try await TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InferRxNormInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

extension InferRxNormInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct InferRxNormInput: Swift.Equatable {
    /// The input text used for analysis.
    /// This member is required.
    public var text: Swift.String?

    public init(
        text: Swift.String? = nil
    )
    {
        self.text = text
    }
}

struct InferRxNormInputBody: Swift.Equatable {
    let text: Swift.String?
}

extension InferRxNormInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension InferRxNormOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InferRxNormOutputBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.modelVersion = output.modelVersion
            self.paginationToken = output.paginationToken
        } else {
            self.entities = nil
            self.modelVersion = nil
            self.paginationToken = nil
        }
    }
}

public struct InferRxNormOutput: Swift.Equatable {
    /// The medication entities detected in the text linked to RxNorm concepts. If the action is successful, the service sends back an HTTP 200 response, as well as the entities detected.
    /// This member is required.
    public var entities: [ComprehendMedicalClientTypes.RxNormEntity]?
    /// The version of the model used to analyze the documents, in the format n.n.n You can use this information to track the model used for a particular batch of documents.
    public var modelVersion: Swift.String?
    /// If the result of the previous request to InferRxNorm was truncated, include the PaginationToken to fetch the next page of medication entities.
    public var paginationToken: Swift.String?

    public init(
        entities: [ComprehendMedicalClientTypes.RxNormEntity]? = nil,
        modelVersion: Swift.String? = nil,
        paginationToken: Swift.String? = nil
    )
    {
        self.entities = entities
        self.modelVersion = modelVersion
        self.paginationToken = paginationToken
    }
}

struct InferRxNormOutputBody: Swift.Equatable {
    let entities: [ComprehendMedicalClientTypes.RxNormEntity]?
    let paginationToken: Swift.String?
    let modelVersion: Swift.String?
}

extension InferRxNormOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities = "Entities"
        case modelVersion = "ModelVersion"
        case paginationToken = "PaginationToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.RxNormEntity?].self, forKey: .entities)
        var entitiesDecoded0:[ComprehendMedicalClientTypes.RxNormEntity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [ComprehendMedicalClientTypes.RxNormEntity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let paginationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
        let modelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
    }
}

enum InferRxNormOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidEncodingException": return try await InvalidEncodingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TextSizeLimitExceededException": return try await TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InferSNOMEDCTInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }
}

extension InferSNOMEDCTInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct InferSNOMEDCTInput: Swift.Equatable {
    /// The input text to be analyzed using InferSNOMEDCT.
    /// This member is required.
    public var text: Swift.String?

    public init(
        text: Swift.String? = nil
    )
    {
        self.text = text
    }
}

struct InferSNOMEDCTInputBody: Swift.Equatable {
    let text: Swift.String?
}

extension InferSNOMEDCTInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension InferSNOMEDCTOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InferSNOMEDCTOutputBody = try responseDecoder.decode(responseBody: data)
            self.characters = output.characters
            self.entities = output.entities
            self.modelVersion = output.modelVersion
            self.paginationToken = output.paginationToken
            self.snomedctDetails = output.snomedctDetails
        } else {
            self.characters = nil
            self.entities = nil
            self.modelVersion = nil
            self.paginationToken = nil
            self.snomedctDetails = nil
        }
    }
}

public struct InferSNOMEDCTOutput: Swift.Equatable {
    /// The number of characters in the input request documentation.
    public var characters: ComprehendMedicalClientTypes.Characters?
    /// The collection of medical concept entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence that Amazon Comprehend Medical has in the detection and analysis. Attributes and traits of the entity are also returned.
    /// This member is required.
    public var entities: [ComprehendMedicalClientTypes.SNOMEDCTEntity]?
    /// The version of the model used to analyze the documents, in the format n.n.n You can use this information to track the model used for a particular batch of documents.
    public var modelVersion: Swift.String?
    /// If the result of the request is truncated, the pagination token can be used to fetch the next page of entities.
    public var paginationToken: Swift.String?
    /// The details of the SNOMED-CT revision, including the edition, language, and version date.
    public var snomedctDetails: ComprehendMedicalClientTypes.SNOMEDCTDetails?

    public init(
        characters: ComprehendMedicalClientTypes.Characters? = nil,
        entities: [ComprehendMedicalClientTypes.SNOMEDCTEntity]? = nil,
        modelVersion: Swift.String? = nil,
        paginationToken: Swift.String? = nil,
        snomedctDetails: ComprehendMedicalClientTypes.SNOMEDCTDetails? = nil
    )
    {
        self.characters = characters
        self.entities = entities
        self.modelVersion = modelVersion
        self.paginationToken = paginationToken
        self.snomedctDetails = snomedctDetails
    }
}

struct InferSNOMEDCTOutputBody: Swift.Equatable {
    let entities: [ComprehendMedicalClientTypes.SNOMEDCTEntity]?
    let paginationToken: Swift.String?
    let modelVersion: Swift.String?
    let snomedctDetails: ComprehendMedicalClientTypes.SNOMEDCTDetails?
    let characters: ComprehendMedicalClientTypes.Characters?
}

extension InferSNOMEDCTOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case characters = "Characters"
        case entities = "Entities"
        case modelVersion = "ModelVersion"
        case paginationToken = "PaginationToken"
        case snomedctDetails = "SNOMEDCTDetails"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.SNOMEDCTEntity?].self, forKey: .entities)
        var entitiesDecoded0:[ComprehendMedicalClientTypes.SNOMEDCTEntity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [ComprehendMedicalClientTypes.SNOMEDCTEntity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let paginationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .paginationToken)
        paginationToken = paginationTokenDecoded
        let modelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
        let snomedctDetailsDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.SNOMEDCTDetails.self, forKey: .snomedctDetails)
        snomedctDetails = snomedctDetailsDecoded
        let charactersDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.Characters.self, forKey: .characters)
        characters = charactersDecoded
    }
}

enum InferSNOMEDCTOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidEncodingException": return try await InvalidEncodingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TextSizeLimitExceededException": return try await TextSizeLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ComprehendMedicalClientTypes.InputDataConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Bucket = "S3Bucket"
        case s3Key = "S3Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = self.s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = self.s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
    }
}

extension ComprehendMedicalClientTypes {
    /// The input properties for an entities detection job. This includes the name of the S3 bucket and the path to the files to be analyzed.
    public struct InputDataConfig: Swift.Equatable {
        /// The URI of the S3 bucket that contains the input data. The bucket must be in the same region as the API endpoint that you are calling.
        /// This member is required.
        public var s3Bucket: Swift.String?
        /// The path to the input data files in the S3 bucket.
        public var s3Key: Swift.String?

        public init(
            s3Bucket: Swift.String? = nil,
            s3Key: Swift.String? = nil
        )
        {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An internal server error occurred. Retry your request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEncodingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidEncodingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input text was not in valid UTF-8 character encoding. Check your text then retry your request.
public struct InvalidEncodingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidEncodingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidEncodingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidEncodingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request that you made is invalid. Check your request to determine why it's invalid and then retry the request.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ComprehendMedicalClientTypes {
    public enum JobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case partialSuccess
        case stopped
        case stopRequested
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .partialSuccess,
                .stopped,
                .stopRequested,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .partialSuccess: return "PARTIAL_SUCCESS"
            case .stopped: return "STOPPED"
            case .stopRequested: return "STOP_REQUESTED"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes {
    public enum LanguageCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case en
        case sdkUnknown(Swift.String)

        public static var allCases: [LanguageCode] {
            return [
                .en,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .en: return "en"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LanguageCode(rawValue: rawValue) ?? LanguageCode.sdkUnknown(rawValue)
        }
    }
}

extension ListEntitiesDetectionV2JobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListEntitiesDetectionV2JobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListEntitiesDetectionV2JobsInput: Swift.Equatable {
    /// Filters the jobs that are returned. You can filter jobs based on their names, status, or the date and time that they were submitted. You can only set one filter at a time.
    public var filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter?
    /// The maximum number of results to return in each page. The default is 100.
    public var maxResults: Swift.Int?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init(
        filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEntitiesDetectionV2JobsInputBody: Swift.Equatable {
    let filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListEntitiesDetectionV2JobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEntitiesDetectionV2JobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEntitiesDetectionV2JobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.comprehendMedicalAsyncJobPropertiesList = output.comprehendMedicalAsyncJobPropertiesList
            self.nextToken = output.nextToken
        } else {
            self.comprehendMedicalAsyncJobPropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListEntitiesDetectionV2JobsOutput: Swift.Equatable {
    /// A list containing the properties of each job returned.
    public var comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init(
        comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesList
        self.nextToken = nextToken
    }
}

struct ListEntitiesDetectionV2JobsOutputBody: Swift.Equatable {
    let comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]?
    let nextToken: Swift.String?
}

extension ListEntitiesDetectionV2JobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comprehendMedicalAsyncJobPropertiesList = "ComprehendMedicalAsyncJobPropertiesList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comprehendMedicalAsyncJobPropertiesListContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?].self, forKey: .comprehendMedicalAsyncJobPropertiesList)
        var comprehendMedicalAsyncJobPropertiesListDecoded0:[ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]? = nil
        if let comprehendMedicalAsyncJobPropertiesListContainer = comprehendMedicalAsyncJobPropertiesListContainer {
            comprehendMedicalAsyncJobPropertiesListDecoded0 = [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]()
            for structure0 in comprehendMedicalAsyncJobPropertiesListContainer {
                if let structure0 = structure0 {
                    comprehendMedicalAsyncJobPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEntitiesDetectionV2JobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListICD10CMInferenceJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListICD10CMInferenceJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListICD10CMInferenceJobsInput: Swift.Equatable {
    /// Filters the jobs that are returned. You can filter jobs based on their names, status, or the date and time that they were submitted. You can only set one filter at a time.
    public var filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter?
    /// The maximum number of results to return in each page. The default is 100.
    public var maxResults: Swift.Int?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init(
        filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListICD10CMInferenceJobsInputBody: Swift.Equatable {
    let filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListICD10CMInferenceJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListICD10CMInferenceJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListICD10CMInferenceJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.comprehendMedicalAsyncJobPropertiesList = output.comprehendMedicalAsyncJobPropertiesList
            self.nextToken = output.nextToken
        } else {
            self.comprehendMedicalAsyncJobPropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListICD10CMInferenceJobsOutput: Swift.Equatable {
    /// A list containing the properties of each job that is returned.
    public var comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init(
        comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesList
        self.nextToken = nextToken
    }
}

struct ListICD10CMInferenceJobsOutputBody: Swift.Equatable {
    let comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]?
    let nextToken: Swift.String?
}

extension ListICD10CMInferenceJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comprehendMedicalAsyncJobPropertiesList = "ComprehendMedicalAsyncJobPropertiesList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comprehendMedicalAsyncJobPropertiesListContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?].self, forKey: .comprehendMedicalAsyncJobPropertiesList)
        var comprehendMedicalAsyncJobPropertiesListDecoded0:[ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]? = nil
        if let comprehendMedicalAsyncJobPropertiesListContainer = comprehendMedicalAsyncJobPropertiesListContainer {
            comprehendMedicalAsyncJobPropertiesListDecoded0 = [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]()
            for structure0 in comprehendMedicalAsyncJobPropertiesListContainer {
                if let structure0 = structure0 {
                    comprehendMedicalAsyncJobPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListICD10CMInferenceJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPHIDetectionJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListPHIDetectionJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPHIDetectionJobsInput: Swift.Equatable {
    /// Filters the jobs that are returned. You can filter jobs based on their names, status, or the date and time that they were submitted. You can only set one filter at a time.
    public var filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter?
    /// The maximum number of results to return in each page. The default is 100.
    public var maxResults: Swift.Int?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init(
        filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPHIDetectionJobsInputBody: Swift.Equatable {
    let filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListPHIDetectionJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPHIDetectionJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPHIDetectionJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.comprehendMedicalAsyncJobPropertiesList = output.comprehendMedicalAsyncJobPropertiesList
            self.nextToken = output.nextToken
        } else {
            self.comprehendMedicalAsyncJobPropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListPHIDetectionJobsOutput: Swift.Equatable {
    /// A list containing the properties of each job returned.
    public var comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init(
        comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesList
        self.nextToken = nextToken
    }
}

struct ListPHIDetectionJobsOutputBody: Swift.Equatable {
    let comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]?
    let nextToken: Swift.String?
}

extension ListPHIDetectionJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comprehendMedicalAsyncJobPropertiesList = "ComprehendMedicalAsyncJobPropertiesList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comprehendMedicalAsyncJobPropertiesListContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?].self, forKey: .comprehendMedicalAsyncJobPropertiesList)
        var comprehendMedicalAsyncJobPropertiesListDecoded0:[ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]? = nil
        if let comprehendMedicalAsyncJobPropertiesListContainer = comprehendMedicalAsyncJobPropertiesListContainer {
            comprehendMedicalAsyncJobPropertiesListDecoded0 = [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]()
            for structure0 in comprehendMedicalAsyncJobPropertiesListContainer {
                if let structure0 = structure0 {
                    comprehendMedicalAsyncJobPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPHIDetectionJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRxNormInferenceJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListRxNormInferenceJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListRxNormInferenceJobsInput: Swift.Equatable {
    /// Filters the jobs that are returned. You can filter jobs based on their names, status, or the date and time that they were submitted. You can only set one filter at a time.
    public var filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter?
    /// Identifies the next page of results to return.
    public var maxResults: Swift.Int?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init(
        filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRxNormInferenceJobsInputBody: Swift.Equatable {
    let filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListRxNormInferenceJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListRxNormInferenceJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRxNormInferenceJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.comprehendMedicalAsyncJobPropertiesList = output.comprehendMedicalAsyncJobPropertiesList
            self.nextToken = output.nextToken
        } else {
            self.comprehendMedicalAsyncJobPropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListRxNormInferenceJobsOutput: Swift.Equatable {
    /// The maximum number of results to return in each page. The default is 100.
    public var comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init(
        comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesList
        self.nextToken = nextToken
    }
}

struct ListRxNormInferenceJobsOutputBody: Swift.Equatable {
    let comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]?
    let nextToken: Swift.String?
}

extension ListRxNormInferenceJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comprehendMedicalAsyncJobPropertiesList = "ComprehendMedicalAsyncJobPropertiesList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comprehendMedicalAsyncJobPropertiesListContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?].self, forKey: .comprehendMedicalAsyncJobPropertiesList)
        var comprehendMedicalAsyncJobPropertiesListDecoded0:[ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]? = nil
        if let comprehendMedicalAsyncJobPropertiesListContainer = comprehendMedicalAsyncJobPropertiesListContainer {
            comprehendMedicalAsyncJobPropertiesListDecoded0 = [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]()
            for structure0 in comprehendMedicalAsyncJobPropertiesListContainer {
                if let structure0 = structure0 {
                    comprehendMedicalAsyncJobPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRxNormInferenceJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSNOMEDCTInferenceJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSNOMEDCTInferenceJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSNOMEDCTInferenceJobsInput: Swift.Equatable {
    /// Provides information for filtering a list of detection jobs.
    public var filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter?
    /// The maximum number of results to return in each page. The default is 100.
    public var maxResults: Swift.Int?
    /// Identifies the next page of InferSNOMEDCT results to return.
    public var nextToken: Swift.String?

    public init(
        filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSNOMEDCTInferenceJobsInputBody: Swift.Equatable {
    let filter: ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListSNOMEDCTInferenceJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListSNOMEDCTInferenceJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSNOMEDCTInferenceJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.comprehendMedicalAsyncJobPropertiesList = output.comprehendMedicalAsyncJobPropertiesList
            self.nextToken = output.nextToken
        } else {
            self.comprehendMedicalAsyncJobPropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListSNOMEDCTInferenceJobsOutput: Swift.Equatable {
    /// A list containing the properties of each job that is returned.
    public var comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]?
    /// Identifies the next page of results to return.
    public var nextToken: Swift.String?

    public init(
        comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesList
        self.nextToken = nextToken
    }
}

struct ListSNOMEDCTInferenceJobsOutputBody: Swift.Equatable {
    let comprehendMedicalAsyncJobPropertiesList: [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]?
    let nextToken: Swift.String?
}

extension ListSNOMEDCTInferenceJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comprehendMedicalAsyncJobPropertiesList = "ComprehendMedicalAsyncJobPropertiesList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comprehendMedicalAsyncJobPropertiesListContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties?].self, forKey: .comprehendMedicalAsyncJobPropertiesList)
        var comprehendMedicalAsyncJobPropertiesListDecoded0:[ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]? = nil
        if let comprehendMedicalAsyncJobPropertiesListContainer = comprehendMedicalAsyncJobPropertiesListContainer {
            comprehendMedicalAsyncJobPropertiesListDecoded0 = [ComprehendMedicalClientTypes.ComprehendMedicalAsyncJobProperties]()
            for structure0 in comprehendMedicalAsyncJobPropertiesListContainer {
                if let structure0 = structure0 {
                    comprehendMedicalAsyncJobPropertiesListDecoded0?.append(structure0)
                }
            }
        }
        comprehendMedicalAsyncJobPropertiesList = comprehendMedicalAsyncJobPropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSNOMEDCTInferenceJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ComprehendMedicalClientTypes.OutputDataConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Bucket = "S3Bucket"
        case s3Key = "S3Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = self.s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = self.s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
    }
}

extension ComprehendMedicalClientTypes {
    /// The output properties for a detection job.
    public struct OutputDataConfig: Swift.Equatable {
        /// When you use the OutputDataConfig object with asynchronous operations, you specify the Amazon S3 location where you want to write the output data. The URI must be in the same region as the API endpoint that you are calling. The location is used as the prefix for the actual location of the output.
        /// This member is required.
        public var s3Bucket: Swift.String?
        /// The path to the output data files in the S3 bucket. Amazon Comprehend Medical creates an output directory using the job ID so that the output from one job does not overwrite the output of another.
        public var s3Key: Swift.String?

        public init(
            s3Bucket: Swift.String? = nil,
            s3Key: Swift.String? = nil
        )
        {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
        }
    }

}

extension ComprehendMedicalClientTypes {
    public enum RelationshipType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acuity
        case administeredVia
        case amount
        case direction
        case dosage
        case duration
        case every
        case `for`
        case form
        case frequency
        case negative
        case overlap
        case quality
        case rate
        case routeOrMode
        case strength
        case systemOrganSite
        case testUnit
        case testUnits
        case testValue
        case usage
        case withDosage
        case sdkUnknown(Swift.String)

        public static var allCases: [RelationshipType] {
            return [
                .acuity,
                .administeredVia,
                .amount,
                .direction,
                .dosage,
                .duration,
                .every,
                .for,
                .form,
                .frequency,
                .negative,
                .overlap,
                .quality,
                .rate,
                .routeOrMode,
                .strength,
                .systemOrganSite,
                .testUnit,
                .testUnits,
                .testValue,
                .usage,
                .withDosage,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acuity: return "ACUITY"
            case .administeredVia: return "ADMINISTERED_VIA"
            case .amount: return "AMOUNT"
            case .direction: return "DIRECTION"
            case .dosage: return "DOSAGE"
            case .duration: return "DURATION"
            case .every: return "EVERY"
            case .for: return "FOR"
            case .form: return "FORM"
            case .frequency: return "FREQUENCY"
            case .negative: return "NEGATIVE"
            case .overlap: return "OVERLAP"
            case .quality: return "QUALITY"
            case .rate: return "RATE"
            case .routeOrMode: return "ROUTE_OR_MODE"
            case .strength: return "STRENGTH"
            case .systemOrganSite: return "SYSTEM_ORGAN_SITE"
            case .testUnit: return "TEST_UNIT"
            case .testUnits: return "TEST_UNITS"
            case .testValue: return "TEST_VALUE"
            case .usage: return "USAGE"
            case .withDosage: return "WITH_DOSAGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RelationshipType(rawValue: rawValue) ?? RelationshipType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource identified by the specified Amazon Resource Name (ARN) was not found. Check the ARN and try your request again.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ComprehendMedicalClientTypes.RxNormAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beginOffset = "BeginOffset"
        case endOffset = "EndOffset"
        case id = "Id"
        case relationshipScore = "RelationshipScore"
        case score = "Score"
        case text = "Text"
        case traits = "Traits"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beginOffset = self.beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let endOffset = self.endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let relationshipScore = self.relationshipScore {
            try encodeContainer.encode(relationshipScore, forKey: .relationshipScore)
        }
        if let score = self.score {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let traits = traits {
            var traitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .traits)
            for rxnormtrait0 in traits {
                try traitsContainer.encode(rxnormtrait0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.RxNormAttributeType.self, forKey: .type)
        type = typeDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
        let relationshipScoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .relationshipScore)
        relationshipScore = relationshipScoreDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .id)
        id = idDecoded
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let traitsContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.RxNormTrait?].self, forKey: .traits)
        var traitsDecoded0:[ComprehendMedicalClientTypes.RxNormTrait]? = nil
        if let traitsContainer = traitsContainer {
            traitsDecoded0 = [ComprehendMedicalClientTypes.RxNormTrait]()
            for structure0 in traitsContainer {
                if let structure0 = structure0 {
                    traitsDecoded0?.append(structure0)
                }
            }
        }
        traits = traitsDecoded0
    }
}

extension ComprehendMedicalClientTypes {
    /// The extracted attributes that relate to this entity. The attributes recognized by InferRxNorm are DOSAGE, DURATION, FORM, FREQUENCY, RATE, ROUTE_OR_MODE.
    public struct RxNormAttribute: Swift.Equatable {
        /// The 0-based character offset in the input text that shows where the attribute begins. The offset returns the UTF-8 code point in the string.
        public var beginOffset: Swift.Int?
        /// The 0-based character offset in the input text that shows where the attribute ends. The offset returns the UTF-8 code point in the string.
        public var endOffset: Swift.Int?
        /// The numeric identifier for this attribute. This is a monotonically increasing id unique within this response rather than a global unique identifier.
        public var id: Swift.Int?
        /// The level of confidence that Amazon Comprehend Medical has that the attribute is accurately linked to an entity.
        public var relationshipScore: Swift.Float?
        /// The level of confidence that Amazon Comprehend Medical has that the segment of text is correctly recognized as an attribute.
        public var score: Swift.Float?
        /// The segment of input text which corresponds to the detected attribute.
        public var text: Swift.String?
        /// Contextual information for the attribute. InferRxNorm recognizes the trait NEGATION for attributes, i.e. that the patient is not taking a specific dose or form of a medication.
        public var traits: [ComprehendMedicalClientTypes.RxNormTrait]?
        /// The type of attribute. The types of attributes recognized by InferRxNorm are BRAND_NAME and GENERIC_NAME.
        public var type: ComprehendMedicalClientTypes.RxNormAttributeType?

        public init(
            beginOffset: Swift.Int? = nil,
            endOffset: Swift.Int? = nil,
            id: Swift.Int? = nil,
            relationshipScore: Swift.Float? = nil,
            score: Swift.Float? = nil,
            text: Swift.String? = nil,
            traits: [ComprehendMedicalClientTypes.RxNormTrait]? = nil,
            type: ComprehendMedicalClientTypes.RxNormAttributeType? = nil
        )
        {
            self.beginOffset = beginOffset
            self.endOffset = endOffset
            self.id = id
            self.relationshipScore = relationshipScore
            self.score = score
            self.text = text
            self.traits = traits
            self.type = type
        }
    }

}

extension ComprehendMedicalClientTypes {
    public enum RxNormAttributeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dosage
        case duration
        case form
        case frequency
        case rate
        case routeOrMode
        case strength
        case sdkUnknown(Swift.String)

        public static var allCases: [RxNormAttributeType] {
            return [
                .dosage,
                .duration,
                .form,
                .frequency,
                .rate,
                .routeOrMode,
                .strength,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dosage: return "DOSAGE"
            case .duration: return "DURATION"
            case .form: return "FORM"
            case .frequency: return "FREQUENCY"
            case .rate: return "RATE"
            case .routeOrMode: return "ROUTE_OR_MODE"
            case .strength: return "STRENGTH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RxNormAttributeType(rawValue: rawValue) ?? RxNormAttributeType.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes.RxNormConcept: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case description = "Description"
        case score = "Score"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let score = self.score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
    }
}

extension ComprehendMedicalClientTypes {
    /// The RxNorm concept that the entity could refer to, along with a score indicating the likelihood of the match.
    public struct RxNormConcept: Swift.Equatable {
        /// RxNorm concept ID, also known as the RxCUI.
        public var code: Swift.String?
        /// The description of the RxNorm concept.
        public var description: Swift.String?
        /// The level of confidence that Amazon Comprehend Medical has that the entity is accurately linked to the reported RxNorm concept.
        public var score: Swift.Float?

        public init(
            code: Swift.String? = nil,
            description: Swift.String? = nil,
            score: Swift.Float? = nil
        )
        {
            self.code = code
            self.description = description
            self.score = score
        }
    }

}

extension ComprehendMedicalClientTypes.RxNormEntity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case beginOffset = "BeginOffset"
        case category = "Category"
        case endOffset = "EndOffset"
        case id = "Id"
        case rxNormConcepts = "RxNormConcepts"
        case score = "Score"
        case text = "Text"
        case traits = "Traits"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for rxnormattribute0 in attributes {
                try attributesContainer.encode(rxnormattribute0)
            }
        }
        if let beginOffset = self.beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let category = self.category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let endOffset = self.endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let rxNormConcepts = rxNormConcepts {
            var rxNormConceptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rxNormConcepts)
            for rxnormconcept0 in rxNormConcepts {
                try rxNormConceptsContainer.encode(rxnormconcept0)
            }
        }
        if let score = self.score {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let traits = traits {
            var traitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .traits)
            for rxnormtrait0 in traits {
                try traitsContainer.encode(rxnormtrait0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .id)
        id = idDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.RxNormEntityCategory.self, forKey: .category)
        category = categoryDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.RxNormEntityType.self, forKey: .type)
        type = typeDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
        let attributesContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.RxNormAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[ComprehendMedicalClientTypes.RxNormAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [ComprehendMedicalClientTypes.RxNormAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let traitsContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.RxNormTrait?].self, forKey: .traits)
        var traitsDecoded0:[ComprehendMedicalClientTypes.RxNormTrait]? = nil
        if let traitsContainer = traitsContainer {
            traitsDecoded0 = [ComprehendMedicalClientTypes.RxNormTrait]()
            for structure0 in traitsContainer {
                if let structure0 = structure0 {
                    traitsDecoded0?.append(structure0)
                }
            }
        }
        traits = traitsDecoded0
        let rxNormConceptsContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.RxNormConcept?].self, forKey: .rxNormConcepts)
        var rxNormConceptsDecoded0:[ComprehendMedicalClientTypes.RxNormConcept]? = nil
        if let rxNormConceptsContainer = rxNormConceptsContainer {
            rxNormConceptsDecoded0 = [ComprehendMedicalClientTypes.RxNormConcept]()
            for structure0 in rxNormConceptsContainer {
                if let structure0 = structure0 {
                    rxNormConceptsDecoded0?.append(structure0)
                }
            }
        }
        rxNormConcepts = rxNormConceptsDecoded0
    }
}

extension ComprehendMedicalClientTypes {
    /// The collection of medical entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence that Amazon Comprehend Medical has in the detection and analysis. Attributes and traits of the entity are also returned.
    public struct RxNormEntity: Swift.Equatable {
        /// The extracted attributes that relate to the entity. The attributes recognized by InferRxNorm are DOSAGE, DURATION, FORM, FREQUENCY, RATE, ROUTE_OR_MODE, and STRENGTH.
        public var attributes: [ComprehendMedicalClientTypes.RxNormAttribute]?
        /// The 0-based character offset in the input text that shows where the entity begins. The offset returns the UTF-8 code point in the string.
        public var beginOffset: Swift.Int?
        /// The category of the entity. The recognized categories are GENERIC or BRAND_NAME.
        public var category: ComprehendMedicalClientTypes.RxNormEntityCategory?
        /// The 0-based character offset in the input text that shows where the entity ends. The offset returns the UTF-8 code point in the string.
        public var endOffset: Swift.Int?
        /// The numeric identifier for the entity. This is a monotonically increasing id unique within this response rather than a global unique identifier.
        public var id: Swift.Int?
        /// The RxNorm concepts that the entity could refer to, along with a score indicating the likelihood of the match.
        public var rxNormConcepts: [ComprehendMedicalClientTypes.RxNormConcept]?
        /// The level of confidence that Amazon Comprehend Medical has in the accuracy of the detected entity.
        public var score: Swift.Float?
        /// The segment of input text extracted from which the entity was detected.
        public var text: Swift.String?
        /// Contextual information for the entity.
        public var traits: [ComprehendMedicalClientTypes.RxNormTrait]?
        /// Describes the specific type of entity. For InferRxNorm, the recognized entity type is MEDICATION.
        public var type: ComprehendMedicalClientTypes.RxNormEntityType?

        public init(
            attributes: [ComprehendMedicalClientTypes.RxNormAttribute]? = nil,
            beginOffset: Swift.Int? = nil,
            category: ComprehendMedicalClientTypes.RxNormEntityCategory? = nil,
            endOffset: Swift.Int? = nil,
            id: Swift.Int? = nil,
            rxNormConcepts: [ComprehendMedicalClientTypes.RxNormConcept]? = nil,
            score: Swift.Float? = nil,
            text: Swift.String? = nil,
            traits: [ComprehendMedicalClientTypes.RxNormTrait]? = nil,
            type: ComprehendMedicalClientTypes.RxNormEntityType? = nil
        )
        {
            self.attributes = attributes
            self.beginOffset = beginOffset
            self.category = category
            self.endOffset = endOffset
            self.id = id
            self.rxNormConcepts = rxNormConcepts
            self.score = score
            self.text = text
            self.traits = traits
            self.type = type
        }
    }

}

extension ComprehendMedicalClientTypes {
    public enum RxNormEntityCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case medication
        case sdkUnknown(Swift.String)

        public static var allCases: [RxNormEntityCategory] {
            return [
                .medication,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .medication: return "MEDICATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RxNormEntityCategory(rawValue: rawValue) ?? RxNormEntityCategory.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes {
    public enum RxNormEntityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case brandName
        case genericName
        case sdkUnknown(Swift.String)

        public static var allCases: [RxNormEntityType] {
            return [
                .brandName,
                .genericName,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .brandName: return "BRAND_NAME"
            case .genericName: return "GENERIC_NAME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RxNormEntityType(rawValue: rawValue) ?? RxNormEntityType.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes.RxNormTrait: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case score = "Score"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let score = self.score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.RxNormTraitName.self, forKey: .name)
        name = nameDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
    }
}

extension ComprehendMedicalClientTypes {
    /// The contextual information for the entity. InferRxNorm recognizes the trait NEGATION, which is any indication that the patient is not taking a medication.
    public struct RxNormTrait: Swift.Equatable {
        /// Provides a name or contextual description about the trait.
        public var name: ComprehendMedicalClientTypes.RxNormTraitName?
        /// The level of confidence that Amazon Comprehend Medical has in the accuracy of the detected trait.
        public var score: Swift.Float?

        public init(
            name: ComprehendMedicalClientTypes.RxNormTraitName? = nil,
            score: Swift.Float? = nil
        )
        {
            self.name = name
            self.score = score
        }
    }

}

extension ComprehendMedicalClientTypes {
    public enum RxNormTraitName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case negation
        case pastHistory
        case sdkUnknown(Swift.String)

        public static var allCases: [RxNormTraitName] {
            return [
                .negation,
                .pastHistory,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .negation: return "NEGATION"
            case .pastHistory: return "PAST_HISTORY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RxNormTraitName(rawValue: rawValue) ?? RxNormTraitName.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes.SNOMEDCTAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case beginOffset = "BeginOffset"
        case category = "Category"
        case endOffset = "EndOffset"
        case id = "Id"
        case relationshipScore = "RelationshipScore"
        case relationshipType = "RelationshipType"
        case snomedctConcepts = "SNOMEDCTConcepts"
        case score = "Score"
        case text = "Text"
        case traits = "Traits"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beginOffset = self.beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let category = self.category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let endOffset = self.endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let relationshipScore = self.relationshipScore {
            try encodeContainer.encode(relationshipScore, forKey: .relationshipScore)
        }
        if let relationshipType = self.relationshipType {
            try encodeContainer.encode(relationshipType.rawValue, forKey: .relationshipType)
        }
        if let snomedctConcepts = snomedctConcepts {
            var snomedctConceptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .snomedctConcepts)
            for snomedctconcept0 in snomedctConcepts {
                try snomedctConceptsContainer.encode(snomedctconcept0)
            }
        }
        if let score = self.score {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let traits = traits {
            var traitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .traits)
            for snomedcttrait0 in traits {
                try traitsContainer.encode(snomedcttrait0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.SNOMEDCTEntityCategory.self, forKey: .category)
        category = categoryDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.SNOMEDCTAttributeType.self, forKey: .type)
        type = typeDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
        let relationshipScoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .relationshipScore)
        relationshipScore = relationshipScoreDecoded
        let relationshipTypeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.SNOMEDCTRelationshipType.self, forKey: .relationshipType)
        relationshipType = relationshipTypeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .id)
        id = idDecoded
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let traitsContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.SNOMEDCTTrait?].self, forKey: .traits)
        var traitsDecoded0:[ComprehendMedicalClientTypes.SNOMEDCTTrait]? = nil
        if let traitsContainer = traitsContainer {
            traitsDecoded0 = [ComprehendMedicalClientTypes.SNOMEDCTTrait]()
            for structure0 in traitsContainer {
                if let structure0 = structure0 {
                    traitsDecoded0?.append(structure0)
                }
            }
        }
        traits = traitsDecoded0
        let snomedctConceptsContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.SNOMEDCTConcept?].self, forKey: .snomedctConcepts)
        var snomedctConceptsDecoded0:[ComprehendMedicalClientTypes.SNOMEDCTConcept]? = nil
        if let snomedctConceptsContainer = snomedctConceptsContainer {
            snomedctConceptsDecoded0 = [ComprehendMedicalClientTypes.SNOMEDCTConcept]()
            for structure0 in snomedctConceptsContainer {
                if let structure0 = structure0 {
                    snomedctConceptsDecoded0?.append(structure0)
                }
            }
        }
        snomedctConcepts = snomedctConceptsDecoded0
    }
}

extension ComprehendMedicalClientTypes {
    /// The extracted attributes that relate to an entity. An extracted segment of the text that is an attribute of an entity, or otherwise related to an entity, such as the dosage of a medication taken.
    public struct SNOMEDCTAttribute: Swift.Equatable {
        /// The 0-based character offset in the input text that shows where the attribute begins. The offset returns the UTF-8 code point in the string.
        public var beginOffset: Swift.Int?
        /// The category of the detected attribute. Possible categories include MEDICAL_CONDITION, ANATOMY, and TEST_TREATMENT_PROCEDURE.
        public var category: ComprehendMedicalClientTypes.SNOMEDCTEntityCategory?
        /// The 0-based character offset in the input text that shows where the attribute ends. The offset returns the UTF-8 code point in the string.
        public var endOffset: Swift.Int?
        /// The numeric identifier for this attribute. This is a monotonically increasing id unique within this response rather than a global unique identifier.
        public var id: Swift.Int?
        /// The level of confidence that Amazon Comprehend Medical has that this attribute is correctly related to this entity.
        public var relationshipScore: Swift.Float?
        /// The type of relationship that exists between the entity and the related attribute.
        public var relationshipType: ComprehendMedicalClientTypes.SNOMEDCTRelationshipType?
        /// The level of confidence that Amazon Comprehend Medical has that the segment of text is correctly recognized as an attribute.
        public var score: Swift.Float?
        /// The SNOMED-CT concepts specific to an attribute, along with a score indicating the likelihood of the match.
        public var snomedctConcepts: [ComprehendMedicalClientTypes.SNOMEDCTConcept]?
        /// The segment of input text extracted as this attribute.
        public var text: Swift.String?
        /// Contextual information for an attribute. Examples include signs, symptoms, diagnosis, and negation.
        public var traits: [ComprehendMedicalClientTypes.SNOMEDCTTrait]?
        /// The type of attribute. Possible types include DX_NAME, ACUITY, DIRECTION, SYSTEM_ORGAN_SITE,TEST_NAME, TEST_VALUE, TEST_UNIT, PROCEDURE_NAME, and TREATMENT_NAME.
        public var type: ComprehendMedicalClientTypes.SNOMEDCTAttributeType?

        public init(
            beginOffset: Swift.Int? = nil,
            category: ComprehendMedicalClientTypes.SNOMEDCTEntityCategory? = nil,
            endOffset: Swift.Int? = nil,
            id: Swift.Int? = nil,
            relationshipScore: Swift.Float? = nil,
            relationshipType: ComprehendMedicalClientTypes.SNOMEDCTRelationshipType? = nil,
            score: Swift.Float? = nil,
            snomedctConcepts: [ComprehendMedicalClientTypes.SNOMEDCTConcept]? = nil,
            text: Swift.String? = nil,
            traits: [ComprehendMedicalClientTypes.SNOMEDCTTrait]? = nil,
            type: ComprehendMedicalClientTypes.SNOMEDCTAttributeType? = nil
        )
        {
            self.beginOffset = beginOffset
            self.category = category
            self.endOffset = endOffset
            self.id = id
            self.relationshipScore = relationshipScore
            self.relationshipType = relationshipType
            self.score = score
            self.snomedctConcepts = snomedctConcepts
            self.text = text
            self.traits = traits
            self.type = type
        }
    }

}

extension ComprehendMedicalClientTypes {
    public enum SNOMEDCTAttributeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acuity
        case direction
        case quality
        case systemOrganSite
        case testUnit
        case testValue
        case sdkUnknown(Swift.String)

        public static var allCases: [SNOMEDCTAttributeType] {
            return [
                .acuity,
                .direction,
                .quality,
                .systemOrganSite,
                .testUnit,
                .testValue,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acuity: return "ACUITY"
            case .direction: return "DIRECTION"
            case .quality: return "QUALITY"
            case .systemOrganSite: return "SYSTEM_ORGAN_SITE"
            case .testUnit: return "TEST_UNIT"
            case .testValue: return "TEST_VALUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SNOMEDCTAttributeType(rawValue: rawValue) ?? SNOMEDCTAttributeType.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes.SNOMEDCTConcept: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case description = "Description"
        case score = "Score"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let score = self.score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
    }
}

extension ComprehendMedicalClientTypes {
    /// The SNOMED-CT concepts that the entity could refer to, along with a score indicating the likelihood of the match.
    public struct SNOMEDCTConcept: Swift.Equatable {
        /// The numeric ID for the SNOMED-CT concept.
        public var code: Swift.String?
        /// The description of the SNOMED-CT concept.
        public var description: Swift.String?
        /// The level of confidence Amazon Comprehend Medical has that the entity should be linked to the identified SNOMED-CT concept.
        public var score: Swift.Float?

        public init(
            code: Swift.String? = nil,
            description: Swift.String? = nil,
            score: Swift.Float? = nil
        )
        {
            self.code = code
            self.description = description
            self.score = score
        }
    }

}

extension ComprehendMedicalClientTypes.SNOMEDCTDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case edition = "Edition"
        case language = "Language"
        case versionDate = "VersionDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let edition = self.edition {
            try encodeContainer.encode(edition, forKey: .edition)
        }
        if let language = self.language {
            try encodeContainer.encode(language, forKey: .language)
        }
        if let versionDate = self.versionDate {
            try encodeContainer.encode(versionDate, forKey: .versionDate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let editionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .edition)
        edition = editionDecoded
        let languageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .language)
        language = languageDecoded
        let versionDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionDate)
        versionDate = versionDateDecoded
    }
}

extension ComprehendMedicalClientTypes {
    /// The information about the revision of the SNOMED-CT ontology in the response. Specifically, the details include the SNOMED-CT edition, language, and version date.
    public struct SNOMEDCTDetails: Swift.Equatable {
        /// The edition of SNOMED-CT used. The edition used for the InferSNOMEDCT editions is the US edition.
        public var edition: Swift.String?
        /// The language used in the SNOMED-CT ontology. All Amazon Comprehend Medical operations are US English (en).
        public var language: Swift.String?
        /// The version date of the SNOMED-CT ontology used.
        public var versionDate: Swift.String?

        public init(
            edition: Swift.String? = nil,
            language: Swift.String? = nil,
            versionDate: Swift.String? = nil
        )
        {
            self.edition = edition
            self.language = language
            self.versionDate = versionDate
        }
    }

}

extension ComprehendMedicalClientTypes.SNOMEDCTEntity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case beginOffset = "BeginOffset"
        case category = "Category"
        case endOffset = "EndOffset"
        case id = "Id"
        case snomedctConcepts = "SNOMEDCTConcepts"
        case score = "Score"
        case text = "Text"
        case traits = "Traits"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for snomedctattribute0 in attributes {
                try attributesContainer.encode(snomedctattribute0)
            }
        }
        if let beginOffset = self.beginOffset {
            try encodeContainer.encode(beginOffset, forKey: .beginOffset)
        }
        if let category = self.category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let endOffset = self.endOffset {
            try encodeContainer.encode(endOffset, forKey: .endOffset)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let snomedctConcepts = snomedctConcepts {
            var snomedctConceptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .snomedctConcepts)
            for snomedctconcept0 in snomedctConcepts {
                try snomedctConceptsContainer.encode(snomedctconcept0)
            }
        }
        if let score = self.score {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let traits = traits {
            var traitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .traits)
            for snomedcttrait0 in traits {
                try traitsContainer.encode(snomedcttrait0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .id)
        id = idDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.SNOMEDCTEntityCategory.self, forKey: .category)
        category = categoryDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.SNOMEDCTEntityType.self, forKey: .type)
        type = typeDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
        let beginOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .beginOffset)
        beginOffset = beginOffsetDecoded
        let endOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endOffset)
        endOffset = endOffsetDecoded
        let attributesContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.SNOMEDCTAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[ComprehendMedicalClientTypes.SNOMEDCTAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [ComprehendMedicalClientTypes.SNOMEDCTAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let traitsContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.SNOMEDCTTrait?].self, forKey: .traits)
        var traitsDecoded0:[ComprehendMedicalClientTypes.SNOMEDCTTrait]? = nil
        if let traitsContainer = traitsContainer {
            traitsDecoded0 = [ComprehendMedicalClientTypes.SNOMEDCTTrait]()
            for structure0 in traitsContainer {
                if let structure0 = structure0 {
                    traitsDecoded0?.append(structure0)
                }
            }
        }
        traits = traitsDecoded0
        let snomedctConceptsContainer = try containerValues.decodeIfPresent([ComprehendMedicalClientTypes.SNOMEDCTConcept?].self, forKey: .snomedctConcepts)
        var snomedctConceptsDecoded0:[ComprehendMedicalClientTypes.SNOMEDCTConcept]? = nil
        if let snomedctConceptsContainer = snomedctConceptsContainer {
            snomedctConceptsDecoded0 = [ComprehendMedicalClientTypes.SNOMEDCTConcept]()
            for structure0 in snomedctConceptsContainer {
                if let structure0 = structure0 {
                    snomedctConceptsDecoded0?.append(structure0)
                }
            }
        }
        snomedctConcepts = snomedctConceptsDecoded0
    }
}

extension ComprehendMedicalClientTypes {
    /// The collection of medical entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence that Amazon Comprehend Medical has in the detection and analysis. Attributes and traits of the entity are also returned.
    public struct SNOMEDCTEntity: Swift.Equatable {
        /// An extracted segment of the text that is an attribute of an entity, or otherwise related to an entity, such as the dosage of a medication taken.
        public var attributes: [ComprehendMedicalClientTypes.SNOMEDCTAttribute]?
        /// The 0-based character offset in the input text that shows where the entity begins. The offset returns the UTF-8 code point in the string.
        public var beginOffset: Swift.Int?
        /// The category of the detected entity. Possible categories are MEDICAL_CONDITION, ANATOMY, or TEST_TREATMENT_PROCEDURE.
        public var category: ComprehendMedicalClientTypes.SNOMEDCTEntityCategory?
        /// The 0-based character offset in the input text that shows where the entity ends. The offset returns the UTF-8 code point in the string.
        public var endOffset: Swift.Int?
        /// The numeric identifier for the entity. This is a monotonically increasing id unique within this response rather than a global unique identifier.
        public var id: Swift.Int?
        /// The level of confidence that Amazon Comprehend Medical has in the accuracy of the detected entity.
        public var score: Swift.Float?
        /// The SNOMED concepts that the entity could refer to, along with a score indicating the likelihood of the match.
        public var snomedctConcepts: [ComprehendMedicalClientTypes.SNOMEDCTConcept]?
        /// The segment of input text extracted as this entity.
        public var text: Swift.String?
        /// Contextual information for the entity.
        public var traits: [ComprehendMedicalClientTypes.SNOMEDCTTrait]?
        /// Describes the specific type of entity with category of entities. Possible types include DX_NAME, ACUITY, DIRECTION, SYSTEM_ORGAN_SITE, TEST_NAME, TEST_VALUE, TEST_UNIT, PROCEDURE_NAME, or TREATMENT_NAME.
        public var type: ComprehendMedicalClientTypes.SNOMEDCTEntityType?

        public init(
            attributes: [ComprehendMedicalClientTypes.SNOMEDCTAttribute]? = nil,
            beginOffset: Swift.Int? = nil,
            category: ComprehendMedicalClientTypes.SNOMEDCTEntityCategory? = nil,
            endOffset: Swift.Int? = nil,
            id: Swift.Int? = nil,
            score: Swift.Float? = nil,
            snomedctConcepts: [ComprehendMedicalClientTypes.SNOMEDCTConcept]? = nil,
            text: Swift.String? = nil,
            traits: [ComprehendMedicalClientTypes.SNOMEDCTTrait]? = nil,
            type: ComprehendMedicalClientTypes.SNOMEDCTEntityType? = nil
        )
        {
            self.attributes = attributes
            self.beginOffset = beginOffset
            self.category = category
            self.endOffset = endOffset
            self.id = id
            self.score = score
            self.snomedctConcepts = snomedctConcepts
            self.text = text
            self.traits = traits
            self.type = type
        }
    }

}

extension ComprehendMedicalClientTypes {
    public enum SNOMEDCTEntityCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case anatomy
        case medicalCondition
        case testTreatmentProcedure
        case sdkUnknown(Swift.String)

        public static var allCases: [SNOMEDCTEntityCategory] {
            return [
                .anatomy,
                .medicalCondition,
                .testTreatmentProcedure,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .anatomy: return "ANATOMY"
            case .medicalCondition: return "MEDICAL_CONDITION"
            case .testTreatmentProcedure: return "TEST_TREATMENT_PROCEDURE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SNOMEDCTEntityCategory(rawValue: rawValue) ?? SNOMEDCTEntityCategory.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes {
    public enum SNOMEDCTEntityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dxName
        case procedureName
        case testName
        case treatmentName
        case sdkUnknown(Swift.String)

        public static var allCases: [SNOMEDCTEntityType] {
            return [
                .dxName,
                .procedureName,
                .testName,
                .treatmentName,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dxName: return "DX_NAME"
            case .procedureName: return "PROCEDURE_NAME"
            case .testName: return "TEST_NAME"
            case .treatmentName: return "TREATMENT_NAME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SNOMEDCTEntityType(rawValue: rawValue) ?? SNOMEDCTEntityType.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes {
    public enum SNOMEDCTRelationshipType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acuity
        case direction
        case quality
        case systemOrganSite
        case testUnit
        case testUnits
        case testValue
        case sdkUnknown(Swift.String)

        public static var allCases: [SNOMEDCTRelationshipType] {
            return [
                .acuity,
                .direction,
                .quality,
                .systemOrganSite,
                .testUnit,
                .testUnits,
                .testValue,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acuity: return "ACUITY"
            case .direction: return "DIRECTION"
            case .quality: return "QUALITY"
            case .systemOrganSite: return "SYSTEM_ORGAN_SITE"
            case .testUnit: return "TEST_UNIT"
            case .testUnits: return "TEST_UNITS"
            case .testValue: return "TEST_VALUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SNOMEDCTRelationshipType(rawValue: rawValue) ?? SNOMEDCTRelationshipType.sdkUnknown(rawValue)
        }
    }
}

extension ComprehendMedicalClientTypes.SNOMEDCTTrait: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case score = "Score"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let score = self.score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.SNOMEDCTTraitName.self, forKey: .name)
        name = nameDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
    }
}

extension ComprehendMedicalClientTypes {
    /// Contextual information for an entity.
    public struct SNOMEDCTTrait: Swift.Equatable {
        /// The name or contextual description of a detected trait.
        public var name: ComprehendMedicalClientTypes.SNOMEDCTTraitName?
        /// The level of confidence that Amazon Comprehend Medical has in the accuracy of a detected trait.
        public var score: Swift.Float?

        public init(
            name: ComprehendMedicalClientTypes.SNOMEDCTTraitName? = nil,
            score: Swift.Float? = nil
        )
        {
            self.name = name
            self.score = score
        }
    }

}

extension ComprehendMedicalClientTypes {
    public enum SNOMEDCTTraitName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case diagnosis
        case future
        case hypothetical
        case lowConfidence
        case negation
        case pastHistory
        case pertainsToFamily
        case sign
        case symptom
        case sdkUnknown(Swift.String)

        public static var allCases: [SNOMEDCTTraitName] {
            return [
                .diagnosis,
                .future,
                .hypothetical,
                .lowConfidence,
                .negation,
                .pastHistory,
                .pertainsToFamily,
                .sign,
                .symptom,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .diagnosis: return "DIAGNOSIS"
            case .future: return "FUTURE"
            case .hypothetical: return "HYPOTHETICAL"
            case .lowConfidence: return "LOW_CONFIDENCE"
            case .negation: return "NEGATION"
            case .pastHistory: return "PAST_HISTORY"
            case .pertainsToFamily: return "PERTAINS_TO_FAMILY"
            case .sign: return "SIGN"
            case .symptom: return "SYMPTOM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SNOMEDCTTraitName(rawValue: rawValue) ?? SNOMEDCTTraitName.sdkUnknown(rawValue)
        }
    }
}

extension ServiceUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The Amazon Comprehend Medical service is temporarily unavailable. Please wait and then retry your request.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StartEntitiesDetectionV2JobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case kmsKey = "KMSKey"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let dataAccessRoleArn = self.dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let inputDataConfig = self.inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let outputDataConfig = self.outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
    }
}

extension StartEntitiesDetectionV2JobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartEntitiesDetectionV2JobInput: Swift.Equatable {
    /// A unique identifier for the request. If you don't set the client request token, Amazon Comprehend Medical generates one for you.
    public var clientRequestToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that grants Amazon Comprehend Medical read access to your input data. For more information, see [Role-Based Permissions Required for Asynchronous Operations](https://docs.aws.amazon.com/comprehend/latest/dg/access-control-managing-permissions-med.html#auth-role-permissions-med).
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// The input configuration that specifies the format and location of the input data for the job.
    /// This member is required.
    public var inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig?
    /// The identifier of the job.
    public var jobName: Swift.String?
    /// An AWS Key Management Service key to encrypt your output files. If you do not specify a key, the files are written in plain text.
    public var kmsKey: Swift.String?
    /// The language of the input documents. All documents must be in the same language. Amazon Comprehend Medical processes files in US English (en).
    /// This member is required.
    public var languageCode: ComprehendMedicalClientTypes.LanguageCode?
    /// The output configuration that specifies where to send the output files.
    /// This member is required.
    public var outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig?

    public init(
        clientRequestToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig? = nil,
        jobName: Swift.String? = nil,
        kmsKey: Swift.String? = nil,
        languageCode: ComprehendMedicalClientTypes.LanguageCode? = nil,
        outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.kmsKey = kmsKey
        self.languageCode = languageCode
        self.outputDataConfig = outputDataConfig
    }
}

struct StartEntitiesDetectionV2JobInputBody: Swift.Equatable {
    let inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig?
    let outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig?
    let dataAccessRoleArn: Swift.String?
    let jobName: Swift.String?
    let clientRequestToken: Swift.String?
    let kmsKey: Swift.String?
    let languageCode: ComprehendMedicalClientTypes.LanguageCode?
}

extension StartEntitiesDetectionV2JobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case kmsKey = "KMSKey"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
    }
}

extension StartEntitiesDetectionV2JobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartEntitiesDetectionV2JobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartEntitiesDetectionV2JobOutput: Swift.Equatable {
    /// The identifier generated for the job. To get the status of a job, use this identifier with the DescribeEntitiesDetectionV2Job operation.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartEntitiesDetectionV2JobOutputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StartEntitiesDetectionV2JobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

enum StartEntitiesDetectionV2JobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartICD10CMInferenceJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case kmsKey = "KMSKey"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let dataAccessRoleArn = self.dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let inputDataConfig = self.inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let outputDataConfig = self.outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
    }
}

extension StartICD10CMInferenceJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartICD10CMInferenceJobInput: Swift.Equatable {
    /// A unique identifier for the request. If you don't set the client request token, Amazon Comprehend Medical generates one.
    public var clientRequestToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that grants Amazon Comprehend Medical read access to your input data. For more information, see [ Role-Based Permissions Required for Asynchronous Operations](https://docs.aws.amazon.com/comprehend/latest/dg/access-control-managing-permissions-med.html#auth-role-permissions-med).
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// Specifies the format and location of the input data for the job.
    /// This member is required.
    public var inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig?
    /// The identifier of the job.
    public var jobName: Swift.String?
    /// An AWS Key Management Service key to encrypt your output files. If you do not specify a key, the files are written in plain text.
    public var kmsKey: Swift.String?
    /// The language of the input documents. All documents must be in the same language.
    /// This member is required.
    public var languageCode: ComprehendMedicalClientTypes.LanguageCode?
    /// Specifies where to send the output files.
    /// This member is required.
    public var outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig?

    public init(
        clientRequestToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig? = nil,
        jobName: Swift.String? = nil,
        kmsKey: Swift.String? = nil,
        languageCode: ComprehendMedicalClientTypes.LanguageCode? = nil,
        outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.kmsKey = kmsKey
        self.languageCode = languageCode
        self.outputDataConfig = outputDataConfig
    }
}

struct StartICD10CMInferenceJobInputBody: Swift.Equatable {
    let inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig?
    let outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig?
    let dataAccessRoleArn: Swift.String?
    let jobName: Swift.String?
    let clientRequestToken: Swift.String?
    let kmsKey: Swift.String?
    let languageCode: ComprehendMedicalClientTypes.LanguageCode?
}

extension StartICD10CMInferenceJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case kmsKey = "KMSKey"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
    }
}

extension StartICD10CMInferenceJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartICD10CMInferenceJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartICD10CMInferenceJobOutput: Swift.Equatable {
    /// The identifier generated for the job. To get the status of a job, use this identifier with the StartICD10CMInferenceJob operation.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartICD10CMInferenceJobOutputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StartICD10CMInferenceJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

enum StartICD10CMInferenceJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartPHIDetectionJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case kmsKey = "KMSKey"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let dataAccessRoleArn = self.dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let inputDataConfig = self.inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let outputDataConfig = self.outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
    }
}

extension StartPHIDetectionJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartPHIDetectionJobInput: Swift.Equatable {
    /// A unique identifier for the request. If you don't set the client request token, Amazon Comprehend Medical generates one.
    public var clientRequestToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that grants Amazon Comprehend Medical read access to your input data. For more information, see [ Role-Based Permissions Required for Asynchronous Operations](https://docs.aws.amazon.com/comprehend/latest/dg/access-control-managing-permissions-med.html#auth-role-permissions-med).
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// Specifies the format and location of the input data for the job.
    /// This member is required.
    public var inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig?
    /// The identifier of the job.
    public var jobName: Swift.String?
    /// An AWS Key Management Service key to encrypt your output files. If you do not specify a key, the files are written in plain text.
    public var kmsKey: Swift.String?
    /// The language of the input documents. All documents must be in the same language.
    /// This member is required.
    public var languageCode: ComprehendMedicalClientTypes.LanguageCode?
    /// Specifies where to send the output files.
    /// This member is required.
    public var outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig?

    public init(
        clientRequestToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig? = nil,
        jobName: Swift.String? = nil,
        kmsKey: Swift.String? = nil,
        languageCode: ComprehendMedicalClientTypes.LanguageCode? = nil,
        outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.kmsKey = kmsKey
        self.languageCode = languageCode
        self.outputDataConfig = outputDataConfig
    }
}

struct StartPHIDetectionJobInputBody: Swift.Equatable {
    let inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig?
    let outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig?
    let dataAccessRoleArn: Swift.String?
    let jobName: Swift.String?
    let clientRequestToken: Swift.String?
    let kmsKey: Swift.String?
    let languageCode: ComprehendMedicalClientTypes.LanguageCode?
}

extension StartPHIDetectionJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case kmsKey = "KMSKey"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
    }
}

extension StartPHIDetectionJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartPHIDetectionJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartPHIDetectionJobOutput: Swift.Equatable {
    /// The identifier generated for the job. To get the status of a job, use this identifier with the DescribePHIDetectionJob operation.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartPHIDetectionJobOutputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StartPHIDetectionJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

enum StartPHIDetectionJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartRxNormInferenceJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case kmsKey = "KMSKey"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let dataAccessRoleArn = self.dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let inputDataConfig = self.inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let outputDataConfig = self.outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
    }
}

extension StartRxNormInferenceJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartRxNormInferenceJobInput: Swift.Equatable {
    /// A unique identifier for the request. If you don't set the client request token, Amazon Comprehend Medical generates one.
    public var clientRequestToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that grants Amazon Comprehend Medical read access to your input data. For more information, see [ Role-Based Permissions Required for Asynchronous Operations](https://docs.aws.amazon.com/comprehend/latest/dg/access-control-managing-permissions-med.html#auth-role-permissions-med).
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// Specifies the format and location of the input data for the job.
    /// This member is required.
    public var inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig?
    /// The identifier of the job.
    public var jobName: Swift.String?
    /// An AWS Key Management Service key to encrypt your output files. If you do not specify a key, the files are written in plain text.
    public var kmsKey: Swift.String?
    /// The language of the input documents. All documents must be in the same language.
    /// This member is required.
    public var languageCode: ComprehendMedicalClientTypes.LanguageCode?
    /// Specifies where to send the output files.
    /// This member is required.
    public var outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig?

    public init(
        clientRequestToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig? = nil,
        jobName: Swift.String? = nil,
        kmsKey: Swift.String? = nil,
        languageCode: ComprehendMedicalClientTypes.LanguageCode? = nil,
        outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.kmsKey = kmsKey
        self.languageCode = languageCode
        self.outputDataConfig = outputDataConfig
    }
}

struct StartRxNormInferenceJobInputBody: Swift.Equatable {
    let inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig?
    let outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig?
    let dataAccessRoleArn: Swift.String?
    let jobName: Swift.String?
    let clientRequestToken: Swift.String?
    let kmsKey: Swift.String?
    let languageCode: ComprehendMedicalClientTypes.LanguageCode?
}

extension StartRxNormInferenceJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case kmsKey = "KMSKey"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
    }
}

extension StartRxNormInferenceJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartRxNormInferenceJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartRxNormInferenceJobOutput: Swift.Equatable {
    /// The identifier of the job.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartRxNormInferenceJobOutputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StartRxNormInferenceJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

enum StartRxNormInferenceJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartSNOMEDCTInferenceJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case kmsKey = "KMSKey"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let dataAccessRoleArn = self.dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let inputDataConfig = self.inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
        if let languageCode = self.languageCode {
            try encodeContainer.encode(languageCode.rawValue, forKey: .languageCode)
        }
        if let outputDataConfig = self.outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
    }
}

extension StartSNOMEDCTInferenceJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartSNOMEDCTInferenceJobInput: Swift.Equatable {
    /// A unique identifier for the request. If you don't set the client request token, Amazon Comprehend Medical generates one.
    public var clientRequestToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that grants Amazon Comprehend Medical read access to your input data.
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// The input properties for an entities detection job. This includes the name of the S3 bucket and the path to the files to be analyzed.
    /// This member is required.
    public var inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig?
    /// The user generated name the asynchronous InferSNOMEDCT job.
    public var jobName: Swift.String?
    /// An AWS Key Management Service key used to encrypt your output files. If you do not specify a key, the files are written in plain text.
    public var kmsKey: Swift.String?
    /// The language of the input documents. All documents must be in the same language.
    /// This member is required.
    public var languageCode: ComprehendMedicalClientTypes.LanguageCode?
    /// The output properties for a detection job.
    /// This member is required.
    public var outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig?

    public init(
        clientRequestToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig? = nil,
        jobName: Swift.String? = nil,
        kmsKey: Swift.String? = nil,
        languageCode: ComprehendMedicalClientTypes.LanguageCode? = nil,
        outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.kmsKey = kmsKey
        self.languageCode = languageCode
        self.outputDataConfig = outputDataConfig
    }
}

struct StartSNOMEDCTInferenceJobInputBody: Swift.Equatable {
    let inputDataConfig: ComprehendMedicalClientTypes.InputDataConfig?
    let outputDataConfig: ComprehendMedicalClientTypes.OutputDataConfig?
    let dataAccessRoleArn: Swift.String?
    let jobName: Swift.String?
    let clientRequestToken: Swift.String?
    let kmsKey: Swift.String?
    let languageCode: ComprehendMedicalClientTypes.LanguageCode?
}

extension StartSNOMEDCTInferenceJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
        case kmsKey = "KMSKey"
        case languageCode = "LanguageCode"
        case outputDataConfig = "OutputDataConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.LanguageCode.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
    }
}

extension StartSNOMEDCTInferenceJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartSNOMEDCTInferenceJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartSNOMEDCTInferenceJobOutput: Swift.Equatable {
    /// The identifier generated for the job. To get the status of a job, use this identifier with the StartSNOMEDCTInferenceJob operation.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartSNOMEDCTInferenceJobOutputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StartSNOMEDCTInferenceJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

enum StartSNOMEDCTInferenceJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopEntitiesDetectionV2JobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension StopEntitiesDetectionV2JobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopEntitiesDetectionV2JobInput: Swift.Equatable {
    /// The identifier of the medical entities job to stop.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopEntitiesDetectionV2JobInputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StopEntitiesDetectionV2JobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StopEntitiesDetectionV2JobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StopEntitiesDetectionV2JobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StopEntitiesDetectionV2JobOutput: Swift.Equatable {
    /// The identifier of the medical entities detection job that was stopped.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopEntitiesDetectionV2JobOutputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StopEntitiesDetectionV2JobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

enum StopEntitiesDetectionV2JobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopICD10CMInferenceJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension StopICD10CMInferenceJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopICD10CMInferenceJobInput: Swift.Equatable {
    /// The identifier of the job.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopICD10CMInferenceJobInputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StopICD10CMInferenceJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StopICD10CMInferenceJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StopICD10CMInferenceJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StopICD10CMInferenceJobOutput: Swift.Equatable {
    /// The identifier generated for the job. To get the status of job, use this identifier with the DescribeICD10CMInferenceJob operation.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopICD10CMInferenceJobOutputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StopICD10CMInferenceJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

enum StopICD10CMInferenceJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopPHIDetectionJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension StopPHIDetectionJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopPHIDetectionJobInput: Swift.Equatable {
    /// The identifier of the PHI detection job to stop.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopPHIDetectionJobInputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StopPHIDetectionJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StopPHIDetectionJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StopPHIDetectionJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StopPHIDetectionJobOutput: Swift.Equatable {
    /// The identifier of the PHI detection job that was stopped.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopPHIDetectionJobOutputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StopPHIDetectionJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

enum StopPHIDetectionJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopRxNormInferenceJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension StopRxNormInferenceJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopRxNormInferenceJobInput: Swift.Equatable {
    /// The identifier of the job.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopRxNormInferenceJobInputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StopRxNormInferenceJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StopRxNormInferenceJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StopRxNormInferenceJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StopRxNormInferenceJobOutput: Swift.Equatable {
    /// The identifier generated for the job. To get the status of job, use this identifier with the DescribeRxNormInferenceJob operation.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopRxNormInferenceJobOutputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StopRxNormInferenceJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

enum StopRxNormInferenceJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopSNOMEDCTInferenceJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension StopSNOMEDCTInferenceJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopSNOMEDCTInferenceJobInput: Swift.Equatable {
    /// The job id of the asynchronous InferSNOMEDCT job to be stopped.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopSNOMEDCTInferenceJobInputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StopSNOMEDCTInferenceJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StopSNOMEDCTInferenceJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StopSNOMEDCTInferenceJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StopSNOMEDCTInferenceJobOutput: Swift.Equatable {
    /// The identifier generated for the job. To get the status of job, use this identifier with the DescribeSNOMEDCTInferenceJob operation.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StopSNOMEDCTInferenceJobOutputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StopSNOMEDCTInferenceJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

enum StopSNOMEDCTInferenceJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TextSizeLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TextSizeLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The size of the text you submitted exceeds the size limit. Reduce the size of the text or use a smaller document and then retry your request.
public struct TextSizeLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TextSizeLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TextSizeLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TextSizeLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyRequestsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have made too many requests within a short period of time. Wait for a short time and then try your request again. Contact customer support for more information about a service limit increase.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ComprehendMedicalClientTypes.Trait: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case score = "Score"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let score = self.score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.AttributeName.self, forKey: .name)
        name = nameDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .score)
        score = scoreDecoded
    }
}

extension ComprehendMedicalClientTypes {
    /// Provides contextual information about the extracted entity.
    public struct Trait: Swift.Equatable {
        /// Provides a name or contextual description about the trait.
        public var name: ComprehendMedicalClientTypes.AttributeName?
        /// The level of confidence that Amazon Comprehend Medical has in the accuracy of this trait.
        public var score: Swift.Float?

        public init(
            name: ComprehendMedicalClientTypes.AttributeName? = nil,
            score: Swift.Float? = nil
        )
        {
            self.name = name
            self.score = score
        }
    }

}

extension ComprehendMedicalClientTypes.UnmappedAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute = "Attribute"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = self.attribute {
            try encodeContainer.encode(attribute, forKey: .attribute)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.EntityType.self, forKey: .type)
        type = typeDecoded
        let attributeDecoded = try containerValues.decodeIfPresent(ComprehendMedicalClientTypes.Attribute.self, forKey: .attribute)
        attribute = attributeDecoded
    }
}

extension ComprehendMedicalClientTypes {
    /// An attribute that was extracted, but Amazon Comprehend Medical was unable to relate to an entity.
    public struct UnmappedAttribute: Swift.Equatable {
        /// The specific attribute that has been extracted but not mapped to an entity.
        public var attribute: ComprehendMedicalClientTypes.Attribute?
        /// The type of the unmapped attribute, could be one of the following values: "MEDICATION", "MEDICAL_CONDITION", "ANATOMY", "TEST_AND_TREATMENT_PROCEDURE" or "PROTECTED_HEALTH_INFORMATION".
        public var type: ComprehendMedicalClientTypes.EntityType?

        public init(
            attribute: ComprehendMedicalClientTypes.Attribute? = nil,
            type: ComprehendMedicalClientTypes.EntityType? = nil
        )
        {
            self.attribute = attribute
            self.type = type
        }
    }

}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The filter that you specified for the operation is invalid. Check the filter values that you entered and try your request again.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
