// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension BedrockAgentClientTypes.APISchema: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
        case s3
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .payload(payload):
                try container.encode(payload, forKey: .payload)
            case let .s3(s3):
                try container.encode(s3, forKey: .s3)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try values.decodeIfPresent(BedrockAgentClientTypes.S3Identifier.self, forKey: .s3)
        if let s3 = s3Decoded {
            self = .s3(s3)
            return
        }
        let payloadDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .payload)
        if let payload = payloadDecoded {
            self = .payload(payload)
            return
        }
        self = .sdkUnknown("")
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about the OpenAPI schema for the action group. For more information, see [Action group OpenAPI schemas](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-api-schema.html). You can either include the schema directly in the payload field or you can upload it to an S3 bucket and specify the S3 bucket location in the s3 field.
    public enum APISchema {
        /// Contains details about the S3 object containing the OpenAPI schema for the action group. For more information, see [Action group OpenAPI schemas](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-api-schema.html).
        case s3(BedrockAgentClientTypes.S3Identifier)
        /// The JSON or YAML-formatted payload defining the OpenAPI schema for the action group. For more information, see [Action group OpenAPI schemas](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-api-schema.html).
        case payload(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request is denied because of missing access permissions.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BedrockAgentClientTypes.ActionGroupExecutor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customcontrol = "customControl"
        case lambda
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .customcontrol(customcontrol):
                try container.encode(customcontrol.rawValue, forKey: .customcontrol)
            case let .lambda(lambda):
                try container.encode(lambda, forKey: .lambda)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .lambda)
        if let lambda = lambdaDecoded {
            self = .lambda(lambda)
            return
        }
        let customcontrolDecoded = try values.decodeIfPresent(BedrockAgentClientTypes.CustomControlMethod.self, forKey: .customcontrol)
        if let customcontrol = customcontrolDecoded {
            self = .customcontrol(customcontrol)
            return
        }
        self = .sdkUnknown("")
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about the Lambda function containing the business logic that is carried out upon invoking the action or the custom control method for handling the information elicited from the user.
    public enum ActionGroupExecutor {
        /// The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action.
        case lambda(Swift.String)
        /// To return the action group invocation results directly in the InvokeAgent response, specify RETURN_CONTROL.
        case customcontrol(BedrockAgentClientTypes.CustomControlMethod)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockAgentClientTypes {
    public enum ActionGroupSignature: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonUserinput
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionGroupSignature] {
            return [
                .amazonUserinput,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonUserinput: return "AMAZON.UserInput"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActionGroupSignature(rawValue: rawValue) ?? ActionGroupSignature.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentClientTypes {
    public enum ActionGroupState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionGroupState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActionGroupState(rawValue: rawValue) ?? ActionGroupState.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentClientTypes.ActionGroupSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionGroupId
        case actionGroupName
        case actionGroupState
        case description
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionGroupId = self.actionGroupId {
            try encodeContainer.encode(actionGroupId, forKey: .actionGroupId)
        }
        if let actionGroupName = self.actionGroupName {
            try encodeContainer.encode(actionGroupName, forKey: .actionGroupName)
        }
        if let actionGroupState = self.actionGroupState {
            try encodeContainer.encode(actionGroupState.rawValue, forKey: .actionGroupState)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionGroupId)
        actionGroupId = actionGroupIdDecoded
        let actionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionGroupName)
        actionGroupName = actionGroupNameDecoded
        let actionGroupStateDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.ActionGroupState.self, forKey: .actionGroupState)
        actionGroupState = actionGroupStateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about an action group.
    public struct ActionGroupSummary {
        /// The unique identifier of the action group.
        /// This member is required.
        public var actionGroupId: Swift.String?
        /// The name of the action group.
        /// This member is required.
        public var actionGroupName: Swift.String?
        /// Specifies whether the action group is available for the agent to invoke or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
        /// This member is required.
        public var actionGroupState: BedrockAgentClientTypes.ActionGroupState?
        /// The description of the action group.
        public var description: Swift.String?
        /// The time at which the action group was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            actionGroupId: Swift.String? = nil,
            actionGroupName: Swift.String? = nil,
            actionGroupState: BedrockAgentClientTypes.ActionGroupState? = nil,
            description: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.actionGroupId = actionGroupId
            self.actionGroupName = actionGroupName
            self.actionGroupState = actionGroupState
            self.description = description
            self.updatedAt = updatedAt
        }
    }

}

extension BedrockAgentClientTypes.Agent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentArn
        case agentId
        case agentName
        case agentResourceRoleArn
        case agentStatus
        case agentVersion
        case clientToken
        case createdAt
        case customerEncryptionKeyArn
        case description
        case failureReasons
        case foundationModel
        case idleSessionTTLInSeconds
        case instruction
        case preparedAt
        case promptOverrideConfiguration
        case recommendedActions
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentArn = self.agentArn {
            try encodeContainer.encode(agentArn, forKey: .agentArn)
        }
        if let agentId = self.agentId {
            try encodeContainer.encode(agentId, forKey: .agentId)
        }
        if let agentName = self.agentName {
            try encodeContainer.encode(agentName, forKey: .agentName)
        }
        if let agentResourceRoleArn = self.agentResourceRoleArn {
            try encodeContainer.encode(agentResourceRoleArn, forKey: .agentResourceRoleArn)
        }
        if let agentStatus = self.agentStatus {
            try encodeContainer.encode(agentStatus.rawValue, forKey: .agentStatus)
        }
        if let agentVersion = self.agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let customerEncryptionKeyArn = self.customerEncryptionKeyArn {
            try encodeContainer.encode(customerEncryptionKeyArn, forKey: .customerEncryptionKeyArn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let failureReasons = failureReasons {
            var failureReasonsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .failureReasons)
            for failurereason0 in failureReasons {
                try failureReasonsContainer.encode(failurereason0)
            }
        }
        if let foundationModel = self.foundationModel {
            try encodeContainer.encode(foundationModel, forKey: .foundationModel)
        }
        if let idleSessionTTLInSeconds = self.idleSessionTTLInSeconds {
            try encodeContainer.encode(idleSessionTTLInSeconds, forKey: .idleSessionTTLInSeconds)
        }
        if let instruction = self.instruction {
            try encodeContainer.encode(instruction, forKey: .instruction)
        }
        if let preparedAt = self.preparedAt {
            try encodeContainer.encodeTimestamp(preparedAt, format: .dateTime, forKey: .preparedAt)
        }
        if let promptOverrideConfiguration = self.promptOverrideConfiguration {
            try encodeContainer.encode(promptOverrideConfiguration, forKey: .promptOverrideConfiguration)
        }
        if let recommendedActions = recommendedActions {
            var recommendedActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recommendedActions)
            for recommendedaction0 in recommendedActions {
                try recommendedActionsContainer.encode(recommendedaction0)
            }
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let agentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentName)
        agentName = agentNameDecoded
        let agentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentArn)
        agentArn = agentArnDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let instructionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instruction)
        instruction = instructionDecoded
        let agentStatusDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentStatus.self, forKey: .agentStatus)
        agentStatus = agentStatusDecoded
        let foundationModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .foundationModel)
        foundationModel = foundationModelDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let idleSessionTTLInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleSessionTTLInSeconds)
        idleSessionTTLInSeconds = idleSessionTTLInSecondsDecoded
        let agentResourceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentResourceRoleArn)
        agentResourceRoleArn = agentResourceRoleArnDecoded
        let customerEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerEncryptionKeyArn)
        customerEncryptionKeyArn = customerEncryptionKeyArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let preparedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .preparedAt)
        preparedAt = preparedAtDecoded
        let failureReasonsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .failureReasons)
        var failureReasonsDecoded0:[Swift.String]? = nil
        if let failureReasonsContainer = failureReasonsContainer {
            failureReasonsDecoded0 = [Swift.String]()
            for string0 in failureReasonsContainer {
                if let string0 = string0 {
                    failureReasonsDecoded0?.append(string0)
                }
            }
        }
        failureReasons = failureReasonsDecoded0
        let recommendedActionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .recommendedActions)
        var recommendedActionsDecoded0:[Swift.String]? = nil
        if let recommendedActionsContainer = recommendedActionsContainer {
            recommendedActionsDecoded0 = [Swift.String]()
            for string0 in recommendedActionsContainer {
                if let string0 = string0 {
                    recommendedActionsDecoded0?.append(string0)
                }
            }
        }
        recommendedActions = recommendedActionsDecoded0
        let promptOverrideConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.PromptOverrideConfiguration.self, forKey: .promptOverrideConfiguration)
        promptOverrideConfiguration = promptOverrideConfigurationDecoded
    }
}

extension BedrockAgentClientTypes.Agent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Agent(agentArn: \(Swift.String(describing: agentArn)), agentId: \(Swift.String(describing: agentId)), agentName: \(Swift.String(describing: agentName)), agentResourceRoleArn: \(Swift.String(describing: agentResourceRoleArn)), agentStatus: \(Swift.String(describing: agentStatus)), agentVersion: \(Swift.String(describing: agentVersion)), clientToken: \(Swift.String(describing: clientToken)), createdAt: \(Swift.String(describing: createdAt)), customerEncryptionKeyArn: \(Swift.String(describing: customerEncryptionKeyArn)), description: \(Swift.String(describing: description)), failureReasons: \(Swift.String(describing: failureReasons)), foundationModel: \(Swift.String(describing: foundationModel)), idleSessionTTLInSeconds: \(Swift.String(describing: idleSessionTTLInSeconds)), preparedAt: \(Swift.String(describing: preparedAt)), recommendedActions: \(Swift.String(describing: recommendedActions)), updatedAt: \(Swift.String(describing: updatedAt)), instruction: \"CONTENT_REDACTED\", promptOverrideConfiguration: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentClientTypes {
    /// Contains details about an agent.
    public struct Agent {
        /// The Amazon Resource Name (ARN) of the agent.
        /// This member is required.
        public var agentArn: Swift.String?
        /// The unique identifier of the agent.
        /// This member is required.
        public var agentId: Swift.String?
        /// The name of the agent.
        /// This member is required.
        public var agentName: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the agent.
        /// This member is required.
        public var agentResourceRoleArn: Swift.String?
        /// The status of the agent and whether it is ready for use. The following statuses are possible:
        ///
        /// * CREATING – The agent is being created.
        ///
        /// * PREPARING – The agent is being prepared.
        ///
        /// * PREPARED – The agent is prepared and ready to be invoked.
        ///
        /// * NOT_PREPARED – The agent has been created but not yet prepared.
        ///
        /// * FAILED – The agent API operation failed.
        ///
        /// * UPDATING – The agent is being updated.
        ///
        /// * DELETING – The agent is being deleted.
        /// This member is required.
        public var agentStatus: BedrockAgentClientTypes.AgentStatus?
        /// The version of the agent.
        /// This member is required.
        public var agentVersion: Swift.String?
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
        public var clientToken: Swift.String?
        /// The time at which the agent was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the KMS key that encrypts the agent.
        public var customerEncryptionKeyArn: Swift.String?
        /// The description of the agent.
        public var description: Swift.String?
        /// Contains reasons that the agent-related API that you invoked failed.
        public var failureReasons: [Swift.String]?
        /// The foundation model used for orchestration by the agent.
        public var foundationModel: Swift.String?
        /// The number of seconds for which Amazon Bedrock keeps information about a user's conversation with the agent. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Bedrock deletes any data provided before the timeout.
        /// This member is required.
        public var idleSessionTTLInSeconds: Swift.Int?
        /// Instructions that tell the agent what it should do and how it should interact with users.
        public var instruction: Swift.String?
        /// The time at which the agent was last prepared.
        public var preparedAt: ClientRuntime.Date?
        /// Contains configurations to override prompt templates in different parts of an agent sequence. For more information, see [Advanced prompts](https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts.html).
        public var promptOverrideConfiguration: BedrockAgentClientTypes.PromptOverrideConfiguration?
        /// Contains recommended actions to take for the agent-related API that you invoked to succeed.
        public var recommendedActions: [Swift.String]?
        /// The time at which the agent was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            agentArn: Swift.String? = nil,
            agentId: Swift.String? = nil,
            agentName: Swift.String? = nil,
            agentResourceRoleArn: Swift.String? = nil,
            agentStatus: BedrockAgentClientTypes.AgentStatus? = nil,
            agentVersion: Swift.String? = nil,
            clientToken: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            customerEncryptionKeyArn: Swift.String? = nil,
            description: Swift.String? = nil,
            failureReasons: [Swift.String]? = nil,
            foundationModel: Swift.String? = nil,
            idleSessionTTLInSeconds: Swift.Int? = nil,
            instruction: Swift.String? = nil,
            preparedAt: ClientRuntime.Date? = nil,
            promptOverrideConfiguration: BedrockAgentClientTypes.PromptOverrideConfiguration? = nil,
            recommendedActions: [Swift.String]? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.agentArn = agentArn
            self.agentId = agentId
            self.agentName = agentName
            self.agentResourceRoleArn = agentResourceRoleArn
            self.agentStatus = agentStatus
            self.agentVersion = agentVersion
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.description = description
            self.failureReasons = failureReasons
            self.foundationModel = foundationModel
            self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
            self.instruction = instruction
            self.preparedAt = preparedAt
            self.promptOverrideConfiguration = promptOverrideConfiguration
            self.recommendedActions = recommendedActions
            self.updatedAt = updatedAt
        }
    }

}

extension BedrockAgentClientTypes.AgentActionGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionGroupExecutor
        case actionGroupId
        case actionGroupName
        case actionGroupState
        case agentId
        case agentVersion
        case apiSchema
        case clientToken
        case createdAt
        case description
        case functionSchema
        case parentActionSignature
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionGroupExecutor = self.actionGroupExecutor {
            try encodeContainer.encode(actionGroupExecutor, forKey: .actionGroupExecutor)
        }
        if let actionGroupId = self.actionGroupId {
            try encodeContainer.encode(actionGroupId, forKey: .actionGroupId)
        }
        if let actionGroupName = self.actionGroupName {
            try encodeContainer.encode(actionGroupName, forKey: .actionGroupName)
        }
        if let actionGroupState = self.actionGroupState {
            try encodeContainer.encode(actionGroupState.rawValue, forKey: .actionGroupState)
        }
        if let agentId = self.agentId {
            try encodeContainer.encode(agentId, forKey: .agentId)
        }
        if let agentVersion = self.agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let apiSchema = self.apiSchema {
            try encodeContainer.encode(apiSchema, forKey: .apiSchema)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let functionSchema = self.functionSchema {
            try encodeContainer.encode(functionSchema, forKey: .functionSchema)
        }
        if let parentActionSignature = self.parentActionSignature {
            try encodeContainer.encode(parentActionSignature.rawValue, forKey: .parentActionSignature)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
        let actionGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionGroupId)
        actionGroupId = actionGroupIdDecoded
        let actionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionGroupName)
        actionGroupName = actionGroupNameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let parentActionSignatureDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.ActionGroupSignature.self, forKey: .parentActionSignature)
        parentActionSignature = parentActionSignatureDecoded
        let actionGroupExecutorDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.ActionGroupExecutor.self, forKey: .actionGroupExecutor)
        actionGroupExecutor = actionGroupExecutorDecoded
        let apiSchemaDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.APISchema.self, forKey: .apiSchema)
        apiSchema = apiSchemaDecoded
        let functionSchemaDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.FunctionSchema.self, forKey: .functionSchema)
        functionSchema = functionSchemaDecoded
        let actionGroupStateDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.ActionGroupState.self, forKey: .actionGroupState)
        actionGroupState = actionGroupStateDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about an action group.
    public struct AgentActionGroup {
        /// The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action or the custom control method for handling the information elicited from the user.
        public var actionGroupExecutor: BedrockAgentClientTypes.ActionGroupExecutor?
        /// The unique identifier of the action group.
        /// This member is required.
        public var actionGroupId: Swift.String?
        /// The name of the action group.
        /// This member is required.
        public var actionGroupName: Swift.String?
        /// Specifies whether the action group is available for the agent to invoke or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
        /// This member is required.
        public var actionGroupState: BedrockAgentClientTypes.ActionGroupState?
        /// The unique identifier of the agent to which the action group belongs.
        /// This member is required.
        public var agentId: Swift.String?
        /// The version of the agent to which the action group belongs.
        /// This member is required.
        public var agentVersion: Swift.String?
        /// Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted payload defining the schema. For more information, see [Action group OpenAPI schemas](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-api-schema.html).
        public var apiSchema: BedrockAgentClientTypes.APISchema?
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
        public var clientToken: Swift.String?
        /// The time at which the action group was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The description of the action group.
        public var description: Swift.String?
        /// Defines functions that each define parameters that the agent needs to invoke from the user. Each function represents an action in an action group.
        public var functionSchema: BedrockAgentClientTypes.FunctionSchema?
        /// If this field is set as AMAZON.UserInput, the agent can request the user for additional information when trying to complete a task. The description, apiSchema, and actionGroupExecutor fields must be blank for this action group. During orchestration, if the agent determines that it needs to invoke an API in an action group, but doesn't have enough information to complete the API request, it will invoke this action group instead and return an [Observation](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Observation.html) reprompting the user for more information.
        public var parentActionSignature: BedrockAgentClientTypes.ActionGroupSignature?
        /// The time at which the action group was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            actionGroupExecutor: BedrockAgentClientTypes.ActionGroupExecutor? = nil,
            actionGroupId: Swift.String? = nil,
            actionGroupName: Swift.String? = nil,
            actionGroupState: BedrockAgentClientTypes.ActionGroupState? = nil,
            agentId: Swift.String? = nil,
            agentVersion: Swift.String? = nil,
            apiSchema: BedrockAgentClientTypes.APISchema? = nil,
            clientToken: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            functionSchema: BedrockAgentClientTypes.FunctionSchema? = nil,
            parentActionSignature: BedrockAgentClientTypes.ActionGroupSignature? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.actionGroupExecutor = actionGroupExecutor
            self.actionGroupId = actionGroupId
            self.actionGroupName = actionGroupName
            self.actionGroupState = actionGroupState
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.apiSchema = apiSchema
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.description = description
            self.functionSchema = functionSchema
            self.parentActionSignature = parentActionSignature
            self.updatedAt = updatedAt
        }
    }

}

extension BedrockAgentClientTypes.AgentAlias: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentAliasArn
        case agentAliasHistoryEvents
        case agentAliasId
        case agentAliasName
        case agentAliasStatus
        case agentId
        case clientToken
        case createdAt
        case description
        case failureReasons
        case routingConfiguration
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentAliasArn = self.agentAliasArn {
            try encodeContainer.encode(agentAliasArn, forKey: .agentAliasArn)
        }
        if let agentAliasHistoryEvents = agentAliasHistoryEvents {
            var agentAliasHistoryEventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .agentAliasHistoryEvents)
            for agentaliashistoryevent0 in agentAliasHistoryEvents {
                try agentAliasHistoryEventsContainer.encode(agentaliashistoryevent0)
            }
        }
        if let agentAliasId = self.agentAliasId {
            try encodeContainer.encode(agentAliasId, forKey: .agentAliasId)
        }
        if let agentAliasName = self.agentAliasName {
            try encodeContainer.encode(agentAliasName, forKey: .agentAliasName)
        }
        if let agentAliasStatus = self.agentAliasStatus {
            try encodeContainer.encode(agentAliasStatus.rawValue, forKey: .agentAliasStatus)
        }
        if let agentId = self.agentId {
            try encodeContainer.encode(agentId, forKey: .agentId)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let failureReasons = failureReasons {
            var failureReasonsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .failureReasons)
            for failurereason0 in failureReasons {
                try failureReasonsContainer.encode(failurereason0)
            }
        }
        if let routingConfiguration = routingConfiguration {
            var routingConfigurationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .routingConfiguration)
            for agentaliasroutingconfigurationlistitem0 in routingConfiguration {
                try routingConfigurationContainer.encode(agentaliasroutingconfigurationlistitem0)
            }
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let agentAliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentAliasId)
        agentAliasId = agentAliasIdDecoded
        let agentAliasNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentAliasName)
        agentAliasName = agentAliasNameDecoded
        let agentAliasArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentAliasArn)
        agentAliasArn = agentAliasArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let routingConfigurationContainer = try containerValues.decodeIfPresent([BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem?].self, forKey: .routingConfiguration)
        var routingConfigurationDecoded0:[BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]? = nil
        if let routingConfigurationContainer = routingConfigurationContainer {
            routingConfigurationDecoded0 = [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]()
            for structure0 in routingConfigurationContainer {
                if let structure0 = structure0 {
                    routingConfigurationDecoded0?.append(structure0)
                }
            }
        }
        routingConfiguration = routingConfigurationDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let agentAliasHistoryEventsContainer = try containerValues.decodeIfPresent([BedrockAgentClientTypes.AgentAliasHistoryEvent?].self, forKey: .agentAliasHistoryEvents)
        var agentAliasHistoryEventsDecoded0:[BedrockAgentClientTypes.AgentAliasHistoryEvent]? = nil
        if let agentAliasHistoryEventsContainer = agentAliasHistoryEventsContainer {
            agentAliasHistoryEventsDecoded0 = [BedrockAgentClientTypes.AgentAliasHistoryEvent]()
            for structure0 in agentAliasHistoryEventsContainer {
                if let structure0 = structure0 {
                    agentAliasHistoryEventsDecoded0?.append(structure0)
                }
            }
        }
        agentAliasHistoryEvents = agentAliasHistoryEventsDecoded0
        let agentAliasStatusDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentAliasStatus.self, forKey: .agentAliasStatus)
        agentAliasStatus = agentAliasStatusDecoded
        let failureReasonsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .failureReasons)
        var failureReasonsDecoded0:[Swift.String]? = nil
        if let failureReasonsContainer = failureReasonsContainer {
            failureReasonsDecoded0 = [Swift.String]()
            for string0 in failureReasonsContainer {
                if let string0 = string0 {
                    failureReasonsDecoded0?.append(string0)
                }
            }
        }
        failureReasons = failureReasonsDecoded0
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about an alias of an agent.
    public struct AgentAlias {
        /// The Amazon Resource Name (ARN) of the alias of the agent.
        /// This member is required.
        public var agentAliasArn: Swift.String?
        /// Contains details about the history of the alias.
        public var agentAliasHistoryEvents: [BedrockAgentClientTypes.AgentAliasHistoryEvent]?
        /// The unique identifier of the alias of the agent.
        /// This member is required.
        public var agentAliasId: Swift.String?
        /// The name of the alias of the agent.
        /// This member is required.
        public var agentAliasName: Swift.String?
        /// The status of the alias of the agent and whether it is ready for use. The following statuses are possible:
        ///
        /// * CREATING – The agent alias is being created.
        ///
        /// * PREPARED – The agent alias is finished being created or updated and is ready to be invoked.
        ///
        /// * FAILED – The agent alias API operation failed.
        ///
        /// * UPDATING – The agent alias is being updated.
        ///
        /// * DELETING – The agent alias is being deleted.
        /// This member is required.
        public var agentAliasStatus: BedrockAgentClientTypes.AgentAliasStatus?
        /// The unique identifier of the agent.
        /// This member is required.
        public var agentId: Swift.String?
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
        public var clientToken: Swift.String?
        /// The time at which the alias of the agent was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The description of the alias of the agent.
        public var description: Swift.String?
        /// Information on the failure of Provisioned Throughput assigned to an agent alias.
        public var failureReasons: [Swift.String]?
        /// Contains details about the routing configuration of the alias.
        /// This member is required.
        public var routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]?
        /// The time at which the alias was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            agentAliasArn: Swift.String? = nil,
            agentAliasHistoryEvents: [BedrockAgentClientTypes.AgentAliasHistoryEvent]? = nil,
            agentAliasId: Swift.String? = nil,
            agentAliasName: Swift.String? = nil,
            agentAliasStatus: BedrockAgentClientTypes.AgentAliasStatus? = nil,
            agentId: Swift.String? = nil,
            clientToken: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            failureReasons: [Swift.String]? = nil,
            routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.agentAliasArn = agentAliasArn
            self.agentAliasHistoryEvents = agentAliasHistoryEvents
            self.agentAliasId = agentAliasId
            self.agentAliasName = agentAliasName
            self.agentAliasStatus = agentAliasStatus
            self.agentId = agentId
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.description = description
            self.failureReasons = failureReasons
            self.routingConfiguration = routingConfiguration
            self.updatedAt = updatedAt
        }
    }

}

extension BedrockAgentClientTypes.AgentAliasHistoryEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endDate
        case routingConfiguration
        case startDate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endDate = self.endDate {
            try encodeContainer.encodeTimestamp(endDate, format: .dateTime, forKey: .endDate)
        }
        if let routingConfiguration = routingConfiguration {
            var routingConfigurationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .routingConfiguration)
            for agentaliasroutingconfigurationlistitem0 in routingConfiguration {
                try routingConfigurationContainer.encode(agentaliasroutingconfigurationlistitem0)
            }
        }
        if let startDate = self.startDate {
            try encodeContainer.encodeTimestamp(startDate, format: .dateTime, forKey: .startDate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routingConfigurationContainer = try containerValues.decodeIfPresent([BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem?].self, forKey: .routingConfiguration)
        var routingConfigurationDecoded0:[BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]? = nil
        if let routingConfigurationContainer = routingConfigurationContainer {
            routingConfigurationDecoded0 = [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]()
            for structure0 in routingConfigurationContainer {
                if let structure0 = structure0 {
                    routingConfigurationDecoded0?.append(structure0)
                }
            }
        }
        routingConfiguration = routingConfigurationDecoded0
        let endDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endDate)
        endDate = endDateDecoded
        let startDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startDate)
        startDate = startDateDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about the history of the alias.
    public struct AgentAliasHistoryEvent {
        /// The date that the alias stopped being associated to the version in the routingConfiguration object
        public var endDate: ClientRuntime.Date?
        /// Contains details about the version of the agent with which the alias is associated.
        public var routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]?
        /// The date that the alias began being associated to the version in the routingConfiguration object.
        public var startDate: ClientRuntime.Date?

        public init(
            endDate: ClientRuntime.Date? = nil,
            routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]? = nil,
            startDate: ClientRuntime.Date? = nil
        )
        {
            self.endDate = endDate
            self.routingConfiguration = routingConfiguration
            self.startDate = startDate
        }
    }

}

extension BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentVersion
        case provisionedThroughput
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentVersion = self.agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let provisionedThroughput = self.provisionedThroughput {
            try encodeContainer.encode(provisionedThroughput, forKey: .provisionedThroughput)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
        let provisionedThroughputDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedThroughput)
        provisionedThroughput = provisionedThroughputDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about the routing configuration of the alias.
    public struct AgentAliasRoutingConfigurationListItem {
        /// The version of the agent with which the alias is associated.
        public var agentVersion: Swift.String?
        /// Information on the Provisioned Throughput assigned to an agent alias.
        public var provisionedThroughput: Swift.String?

        public init(
            agentVersion: Swift.String? = nil,
            provisionedThroughput: Swift.String? = nil
        )
        {
            self.agentVersion = agentVersion
            self.provisionedThroughput = provisionedThroughput
        }
    }

}

extension BedrockAgentClientTypes {
    public enum AgentAliasStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creating
        case deleting
        case failed
        case prepared
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [AgentAliasStatus] {
            return [
                .creating,
                .deleting,
                .failed,
                .prepared,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .prepared: return "PREPARED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AgentAliasStatus(rawValue: rawValue) ?? AgentAliasStatus.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentClientTypes.AgentAliasSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentAliasId
        case agentAliasName
        case agentAliasStatus
        case createdAt
        case description
        case routingConfiguration
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentAliasId = self.agentAliasId {
            try encodeContainer.encode(agentAliasId, forKey: .agentAliasId)
        }
        if let agentAliasName = self.agentAliasName {
            try encodeContainer.encode(agentAliasName, forKey: .agentAliasName)
        }
        if let agentAliasStatus = self.agentAliasStatus {
            try encodeContainer.encode(agentAliasStatus.rawValue, forKey: .agentAliasStatus)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let routingConfiguration = routingConfiguration {
            var routingConfigurationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .routingConfiguration)
            for agentaliasroutingconfigurationlistitem0 in routingConfiguration {
                try routingConfigurationContainer.encode(agentaliasroutingconfigurationlistitem0)
            }
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentAliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentAliasId)
        agentAliasId = agentAliasIdDecoded
        let agentAliasNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentAliasName)
        agentAliasName = agentAliasNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let routingConfigurationContainer = try containerValues.decodeIfPresent([BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem?].self, forKey: .routingConfiguration)
        var routingConfigurationDecoded0:[BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]? = nil
        if let routingConfigurationContainer = routingConfigurationContainer {
            routingConfigurationDecoded0 = [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]()
            for structure0 in routingConfigurationContainer {
                if let structure0 = structure0 {
                    routingConfigurationDecoded0?.append(structure0)
                }
            }
        }
        routingConfiguration = routingConfigurationDecoded0
        let agentAliasStatusDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentAliasStatus.self, forKey: .agentAliasStatus)
        agentAliasStatus = agentAliasStatusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about an alias of an agent.
    public struct AgentAliasSummary {
        /// Contains details about
        /// This member is required.
        public var agentAliasId: Swift.String?
        /// The name of the alias.
        /// This member is required.
        public var agentAliasName: Swift.String?
        /// The status of the alias.
        /// This member is required.
        public var agentAliasStatus: BedrockAgentClientTypes.AgentAliasStatus?
        /// The time at which the alias of the agent was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The description of the alias.
        public var description: Swift.String?
        /// Contains details about the version of the agent with which the alias is associated.
        public var routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]?
        /// The time at which the alias was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            agentAliasId: Swift.String? = nil,
            agentAliasName: Swift.String? = nil,
            agentAliasStatus: BedrockAgentClientTypes.AgentAliasStatus? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.agentAliasId = agentAliasId
            self.agentAliasName = agentAliasName
            self.agentAliasStatus = agentAliasStatus
            self.createdAt = createdAt
            self.description = description
            self.routingConfiguration = routingConfiguration
            self.updatedAt = updatedAt
        }
    }

}

extension BedrockAgentClientTypes.AgentKnowledgeBase: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentId
        case agentVersion
        case createdAt
        case description
        case knowledgeBaseId
        case knowledgeBaseState
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentId = self.agentId {
            try encodeContainer.encode(agentId, forKey: .agentId)
        }
        if let agentVersion = self.agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let knowledgeBaseState = self.knowledgeBaseState {
            try encodeContainer.encode(knowledgeBaseState.rawValue, forKey: .knowledgeBaseState)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let knowledgeBaseStateDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.KnowledgeBaseState.self, forKey: .knowledgeBaseState)
        knowledgeBaseState = knowledgeBaseStateDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about a knowledge base that is associated with an agent.
    public struct AgentKnowledgeBase {
        /// The unique identifier of the agent with which the knowledge base is associated.
        /// This member is required.
        public var agentId: Swift.String?
        /// The version of the agent with which the knowledge base is associated.
        /// This member is required.
        public var agentVersion: Swift.String?
        /// The time at which the association between the agent and the knowledge base was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The description of the association between the agent and the knowledge base.
        /// This member is required.
        public var description: Swift.String?
        /// The unique identifier of the association between the agent and the knowledge base.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// Specifies whether to use the knowledge base or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
        /// This member is required.
        public var knowledgeBaseState: BedrockAgentClientTypes.KnowledgeBaseState?
        /// The time at which the association between the agent and the knowledge base was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            agentId: Swift.String? = nil,
            agentVersion: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            knowledgeBaseState: BedrockAgentClientTypes.KnowledgeBaseState? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.createdAt = createdAt
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseState = knowledgeBaseState
            self.updatedAt = updatedAt
        }
    }

}

extension BedrockAgentClientTypes.AgentKnowledgeBaseSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case knowledgeBaseId
        case knowledgeBaseState
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let knowledgeBaseState = self.knowledgeBaseState {
            try encodeContainer.encode(knowledgeBaseState.rawValue, forKey: .knowledgeBaseState)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let knowledgeBaseStateDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.KnowledgeBaseState.self, forKey: .knowledgeBaseState)
        knowledgeBaseState = knowledgeBaseStateDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about a knowledge base associated with an agent.
    public struct AgentKnowledgeBaseSummary {
        /// The description of the knowledge base associated with an agent.
        public var description: Swift.String?
        /// The unique identifier of the knowledge base associated with an agent.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// Specifies whether the agent uses the knowledge base or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
        /// This member is required.
        public var knowledgeBaseState: BedrockAgentClientTypes.KnowledgeBaseState?
        /// The time at which the knowledge base associated with an agent was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            description: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            knowledgeBaseState: BedrockAgentClientTypes.KnowledgeBaseState? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseState = knowledgeBaseState
            self.updatedAt = updatedAt
        }
    }

}

extension BedrockAgentClientTypes {
    public enum AgentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creating
        case deleting
        case failed
        case notPrepared
        case prepared
        case preparing
        case updating
        case versioning
        case sdkUnknown(Swift.String)

        public static var allCases: [AgentStatus] {
            return [
                .creating,
                .deleting,
                .failed,
                .notPrepared,
                .prepared,
                .preparing,
                .updating,
                .versioning,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .notPrepared: return "NOT_PREPARED"
            case .prepared: return "PREPARED"
            case .preparing: return "PREPARING"
            case .updating: return "UPDATING"
            case .versioning: return "VERSIONING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AgentStatus(rawValue: rawValue) ?? AgentStatus.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentClientTypes.AgentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentId
        case agentName
        case agentStatus
        case description
        case latestAgentVersion
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentId = self.agentId {
            try encodeContainer.encode(agentId, forKey: .agentId)
        }
        if let agentName = self.agentName {
            try encodeContainer.encode(agentName, forKey: .agentName)
        }
        if let agentStatus = self.agentStatus {
            try encodeContainer.encode(agentStatus.rawValue, forKey: .agentStatus)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let latestAgentVersion = self.latestAgentVersion {
            try encodeContainer.encode(latestAgentVersion, forKey: .latestAgentVersion)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let agentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentName)
        agentName = agentNameDecoded
        let agentStatusDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentStatus.self, forKey: .agentStatus)
        agentStatus = agentStatusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let latestAgentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestAgentVersion)
        latestAgentVersion = latestAgentVersionDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about an agent.
    public struct AgentSummary {
        /// The unique identifier of the agent.
        /// This member is required.
        public var agentId: Swift.String?
        /// The name of the agent.
        /// This member is required.
        public var agentName: Swift.String?
        /// The status of the agent.
        /// This member is required.
        public var agentStatus: BedrockAgentClientTypes.AgentStatus?
        /// The description of the agent.
        public var description: Swift.String?
        /// The latest version of the agent.
        public var latestAgentVersion: Swift.String?
        /// The time at which the agent was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            agentId: Swift.String? = nil,
            agentName: Swift.String? = nil,
            agentStatus: BedrockAgentClientTypes.AgentStatus? = nil,
            description: Swift.String? = nil,
            latestAgentVersion: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.agentId = agentId
            self.agentName = agentName
            self.agentStatus = agentStatus
            self.description = description
            self.latestAgentVersion = latestAgentVersion
            self.updatedAt = updatedAt
        }
    }

}

extension BedrockAgentClientTypes.AgentVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentArn
        case agentId
        case agentName
        case agentResourceRoleArn
        case agentStatus
        case createdAt
        case customerEncryptionKeyArn
        case description
        case failureReasons
        case foundationModel
        case idleSessionTTLInSeconds
        case instruction
        case promptOverrideConfiguration
        case recommendedActions
        case updatedAt
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentArn = self.agentArn {
            try encodeContainer.encode(agentArn, forKey: .agentArn)
        }
        if let agentId = self.agentId {
            try encodeContainer.encode(agentId, forKey: .agentId)
        }
        if let agentName = self.agentName {
            try encodeContainer.encode(agentName, forKey: .agentName)
        }
        if let agentResourceRoleArn = self.agentResourceRoleArn {
            try encodeContainer.encode(agentResourceRoleArn, forKey: .agentResourceRoleArn)
        }
        if let agentStatus = self.agentStatus {
            try encodeContainer.encode(agentStatus.rawValue, forKey: .agentStatus)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let customerEncryptionKeyArn = self.customerEncryptionKeyArn {
            try encodeContainer.encode(customerEncryptionKeyArn, forKey: .customerEncryptionKeyArn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let failureReasons = failureReasons {
            var failureReasonsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .failureReasons)
            for failurereason0 in failureReasons {
                try failureReasonsContainer.encode(failurereason0)
            }
        }
        if let foundationModel = self.foundationModel {
            try encodeContainer.encode(foundationModel, forKey: .foundationModel)
        }
        if let idleSessionTTLInSeconds = self.idleSessionTTLInSeconds {
            try encodeContainer.encode(idleSessionTTLInSeconds, forKey: .idleSessionTTLInSeconds)
        }
        if let instruction = self.instruction {
            try encodeContainer.encode(instruction, forKey: .instruction)
        }
        if let promptOverrideConfiguration = self.promptOverrideConfiguration {
            try encodeContainer.encode(promptOverrideConfiguration, forKey: .promptOverrideConfiguration)
        }
        if let recommendedActions = recommendedActions {
            var recommendedActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recommendedActions)
            for recommendedaction0 in recommendedActions {
                try recommendedActionsContainer.encode(recommendedaction0)
            }
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let agentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentName)
        agentName = agentNameDecoded
        let agentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentArn)
        agentArn = agentArnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let instructionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instruction)
        instruction = instructionDecoded
        let agentStatusDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentStatus.self, forKey: .agentStatus)
        agentStatus = agentStatusDecoded
        let foundationModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .foundationModel)
        foundationModel = foundationModelDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let idleSessionTTLInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleSessionTTLInSeconds)
        idleSessionTTLInSeconds = idleSessionTTLInSecondsDecoded
        let agentResourceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentResourceRoleArn)
        agentResourceRoleArn = agentResourceRoleArnDecoded
        let customerEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerEncryptionKeyArn)
        customerEncryptionKeyArn = customerEncryptionKeyArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let failureReasonsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .failureReasons)
        var failureReasonsDecoded0:[Swift.String]? = nil
        if let failureReasonsContainer = failureReasonsContainer {
            failureReasonsDecoded0 = [Swift.String]()
            for string0 in failureReasonsContainer {
                if let string0 = string0 {
                    failureReasonsDecoded0?.append(string0)
                }
            }
        }
        failureReasons = failureReasonsDecoded0
        let recommendedActionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .recommendedActions)
        var recommendedActionsDecoded0:[Swift.String]? = nil
        if let recommendedActionsContainer = recommendedActionsContainer {
            recommendedActionsDecoded0 = [Swift.String]()
            for string0 in recommendedActionsContainer {
                if let string0 = string0 {
                    recommendedActionsDecoded0?.append(string0)
                }
            }
        }
        recommendedActions = recommendedActionsDecoded0
        let promptOverrideConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.PromptOverrideConfiguration.self, forKey: .promptOverrideConfiguration)
        promptOverrideConfiguration = promptOverrideConfigurationDecoded
    }
}

extension BedrockAgentClientTypes.AgentVersion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AgentVersion(agentArn: \(Swift.String(describing: agentArn)), agentId: \(Swift.String(describing: agentId)), agentName: \(Swift.String(describing: agentName)), agentResourceRoleArn: \(Swift.String(describing: agentResourceRoleArn)), agentStatus: \(Swift.String(describing: agentStatus)), createdAt: \(Swift.String(describing: createdAt)), customerEncryptionKeyArn: \(Swift.String(describing: customerEncryptionKeyArn)), description: \(Swift.String(describing: description)), failureReasons: \(Swift.String(describing: failureReasons)), foundationModel: \(Swift.String(describing: foundationModel)), idleSessionTTLInSeconds: \(Swift.String(describing: idleSessionTTLInSeconds)), recommendedActions: \(Swift.String(describing: recommendedActions)), updatedAt: \(Swift.String(describing: updatedAt)), version: \(Swift.String(describing: version)), instruction: \"CONTENT_REDACTED\", promptOverrideConfiguration: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentClientTypes {
    /// Contains details about a version of an agent.
    public struct AgentVersion {
        /// The Amazon Resource Name (ARN) of the agent that the version belongs to.
        /// This member is required.
        public var agentArn: Swift.String?
        /// The unique identifier of the agent that the version belongs to.
        /// This member is required.
        public var agentId: Swift.String?
        /// The name of the agent that the version belongs to.
        /// This member is required.
        public var agentName: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the agent.
        /// This member is required.
        public var agentResourceRoleArn: Swift.String?
        /// The status of the agent that the version belongs to.
        /// This member is required.
        public var agentStatus: BedrockAgentClientTypes.AgentStatus?
        /// The time at which the version was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the KMS key that encrypts the agent.
        public var customerEncryptionKeyArn: Swift.String?
        /// The description of the version.
        public var description: Swift.String?
        /// A list of reasons that the API operation on the version failed.
        public var failureReasons: [Swift.String]?
        /// The foundation model that the version invokes.
        public var foundationModel: Swift.String?
        /// The number of seconds for which Amazon Bedrock keeps information about a user's conversation with the agent. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Bedrock deletes any data provided before the timeout.
        /// This member is required.
        public var idleSessionTTLInSeconds: Swift.Int?
        /// The instructions provided to the agent.
        public var instruction: Swift.String?
        /// Contains configurations to override prompt templates in different parts of an agent sequence. For more information, see [Advanced prompts](https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts.html).
        public var promptOverrideConfiguration: BedrockAgentClientTypes.PromptOverrideConfiguration?
        /// A list of recommended actions to take for the failed API operation on the version to succeed.
        public var recommendedActions: [Swift.String]?
        /// The time at which the version was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?
        /// The version number.
        /// This member is required.
        public var version: Swift.String?

        public init(
            agentArn: Swift.String? = nil,
            agentId: Swift.String? = nil,
            agentName: Swift.String? = nil,
            agentResourceRoleArn: Swift.String? = nil,
            agentStatus: BedrockAgentClientTypes.AgentStatus? = nil,
            createdAt: ClientRuntime.Date? = nil,
            customerEncryptionKeyArn: Swift.String? = nil,
            description: Swift.String? = nil,
            failureReasons: [Swift.String]? = nil,
            foundationModel: Swift.String? = nil,
            idleSessionTTLInSeconds: Swift.Int? = nil,
            instruction: Swift.String? = nil,
            promptOverrideConfiguration: BedrockAgentClientTypes.PromptOverrideConfiguration? = nil,
            recommendedActions: [Swift.String]? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            version: Swift.String? = nil
        )
        {
            self.agentArn = agentArn
            self.agentId = agentId
            self.agentName = agentName
            self.agentResourceRoleArn = agentResourceRoleArn
            self.agentStatus = agentStatus
            self.createdAt = createdAt
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.description = description
            self.failureReasons = failureReasons
            self.foundationModel = foundationModel
            self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
            self.instruction = instruction
            self.promptOverrideConfiguration = promptOverrideConfiguration
            self.recommendedActions = recommendedActions
            self.updatedAt = updatedAt
            self.version = version
        }
    }

}

extension BedrockAgentClientTypes.AgentVersionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentName
        case agentStatus
        case agentVersion
        case createdAt
        case description
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentName = self.agentName {
            try encodeContainer.encode(agentName, forKey: .agentName)
        }
        if let agentStatus = self.agentStatus {
            try encodeContainer.encode(agentStatus.rawValue, forKey: .agentStatus)
        }
        if let agentVersion = self.agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentName)
        agentName = agentNameDecoded
        let agentStatusDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentStatus.self, forKey: .agentStatus)
        agentStatus = agentStatusDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about a version of an agent.
    public struct AgentVersionSummary {
        /// The name of the agent to which the version belongs.
        /// This member is required.
        public var agentName: Swift.String?
        /// The status of the agent to which the version belongs.
        /// This member is required.
        public var agentStatus: BedrockAgentClientTypes.AgentStatus?
        /// The version of the agent.
        /// This member is required.
        public var agentVersion: Swift.String?
        /// The time at which the version was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The description of the version of the agent.
        public var description: Swift.String?
        /// The time at which the version was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            agentName: Swift.String? = nil,
            agentStatus: BedrockAgentClientTypes.AgentStatus? = nil,
            agentVersion: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.agentName = agentName
            self.agentStatus = agentStatus
            self.agentVersion = agentVersion
            self.createdAt = createdAt
            self.description = description
            self.updatedAt = updatedAt
        }
    }

}

extension AssociateAgentKnowledgeBaseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case knowledgeBaseId
        case knowledgeBaseState
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let knowledgeBaseState = self.knowledgeBaseState {
            try encodeContainer.encode(knowledgeBaseState.rawValue, forKey: .knowledgeBaseState)
        }
    }
}

extension AssociateAgentKnowledgeBaseInput {

    static func urlPathProvider(_ value: AssociateAgentKnowledgeBaseInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/knowledgebases"
    }
}

public struct AssociateAgentKnowledgeBaseInput {
    /// The unique identifier of the agent with which you want to associate the knowledge base.
    /// This member is required.
    public var agentId: Swift.String?
    /// The version of the agent with which you want to associate the knowledge base.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// A description of what the agent should use the knowledge base for.
    /// This member is required.
    public var description: Swift.String?
    /// The unique identifier of the knowledge base to associate with the agent.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// Specifies whether to use the knowledge base or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
    public var knowledgeBaseState: BedrockAgentClientTypes.KnowledgeBaseState?

    public init(
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        description: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil,
        knowledgeBaseState: BedrockAgentClientTypes.KnowledgeBaseState? = nil
    )
    {
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.description = description
        self.knowledgeBaseId = knowledgeBaseId
        self.knowledgeBaseState = knowledgeBaseState
    }
}

struct AssociateAgentKnowledgeBaseInputBody {
    let knowledgeBaseId: Swift.String?
    let description: Swift.String?
    let knowledgeBaseState: BedrockAgentClientTypes.KnowledgeBaseState?
}

extension AssociateAgentKnowledgeBaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case knowledgeBaseId
        case knowledgeBaseState
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let knowledgeBaseStateDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.KnowledgeBaseState.self, forKey: .knowledgeBaseState)
        knowledgeBaseState = knowledgeBaseStateDecoded
    }
}

extension AssociateAgentKnowledgeBaseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateAgentKnowledgeBaseOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentKnowledgeBase = output.agentKnowledgeBase
        } else {
            self.agentKnowledgeBase = nil
        }
    }
}

public struct AssociateAgentKnowledgeBaseOutput {
    /// Contains details about the knowledge base that has been associated with the agent.
    /// This member is required.
    public var agentKnowledgeBase: BedrockAgentClientTypes.AgentKnowledgeBase?

    public init(
        agentKnowledgeBase: BedrockAgentClientTypes.AgentKnowledgeBase? = nil
    )
    {
        self.agentKnowledgeBase = agentKnowledgeBase
    }
}

struct AssociateAgentKnowledgeBaseOutputBody {
    let agentKnowledgeBase: BedrockAgentClientTypes.AgentKnowledgeBase?
}

extension AssociateAgentKnowledgeBaseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentKnowledgeBase
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentKnowledgeBaseDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentKnowledgeBase.self, forKey: .agentKnowledgeBase)
        agentKnowledgeBase = agentKnowledgeBaseDecoded
    }
}

enum AssociateAgentKnowledgeBaseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

public enum BedrockAgentClientTypes {}

extension BedrockAgentClientTypes.ChunkingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chunkingStrategy
        case fixedSizeChunkingConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chunkingStrategy = self.chunkingStrategy {
            try encodeContainer.encode(chunkingStrategy.rawValue, forKey: .chunkingStrategy)
        }
        if let fixedSizeChunkingConfiguration = self.fixedSizeChunkingConfiguration {
            try encodeContainer.encode(fixedSizeChunkingConfiguration, forKey: .fixedSizeChunkingConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let chunkingStrategyDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.ChunkingStrategy.self, forKey: .chunkingStrategy)
        chunkingStrategy = chunkingStrategyDecoded
        let fixedSizeChunkingConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.FixedSizeChunkingConfiguration.self, forKey: .fixedSizeChunkingConfiguration)
        fixedSizeChunkingConfiguration = fixedSizeChunkingConfigurationDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.
    public struct ChunkingConfiguration {
        /// Knowledge base can split your source data into chunks. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. You have the following options for chunking your data. If you opt for NONE, then you may want to pre-process your files by splitting them up such that each file corresponds to a chunk.
        ///
        /// * FIXED_SIZE – Amazon Bedrock splits your source data into chunks of the approximate size that you set in the fixedSizeChunkingConfiguration.
        ///
        /// * NONE – Amazon Bedrock treats each file as one chunk. If you choose this option, you may want to pre-process your documents by splitting them into separate files.
        /// This member is required.
        public var chunkingStrategy: BedrockAgentClientTypes.ChunkingStrategy?
        /// Configurations for when you choose fixed-size chunking. If you set the chunkingStrategy as NONE, exclude this field.
        public var fixedSizeChunkingConfiguration: BedrockAgentClientTypes.FixedSizeChunkingConfiguration?

        public init(
            chunkingStrategy: BedrockAgentClientTypes.ChunkingStrategy? = nil,
            fixedSizeChunkingConfiguration: BedrockAgentClientTypes.FixedSizeChunkingConfiguration? = nil
        )
        {
            self.chunkingStrategy = chunkingStrategy
            self.fixedSizeChunkingConfiguration = fixedSizeChunkingConfiguration
        }
    }

}

extension BedrockAgentClientTypes {
    public enum ChunkingStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fixedSize
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [ChunkingStrategy] {
            return [
                .fixedSize,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fixedSize: return "FIXED_SIZE"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChunkingStrategy(rawValue: rawValue) ?? ChunkingStrategy.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There was a conflict performing an operation.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateAgentActionGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionGroupExecutor
        case actionGroupName
        case actionGroupState
        case apiSchema
        case clientToken
        case description
        case functionSchema
        case parentActionGroupSignature
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionGroupExecutor = self.actionGroupExecutor {
            try encodeContainer.encode(actionGroupExecutor, forKey: .actionGroupExecutor)
        }
        if let actionGroupName = self.actionGroupName {
            try encodeContainer.encode(actionGroupName, forKey: .actionGroupName)
        }
        if let actionGroupState = self.actionGroupState {
            try encodeContainer.encode(actionGroupState.rawValue, forKey: .actionGroupState)
        }
        if let apiSchema = self.apiSchema {
            try encodeContainer.encode(apiSchema, forKey: .apiSchema)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let functionSchema = self.functionSchema {
            try encodeContainer.encode(functionSchema, forKey: .functionSchema)
        }
        if let parentActionGroupSignature = self.parentActionGroupSignature {
            try encodeContainer.encode(parentActionGroupSignature.rawValue, forKey: .parentActionGroupSignature)
        }
    }
}

extension CreateAgentActionGroupInput {

    static func urlPathProvider(_ value: CreateAgentActionGroupInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/actiongroups"
    }
}

public struct CreateAgentActionGroupInput {
    /// The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action or the custom control method for handling the information elicited from the user.
    public var actionGroupExecutor: BedrockAgentClientTypes.ActionGroupExecutor?
    /// The name to give the action group.
    /// This member is required.
    public var actionGroupName: Swift.String?
    /// Specifies whether the action group is available for the agent to invoke or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
    public var actionGroupState: BedrockAgentClientTypes.ActionGroupState?
    /// The unique identifier of the agent for which to create the action group.
    /// This member is required.
    public var agentId: Swift.String?
    /// The version of the agent for which to create the action group.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted payload defining the schema. For more information, see [Action group OpenAPI schemas](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-api-schema.html).
    public var apiSchema: BedrockAgentClientTypes.APISchema?
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// A description of the action group.
    public var description: Swift.String?
    /// Contains details about the function schema for the action group or the JSON or YAML-formatted payload defining the schema.
    public var functionSchema: BedrockAgentClientTypes.FunctionSchema?
    /// To allow your agent to request the user for additional information when trying to complete a task, set this field to AMAZON.UserInput. You must leave the description, apiSchema, and actionGroupExecutor fields blank for this action group. During orchestration, if your agent determines that it needs to invoke an API in an action group, but doesn't have enough information to complete the API request, it will invoke this action group instead and return an [Observation](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Observation.html) reprompting the user for more information.
    public var parentActionGroupSignature: BedrockAgentClientTypes.ActionGroupSignature?

    public init(
        actionGroupExecutor: BedrockAgentClientTypes.ActionGroupExecutor? = nil,
        actionGroupName: Swift.String? = nil,
        actionGroupState: BedrockAgentClientTypes.ActionGroupState? = nil,
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        apiSchema: BedrockAgentClientTypes.APISchema? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        functionSchema: BedrockAgentClientTypes.FunctionSchema? = nil,
        parentActionGroupSignature: BedrockAgentClientTypes.ActionGroupSignature? = nil
    )
    {
        self.actionGroupExecutor = actionGroupExecutor
        self.actionGroupName = actionGroupName
        self.actionGroupState = actionGroupState
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.apiSchema = apiSchema
        self.clientToken = clientToken
        self.description = description
        self.functionSchema = functionSchema
        self.parentActionGroupSignature = parentActionGroupSignature
    }
}

struct CreateAgentActionGroupInputBody {
    let actionGroupName: Swift.String?
    let clientToken: Swift.String?
    let description: Swift.String?
    let parentActionGroupSignature: BedrockAgentClientTypes.ActionGroupSignature?
    let actionGroupExecutor: BedrockAgentClientTypes.ActionGroupExecutor?
    let apiSchema: BedrockAgentClientTypes.APISchema?
    let actionGroupState: BedrockAgentClientTypes.ActionGroupState?
    let functionSchema: BedrockAgentClientTypes.FunctionSchema?
}

extension CreateAgentActionGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionGroupExecutor
        case actionGroupName
        case actionGroupState
        case apiSchema
        case clientToken
        case description
        case functionSchema
        case parentActionGroupSignature
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionGroupName)
        actionGroupName = actionGroupNameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parentActionGroupSignatureDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.ActionGroupSignature.self, forKey: .parentActionGroupSignature)
        parentActionGroupSignature = parentActionGroupSignatureDecoded
        let actionGroupExecutorDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.ActionGroupExecutor.self, forKey: .actionGroupExecutor)
        actionGroupExecutor = actionGroupExecutorDecoded
        let apiSchemaDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.APISchema.self, forKey: .apiSchema)
        apiSchema = apiSchemaDecoded
        let actionGroupStateDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.ActionGroupState.self, forKey: .actionGroupState)
        actionGroupState = actionGroupStateDecoded
        let functionSchemaDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.FunctionSchema.self, forKey: .functionSchema)
        functionSchema = functionSchemaDecoded
    }
}

extension CreateAgentActionGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAgentActionGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentActionGroup = output.agentActionGroup
        } else {
            self.agentActionGroup = nil
        }
    }
}

public struct CreateAgentActionGroupOutput {
    /// Contains details about the action group that was created.
    /// This member is required.
    public var agentActionGroup: BedrockAgentClientTypes.AgentActionGroup?

    public init(
        agentActionGroup: BedrockAgentClientTypes.AgentActionGroup? = nil
    )
    {
        self.agentActionGroup = agentActionGroup
    }
}

struct CreateAgentActionGroupOutputBody {
    let agentActionGroup: BedrockAgentClientTypes.AgentActionGroup?
}

extension CreateAgentActionGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentActionGroup
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentActionGroupDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentActionGroup.self, forKey: .agentActionGroup)
        agentActionGroup = agentActionGroupDecoded
    }
}

enum CreateAgentActionGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateAgentAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentAliasName
        case clientToken
        case description
        case routingConfiguration
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentAliasName = self.agentAliasName {
            try encodeContainer.encode(agentAliasName, forKey: .agentAliasName)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let routingConfiguration = routingConfiguration {
            var routingConfigurationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .routingConfiguration)
            for agentaliasroutingconfigurationlistitem0 in routingConfiguration {
                try routingConfigurationContainer.encode(agentaliasroutingconfigurationlistitem0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAgentAliasInput {

    static func urlPathProvider(_ value: CreateAgentAliasInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentaliases"
    }
}

public struct CreateAgentAliasInput {
    /// The name of the alias.
    /// This member is required.
    public var agentAliasName: Swift.String?
    /// The unique identifier of the agent.
    /// This member is required.
    public var agentId: Swift.String?
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// A description of the alias of the agent.
    public var description: Swift.String?
    /// Contains details about the routing configuration of the alias.
    public var routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]?
    /// Any tags that you want to attach to the alias of the agent.
    public var tags: [Swift.String:Swift.String]?

    public init(
        agentAliasName: Swift.String? = nil,
        agentId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.agentAliasName = agentAliasName
        self.agentId = agentId
        self.clientToken = clientToken
        self.description = description
        self.routingConfiguration = routingConfiguration
        self.tags = tags
    }
}

struct CreateAgentAliasInputBody {
    let agentAliasName: Swift.String?
    let clientToken: Swift.String?
    let description: Swift.String?
    let routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateAgentAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentAliasName
        case clientToken
        case description
        case routingConfiguration
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentAliasNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentAliasName)
        agentAliasName = agentAliasNameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let routingConfigurationContainer = try containerValues.decodeIfPresent([BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem?].self, forKey: .routingConfiguration)
        var routingConfigurationDecoded0:[BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]? = nil
        if let routingConfigurationContainer = routingConfigurationContainer {
            routingConfigurationDecoded0 = [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]()
            for structure0 in routingConfigurationContainer {
                if let structure0 = structure0 {
                    routingConfigurationDecoded0?.append(structure0)
                }
            }
        }
        routingConfiguration = routingConfigurationDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAgentAliasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAgentAliasOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentAlias = output.agentAlias
        } else {
            self.agentAlias = nil
        }
    }
}

public struct CreateAgentAliasOutput {
    /// Contains details about the alias that was created.
    /// This member is required.
    public var agentAlias: BedrockAgentClientTypes.AgentAlias?

    public init(
        agentAlias: BedrockAgentClientTypes.AgentAlias? = nil
    )
    {
        self.agentAlias = agentAlias
    }
}

struct CreateAgentAliasOutputBody {
    let agentAlias: BedrockAgentClientTypes.AgentAlias?
}

extension CreateAgentAliasOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentAlias
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentAliasDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentAlias.self, forKey: .agentAlias)
        agentAlias = agentAliasDecoded
    }
}

enum CreateAgentAliasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateAgentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAgentInput(agentName: \(Swift.String(describing: agentName)), agentResourceRoleArn: \(Swift.String(describing: agentResourceRoleArn)), clientToken: \(Swift.String(describing: clientToken)), customerEncryptionKeyArn: \(Swift.String(describing: customerEncryptionKeyArn)), description: \(Swift.String(describing: description)), foundationModel: \(Swift.String(describing: foundationModel)), idleSessionTTLInSeconds: \(Swift.String(describing: idleSessionTTLInSeconds)), tags: \(Swift.String(describing: tags)), instruction: \"CONTENT_REDACTED\", promptOverrideConfiguration: \"CONTENT_REDACTED\")"}
}

extension CreateAgentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentName
        case agentResourceRoleArn
        case clientToken
        case customerEncryptionKeyArn
        case description
        case foundationModel
        case idleSessionTTLInSeconds
        case instruction
        case promptOverrideConfiguration
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentName = self.agentName {
            try encodeContainer.encode(agentName, forKey: .agentName)
        }
        if let agentResourceRoleArn = self.agentResourceRoleArn {
            try encodeContainer.encode(agentResourceRoleArn, forKey: .agentResourceRoleArn)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let customerEncryptionKeyArn = self.customerEncryptionKeyArn {
            try encodeContainer.encode(customerEncryptionKeyArn, forKey: .customerEncryptionKeyArn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let foundationModel = self.foundationModel {
            try encodeContainer.encode(foundationModel, forKey: .foundationModel)
        }
        if let idleSessionTTLInSeconds = self.idleSessionTTLInSeconds {
            try encodeContainer.encode(idleSessionTTLInSeconds, forKey: .idleSessionTTLInSeconds)
        }
        if let instruction = self.instruction {
            try encodeContainer.encode(instruction, forKey: .instruction)
        }
        if let promptOverrideConfiguration = self.promptOverrideConfiguration {
            try encodeContainer.encode(promptOverrideConfiguration, forKey: .promptOverrideConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAgentInput {

    static func urlPathProvider(_ value: CreateAgentInput) -> Swift.String? {
        return "/agents"
    }
}

public struct CreateAgentInput {
    /// A name for the agent that you create.
    /// This member is required.
    public var agentName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the agent.
    public var agentResourceRoleArn: Swift.String?
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the KMS key with which to encrypt the agent.
    public var customerEncryptionKeyArn: Swift.String?
    /// A description of the agent.
    public var description: Swift.String?
    /// The foundation model to be used for orchestration by the agent you create.
    public var foundationModel: Swift.String?
    /// The number of seconds for which Amazon Bedrock keeps information about a user's conversation with the agent. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Bedrock deletes any data provided before the timeout.
    public var idleSessionTTLInSeconds: Swift.Int?
    /// Instructions that tell the agent what it should do and how it should interact with users.
    public var instruction: Swift.String?
    /// Contains configurations to override prompts in different parts of an agent sequence. For more information, see [Advanced prompts](https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts.html).
    public var promptOverrideConfiguration: BedrockAgentClientTypes.PromptOverrideConfiguration?
    /// Any tags that you want to attach to the agent.
    public var tags: [Swift.String:Swift.String]?

    public init(
        agentName: Swift.String? = nil,
        agentResourceRoleArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        customerEncryptionKeyArn: Swift.String? = nil,
        description: Swift.String? = nil,
        foundationModel: Swift.String? = nil,
        idleSessionTTLInSeconds: Swift.Int? = nil,
        instruction: Swift.String? = nil,
        promptOverrideConfiguration: BedrockAgentClientTypes.PromptOverrideConfiguration? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.agentName = agentName
        self.agentResourceRoleArn = agentResourceRoleArn
        self.clientToken = clientToken
        self.customerEncryptionKeyArn = customerEncryptionKeyArn
        self.description = description
        self.foundationModel = foundationModel
        self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
        self.instruction = instruction
        self.promptOverrideConfiguration = promptOverrideConfiguration
        self.tags = tags
    }
}

struct CreateAgentInputBody {
    let agentName: Swift.String?
    let clientToken: Swift.String?
    let instruction: Swift.String?
    let foundationModel: Swift.String?
    let description: Swift.String?
    let idleSessionTTLInSeconds: Swift.Int?
    let agentResourceRoleArn: Swift.String?
    let customerEncryptionKeyArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let promptOverrideConfiguration: BedrockAgentClientTypes.PromptOverrideConfiguration?
}

extension CreateAgentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentName
        case agentResourceRoleArn
        case clientToken
        case customerEncryptionKeyArn
        case description
        case foundationModel
        case idleSessionTTLInSeconds
        case instruction
        case promptOverrideConfiguration
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentName)
        agentName = agentNameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let instructionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instruction)
        instruction = instructionDecoded
        let foundationModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .foundationModel)
        foundationModel = foundationModelDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let idleSessionTTLInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleSessionTTLInSeconds)
        idleSessionTTLInSeconds = idleSessionTTLInSecondsDecoded
        let agentResourceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentResourceRoleArn)
        agentResourceRoleArn = agentResourceRoleArnDecoded
        let customerEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerEncryptionKeyArn)
        customerEncryptionKeyArn = customerEncryptionKeyArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let promptOverrideConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.PromptOverrideConfiguration.self, forKey: .promptOverrideConfiguration)
        promptOverrideConfiguration = promptOverrideConfigurationDecoded
    }
}

extension CreateAgentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAgentOutputBody = try responseDecoder.decode(responseBody: data)
            self.agent = output.agent
        } else {
            self.agent = nil
        }
    }
}

public struct CreateAgentOutput {
    /// Contains details about the agent created.
    /// This member is required.
    public var agent: BedrockAgentClientTypes.Agent?

    public init(
        agent: BedrockAgentClientTypes.Agent? = nil
    )
    {
        self.agent = agent
    }
}

struct CreateAgentOutputBody {
    let agent: BedrockAgentClientTypes.Agent?
}

extension CreateAgentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agent
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.Agent.self, forKey: .agent)
        agent = agentDecoded
    }
}

enum CreateAgentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDataSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case dataDeletionPolicy
        case dataSourceConfiguration
        case description
        case name
        case serverSideEncryptionConfiguration
        case vectorIngestionConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dataDeletionPolicy = self.dataDeletionPolicy {
            try encodeContainer.encode(dataDeletionPolicy.rawValue, forKey: .dataDeletionPolicy)
        }
        if let dataSourceConfiguration = self.dataSourceConfiguration {
            try encodeContainer.encode(dataSourceConfiguration, forKey: .dataSourceConfiguration)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverSideEncryptionConfiguration = self.serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let vectorIngestionConfiguration = self.vectorIngestionConfiguration {
            try encodeContainer.encode(vectorIngestionConfiguration, forKey: .vectorIngestionConfiguration)
        }
    }
}

extension CreateDataSourceInput {

    static func urlPathProvider(_ value: CreateDataSourceInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/datasources"
    }
}

public struct CreateDataSourceInput {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The data deletion policy assigned to the data source.
    public var dataDeletionPolicy: BedrockAgentClientTypes.DataDeletionPolicy?
    /// Contains metadata about where the data source is stored.
    /// This member is required.
    public var dataSourceConfiguration: BedrockAgentClientTypes.DataSourceConfiguration?
    /// A description of the data source.
    public var description: Swift.String?
    /// The unique identifier of the knowledge base to which to add the data source.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The name of the data source.
    /// This member is required.
    public var name: Swift.String?
    /// Contains details about the server-side encryption for the data source.
    public var serverSideEncryptionConfiguration: BedrockAgentClientTypes.ServerSideEncryptionConfiguration?
    /// Contains details about how to ingest the documents in the data source.
    public var vectorIngestionConfiguration: BedrockAgentClientTypes.VectorIngestionConfiguration?

    public init(
        clientToken: Swift.String? = nil,
        dataDeletionPolicy: BedrockAgentClientTypes.DataDeletionPolicy? = nil,
        dataSourceConfiguration: BedrockAgentClientTypes.DataSourceConfiguration? = nil,
        description: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil,
        name: Swift.String? = nil,
        serverSideEncryptionConfiguration: BedrockAgentClientTypes.ServerSideEncryptionConfiguration? = nil,
        vectorIngestionConfiguration: BedrockAgentClientTypes.VectorIngestionConfiguration? = nil
    )
    {
        self.clientToken = clientToken
        self.dataDeletionPolicy = dataDeletionPolicy
        self.dataSourceConfiguration = dataSourceConfiguration
        self.description = description
        self.knowledgeBaseId = knowledgeBaseId
        self.name = name
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
        self.vectorIngestionConfiguration = vectorIngestionConfiguration
    }
}

struct CreateDataSourceInputBody {
    let clientToken: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let dataSourceConfiguration: BedrockAgentClientTypes.DataSourceConfiguration?
    let dataDeletionPolicy: BedrockAgentClientTypes.DataDeletionPolicy?
    let serverSideEncryptionConfiguration: BedrockAgentClientTypes.ServerSideEncryptionConfiguration?
    let vectorIngestionConfiguration: BedrockAgentClientTypes.VectorIngestionConfiguration?
}

extension CreateDataSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case dataDeletionPolicy
        case dataSourceConfiguration
        case description
        case name
        case serverSideEncryptionConfiguration
        case vectorIngestionConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourceConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.DataSourceConfiguration.self, forKey: .dataSourceConfiguration)
        dataSourceConfiguration = dataSourceConfigurationDecoded
        let dataDeletionPolicyDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.DataDeletionPolicy.self, forKey: .dataDeletionPolicy)
        dataDeletionPolicy = dataDeletionPolicyDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let vectorIngestionConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.VectorIngestionConfiguration.self, forKey: .vectorIngestionConfiguration)
        vectorIngestionConfiguration = vectorIngestionConfigurationDecoded
    }
}

extension CreateDataSourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDataSourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataSource = output.dataSource
        } else {
            self.dataSource = nil
        }
    }
}

public struct CreateDataSourceOutput {
    /// Contains details about the data source.
    /// This member is required.
    public var dataSource: BedrockAgentClientTypes.DataSource?

    public init(
        dataSource: BedrockAgentClientTypes.DataSource? = nil
    )
    {
        self.dataSource = dataSource
    }
}

struct CreateDataSourceOutputBody {
    let dataSource: BedrockAgentClientTypes.DataSource?
}

extension CreateDataSourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
    }
}

enum CreateDataSourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateKnowledgeBaseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case knowledgeBaseConfiguration
        case name
        case roleArn
        case storageConfiguration
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let knowledgeBaseConfiguration = self.knowledgeBaseConfiguration {
            try encodeContainer.encode(knowledgeBaseConfiguration, forKey: .knowledgeBaseConfiguration)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let storageConfiguration = self.storageConfiguration {
            try encodeContainer.encode(storageConfiguration, forKey: .storageConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateKnowledgeBaseInput {

    static func urlPathProvider(_ value: CreateKnowledgeBaseInput) -> Swift.String? {
        return "/knowledgebases"
    }
}

public struct CreateKnowledgeBaseInput {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// A description of the knowledge base.
    public var description: Swift.String?
    /// Contains details about the embeddings model used for the knowledge base.
    /// This member is required.
    public var knowledgeBaseConfiguration: BedrockAgentClientTypes.KnowledgeBaseConfiguration?
    /// A name for the knowledge base.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the knowledge base.
    /// This member is required.
    public var roleArn: Swift.String?
    /// Contains details about the configuration of the vector database used for the knowledge base.
    /// This member is required.
    public var storageConfiguration: BedrockAgentClientTypes.StorageConfiguration?
    /// Specify the key-value pairs for the tags that you want to attach to your knowledge base in this object.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        knowledgeBaseConfiguration: BedrockAgentClientTypes.KnowledgeBaseConfiguration? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        storageConfiguration: BedrockAgentClientTypes.StorageConfiguration? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.knowledgeBaseConfiguration = knowledgeBaseConfiguration
        self.name = name
        self.roleArn = roleArn
        self.storageConfiguration = storageConfiguration
        self.tags = tags
    }
}

struct CreateKnowledgeBaseInputBody {
    let clientToken: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let roleArn: Swift.String?
    let knowledgeBaseConfiguration: BedrockAgentClientTypes.KnowledgeBaseConfiguration?
    let storageConfiguration: BedrockAgentClientTypes.StorageConfiguration?
    let tags: [Swift.String:Swift.String]?
}

extension CreateKnowledgeBaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case knowledgeBaseConfiguration
        case name
        case roleArn
        case storageConfiguration
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let knowledgeBaseConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.KnowledgeBaseConfiguration.self, forKey: .knowledgeBaseConfiguration)
        knowledgeBaseConfiguration = knowledgeBaseConfigurationDecoded
        let storageConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.StorageConfiguration.self, forKey: .storageConfiguration)
        storageConfiguration = storageConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateKnowledgeBaseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateKnowledgeBaseOutputBody = try responseDecoder.decode(responseBody: data)
            self.knowledgeBase = output.knowledgeBase
        } else {
            self.knowledgeBase = nil
        }
    }
}

public struct CreateKnowledgeBaseOutput {
    /// Contains details about the knowledge base.
    /// This member is required.
    public var knowledgeBase: BedrockAgentClientTypes.KnowledgeBase?

    public init(
        knowledgeBase: BedrockAgentClientTypes.KnowledgeBase? = nil
    )
    {
        self.knowledgeBase = knowledgeBase
    }
}

struct CreateKnowledgeBaseOutputBody {
    let knowledgeBase: BedrockAgentClientTypes.KnowledgeBase?
}

extension CreateKnowledgeBaseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knowledgeBase
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.KnowledgeBase.self, forKey: .knowledgeBase)
        knowledgeBase = knowledgeBaseDecoded
    }
}

enum CreateKnowledgeBaseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BedrockAgentClientTypes {
    public enum CreationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case overridden
        case sdkUnknown(Swift.String)

        public static var allCases: [CreationMode] {
            return [
                .default,
                .overridden,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .overridden: return "OVERRIDDEN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CreationMode(rawValue: rawValue) ?? CreationMode.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentClientTypes {
    public enum CustomControlMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case returnControl
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomControlMethod] {
            return [
                .returnControl,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .returnControl: return "RETURN_CONTROL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomControlMethod(rawValue: rawValue) ?? CustomControlMethod.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentClientTypes {
    public enum DataDeletionPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case delete
        case retain
        case sdkUnknown(Swift.String)

        public static var allCases: [DataDeletionPolicy] {
            return [
                .delete,
                .retain,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case .retain: return "RETAIN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataDeletionPolicy(rawValue: rawValue) ?? DataDeletionPolicy.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentClientTypes.DataSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case dataDeletionPolicy
        case dataSourceConfiguration
        case dataSourceId
        case description
        case failureReasons
        case knowledgeBaseId
        case name
        case serverSideEncryptionConfiguration
        case status
        case updatedAt
        case vectorIngestionConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let dataDeletionPolicy = self.dataDeletionPolicy {
            try encodeContainer.encode(dataDeletionPolicy.rawValue, forKey: .dataDeletionPolicy)
        }
        if let dataSourceConfiguration = self.dataSourceConfiguration {
            try encodeContainer.encode(dataSourceConfiguration, forKey: .dataSourceConfiguration)
        }
        if let dataSourceId = self.dataSourceId {
            try encodeContainer.encode(dataSourceId, forKey: .dataSourceId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let failureReasons = failureReasons {
            var failureReasonsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .failureReasons)
            for failurereason0 in failureReasons {
                try failureReasonsContainer.encode(failurereason0)
            }
        }
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverSideEncryptionConfiguration = self.serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
        if let vectorIngestionConfiguration = self.vectorIngestionConfiguration {
            try encodeContainer.encode(vectorIngestionConfiguration, forKey: .vectorIngestionConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.DataSourceStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourceConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.DataSourceConfiguration.self, forKey: .dataSourceConfiguration)
        dataSourceConfiguration = dataSourceConfigurationDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let vectorIngestionConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.VectorIngestionConfiguration.self, forKey: .vectorIngestionConfiguration)
        vectorIngestionConfiguration = vectorIngestionConfigurationDecoded
        let dataDeletionPolicyDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.DataDeletionPolicy.self, forKey: .dataDeletionPolicy)
        dataDeletionPolicy = dataDeletionPolicyDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let failureReasonsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .failureReasons)
        var failureReasonsDecoded0:[Swift.String]? = nil
        if let failureReasonsContainer = failureReasonsContainer {
            failureReasonsDecoded0 = [Swift.String]()
            for string0 in failureReasonsContainer {
                if let string0 = string0 {
                    failureReasonsDecoded0?.append(string0)
                }
            }
        }
        failureReasons = failureReasonsDecoded0
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about a data source.
    public struct DataSource {
        /// The time at which the data source was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The data deletion policy for a data source.
        public var dataDeletionPolicy: BedrockAgentClientTypes.DataDeletionPolicy?
        /// Contains details about how the data source is stored.
        /// This member is required.
        public var dataSourceConfiguration: BedrockAgentClientTypes.DataSourceConfiguration?
        /// The unique identifier of the data source.
        /// This member is required.
        public var dataSourceId: Swift.String?
        /// The description of the data source.
        public var description: Swift.String?
        /// The detailed reasons on the failure to delete a data source.
        public var failureReasons: [Swift.String]?
        /// The unique identifier of the knowledge base to which the data source belongs.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The name of the data source.
        /// This member is required.
        public var name: Swift.String?
        /// Contains details about the configuration of the server-side encryption.
        public var serverSideEncryptionConfiguration: BedrockAgentClientTypes.ServerSideEncryptionConfiguration?
        /// The status of the data source. The following statuses are possible:
        ///
        /// * Available – The data source has been created and is ready for ingestion into the knowledge base.
        ///
        /// * Deleting – The data source is being deleted.
        /// This member is required.
        public var status: BedrockAgentClientTypes.DataSourceStatus?
        /// The time at which the data source was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?
        /// Contains details about how to ingest the documents in the data source.
        public var vectorIngestionConfiguration: BedrockAgentClientTypes.VectorIngestionConfiguration?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            dataDeletionPolicy: BedrockAgentClientTypes.DataDeletionPolicy? = nil,
            dataSourceConfiguration: BedrockAgentClientTypes.DataSourceConfiguration? = nil,
            dataSourceId: Swift.String? = nil,
            description: Swift.String? = nil,
            failureReasons: [Swift.String]? = nil,
            knowledgeBaseId: Swift.String? = nil,
            name: Swift.String? = nil,
            serverSideEncryptionConfiguration: BedrockAgentClientTypes.ServerSideEncryptionConfiguration? = nil,
            status: BedrockAgentClientTypes.DataSourceStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            vectorIngestionConfiguration: BedrockAgentClientTypes.VectorIngestionConfiguration? = nil
        )
        {
            self.createdAt = createdAt
            self.dataDeletionPolicy = dataDeletionPolicy
            self.dataSourceConfiguration = dataSourceConfiguration
            self.dataSourceId = dataSourceId
            self.description = description
            self.failureReasons = failureReasons
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.status = status
            self.updatedAt = updatedAt
            self.vectorIngestionConfiguration = vectorIngestionConfiguration
        }
    }

}

extension BedrockAgentClientTypes.DataSourceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Configuration
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Configuration = self.s3Configuration {
            try encodeContainer.encode(s3Configuration, forKey: .s3Configuration)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.DataSourceType.self, forKey: .type)
        type = typeDecoded
        let s3ConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.S3DataSourceConfiguration.self, forKey: .s3Configuration)
        s3Configuration = s3ConfigurationDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about how a data source is stored.
    public struct DataSourceConfiguration {
        /// Contains details about the configuration of the S3 object containing the data source.
        public var s3Configuration: BedrockAgentClientTypes.S3DataSourceConfiguration?
        /// The type of storage for the data source.
        /// This member is required.
        public var type: BedrockAgentClientTypes.DataSourceType?

        public init(
            s3Configuration: BedrockAgentClientTypes.S3DataSourceConfiguration? = nil,
            type: BedrockAgentClientTypes.DataSourceType? = nil
        )
        {
            self.s3Configuration = s3Configuration
            self.type = type
        }
    }

}

extension BedrockAgentClientTypes {
    public enum DataSourceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleteUnsuccessful
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceStatus] {
            return [
                .available,
                .deleteUnsuccessful,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleteUnsuccessful: return "DELETE_UNSUCCESSFUL"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSourceStatus(rawValue: rawValue) ?? DataSourceStatus.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentClientTypes.DataSourceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceId
        case description
        case knowledgeBaseId
        case name
        case status
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceId = self.dataSourceId {
            try encodeContainer.encode(dataSourceId, forKey: .dataSourceId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.DataSourceStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about a data source.
    public struct DataSourceSummary {
        /// The unique identifier of the data source.
        /// This member is required.
        public var dataSourceId: Swift.String?
        /// The description of the data source.
        public var description: Swift.String?
        /// The unique identifier of the knowledge base to which the data source belongs.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The name of the data source.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the data source.
        /// This member is required.
        public var status: BedrockAgentClientTypes.DataSourceStatus?
        /// The time at which the data source was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            dataSourceId: Swift.String? = nil,
            description: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            name: Swift.String? = nil,
            status: BedrockAgentClientTypes.DataSourceStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.dataSourceId = dataSourceId
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension BedrockAgentClientTypes {
    public enum DataSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceType] {
            return [
                .s3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSourceType(rawValue: rawValue) ?? DataSourceType.sdkUnknown(rawValue)
        }
    }
}

extension DeleteAgentActionGroupInput {

    static func queryItemProvider(_ value: DeleteAgentActionGroupInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let skipResourceInUseCheck = value.skipResourceInUseCheck {
            let skipResourceInUseCheckQueryItem = ClientRuntime.SDKURLQueryItem(name: "skipResourceInUseCheck".urlPercentEncoding(), value: Swift.String(skipResourceInUseCheck).urlPercentEncoding())
            items.append(skipResourceInUseCheckQueryItem)
        }
        return items
    }
}

extension DeleteAgentActionGroupInput {

    static func urlPathProvider(_ value: DeleteAgentActionGroupInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        guard let actionGroupId = value.actionGroupId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/actiongroups/\(actionGroupId.urlPercentEncoding())"
    }
}

public struct DeleteAgentActionGroupInput {
    /// The unique identifier of the action group to delete.
    /// This member is required.
    public var actionGroupId: Swift.String?
    /// The unique identifier of the agent that the action group belongs to.
    /// This member is required.
    public var agentId: Swift.String?
    /// The version of the agent that the action group belongs to.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// By default, this value is false and deletion is stopped if the resource is in use. If you set it to true, the resource will be deleted even if the resource is in use.
    public var skipResourceInUseCheck: Swift.Bool?

    public init(
        actionGroupId: Swift.String? = nil,
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        skipResourceInUseCheck: Swift.Bool? = nil
    )
    {
        self.actionGroupId = actionGroupId
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.skipResourceInUseCheck = skipResourceInUseCheck
    }
}

struct DeleteAgentActionGroupInputBody {
}

extension DeleteAgentActionGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAgentActionGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAgentActionGroupOutput {

    public init() { }
}

enum DeleteAgentActionGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAgentAliasInput {

    static func urlPathProvider(_ value: DeleteAgentAliasInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentAliasId = value.agentAliasId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentaliases/\(agentAliasId.urlPercentEncoding())"
    }
}

public struct DeleteAgentAliasInput {
    /// The unique identifier of the alias to delete.
    /// This member is required.
    public var agentAliasId: Swift.String?
    /// The unique identifier of the agent that the alias belongs to.
    /// This member is required.
    public var agentId: Swift.String?

    public init(
        agentAliasId: Swift.String? = nil,
        agentId: Swift.String? = nil
    )
    {
        self.agentAliasId = agentAliasId
        self.agentId = agentId
    }
}

struct DeleteAgentAliasInputBody {
}

extension DeleteAgentAliasInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAgentAliasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteAgentAliasOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentAliasId = output.agentAliasId
            self.agentAliasStatus = output.agentAliasStatus
            self.agentId = output.agentId
        } else {
            self.agentAliasId = nil
            self.agentAliasStatus = nil
            self.agentId = nil
        }
    }
}

public struct DeleteAgentAliasOutput {
    /// The unique identifier of the alias that was deleted.
    /// This member is required.
    public var agentAliasId: Swift.String?
    /// The status of the alias.
    /// This member is required.
    public var agentAliasStatus: BedrockAgentClientTypes.AgentAliasStatus?
    /// The unique identifier of the agent that the alias belongs to.
    /// This member is required.
    public var agentId: Swift.String?

    public init(
        agentAliasId: Swift.String? = nil,
        agentAliasStatus: BedrockAgentClientTypes.AgentAliasStatus? = nil,
        agentId: Swift.String? = nil
    )
    {
        self.agentAliasId = agentAliasId
        self.agentAliasStatus = agentAliasStatus
        self.agentId = agentId
    }
}

struct DeleteAgentAliasOutputBody {
    let agentId: Swift.String?
    let agentAliasId: Swift.String?
    let agentAliasStatus: BedrockAgentClientTypes.AgentAliasStatus?
}

extension DeleteAgentAliasOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentAliasId
        case agentAliasStatus
        case agentId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let agentAliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentAliasId)
        agentAliasId = agentAliasIdDecoded
        let agentAliasStatusDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentAliasStatus.self, forKey: .agentAliasStatus)
        agentAliasStatus = agentAliasStatusDecoded
    }
}

enum DeleteAgentAliasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAgentInput {

    static func queryItemProvider(_ value: DeleteAgentInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let skipResourceInUseCheck = value.skipResourceInUseCheck {
            let skipResourceInUseCheckQueryItem = ClientRuntime.SDKURLQueryItem(name: "skipResourceInUseCheck".urlPercentEncoding(), value: Swift.String(skipResourceInUseCheck).urlPercentEncoding())
            items.append(skipResourceInUseCheckQueryItem)
        }
        return items
    }
}

extension DeleteAgentInput {

    static func urlPathProvider(_ value: DeleteAgentInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())"
    }
}

public struct DeleteAgentInput {
    /// The unique identifier of the agent to delete.
    /// This member is required.
    public var agentId: Swift.String?
    /// By default, this value is false and deletion is stopped if the resource is in use. If you set it to true, the resource will be deleted even if the resource is in use.
    public var skipResourceInUseCheck: Swift.Bool?

    public init(
        agentId: Swift.String? = nil,
        skipResourceInUseCheck: Swift.Bool? = nil
    )
    {
        self.agentId = agentId
        self.skipResourceInUseCheck = skipResourceInUseCheck
    }
}

struct DeleteAgentInputBody {
}

extension DeleteAgentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAgentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteAgentOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentId = output.agentId
            self.agentStatus = output.agentStatus
        } else {
            self.agentId = nil
            self.agentStatus = nil
        }
    }
}

public struct DeleteAgentOutput {
    /// The unique identifier of the agent that was deleted.
    /// This member is required.
    public var agentId: Swift.String?
    /// The status of the agent.
    /// This member is required.
    public var agentStatus: BedrockAgentClientTypes.AgentStatus?

    public init(
        agentId: Swift.String? = nil,
        agentStatus: BedrockAgentClientTypes.AgentStatus? = nil
    )
    {
        self.agentId = agentId
        self.agentStatus = agentStatus
    }
}

struct DeleteAgentOutputBody {
    let agentId: Swift.String?
    let agentStatus: BedrockAgentClientTypes.AgentStatus?
}

extension DeleteAgentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentId
        case agentStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let agentStatusDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentStatus.self, forKey: .agentStatus)
        agentStatus = agentStatusDecoded
    }
}

enum DeleteAgentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAgentVersionInput {

    static func queryItemProvider(_ value: DeleteAgentVersionInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let skipResourceInUseCheck = value.skipResourceInUseCheck {
            let skipResourceInUseCheckQueryItem = ClientRuntime.SDKURLQueryItem(name: "skipResourceInUseCheck".urlPercentEncoding(), value: Swift.String(skipResourceInUseCheck).urlPercentEncoding())
            items.append(skipResourceInUseCheckQueryItem)
        }
        return items
    }
}

extension DeleteAgentVersionInput {

    static func urlPathProvider(_ value: DeleteAgentVersionInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())"
    }
}

public struct DeleteAgentVersionInput {
    /// The unique identifier of the agent that the version belongs to.
    /// This member is required.
    public var agentId: Swift.String?
    /// The version of the agent to delete.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// By default, this value is false and deletion is stopped if the resource is in use. If you set it to true, the resource will be deleted even if the resource is in use.
    public var skipResourceInUseCheck: Swift.Bool?

    public init(
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        skipResourceInUseCheck: Swift.Bool? = nil
    )
    {
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.skipResourceInUseCheck = skipResourceInUseCheck
    }
}

struct DeleteAgentVersionInputBody {
}

extension DeleteAgentVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAgentVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteAgentVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentId = output.agentId
            self.agentStatus = output.agentStatus
            self.agentVersion = output.agentVersion
        } else {
            self.agentId = nil
            self.agentStatus = nil
            self.agentVersion = nil
        }
    }
}

public struct DeleteAgentVersionOutput {
    /// The unique identifier of the agent that the version belongs to.
    /// This member is required.
    public var agentId: Swift.String?
    /// The status of the agent version.
    /// This member is required.
    public var agentStatus: BedrockAgentClientTypes.AgentStatus?
    /// The version that was deleted.
    /// This member is required.
    public var agentVersion: Swift.String?

    public init(
        agentId: Swift.String? = nil,
        agentStatus: BedrockAgentClientTypes.AgentStatus? = nil,
        agentVersion: Swift.String? = nil
    )
    {
        self.agentId = agentId
        self.agentStatus = agentStatus
        self.agentVersion = agentVersion
    }
}

struct DeleteAgentVersionOutputBody {
    let agentId: Swift.String?
    let agentVersion: Swift.String?
    let agentStatus: BedrockAgentClientTypes.AgentStatus?
}

extension DeleteAgentVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentId
        case agentStatus
        case agentVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
        let agentStatusDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentStatus.self, forKey: .agentStatus)
        agentStatus = agentStatusDecoded
    }
}

enum DeleteAgentVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDataSourceInput {

    static func urlPathProvider(_ value: DeleteDataSourceInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let dataSourceId = value.dataSourceId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())"
    }
}

public struct DeleteDataSourceInput {
    /// The unique identifier of the data source to delete.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The unique identifier of the knowledge base from which to delete the data source.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        dataSourceId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.dataSourceId = dataSourceId
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct DeleteDataSourceInputBody {
}

extension DeleteDataSourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDataSourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteDataSourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataSourceId = output.dataSourceId
            self.knowledgeBaseId = output.knowledgeBaseId
            self.status = output.status
        } else {
            self.dataSourceId = nil
            self.knowledgeBaseId = nil
            self.status = nil
        }
    }
}

public struct DeleteDataSourceOutput {
    /// The unique identifier of the data source that was deleted.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The unique identifier of the knowledge base to which the data source that was deleted belonged.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The status of the data source.
    /// This member is required.
    public var status: BedrockAgentClientTypes.DataSourceStatus?

    public init(
        dataSourceId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil,
        status: BedrockAgentClientTypes.DataSourceStatus? = nil
    )
    {
        self.dataSourceId = dataSourceId
        self.knowledgeBaseId = knowledgeBaseId
        self.status = status
    }
}

struct DeleteDataSourceOutputBody {
    let knowledgeBaseId: Swift.String?
    let dataSourceId: Swift.String?
    let status: BedrockAgentClientTypes.DataSourceStatus?
}

extension DeleteDataSourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceId
        case knowledgeBaseId
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.DataSourceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum DeleteDataSourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteKnowledgeBaseInput {

    static func urlPathProvider(_ value: DeleteKnowledgeBaseInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())"
    }
}

public struct DeleteKnowledgeBaseInput {
    /// The unique identifier of the knowledge base to delete.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct DeleteKnowledgeBaseInputBody {
}

extension DeleteKnowledgeBaseInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteKnowledgeBaseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteKnowledgeBaseOutputBody = try responseDecoder.decode(responseBody: data)
            self.knowledgeBaseId = output.knowledgeBaseId
            self.status = output.status
        } else {
            self.knowledgeBaseId = nil
            self.status = nil
        }
    }
}

public struct DeleteKnowledgeBaseOutput {
    /// The unique identifier of the knowledge base that was deleted.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The status of the knowledge base and whether it has been successfully deleted.
    /// This member is required.
    public var status: BedrockAgentClientTypes.KnowledgeBaseStatus?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        status: BedrockAgentClientTypes.KnowledgeBaseStatus? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
        self.status = status
    }
}

struct DeleteKnowledgeBaseOutputBody {
    let knowledgeBaseId: Swift.String?
    let status: BedrockAgentClientTypes.KnowledgeBaseStatus?
}

extension DeleteKnowledgeBaseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knowledgeBaseId
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.KnowledgeBaseStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum DeleteKnowledgeBaseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateAgentKnowledgeBaseInput {

    static func urlPathProvider(_ value: DisassociateAgentKnowledgeBaseInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())"
    }
}

public struct DisassociateAgentKnowledgeBaseInput {
    /// The unique identifier of the agent from which to disassociate the knowledge base.
    /// This member is required.
    public var agentId: Swift.String?
    /// The version of the agent from which to disassociate the knowledge base.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// The unique identifier of the knowledge base to disassociate.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct DisassociateAgentKnowledgeBaseInputBody {
}

extension DisassociateAgentKnowledgeBaseInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateAgentKnowledgeBaseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateAgentKnowledgeBaseOutput {

    public init() { }
}

enum DisassociateAgentKnowledgeBaseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BedrockAgentClientTypes.FixedSizeChunkingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxTokens
        case overlapPercentage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxTokens = self.maxTokens {
            try encodeContainer.encode(maxTokens, forKey: .maxTokens)
        }
        if let overlapPercentage = self.overlapPercentage {
            try encodeContainer.encode(overlapPercentage, forKey: .overlapPercentage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxTokensDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxTokens)
        maxTokens = maxTokensDecoded
        let overlapPercentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .overlapPercentage)
        overlapPercentage = overlapPercentageDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Configurations for when you choose fixed-size chunking. If you set the chunkingStrategy as NONE, exclude this field.
    public struct FixedSizeChunkingConfiguration {
        /// The maximum number of tokens to include in a chunk.
        /// This member is required.
        public var maxTokens: Swift.Int?
        /// The percentage of overlap between adjacent chunks of a data source.
        /// This member is required.
        public var overlapPercentage: Swift.Int?

        public init(
            maxTokens: Swift.Int? = nil,
            overlapPercentage: Swift.Int? = nil
        )
        {
            self.maxTokens = maxTokens
            self.overlapPercentage = overlapPercentage
        }
    }

}

extension BedrockAgentClientTypes.Function: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case parameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parameterMap0) in parameters {
                try parametersContainer.encode(parameterMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: BedrockAgentClientTypes.ParameterDetail?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:BedrockAgentClientTypes.ParameterDetail]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:BedrockAgentClientTypes.ParameterDetail]()
            for (key0, parameterdetail0) in parametersContainer {
                if let parameterdetail0 = parameterdetail0 {
                    parametersDecoded0?[key0] = parameterdetail0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension BedrockAgentClientTypes {
    /// Defines parameters that the agent needs to invoke from the user to complete the function. Corresponds to an action in an action group. This data type is used in the following API operations:
    ///
    /// * [CreateAgentActionGroup request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_CreateAgentActionGroup.html#API_agent_CreateAgentActionGroup_RequestSyntax)
    ///
    /// * [CreateAgentActionGroup response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_CreateAgentActionGroup.html#API_agent_CreateAgentActionGroup_ResponseSyntax)
    ///
    /// * [UpdateAgentActionGroup request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_UpdateAgentActionGroup.html#API_agent_UpdateAgentActionGroup_RequestSyntax)
    ///
    /// * [UpdateAgentActionGroup response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_UpdateAgentActionGroup.html#API_agent_UpdateAgentActionGroup_ResponseSyntax)
    ///
    /// * [GetAgentActionGroup response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_GetAgentActionGroup.html#API_agent_GetAgentActionGroup_ResponseSyntax)
    public struct Function {
        /// A description of the function and its purpose.
        public var description: Swift.String?
        /// A name for the function.
        /// This member is required.
        public var name: Swift.String?
        /// The parameters that the agent elicits from the user to fulfill the function.
        public var parameters: [Swift.String:BedrockAgentClientTypes.ParameterDetail]?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            parameters: [Swift.String:BedrockAgentClientTypes.ParameterDetail]? = nil
        )
        {
            self.description = description
            self.name = name
            self.parameters = parameters
        }
    }

}

extension BedrockAgentClientTypes.FunctionSchema: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functions
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .functions(functions):
                var functionsContainer = container.nestedUnkeyedContainer(forKey: .functions)
                for function0 in functions {
                    try functionsContainer.encode(function0)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let functionsContainer = try values.decodeIfPresent([BedrockAgentClientTypes.Function?].self, forKey: .functions)
        var functionsDecoded0:[BedrockAgentClientTypes.Function]? = nil
        if let functionsContainer = functionsContainer {
            functionsDecoded0 = [BedrockAgentClientTypes.Function]()
            for structure0 in functionsContainer {
                if let structure0 = structure0 {
                    functionsDecoded0?.append(structure0)
                }
            }
        }
        if let functions = functionsDecoded0 {
            self = .functions(functions)
            return
        }
        self = .sdkUnknown("")
    }
}

extension BedrockAgentClientTypes {
    /// Defines functions that each define parameters that the agent needs to invoke from the user. Each function represents an action in an action group. This data type is used in the following API operations:
    ///
    /// * [CreateAgentActionGroup request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_CreateAgentActionGroup.html#API_agent_CreateAgentActionGroup_RequestSyntax)
    ///
    /// * [CreateAgentActionGroup response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_CreateAgentActionGroup.html#API_agent_CreateAgentActionGroup_ResponseSyntax)
    ///
    /// * [UpdateAgentActionGroup request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_UpdateAgentActionGroup.html#API_agent_UpdateAgentActionGroup_RequestSyntax)
    ///
    /// * [UpdateAgentActionGroup response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_UpdateAgentActionGroup.html#API_agent_UpdateAgentActionGroup_ResponseSyntax)
    ///
    /// * [GetAgentActionGroup response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_GetAgentActionGroup.html#API_agent_GetAgentActionGroup_ResponseSyntax)
    public enum FunctionSchema {
        /// A list of functions that each define an action in the action group.
        case functions([BedrockAgentClientTypes.Function])
        case sdkUnknown(Swift.String)
    }

}

extension GetAgentActionGroupInput {

    static func urlPathProvider(_ value: GetAgentActionGroupInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        guard let actionGroupId = value.actionGroupId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/actiongroups/\(actionGroupId.urlPercentEncoding())"
    }
}

public struct GetAgentActionGroupInput {
    /// The unique identifier of the action group for which to get information.
    /// This member is required.
    public var actionGroupId: Swift.String?
    /// The unique identifier of the agent that the action group belongs to.
    /// This member is required.
    public var agentId: Swift.String?
    /// The version of the agent that the action group belongs to.
    /// This member is required.
    public var agentVersion: Swift.String?

    public init(
        actionGroupId: Swift.String? = nil,
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil
    )
    {
        self.actionGroupId = actionGroupId
        self.agentId = agentId
        self.agentVersion = agentVersion
    }
}

struct GetAgentActionGroupInputBody {
}

extension GetAgentActionGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAgentActionGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAgentActionGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentActionGroup = output.agentActionGroup
        } else {
            self.agentActionGroup = nil
        }
    }
}

public struct GetAgentActionGroupOutput {
    /// Contains details about the action group.
    /// This member is required.
    public var agentActionGroup: BedrockAgentClientTypes.AgentActionGroup?

    public init(
        agentActionGroup: BedrockAgentClientTypes.AgentActionGroup? = nil
    )
    {
        self.agentActionGroup = agentActionGroup
    }
}

struct GetAgentActionGroupOutputBody {
    let agentActionGroup: BedrockAgentClientTypes.AgentActionGroup?
}

extension GetAgentActionGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentActionGroup
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentActionGroupDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentActionGroup.self, forKey: .agentActionGroup)
        agentActionGroup = agentActionGroupDecoded
    }
}

enum GetAgentActionGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAgentAliasInput {

    static func urlPathProvider(_ value: GetAgentAliasInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentAliasId = value.agentAliasId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentaliases/\(agentAliasId.urlPercentEncoding())"
    }
}

public struct GetAgentAliasInput {
    /// The unique identifier of the alias for which to get information.
    /// This member is required.
    public var agentAliasId: Swift.String?
    /// The unique identifier of the agent to which the alias to get information belongs.
    /// This member is required.
    public var agentId: Swift.String?

    public init(
        agentAliasId: Swift.String? = nil,
        agentId: Swift.String? = nil
    )
    {
        self.agentAliasId = agentAliasId
        self.agentId = agentId
    }
}

struct GetAgentAliasInputBody {
}

extension GetAgentAliasInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAgentAliasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAgentAliasOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentAlias = output.agentAlias
        } else {
            self.agentAlias = nil
        }
    }
}

public struct GetAgentAliasOutput {
    /// Contains information about the alias.
    /// This member is required.
    public var agentAlias: BedrockAgentClientTypes.AgentAlias?

    public init(
        agentAlias: BedrockAgentClientTypes.AgentAlias? = nil
    )
    {
        self.agentAlias = agentAlias
    }
}

struct GetAgentAliasOutputBody {
    let agentAlias: BedrockAgentClientTypes.AgentAlias?
}

extension GetAgentAliasOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentAlias
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentAliasDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentAlias.self, forKey: .agentAlias)
        agentAlias = agentAliasDecoded
    }
}

enum GetAgentAliasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAgentInput {

    static func urlPathProvider(_ value: GetAgentInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())"
    }
}

public struct GetAgentInput {
    /// The unique identifier of the agent.
    /// This member is required.
    public var agentId: Swift.String?

    public init(
        agentId: Swift.String? = nil
    )
    {
        self.agentId = agentId
    }
}

struct GetAgentInputBody {
}

extension GetAgentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAgentKnowledgeBaseInput {

    static func urlPathProvider(_ value: GetAgentKnowledgeBaseInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())"
    }
}

public struct GetAgentKnowledgeBaseInput {
    /// The unique identifier of the agent with which the knowledge base is associated.
    /// This member is required.
    public var agentId: Swift.String?
    /// The version of the agent with which the knowledge base is associated.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// The unique identifier of the knowledge base associated with the agent.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct GetAgentKnowledgeBaseInputBody {
}

extension GetAgentKnowledgeBaseInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAgentKnowledgeBaseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAgentKnowledgeBaseOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentKnowledgeBase = output.agentKnowledgeBase
        } else {
            self.agentKnowledgeBase = nil
        }
    }
}

public struct GetAgentKnowledgeBaseOutput {
    /// Contains details about a knowledge base attached to an agent.
    /// This member is required.
    public var agentKnowledgeBase: BedrockAgentClientTypes.AgentKnowledgeBase?

    public init(
        agentKnowledgeBase: BedrockAgentClientTypes.AgentKnowledgeBase? = nil
    )
    {
        self.agentKnowledgeBase = agentKnowledgeBase
    }
}

struct GetAgentKnowledgeBaseOutputBody {
    let agentKnowledgeBase: BedrockAgentClientTypes.AgentKnowledgeBase?
}

extension GetAgentKnowledgeBaseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentKnowledgeBase
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentKnowledgeBaseDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentKnowledgeBase.self, forKey: .agentKnowledgeBase)
        agentKnowledgeBase = agentKnowledgeBaseDecoded
    }
}

enum GetAgentKnowledgeBaseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAgentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAgentOutputBody = try responseDecoder.decode(responseBody: data)
            self.agent = output.agent
        } else {
            self.agent = nil
        }
    }
}

public struct GetAgentOutput {
    /// Contains details about the agent.
    /// This member is required.
    public var agent: BedrockAgentClientTypes.Agent?

    public init(
        agent: BedrockAgentClientTypes.Agent? = nil
    )
    {
        self.agent = agent
    }
}

struct GetAgentOutputBody {
    let agent: BedrockAgentClientTypes.Agent?
}

extension GetAgentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agent
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.Agent.self, forKey: .agent)
        agent = agentDecoded
    }
}

enum GetAgentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAgentVersionInput {

    static func urlPathProvider(_ value: GetAgentVersionInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())"
    }
}

public struct GetAgentVersionInput {
    /// The unique identifier of the agent.
    /// This member is required.
    public var agentId: Swift.String?
    /// The version of the agent.
    /// This member is required.
    public var agentVersion: Swift.String?

    public init(
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil
    )
    {
        self.agentId = agentId
        self.agentVersion = agentVersion
    }
}

struct GetAgentVersionInputBody {
}

extension GetAgentVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAgentVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAgentVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentVersion = output.agentVersion
        } else {
            self.agentVersion = nil
        }
    }
}

public struct GetAgentVersionOutput {
    /// Contains details about the version of the agent.
    /// This member is required.
    public var agentVersion: BedrockAgentClientTypes.AgentVersion?

    public init(
        agentVersion: BedrockAgentClientTypes.AgentVersion? = nil
    )
    {
        self.agentVersion = agentVersion
    }
}

struct GetAgentVersionOutputBody {
    let agentVersion: BedrockAgentClientTypes.AgentVersion?
}

extension GetAgentVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentVersionDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentVersion.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
    }
}

enum GetAgentVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDataSourceInput {

    static func urlPathProvider(_ value: GetDataSourceInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let dataSourceId = value.dataSourceId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())"
    }
}

public struct GetDataSourceInput {
    /// The unique identifier of the data source.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The unique identifier of the knowledge base that the data source was added to.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        dataSourceId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.dataSourceId = dataSourceId
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct GetDataSourceInputBody {
}

extension GetDataSourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDataSourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDataSourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataSource = output.dataSource
        } else {
            self.dataSource = nil
        }
    }
}

public struct GetDataSourceOutput {
    /// Contains details about the data source.
    /// This member is required.
    public var dataSource: BedrockAgentClientTypes.DataSource?

    public init(
        dataSource: BedrockAgentClientTypes.DataSource? = nil
    )
    {
        self.dataSource = dataSource
    }
}

struct GetDataSourceOutputBody {
    let dataSource: BedrockAgentClientTypes.DataSource?
}

extension GetDataSourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
    }
}

enum GetDataSourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetIngestionJobInput {

    static func urlPathProvider(_ value: GetIngestionJobInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let dataSourceId = value.dataSourceId else {
            return nil
        }
        guard let ingestionJobId = value.ingestionJobId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())/ingestionjobs/\(ingestionJobId.urlPercentEncoding())"
    }
}

public struct GetIngestionJobInput {
    /// The unique identifier of the data source in the ingestion job.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The unique identifier of the ingestion job.
    /// This member is required.
    public var ingestionJobId: Swift.String?
    /// The unique identifier of the knowledge base for which the ingestion job applies.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        dataSourceId: Swift.String? = nil,
        ingestionJobId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.dataSourceId = dataSourceId
        self.ingestionJobId = ingestionJobId
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct GetIngestionJobInputBody {
}

extension GetIngestionJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetIngestionJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetIngestionJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.ingestionJob = output.ingestionJob
        } else {
            self.ingestionJob = nil
        }
    }
}

public struct GetIngestionJobOutput {
    /// Contains details about the ingestion job.
    /// This member is required.
    public var ingestionJob: BedrockAgentClientTypes.IngestionJob?

    public init(
        ingestionJob: BedrockAgentClientTypes.IngestionJob? = nil
    )
    {
        self.ingestionJob = ingestionJob
    }
}

struct GetIngestionJobOutputBody {
    let ingestionJob: BedrockAgentClientTypes.IngestionJob?
}

extension GetIngestionJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ingestionJob
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ingestionJobDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.IngestionJob.self, forKey: .ingestionJob)
        ingestionJob = ingestionJobDecoded
    }
}

enum GetIngestionJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetKnowledgeBaseInput {

    static func urlPathProvider(_ value: GetKnowledgeBaseInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())"
    }
}

public struct GetKnowledgeBaseInput {
    /// The unique identifier of the knowledge base for which to get information.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct GetKnowledgeBaseInputBody {
}

extension GetKnowledgeBaseInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetKnowledgeBaseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetKnowledgeBaseOutputBody = try responseDecoder.decode(responseBody: data)
            self.knowledgeBase = output.knowledgeBase
        } else {
            self.knowledgeBase = nil
        }
    }
}

public struct GetKnowledgeBaseOutput {
    /// Contains details about the knowledge base.
    /// This member is required.
    public var knowledgeBase: BedrockAgentClientTypes.KnowledgeBase?

    public init(
        knowledgeBase: BedrockAgentClientTypes.KnowledgeBase? = nil
    )
    {
        self.knowledgeBase = knowledgeBase
    }
}

struct GetKnowledgeBaseOutputBody {
    let knowledgeBase: BedrockAgentClientTypes.KnowledgeBase?
}

extension GetKnowledgeBaseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knowledgeBase
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.KnowledgeBase.self, forKey: .knowledgeBase)
        knowledgeBase = knowledgeBaseDecoded
    }
}

enum GetKnowledgeBaseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BedrockAgentClientTypes.InferenceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maximumLength
        case stopSequences
        case temperature
        case topk = "topK"
        case topp = "topP"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maximumLength = self.maximumLength {
            try encodeContainer.encode(maximumLength, forKey: .maximumLength)
        }
        if let stopSequences = stopSequences {
            var stopSequencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stopSequences)
            for string0 in stopSequences {
                try stopSequencesContainer.encode(string0)
            }
        }
        if let temperature = self.temperature {
            try encodeContainer.encode(temperature, forKey: .temperature)
        }
        if let topk = self.topk {
            try encodeContainer.encode(topk, forKey: .topk)
        }
        if let topp = self.topp {
            try encodeContainer.encode(topp, forKey: .topp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let temperatureDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .temperature)
        temperature = temperatureDecoded
        let toppDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .topp)
        topp = toppDecoded
        let topkDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .topk)
        topk = topkDecoded
        let maximumLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumLength)
        maximumLength = maximumLengthDecoded
        let stopSequencesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stopSequences)
        var stopSequencesDecoded0:[Swift.String]? = nil
        if let stopSequencesContainer = stopSequencesContainer {
            stopSequencesDecoded0 = [Swift.String]()
            for string0 in stopSequencesContainer {
                if let string0 = string0 {
                    stopSequencesDecoded0?.append(string0)
                }
            }
        }
        stopSequences = stopSequencesDecoded0
    }
}

extension BedrockAgentClientTypes {
    /// Contains inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the promptType. For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html).
    public struct InferenceConfiguration {
        /// The maximum number of tokens to allow in the generated response.
        public var maximumLength: Swift.Int?
        /// A list of stop sequences. A stop sequence is a sequence of characters that causes the model to stop generating the response.
        public var stopSequences: [Swift.String]?
        /// The likelihood of the model selecting higher-probability options while generating a response. A lower value makes the model more likely to choose higher-probability options, while a higher value makes the model more likely to choose lower-probability options.
        public var temperature: Swift.Float?
        /// While generating a response, the model determines the probability of the following token at each point of generation. The value that you set for topK is the number of most-likely candidates from which the model chooses the next token in the sequence. For example, if you set topK to 50, the model selects the next token from among the top 50 most likely choices.
        public var topk: Swift.Int?
        /// While generating a response, the model determines the probability of the following token at each point of generation. The value that you set for Top P determines the number of most-likely candidates from which the model chooses the next token in the sequence. For example, if you set topP to 80, the model only selects the next token from the top 80% of the probability distribution of next tokens.
        public var topp: Swift.Float?

        public init(
            maximumLength: Swift.Int? = nil,
            stopSequences: [Swift.String]? = nil,
            temperature: Swift.Float? = nil,
            topk: Swift.Int? = nil,
            topp: Swift.Float? = nil
        )
        {
            self.maximumLength = maximumLength
            self.stopSequences = stopSequences
            self.temperature = temperature
            self.topk = topk
            self.topp = topp
        }
    }

}

extension BedrockAgentClientTypes.IngestionJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceId
        case description
        case failureReasons
        case ingestionJobId
        case knowledgeBaseId
        case startedAt
        case statistics
        case status
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceId = self.dataSourceId {
            try encodeContainer.encode(dataSourceId, forKey: .dataSourceId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let failureReasons = failureReasons {
            var failureReasonsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .failureReasons)
            for failurereason0 in failureReasons {
                try failureReasonsContainer.encode(failurereason0)
            }
        }
        if let ingestionJobId = self.ingestionJobId {
            try encodeContainer.encode(ingestionJobId, forKey: .ingestionJobId)
        }
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let startedAt = self.startedAt {
            try encodeContainer.encodeTimestamp(startedAt, format: .dateTime, forKey: .startedAt)
        }
        if let statistics = self.statistics {
            try encodeContainer.encode(statistics, forKey: .statistics)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let ingestionJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ingestionJobId)
        ingestionJobId = ingestionJobIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.IngestionJobStatus.self, forKey: .status)
        status = statusDecoded
        let statisticsDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.IngestionJobStatistics.self, forKey: .statistics)
        statistics = statisticsDecoded
        let failureReasonsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .failureReasons)
        var failureReasonsDecoded0:[Swift.String]? = nil
        if let failureReasonsContainer = failureReasonsContainer {
            failureReasonsDecoded0 = [Swift.String]()
            for string0 in failureReasonsContainer {
                if let string0 = string0 {
                    failureReasonsDecoded0?.append(string0)
                }
            }
        }
        failureReasons = failureReasonsDecoded0
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedAt)
        startedAt = startedAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about an ingestion job, which converts a data source to embeddings for a vector store in knowledge base. This data type is used in the following API operations:
    ///
    /// * [StartIngestionJob response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_StartIngestionJob.html#API_agent_StartIngestionJob_ResponseSyntax)
    ///
    /// * [GetIngestionJob response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_GetIngestionJob.html#API_agent_GetIngestionJob_ResponseSyntax)
    ///
    /// * [ListIngestionJob response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_ListIngestionJobs.html#API_agent_ListIngestionJobs_ResponseSyntax)
    public struct IngestionJob {
        /// The unique identifier of the ingested data source.
        /// This member is required.
        public var dataSourceId: Swift.String?
        /// The description of the ingestion job.
        public var description: Swift.String?
        /// A list of reasons that the ingestion job failed.
        public var failureReasons: [Swift.String]?
        /// The unique identifier of the ingestion job.
        /// This member is required.
        public var ingestionJobId: Swift.String?
        /// The unique identifier of the knowledge base to which the data source is being added.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The time at which the ingestion job started.
        /// This member is required.
        public var startedAt: ClientRuntime.Date?
        /// Contains statistics about the ingestion job.
        public var statistics: BedrockAgentClientTypes.IngestionJobStatistics?
        /// The status of the ingestion job.
        /// This member is required.
        public var status: BedrockAgentClientTypes.IngestionJobStatus?
        /// The time at which the ingestion job was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            dataSourceId: Swift.String? = nil,
            description: Swift.String? = nil,
            failureReasons: [Swift.String]? = nil,
            ingestionJobId: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            startedAt: ClientRuntime.Date? = nil,
            statistics: BedrockAgentClientTypes.IngestionJobStatistics? = nil,
            status: BedrockAgentClientTypes.IngestionJobStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.dataSourceId = dataSourceId
            self.description = description
            self.failureReasons = failureReasons
            self.ingestionJobId = ingestionJobId
            self.knowledgeBaseId = knowledgeBaseId
            self.startedAt = startedAt
            self.statistics = statistics
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension BedrockAgentClientTypes.IngestionJobFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute
        case `operator` = "operator"
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = self.attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for ingestionjobfiltervalue0 in values {
                try valuesContainer.encode(ingestionjobfiltervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.IngestionJobFilterAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.IngestionJobFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension BedrockAgentClientTypes {
    /// Defines a filter by which to filter the results.
    public struct IngestionJobFilter {
        /// The attribute by which to filter the results.
        /// This member is required.
        public var attribute: BedrockAgentClientTypes.IngestionJobFilterAttribute?
        /// The operation to carry out between the attribute and the values.
        /// This member is required.
        public var `operator`: BedrockAgentClientTypes.IngestionJobFilterOperator?
        /// A list of values for the attribute.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            attribute: BedrockAgentClientTypes.IngestionJobFilterAttribute? = nil,
            `operator`: BedrockAgentClientTypes.IngestionJobFilterOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.attribute = attribute
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension BedrockAgentClientTypes {
    public enum IngestionJobFilterAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionJobFilterAttribute] {
            return [
                .status,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .status: return "STATUS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IngestionJobFilterAttribute(rawValue: rawValue) ?? IngestionJobFilterAttribute.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentClientTypes {
    public enum IngestionJobFilterOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case eq
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionJobFilterOperator] {
            return [
                .eq,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .eq: return "EQ"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IngestionJobFilterOperator(rawValue: rawValue) ?? IngestionJobFilterOperator.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentClientTypes.IngestionJobSortBy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute
        case order
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = self.attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let order = self.order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.IngestionJobSortByAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let orderDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.SortOrder.self, forKey: .order)
        order = orderDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Parameters by which to sort the results.
    public struct IngestionJobSortBy {
        /// The attribute by which to sort the results.
        /// This member is required.
        public var attribute: BedrockAgentClientTypes.IngestionJobSortByAttribute?
        /// The order by which to sort the results.
        /// This member is required.
        public var order: BedrockAgentClientTypes.SortOrder?

        public init(
            attribute: BedrockAgentClientTypes.IngestionJobSortByAttribute? = nil,
            order: BedrockAgentClientTypes.SortOrder? = nil
        )
        {
            self.attribute = attribute
            self.order = order
        }
    }

}

extension BedrockAgentClientTypes {
    public enum IngestionJobSortByAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case startedAt
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionJobSortByAttribute] {
            return [
                .startedAt,
                .status,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .startedAt: return "STARTED_AT"
            case .status: return "STATUS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IngestionJobSortByAttribute(rawValue: rawValue) ?? IngestionJobSortByAttribute.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentClientTypes.IngestionJobStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case numberOfDocumentsDeleted
        case numberOfDocumentsFailed
        case numberOfDocumentsScanned
        case numberOfMetadataDocumentsModified
        case numberOfMetadataDocumentsScanned
        case numberOfModifiedDocumentsIndexed
        case numberOfNewDocumentsIndexed
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if numberOfDocumentsDeleted != 0 {
            try encodeContainer.encode(numberOfDocumentsDeleted, forKey: .numberOfDocumentsDeleted)
        }
        if numberOfDocumentsFailed != 0 {
            try encodeContainer.encode(numberOfDocumentsFailed, forKey: .numberOfDocumentsFailed)
        }
        if numberOfDocumentsScanned != 0 {
            try encodeContainer.encode(numberOfDocumentsScanned, forKey: .numberOfDocumentsScanned)
        }
        if numberOfMetadataDocumentsModified != 0 {
            try encodeContainer.encode(numberOfMetadataDocumentsModified, forKey: .numberOfMetadataDocumentsModified)
        }
        if numberOfMetadataDocumentsScanned != 0 {
            try encodeContainer.encode(numberOfMetadataDocumentsScanned, forKey: .numberOfMetadataDocumentsScanned)
        }
        if numberOfModifiedDocumentsIndexed != 0 {
            try encodeContainer.encode(numberOfModifiedDocumentsIndexed, forKey: .numberOfModifiedDocumentsIndexed)
        }
        if numberOfNewDocumentsIndexed != 0 {
            try encodeContainer.encode(numberOfNewDocumentsIndexed, forKey: .numberOfNewDocumentsIndexed)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberOfDocumentsScannedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfDocumentsScanned) ?? 0
        numberOfDocumentsScanned = numberOfDocumentsScannedDecoded
        let numberOfMetadataDocumentsScannedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfMetadataDocumentsScanned) ?? 0
        numberOfMetadataDocumentsScanned = numberOfMetadataDocumentsScannedDecoded
        let numberOfNewDocumentsIndexedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfNewDocumentsIndexed) ?? 0
        numberOfNewDocumentsIndexed = numberOfNewDocumentsIndexedDecoded
        let numberOfModifiedDocumentsIndexedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfModifiedDocumentsIndexed) ?? 0
        numberOfModifiedDocumentsIndexed = numberOfModifiedDocumentsIndexedDecoded
        let numberOfMetadataDocumentsModifiedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfMetadataDocumentsModified) ?? 0
        numberOfMetadataDocumentsModified = numberOfMetadataDocumentsModifiedDecoded
        let numberOfDocumentsDeletedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfDocumentsDeleted) ?? 0
        numberOfDocumentsDeleted = numberOfDocumentsDeletedDecoded
        let numberOfDocumentsFailedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfDocumentsFailed) ?? 0
        numberOfDocumentsFailed = numberOfDocumentsFailedDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains the statistics for the ingestion job.
    public struct IngestionJobStatistics {
        /// The number of source documents that was deleted.
        public var numberOfDocumentsDeleted: Swift.Int
        /// The number of source documents that failed to be ingested.
        public var numberOfDocumentsFailed: Swift.Int
        /// The total number of source documents that were scanned. Includes new, updated, and unchanged documents.
        public var numberOfDocumentsScanned: Swift.Int
        /// The number of metadata files that were updated or deleted.
        public var numberOfMetadataDocumentsModified: Swift.Int
        /// The total number of metadata files that were scanned. Includes new, updated, and unchanged files.
        public var numberOfMetadataDocumentsScanned: Swift.Int
        /// The number of modified source documents in the data source that were successfully indexed.
        public var numberOfModifiedDocumentsIndexed: Swift.Int
        /// The number of new source documents in the data source that were successfully indexed.
        public var numberOfNewDocumentsIndexed: Swift.Int

        public init(
            numberOfDocumentsDeleted: Swift.Int = 0,
            numberOfDocumentsFailed: Swift.Int = 0,
            numberOfDocumentsScanned: Swift.Int = 0,
            numberOfMetadataDocumentsModified: Swift.Int = 0,
            numberOfMetadataDocumentsScanned: Swift.Int = 0,
            numberOfModifiedDocumentsIndexed: Swift.Int = 0,
            numberOfNewDocumentsIndexed: Swift.Int = 0
        )
        {
            self.numberOfDocumentsDeleted = numberOfDocumentsDeleted
            self.numberOfDocumentsFailed = numberOfDocumentsFailed
            self.numberOfDocumentsScanned = numberOfDocumentsScanned
            self.numberOfMetadataDocumentsModified = numberOfMetadataDocumentsModified
            self.numberOfMetadataDocumentsScanned = numberOfMetadataDocumentsScanned
            self.numberOfModifiedDocumentsIndexed = numberOfModifiedDocumentsIndexed
            self.numberOfNewDocumentsIndexed = numberOfNewDocumentsIndexed
        }
    }

}

extension BedrockAgentClientTypes {
    public enum IngestionJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case failed
        case inProgress
        case starting
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionJobStatus] {
            return [
                .complete,
                .failed,
                .inProgress,
                .starting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .starting: return "STARTING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IngestionJobStatus(rawValue: rawValue) ?? IngestionJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentClientTypes.IngestionJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceId
        case description
        case ingestionJobId
        case knowledgeBaseId
        case startedAt
        case statistics
        case status
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceId = self.dataSourceId {
            try encodeContainer.encode(dataSourceId, forKey: .dataSourceId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ingestionJobId = self.ingestionJobId {
            try encodeContainer.encode(ingestionJobId, forKey: .ingestionJobId)
        }
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let startedAt = self.startedAt {
            try encodeContainer.encodeTimestamp(startedAt, format: .dateTime, forKey: .startedAt)
        }
        if let statistics = self.statistics {
            try encodeContainer.encode(statistics, forKey: .statistics)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let ingestionJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ingestionJobId)
        ingestionJobId = ingestionJobIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.IngestionJobStatus.self, forKey: .status)
        status = statusDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedAt)
        startedAt = startedAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let statisticsDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.IngestionJobStatistics.self, forKey: .statistics)
        statistics = statisticsDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about an ingestion job.
    public struct IngestionJobSummary {
        /// The unique identifier of the data source in the ingestion job.
        /// This member is required.
        public var dataSourceId: Swift.String?
        /// The description of the ingestion job.
        public var description: Swift.String?
        /// The unique identifier of the ingestion job.
        /// This member is required.
        public var ingestionJobId: Swift.String?
        /// The unique identifier of the knowledge base to which the data source is added.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The time at which the ingestion job was started.
        /// This member is required.
        public var startedAt: ClientRuntime.Date?
        /// Contains statistics for the ingestion job.
        public var statistics: BedrockAgentClientTypes.IngestionJobStatistics?
        /// The status of the ingestion job.
        /// This member is required.
        public var status: BedrockAgentClientTypes.IngestionJobStatus?
        /// The time at which the ingestion job was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            dataSourceId: Swift.String? = nil,
            description: Swift.String? = nil,
            ingestionJobId: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            startedAt: ClientRuntime.Date? = nil,
            statistics: BedrockAgentClientTypes.IngestionJobStatistics? = nil,
            status: BedrockAgentClientTypes.IngestionJobStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.dataSourceId = dataSourceId
            self.description = description
            self.ingestionJobId = ingestionJobId
            self.knowledgeBaseId = knowledgeBaseId
            self.startedAt = startedAt
            self.statistics = statistics
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An internal server error occurred. Retry your request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BedrockAgentClientTypes.KnowledgeBase: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case description
        case failureReasons
        case knowledgeBaseArn
        case knowledgeBaseConfiguration
        case knowledgeBaseId
        case name
        case roleArn
        case status
        case storageConfiguration
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let failureReasons = failureReasons {
            var failureReasonsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .failureReasons)
            for failurereason0 in failureReasons {
                try failureReasonsContainer.encode(failurereason0)
            }
        }
        if let knowledgeBaseArn = self.knowledgeBaseArn {
            try encodeContainer.encode(knowledgeBaseArn, forKey: .knowledgeBaseArn)
        }
        if let knowledgeBaseConfiguration = self.knowledgeBaseConfiguration {
            try encodeContainer.encode(knowledgeBaseConfiguration, forKey: .knowledgeBaseConfiguration)
        }
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let storageConfiguration = self.storageConfiguration {
            try encodeContainer.encode(storageConfiguration, forKey: .storageConfiguration)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let knowledgeBaseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseArn)
        knowledgeBaseArn = knowledgeBaseArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let knowledgeBaseConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.KnowledgeBaseConfiguration.self, forKey: .knowledgeBaseConfiguration)
        knowledgeBaseConfiguration = knowledgeBaseConfigurationDecoded
        let storageConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.StorageConfiguration.self, forKey: .storageConfiguration)
        storageConfiguration = storageConfigurationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.KnowledgeBaseStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let failureReasonsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .failureReasons)
        var failureReasonsDecoded0:[Swift.String]? = nil
        if let failureReasonsContainer = failureReasonsContainer {
            failureReasonsDecoded0 = [Swift.String]()
            for string0 in failureReasonsContainer {
                if let string0 = string0 {
                    failureReasonsDecoded0?.append(string0)
                }
            }
        }
        failureReasons = failureReasonsDecoded0
    }
}

extension BedrockAgentClientTypes {
    /// Contains information about a knowledge base.
    public struct KnowledgeBase {
        /// The time at which the knowledge base was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The description of the knowledge base.
        public var description: Swift.String?
        /// A list of reasons that the API operation on the knowledge base failed.
        public var failureReasons: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// Contains details about the embeddings configuration of the knowledge base.
        /// This member is required.
        public var knowledgeBaseConfiguration: BedrockAgentClientTypes.KnowledgeBaseConfiguration?
        /// The unique identifier of the knowledge base.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The name of the knowledge base.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the knowledge base.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The status of the knowledge base. The following statuses are possible:
        ///
        /// * CREATING – The knowledge base is being created.
        ///
        /// * ACTIVE – The knowledge base is ready to be queried.
        ///
        /// * DELETING – The knowledge base is being deleted.
        ///
        /// * UPDATING – The knowledge base is being updated.
        ///
        /// * FAILED – The knowledge base API operation failed.
        /// This member is required.
        public var status: BedrockAgentClientTypes.KnowledgeBaseStatus?
        /// Contains details about the storage configuration of the knowledge base.
        /// This member is required.
        public var storageConfiguration: BedrockAgentClientTypes.StorageConfiguration?
        /// The time at which the knowledge base was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            failureReasons: [Swift.String]? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseConfiguration: BedrockAgentClientTypes.KnowledgeBaseConfiguration? = nil,
            knowledgeBaseId: Swift.String? = nil,
            name: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            status: BedrockAgentClientTypes.KnowledgeBaseStatus? = nil,
            storageConfiguration: BedrockAgentClientTypes.StorageConfiguration? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.failureReasons = failureReasons
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseConfiguration = knowledgeBaseConfiguration
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.roleArn = roleArn
            self.status = status
            self.storageConfiguration = storageConfiguration
            self.updatedAt = updatedAt
        }
    }

}

extension BedrockAgentClientTypes.KnowledgeBaseConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type
        case vectorKnowledgeBaseConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let vectorKnowledgeBaseConfiguration = self.vectorKnowledgeBaseConfiguration {
            try encodeContainer.encode(vectorKnowledgeBaseConfiguration, forKey: .vectorKnowledgeBaseConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.KnowledgeBaseType.self, forKey: .type)
        type = typeDecoded
        let vectorKnowledgeBaseConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.VectorKnowledgeBaseConfiguration.self, forKey: .vectorKnowledgeBaseConfiguration)
        vectorKnowledgeBaseConfiguration = vectorKnowledgeBaseConfigurationDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about the embeddings configuration of the knowledge base.
    public struct KnowledgeBaseConfiguration {
        /// The type of data that the data source is converted into for the knowledge base.
        /// This member is required.
        public var type: BedrockAgentClientTypes.KnowledgeBaseType?
        /// Contains details about the embeddings model that'sused to convert the data source.
        public var vectorKnowledgeBaseConfiguration: BedrockAgentClientTypes.VectorKnowledgeBaseConfiguration?

        public init(
            type: BedrockAgentClientTypes.KnowledgeBaseType? = nil,
            vectorKnowledgeBaseConfiguration: BedrockAgentClientTypes.VectorKnowledgeBaseConfiguration? = nil
        )
        {
            self.type = type
            self.vectorKnowledgeBaseConfiguration = vectorKnowledgeBaseConfiguration
        }
    }

}

extension BedrockAgentClientTypes {
    public enum KnowledgeBaseState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [KnowledgeBaseState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KnowledgeBaseState(rawValue: rawValue) ?? KnowledgeBaseState.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentClientTypes {
    public enum KnowledgeBaseStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleteUnsuccessful
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [KnowledgeBaseStatus] {
            return [
                .active,
                .creating,
                .deleteUnsuccessful,
                .deleting,
                .failed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleteUnsuccessful: return "DELETE_UNSUCCESSFUL"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KnowledgeBaseStatus(rawValue: rawValue) ?? KnowledgeBaseStatus.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentClientTypes {
    public enum KnowledgeBaseStorageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mongoDbAtlas
        case opensearchServerless
        case pinecone
        case rds
        case redisEnterpriseCloud
        case sdkUnknown(Swift.String)

        public static var allCases: [KnowledgeBaseStorageType] {
            return [
                .mongoDbAtlas,
                .opensearchServerless,
                .pinecone,
                .rds,
                .redisEnterpriseCloud,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mongoDbAtlas: return "MONGO_DB_ATLAS"
            case .opensearchServerless: return "OPENSEARCH_SERVERLESS"
            case .pinecone: return "PINECONE"
            case .rds: return "RDS"
            case .redisEnterpriseCloud: return "REDIS_ENTERPRISE_CLOUD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KnowledgeBaseStorageType(rawValue: rawValue) ?? KnowledgeBaseStorageType.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentClientTypes.KnowledgeBaseSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case knowledgeBaseId
        case name
        case status
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.KnowledgeBaseStatus.self, forKey: .status)
        status = statusDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about a knowledge base.
    public struct KnowledgeBaseSummary {
        /// The description of the knowledge base.
        public var description: Swift.String?
        /// The unique identifier of the knowledge base.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The name of the knowledge base.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the knowledge base.
        /// This member is required.
        public var status: BedrockAgentClientTypes.KnowledgeBaseStatus?
        /// The time at which the knowledge base was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            description: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            name: Swift.String? = nil,
            status: BedrockAgentClientTypes.KnowledgeBaseStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension BedrockAgentClientTypes {
    public enum KnowledgeBaseType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case vector
        case sdkUnknown(Swift.String)

        public static var allCases: [KnowledgeBaseType] {
            return [
                .vector,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .vector: return "VECTOR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KnowledgeBaseType(rawValue: rawValue) ?? KnowledgeBaseType.sdkUnknown(rawValue)
        }
    }
}

extension ListAgentActionGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAgentActionGroupsInput {

    static func urlPathProvider(_ value: ListAgentActionGroupsInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/actiongroups"
    }
}

public struct ListAgentActionGroupsInput {
    /// The unique identifier of the agent.
    /// This member is required.
    public var agentId: Swift.String?
    /// The version of the agent.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAgentActionGroupsInputBody {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAgentActionGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAgentActionGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAgentActionGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.actionGroupSummaries = output.actionGroupSummaries
            self.nextToken = output.nextToken
        } else {
            self.actionGroupSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAgentActionGroupsOutput {
    /// A list of objects, each of which contains information about an action group.
    /// This member is required.
    public var actionGroupSummaries: [BedrockAgentClientTypes.ActionGroupSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        actionGroupSummaries: [BedrockAgentClientTypes.ActionGroupSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actionGroupSummaries = actionGroupSummaries
        self.nextToken = nextToken
    }
}

struct ListAgentActionGroupsOutputBody {
    let actionGroupSummaries: [BedrockAgentClientTypes.ActionGroupSummary]?
    let nextToken: Swift.String?
}

extension ListAgentActionGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionGroupSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionGroupSummariesContainer = try containerValues.decodeIfPresent([BedrockAgentClientTypes.ActionGroupSummary?].self, forKey: .actionGroupSummaries)
        var actionGroupSummariesDecoded0:[BedrockAgentClientTypes.ActionGroupSummary]? = nil
        if let actionGroupSummariesContainer = actionGroupSummariesContainer {
            actionGroupSummariesDecoded0 = [BedrockAgentClientTypes.ActionGroupSummary]()
            for structure0 in actionGroupSummariesContainer {
                if let structure0 = structure0 {
                    actionGroupSummariesDecoded0?.append(structure0)
                }
            }
        }
        actionGroupSummaries = actionGroupSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAgentActionGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAgentAliasesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAgentAliasesInput {

    static func urlPathProvider(_ value: ListAgentAliasesInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentaliases"
    }
}

public struct ListAgentAliasesInput {
    /// The unique identifier of the agent.
    /// This member is required.
    public var agentId: Swift.String?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        agentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentId = agentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAgentAliasesInputBody {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAgentAliasesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAgentAliasesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAgentAliasesOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentAliasSummaries = output.agentAliasSummaries
            self.nextToken = output.nextToken
        } else {
            self.agentAliasSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAgentAliasesOutput {
    /// A list of objects, each of which contains information about an alias of the agent.
    /// This member is required.
    public var agentAliasSummaries: [BedrockAgentClientTypes.AgentAliasSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        agentAliasSummaries: [BedrockAgentClientTypes.AgentAliasSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentAliasSummaries = agentAliasSummaries
        self.nextToken = nextToken
    }
}

struct ListAgentAliasesOutputBody {
    let agentAliasSummaries: [BedrockAgentClientTypes.AgentAliasSummary]?
    let nextToken: Swift.String?
}

extension ListAgentAliasesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentAliasSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentAliasSummariesContainer = try containerValues.decodeIfPresent([BedrockAgentClientTypes.AgentAliasSummary?].self, forKey: .agentAliasSummaries)
        var agentAliasSummariesDecoded0:[BedrockAgentClientTypes.AgentAliasSummary]? = nil
        if let agentAliasSummariesContainer = agentAliasSummariesContainer {
            agentAliasSummariesDecoded0 = [BedrockAgentClientTypes.AgentAliasSummary]()
            for structure0 in agentAliasSummariesContainer {
                if let structure0 = structure0 {
                    agentAliasSummariesDecoded0?.append(structure0)
                }
            }
        }
        agentAliasSummaries = agentAliasSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAgentAliasesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAgentKnowledgeBasesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAgentKnowledgeBasesInput {

    static func urlPathProvider(_ value: ListAgentKnowledgeBasesInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/knowledgebases"
    }
}

public struct ListAgentKnowledgeBasesInput {
    /// The unique identifier of the agent for which to return information about knowledge bases associated with it.
    /// This member is required.
    public var agentId: Swift.String?
    /// The version of the agent for which to return information about knowledge bases associated with it.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAgentKnowledgeBasesInputBody {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAgentKnowledgeBasesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAgentKnowledgeBasesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAgentKnowledgeBasesOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentKnowledgeBaseSummaries = output.agentKnowledgeBaseSummaries
            self.nextToken = output.nextToken
        } else {
            self.agentKnowledgeBaseSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAgentKnowledgeBasesOutput {
    /// A list of objects, each of which contains information about a knowledge base associated with the agent.
    /// This member is required.
    public var agentKnowledgeBaseSummaries: [BedrockAgentClientTypes.AgentKnowledgeBaseSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        agentKnowledgeBaseSummaries: [BedrockAgentClientTypes.AgentKnowledgeBaseSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentKnowledgeBaseSummaries = agentKnowledgeBaseSummaries
        self.nextToken = nextToken
    }
}

struct ListAgentKnowledgeBasesOutputBody {
    let agentKnowledgeBaseSummaries: [BedrockAgentClientTypes.AgentKnowledgeBaseSummary]?
    let nextToken: Swift.String?
}

extension ListAgentKnowledgeBasesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentKnowledgeBaseSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentKnowledgeBaseSummariesContainer = try containerValues.decodeIfPresent([BedrockAgentClientTypes.AgentKnowledgeBaseSummary?].self, forKey: .agentKnowledgeBaseSummaries)
        var agentKnowledgeBaseSummariesDecoded0:[BedrockAgentClientTypes.AgentKnowledgeBaseSummary]? = nil
        if let agentKnowledgeBaseSummariesContainer = agentKnowledgeBaseSummariesContainer {
            agentKnowledgeBaseSummariesDecoded0 = [BedrockAgentClientTypes.AgentKnowledgeBaseSummary]()
            for structure0 in agentKnowledgeBaseSummariesContainer {
                if let structure0 = structure0 {
                    agentKnowledgeBaseSummariesDecoded0?.append(structure0)
                }
            }
        }
        agentKnowledgeBaseSummaries = agentKnowledgeBaseSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAgentKnowledgeBasesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAgentVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAgentVersionsInput {

    static func urlPathProvider(_ value: ListAgentVersionsInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions"
    }
}

public struct ListAgentVersionsInput {
    /// The unique identifier of the agent.
    /// This member is required.
    public var agentId: Swift.String?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        agentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentId = agentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAgentVersionsInputBody {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAgentVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAgentVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAgentVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentVersionSummaries = output.agentVersionSummaries
            self.nextToken = output.nextToken
        } else {
            self.agentVersionSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAgentVersionsOutput {
    /// A list of objects, each of which contains information about a version of the agent.
    /// This member is required.
    public var agentVersionSummaries: [BedrockAgentClientTypes.AgentVersionSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        agentVersionSummaries: [BedrockAgentClientTypes.AgentVersionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentVersionSummaries = agentVersionSummaries
        self.nextToken = nextToken
    }
}

struct ListAgentVersionsOutputBody {
    let agentVersionSummaries: [BedrockAgentClientTypes.AgentVersionSummary]?
    let nextToken: Swift.String?
}

extension ListAgentVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentVersionSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentVersionSummariesContainer = try containerValues.decodeIfPresent([BedrockAgentClientTypes.AgentVersionSummary?].self, forKey: .agentVersionSummaries)
        var agentVersionSummariesDecoded0:[BedrockAgentClientTypes.AgentVersionSummary]? = nil
        if let agentVersionSummariesContainer = agentVersionSummariesContainer {
            agentVersionSummariesDecoded0 = [BedrockAgentClientTypes.AgentVersionSummary]()
            for structure0 in agentVersionSummariesContainer {
                if let structure0 = structure0 {
                    agentVersionSummariesDecoded0?.append(structure0)
                }
            }
        }
        agentVersionSummaries = agentVersionSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAgentVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAgentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAgentsInput {

    static func urlPathProvider(_ value: ListAgentsInput) -> Swift.String? {
        return "/agents"
    }
}

public struct ListAgentsInput {
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAgentsInputBody {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAgentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAgentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAgentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentSummaries = output.agentSummaries
            self.nextToken = output.nextToken
        } else {
            self.agentSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAgentsOutput {
    /// A list of objects, each of which contains information about an agent.
    /// This member is required.
    public var agentSummaries: [BedrockAgentClientTypes.AgentSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        agentSummaries: [BedrockAgentClientTypes.AgentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentSummaries = agentSummaries
        self.nextToken = nextToken
    }
}

struct ListAgentsOutputBody {
    let agentSummaries: [BedrockAgentClientTypes.AgentSummary]?
    let nextToken: Swift.String?
}

extension ListAgentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentSummariesContainer = try containerValues.decodeIfPresent([BedrockAgentClientTypes.AgentSummary?].self, forKey: .agentSummaries)
        var agentSummariesDecoded0:[BedrockAgentClientTypes.AgentSummary]? = nil
        if let agentSummariesContainer = agentSummariesContainer {
            agentSummariesDecoded0 = [BedrockAgentClientTypes.AgentSummary]()
            for structure0 in agentSummariesContainer {
                if let structure0 = structure0 {
                    agentSummariesDecoded0?.append(structure0)
                }
            }
        }
        agentSummaries = agentSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAgentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDataSourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDataSourcesInput {

    static func urlPathProvider(_ value: ListDataSourcesInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/datasources"
    }
}

public struct ListDataSourcesInput {
    /// The unique identifier of the knowledge base for which to return a list of information.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDataSourcesInputBody {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListDataSourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDataSourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDataSourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataSourceSummaries = output.dataSourceSummaries
            self.nextToken = output.nextToken
        } else {
            self.dataSourceSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListDataSourcesOutput {
    /// A list of objects, each of which contains information about a data source.
    /// This member is required.
    public var dataSourceSummaries: [BedrockAgentClientTypes.DataSourceSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        dataSourceSummaries: [BedrockAgentClientTypes.DataSourceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataSourceSummaries = dataSourceSummaries
        self.nextToken = nextToken
    }
}

struct ListDataSourcesOutputBody {
    let dataSourceSummaries: [BedrockAgentClientTypes.DataSourceSummary]?
    let nextToken: Swift.String?
}

extension ListDataSourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceSummariesContainer = try containerValues.decodeIfPresent([BedrockAgentClientTypes.DataSourceSummary?].self, forKey: .dataSourceSummaries)
        var dataSourceSummariesDecoded0:[BedrockAgentClientTypes.DataSourceSummary]? = nil
        if let dataSourceSummariesContainer = dataSourceSummariesContainer {
            dataSourceSummariesDecoded0 = [BedrockAgentClientTypes.DataSourceSummary]()
            for structure0 in dataSourceSummariesContainer {
                if let structure0 = structure0 {
                    dataSourceSummariesDecoded0?.append(structure0)
                }
            }
        }
        dataSourceSummaries = dataSourceSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDataSourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListIngestionJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case sortBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for ingestionjobfilter0 in filters {
                try filtersContainer.encode(ingestionjobfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
    }
}

extension ListIngestionJobsInput {

    static func urlPathProvider(_ value: ListIngestionJobsInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let dataSourceId = value.dataSourceId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())/ingestionjobs"
    }
}

public struct ListIngestionJobsInput {
    /// The unique identifier of the data source for which to return ingestion jobs.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// Contains a definition of a filter for which to filter the results.
    public var filters: [BedrockAgentClientTypes.IngestionJobFilter]?
    /// The unique identifier of the knowledge base for which to return ingestion jobs.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?
    /// Contains details about how to sort the results.
    public var sortBy: BedrockAgentClientTypes.IngestionJobSortBy?

    public init(
        dataSourceId: Swift.String? = nil,
        filters: [BedrockAgentClientTypes.IngestionJobFilter]? = nil,
        knowledgeBaseId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: BedrockAgentClientTypes.IngestionJobSortBy? = nil
    )
    {
        self.dataSourceId = dataSourceId
        self.filters = filters
        self.knowledgeBaseId = knowledgeBaseId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
    }
}

struct ListIngestionJobsInputBody {
    let filters: [BedrockAgentClientTypes.IngestionJobFilter]?
    let sortBy: BedrockAgentClientTypes.IngestionJobSortBy?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListIngestionJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case sortBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([BedrockAgentClientTypes.IngestionJobFilter?].self, forKey: .filters)
        var filtersDecoded0:[BedrockAgentClientTypes.IngestionJobFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [BedrockAgentClientTypes.IngestionJobFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortByDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.IngestionJobSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListIngestionJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListIngestionJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.ingestionJobSummaries = output.ingestionJobSummaries
            self.nextToken = output.nextToken
        } else {
            self.ingestionJobSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListIngestionJobsOutput {
    /// A list of objects, each of which contains information about an ingestion job.
    /// This member is required.
    public var ingestionJobSummaries: [BedrockAgentClientTypes.IngestionJobSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        ingestionJobSummaries: [BedrockAgentClientTypes.IngestionJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ingestionJobSummaries = ingestionJobSummaries
        self.nextToken = nextToken
    }
}

struct ListIngestionJobsOutputBody {
    let ingestionJobSummaries: [BedrockAgentClientTypes.IngestionJobSummary]?
    let nextToken: Swift.String?
}

extension ListIngestionJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ingestionJobSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ingestionJobSummariesContainer = try containerValues.decodeIfPresent([BedrockAgentClientTypes.IngestionJobSummary?].self, forKey: .ingestionJobSummaries)
        var ingestionJobSummariesDecoded0:[BedrockAgentClientTypes.IngestionJobSummary]? = nil
        if let ingestionJobSummariesContainer = ingestionJobSummariesContainer {
            ingestionJobSummariesDecoded0 = [BedrockAgentClientTypes.IngestionJobSummary]()
            for structure0 in ingestionJobSummariesContainer {
                if let structure0 = structure0 {
                    ingestionJobSummariesDecoded0?.append(structure0)
                }
            }
        }
        ingestionJobSummaries = ingestionJobSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListIngestionJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListKnowledgeBasesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListKnowledgeBasesInput {

    static func urlPathProvider(_ value: ListKnowledgeBasesInput) -> Swift.String? {
        return "/knowledgebases"
    }
}

public struct ListKnowledgeBasesInput {
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListKnowledgeBasesInputBody {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListKnowledgeBasesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListKnowledgeBasesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListKnowledgeBasesOutputBody = try responseDecoder.decode(responseBody: data)
            self.knowledgeBaseSummaries = output.knowledgeBaseSummaries
            self.nextToken = output.nextToken
        } else {
            self.knowledgeBaseSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListKnowledgeBasesOutput {
    /// A list of objects, each of which contains information about a knowledge base.
    /// This member is required.
    public var knowledgeBaseSummaries: [BedrockAgentClientTypes.KnowledgeBaseSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        knowledgeBaseSummaries: [BedrockAgentClientTypes.KnowledgeBaseSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.knowledgeBaseSummaries = knowledgeBaseSummaries
        self.nextToken = nextToken
    }
}

struct ListKnowledgeBasesOutputBody {
    let knowledgeBaseSummaries: [BedrockAgentClientTypes.KnowledgeBaseSummary]?
    let nextToken: Swift.String?
}

extension ListKnowledgeBasesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knowledgeBaseSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseSummariesContainer = try containerValues.decodeIfPresent([BedrockAgentClientTypes.KnowledgeBaseSummary?].self, forKey: .knowledgeBaseSummaries)
        var knowledgeBaseSummariesDecoded0:[BedrockAgentClientTypes.KnowledgeBaseSummary]? = nil
        if let knowledgeBaseSummariesContainer = knowledgeBaseSummariesContainer {
            knowledgeBaseSummariesDecoded0 = [BedrockAgentClientTypes.KnowledgeBaseSummary]()
            for structure0 in knowledgeBaseSummariesContainer {
                if let structure0 = structure0 {
                    knowledgeBaseSummariesDecoded0?.append(structure0)
                }
            }
        }
        knowledgeBaseSummaries = knowledgeBaseSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListKnowledgeBasesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) of the resource for which to list tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput {
    /// The key-value pairs for the tags associated with the resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BedrockAgentClientTypes.MongoDbAtlasConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectionName
        case credentialsSecretArn
        case databaseName
        case endpoint
        case endpointServiceName
        case fieldMapping
        case vectorIndexName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collectionName = self.collectionName {
            try encodeContainer.encode(collectionName, forKey: .collectionName)
        }
        if let credentialsSecretArn = self.credentialsSecretArn {
            try encodeContainer.encode(credentialsSecretArn, forKey: .credentialsSecretArn)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let endpointServiceName = self.endpointServiceName {
            try encodeContainer.encode(endpointServiceName, forKey: .endpointServiceName)
        }
        if let fieldMapping = self.fieldMapping {
            try encodeContainer.encode(fieldMapping, forKey: .fieldMapping)
        }
        if let vectorIndexName = self.vectorIndexName {
            try encodeContainer.encode(vectorIndexName, forKey: .vectorIndexName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let collectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectionName)
        collectionName = collectionNameDecoded
        let vectorIndexNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vectorIndexName)
        vectorIndexName = vectorIndexNameDecoded
        let credentialsSecretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentialsSecretArn)
        credentialsSecretArn = credentialsSecretArnDecoded
        let fieldMappingDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.MongoDbAtlasFieldMapping.self, forKey: .fieldMapping)
        fieldMapping = fieldMappingDecoded
        let endpointServiceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointServiceName)
        endpointServiceName = endpointServiceNameDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about the storage configuration of the knowledge base in MongoDB Atlas.
    public struct MongoDbAtlasConfiguration {
        /// The collection name of the knowledge base in MongoDB Atlas.
        /// This member is required.
        public var collectionName: Swift.String?
        /// The Amazon Resource Name (ARN) of the secret that you created in Secrets Manager that contains user credentials for your MongoDB Atlas cluster.
        /// This member is required.
        public var credentialsSecretArn: Swift.String?
        /// The database name in your MongoDB Atlas cluster for your knowledge base.
        /// This member is required.
        public var databaseName: Swift.String?
        /// The endpoint URL of your MongoDB Atlas cluster for your knowledge base.
        /// This member is required.
        public var endpoint: Swift.String?
        /// The name of the VPC endpoint service in your account that is connected to your MongoDB Atlas cluster.
        public var endpointServiceName: Swift.String?
        /// Contains the names of the fields to which to map information about the vector store.
        /// This member is required.
        public var fieldMapping: BedrockAgentClientTypes.MongoDbAtlasFieldMapping?
        /// The name of the MongoDB Atlas vector search index.
        /// This member is required.
        public var vectorIndexName: Swift.String?

        public init(
            collectionName: Swift.String? = nil,
            credentialsSecretArn: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            endpoint: Swift.String? = nil,
            endpointServiceName: Swift.String? = nil,
            fieldMapping: BedrockAgentClientTypes.MongoDbAtlasFieldMapping? = nil,
            vectorIndexName: Swift.String? = nil
        )
        {
            self.collectionName = collectionName
            self.credentialsSecretArn = credentialsSecretArn
            self.databaseName = databaseName
            self.endpoint = endpoint
            self.endpointServiceName = endpointServiceName
            self.fieldMapping = fieldMapping
            self.vectorIndexName = vectorIndexName
        }
    }

}

extension BedrockAgentClientTypes.MongoDbAtlasFieldMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadataField
        case textField
        case vectorField
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadataField = self.metadataField {
            try encodeContainer.encode(metadataField, forKey: .metadataField)
        }
        if let textField = self.textField {
            try encodeContainer.encode(textField, forKey: .textField)
        }
        if let vectorField = self.vectorField {
            try encodeContainer.encode(vectorField, forKey: .vectorField)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vectorFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vectorField)
        vectorField = vectorFieldDecoded
        let textFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .textField)
        textField = textFieldDecoded
        let metadataFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadataField)
        metadataField = metadataFieldDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains the names of the fields to which to map information about the vector store.
    public struct MongoDbAtlasFieldMapping {
        /// The name of the field in which Amazon Bedrock stores metadata about the vector store.
        /// This member is required.
        public var metadataField: Swift.String?
        /// The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        /// This member is required.
        public var textField: Swift.String?
        /// The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        /// This member is required.
        public var vectorField: Swift.String?

        public init(
            metadataField: Swift.String? = nil,
            textField: Swift.String? = nil,
            vectorField: Swift.String? = nil
        )
        {
            self.metadataField = metadataField
            self.textField = textField
            self.vectorField = vectorField
        }
    }

}

extension BedrockAgentClientTypes.OpenSearchServerlessConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectionArn
        case fieldMapping
        case vectorIndexName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collectionArn = self.collectionArn {
            try encodeContainer.encode(collectionArn, forKey: .collectionArn)
        }
        if let fieldMapping = self.fieldMapping {
            try encodeContainer.encode(fieldMapping, forKey: .fieldMapping)
        }
        if let vectorIndexName = self.vectorIndexName {
            try encodeContainer.encode(vectorIndexName, forKey: .vectorIndexName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectionArn)
        collectionArn = collectionArnDecoded
        let vectorIndexNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vectorIndexName)
        vectorIndexName = vectorIndexNameDecoded
        let fieldMappingDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.OpenSearchServerlessFieldMapping.self, forKey: .fieldMapping)
        fieldMapping = fieldMappingDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about the storage configuration of the knowledge base in Amazon OpenSearch Service. For more information, see [Create a vector index in Amazon OpenSearch Service](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-oss.html).
    public struct OpenSearchServerlessConfiguration {
        /// The Amazon Resource Name (ARN) of the OpenSearch Service vector store.
        /// This member is required.
        public var collectionArn: Swift.String?
        /// Contains the names of the fields to which to map information about the vector store.
        /// This member is required.
        public var fieldMapping: BedrockAgentClientTypes.OpenSearchServerlessFieldMapping?
        /// The name of the vector store.
        /// This member is required.
        public var vectorIndexName: Swift.String?

        public init(
            collectionArn: Swift.String? = nil,
            fieldMapping: BedrockAgentClientTypes.OpenSearchServerlessFieldMapping? = nil,
            vectorIndexName: Swift.String? = nil
        )
        {
            self.collectionArn = collectionArn
            self.fieldMapping = fieldMapping
            self.vectorIndexName = vectorIndexName
        }
    }

}

extension BedrockAgentClientTypes.OpenSearchServerlessFieldMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadataField
        case textField
        case vectorField
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadataField = self.metadataField {
            try encodeContainer.encode(metadataField, forKey: .metadataField)
        }
        if let textField = self.textField {
            try encodeContainer.encode(textField, forKey: .textField)
        }
        if let vectorField = self.vectorField {
            try encodeContainer.encode(vectorField, forKey: .vectorField)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vectorFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vectorField)
        vectorField = vectorFieldDecoded
        let textFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .textField)
        textField = textFieldDecoded
        let metadataFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadataField)
        metadataField = metadataFieldDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains the names of the fields to which to map information about the vector store.
    public struct OpenSearchServerlessFieldMapping {
        /// The name of the field in which Amazon Bedrock stores metadata about the vector store.
        /// This member is required.
        public var metadataField: Swift.String?
        /// The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        /// This member is required.
        public var textField: Swift.String?
        /// The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        /// This member is required.
        public var vectorField: Swift.String?

        public init(
            metadataField: Swift.String? = nil,
            textField: Swift.String? = nil,
            vectorField: Swift.String? = nil
        )
        {
            self.metadataField = metadataField
            self.textField = textField
            self.vectorField = vectorField
        }
    }

}

extension BedrockAgentClientTypes.ParameterDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case `required` = "required"
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let `required` = self.`required` {
            try encodeContainer.encode(`required`, forKey: .`required`)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
        let requiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .required)
        `required` = requiredDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about a parameter in a function for an action group. This data type is used in the following API operations:
    ///
    /// * [CreateAgentActionGroup request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_CreateAgentActionGroup.html#API_agent_CreateAgentActionGroup_RequestSyntax)
    ///
    /// * [CreateAgentActionGroup response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_CreateAgentActionGroup.html#API_agent_CreateAgentActionGroup_ResponseSyntax)
    ///
    /// * [UpdateAgentActionGroup request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_UpdateAgentActionGroup.html#API_agent_UpdateAgentActionGroup_RequestSyntax)
    ///
    /// * [UpdateAgentActionGroup response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_UpdateAgentActionGroup.html#API_agent_UpdateAgentActionGroup_ResponseSyntax)
    ///
    /// * [GetAgentActionGroup response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_GetAgentActionGroup.html#API_agent_GetAgentActionGroup_ResponseSyntax)
    public struct ParameterDetail {
        /// A description of the parameter. Helps the foundation model determine how to elicit the parameters from the user.
        public var description: Swift.String?
        /// Whether the parameter is required for the agent to complete the function for action group invocation.
        public var `required`: Swift.Bool?
        /// The data type of the parameter.
        /// This member is required.
        public var type: BedrockAgentClientTypes.ModelType?

        public init(
            description: Swift.String? = nil,
            `required`: Swift.Bool? = nil,
            type: BedrockAgentClientTypes.ModelType? = nil
        )
        {
            self.description = description
            self.`required` = `required`
            self.type = type
        }
    }

}

extension BedrockAgentClientTypes.PineconeConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionString
        case credentialsSecretArn
        case fieldMapping
        case namespace
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionString = self.connectionString {
            try encodeContainer.encode(connectionString, forKey: .connectionString)
        }
        if let credentialsSecretArn = self.credentialsSecretArn {
            try encodeContainer.encode(credentialsSecretArn, forKey: .credentialsSecretArn)
        }
        if let fieldMapping = self.fieldMapping {
            try encodeContainer.encode(fieldMapping, forKey: .fieldMapping)
        }
        if let namespace = self.namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionString)
        connectionString = connectionStringDecoded
        let credentialsSecretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentialsSecretArn)
        credentialsSecretArn = credentialsSecretArnDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let fieldMappingDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.PineconeFieldMapping.self, forKey: .fieldMapping)
        fieldMapping = fieldMappingDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about the storage configuration of the knowledge base in Pinecone. For more information, see [Create a vector index in Pinecone](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-pinecone.html).
    public struct PineconeConfiguration {
        /// The endpoint URL for your index management page.
        /// This member is required.
        public var connectionString: Swift.String?
        /// The Amazon Resource Name (ARN) of the secret that you created in Secrets Manager that is linked to your Pinecone API key.
        /// This member is required.
        public var credentialsSecretArn: Swift.String?
        /// Contains the names of the fields to which to map information about the vector store.
        /// This member is required.
        public var fieldMapping: BedrockAgentClientTypes.PineconeFieldMapping?
        /// The namespace to be used to write new data to your database.
        public var namespace: Swift.String?

        public init(
            connectionString: Swift.String? = nil,
            credentialsSecretArn: Swift.String? = nil,
            fieldMapping: BedrockAgentClientTypes.PineconeFieldMapping? = nil,
            namespace: Swift.String? = nil
        )
        {
            self.connectionString = connectionString
            self.credentialsSecretArn = credentialsSecretArn
            self.fieldMapping = fieldMapping
            self.namespace = namespace
        }
    }

}

extension BedrockAgentClientTypes.PineconeFieldMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadataField
        case textField
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadataField = self.metadataField {
            try encodeContainer.encode(metadataField, forKey: .metadataField)
        }
        if let textField = self.textField {
            try encodeContainer.encode(textField, forKey: .textField)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .textField)
        textField = textFieldDecoded
        let metadataFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadataField)
        metadataField = metadataFieldDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains the names of the fields to which to map information about the vector store.
    public struct PineconeFieldMapping {
        /// The name of the field in which Amazon Bedrock stores metadata about the vector store.
        /// This member is required.
        public var metadataField: Swift.String?
        /// The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        /// This member is required.
        public var textField: Swift.String?

        public init(
            metadataField: Swift.String? = nil,
            textField: Swift.String? = nil
        )
        {
            self.metadataField = metadataField
            self.textField = textField
        }
    }

}

extension PrepareAgentInput {

    static func urlPathProvider(_ value: PrepareAgentInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())"
    }
}

public struct PrepareAgentInput {
    /// The unique identifier of the agent for which to create a DRAFT version.
    /// This member is required.
    public var agentId: Swift.String?

    public init(
        agentId: Swift.String? = nil
    )
    {
        self.agentId = agentId
    }
}

struct PrepareAgentInputBody {
}

extension PrepareAgentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension PrepareAgentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PrepareAgentOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentId = output.agentId
            self.agentStatus = output.agentStatus
            self.agentVersion = output.agentVersion
            self.preparedAt = output.preparedAt
        } else {
            self.agentId = nil
            self.agentStatus = nil
            self.agentVersion = nil
            self.preparedAt = nil
        }
    }
}

public struct PrepareAgentOutput {
    /// The unique identifier of the agent for which the DRAFT version was created.
    /// This member is required.
    public var agentId: Swift.String?
    /// The status of the DRAFT version and whether it is ready for use.
    /// This member is required.
    public var agentStatus: BedrockAgentClientTypes.AgentStatus?
    /// The version of the agent.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// The time at which the DRAFT version of the agent was last prepared.
    /// This member is required.
    public var preparedAt: ClientRuntime.Date?

    public init(
        agentId: Swift.String? = nil,
        agentStatus: BedrockAgentClientTypes.AgentStatus? = nil,
        agentVersion: Swift.String? = nil,
        preparedAt: ClientRuntime.Date? = nil
    )
    {
        self.agentId = agentId
        self.agentStatus = agentStatus
        self.agentVersion = agentVersion
        self.preparedAt = preparedAt
    }
}

struct PrepareAgentOutputBody {
    let agentId: Swift.String?
    let agentStatus: BedrockAgentClientTypes.AgentStatus?
    let agentVersion: Swift.String?
    let preparedAt: ClientRuntime.Date?
}

extension PrepareAgentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentId
        case agentStatus
        case agentVersion
        case preparedAt
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let agentStatusDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentStatus.self, forKey: .agentStatus)
        agentStatus = agentStatusDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
        let preparedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .preparedAt)
        preparedAt = preparedAtDecoded
    }
}

enum PrepareAgentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BedrockAgentClientTypes.PromptConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case basePromptTemplate
        case inferenceConfiguration
        case parserMode
        case promptCreationMode
        case promptState
        case promptType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let basePromptTemplate = self.basePromptTemplate {
            try encodeContainer.encode(basePromptTemplate, forKey: .basePromptTemplate)
        }
        if let inferenceConfiguration = self.inferenceConfiguration {
            try encodeContainer.encode(inferenceConfiguration, forKey: .inferenceConfiguration)
        }
        if let parserMode = self.parserMode {
            try encodeContainer.encode(parserMode.rawValue, forKey: .parserMode)
        }
        if let promptCreationMode = self.promptCreationMode {
            try encodeContainer.encode(promptCreationMode.rawValue, forKey: .promptCreationMode)
        }
        if let promptState = self.promptState {
            try encodeContainer.encode(promptState.rawValue, forKey: .promptState)
        }
        if let promptType = self.promptType {
            try encodeContainer.encode(promptType.rawValue, forKey: .promptType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let promptTypeDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.PromptType.self, forKey: .promptType)
        promptType = promptTypeDecoded
        let promptCreationModeDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.CreationMode.self, forKey: .promptCreationMode)
        promptCreationMode = promptCreationModeDecoded
        let promptStateDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.PromptState.self, forKey: .promptState)
        promptState = promptStateDecoded
        let basePromptTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .basePromptTemplate)
        basePromptTemplate = basePromptTemplateDecoded
        let inferenceConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.InferenceConfiguration.self, forKey: .inferenceConfiguration)
        inferenceConfiguration = inferenceConfigurationDecoded
        let parserModeDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.CreationMode.self, forKey: .parserMode)
        parserMode = parserModeDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains configurations to override a prompt template in one part of an agent sequence. For more information, see [Advanced prompts](https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts.html).
    public struct PromptConfiguration {
        /// Defines the prompt template with which to replace the default prompt template. You can use placeholder variables in the base prompt template to customize the prompt. For more information, see [Prompt template placeholder variables](https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-placeholders.html).
        public var basePromptTemplate: Swift.String?
        /// Contains inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the promptType. For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html).
        public var inferenceConfiguration: BedrockAgentClientTypes.InferenceConfiguration?
        /// Specifies whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the promptType. If you set the field as OVERRIDEN, the overrideLambda field in the [PromptOverrideConfiguration](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptOverrideConfiguration.html) must be specified with the ARN of a Lambda function.
        public var parserMode: BedrockAgentClientTypes.CreationMode?
        /// Specifies whether to override the default prompt template for this promptType. Set this value to OVERRIDDEN to use the prompt that you provide in the basePromptTemplate. If you leave it as DEFAULT, the agent uses a default prompt template.
        public var promptCreationMode: BedrockAgentClientTypes.CreationMode?
        /// Specifies whether to allow the agent to carry out the step specified in the promptType. If you set this value to DISABLED, the agent skips that step. The default state for each promptType is as follows.
        ///
        /// * PRE_PROCESSING – ENABLED
        ///
        /// * ORCHESTRATION – ENABLED
        ///
        /// * KNOWLEDGE_BASE_RESPONSE_GENERATION – ENABLED
        ///
        /// * POST_PROCESSING – DISABLED
        public var promptState: BedrockAgentClientTypes.PromptState?
        /// The step in the agent sequence that this prompt configuration applies to.
        public var promptType: BedrockAgentClientTypes.PromptType?

        public init(
            basePromptTemplate: Swift.String? = nil,
            inferenceConfiguration: BedrockAgentClientTypes.InferenceConfiguration? = nil,
            parserMode: BedrockAgentClientTypes.CreationMode? = nil,
            promptCreationMode: BedrockAgentClientTypes.CreationMode? = nil,
            promptState: BedrockAgentClientTypes.PromptState? = nil,
            promptType: BedrockAgentClientTypes.PromptType? = nil
        )
        {
            self.basePromptTemplate = basePromptTemplate
            self.inferenceConfiguration = inferenceConfiguration
            self.parserMode = parserMode
            self.promptCreationMode = promptCreationMode
            self.promptState = promptState
            self.promptType = promptType
        }
    }

}

extension BedrockAgentClientTypes.PromptOverrideConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case overrideLambda
        case promptConfigurations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let overrideLambda = self.overrideLambda {
            try encodeContainer.encode(overrideLambda, forKey: .overrideLambda)
        }
        if let promptConfigurations = promptConfigurations {
            var promptConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .promptConfigurations)
            for promptconfiguration0 in promptConfigurations {
                try promptConfigurationsContainer.encode(promptconfiguration0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let promptConfigurationsContainer = try containerValues.decodeIfPresent([BedrockAgentClientTypes.PromptConfiguration?].self, forKey: .promptConfigurations)
        var promptConfigurationsDecoded0:[BedrockAgentClientTypes.PromptConfiguration]? = nil
        if let promptConfigurationsContainer = promptConfigurationsContainer {
            promptConfigurationsDecoded0 = [BedrockAgentClientTypes.PromptConfiguration]()
            for structure0 in promptConfigurationsContainer {
                if let structure0 = structure0 {
                    promptConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        promptConfigurations = promptConfigurationsDecoded0
        let overrideLambdaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .overrideLambda)
        overrideLambda = overrideLambdaDecoded
    }
}

extension BedrockAgentClientTypes.PromptOverrideConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentClientTypes {
    /// Contains configurations to override prompts in different parts of an agent sequence. For more information, see [Advanced prompts](https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts.html).
    public struct PromptOverrideConfiguration {
        /// The ARN of the Lambda function to use when parsing the raw foundation model output in parts of the agent sequence. If you specify this field, at least one of the promptConfigurations must contain a parserMode value that is set to OVERRIDDEN.
        public var overrideLambda: Swift.String?
        /// Contains configurations to override a prompt template in one part of an agent sequence. For more information, see [Advanced prompts](https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts.html).
        /// This member is required.
        public var promptConfigurations: [BedrockAgentClientTypes.PromptConfiguration]?

        public init(
            overrideLambda: Swift.String? = nil,
            promptConfigurations: [BedrockAgentClientTypes.PromptConfiguration]? = nil
        )
        {
            self.overrideLambda = overrideLambda
            self.promptConfigurations = promptConfigurations
        }
    }

}

extension BedrockAgentClientTypes {
    public enum PromptState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PromptState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PromptState(rawValue: rawValue) ?? PromptState.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentClientTypes {
    public enum PromptType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case knowledgeBaseResponseGeneration
        case orchestration
        case postProcessing
        case preProcessing
        case sdkUnknown(Swift.String)

        public static var allCases: [PromptType] {
            return [
                .knowledgeBaseResponseGeneration,
                .orchestration,
                .postProcessing,
                .preProcessing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .knowledgeBaseResponseGeneration: return "KNOWLEDGE_BASE_RESPONSE_GENERATION"
            case .orchestration: return "ORCHESTRATION"
            case .postProcessing: return "POST_PROCESSING"
            case .preProcessing: return "PRE_PROCESSING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PromptType(rawValue: rawValue) ?? PromptType.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentClientTypes.RdsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentialsSecretArn
        case databaseName
        case fieldMapping
        case resourceArn
        case tableName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let credentialsSecretArn = self.credentialsSecretArn {
            try encodeContainer.encode(credentialsSecretArn, forKey: .credentialsSecretArn)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let fieldMapping = self.fieldMapping {
            try encodeContainer.encode(fieldMapping, forKey: .fieldMapping)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let credentialsSecretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentialsSecretArn)
        credentialsSecretArn = credentialsSecretArnDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let fieldMappingDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.RdsFieldMapping.self, forKey: .fieldMapping)
        fieldMapping = fieldMappingDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about the storage configuration of the knowledge base in Amazon RDS. For more information, see [Create a vector index in Amazon RDS](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-rds.html).
    public struct RdsConfiguration {
        /// The Amazon Resource Name (ARN) of the secret that you created in Secrets Manager that is linked to your Amazon RDS database.
        /// This member is required.
        public var credentialsSecretArn: Swift.String?
        /// The name of your Amazon RDS database.
        /// This member is required.
        public var databaseName: Swift.String?
        /// Contains the names of the fields to which to map information about the vector store.
        /// This member is required.
        public var fieldMapping: BedrockAgentClientTypes.RdsFieldMapping?
        /// The Amazon Resource Name (ARN) of the vector store.
        /// This member is required.
        public var resourceArn: Swift.String?
        /// The name of the table in the database.
        /// This member is required.
        public var tableName: Swift.String?

        public init(
            credentialsSecretArn: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            fieldMapping: BedrockAgentClientTypes.RdsFieldMapping? = nil,
            resourceArn: Swift.String? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.credentialsSecretArn = credentialsSecretArn
            self.databaseName = databaseName
            self.fieldMapping = fieldMapping
            self.resourceArn = resourceArn
            self.tableName = tableName
        }
    }

}

extension BedrockAgentClientTypes.RdsFieldMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadataField
        case primaryKeyField
        case textField
        case vectorField
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadataField = self.metadataField {
            try encodeContainer.encode(metadataField, forKey: .metadataField)
        }
        if let primaryKeyField = self.primaryKeyField {
            try encodeContainer.encode(primaryKeyField, forKey: .primaryKeyField)
        }
        if let textField = self.textField {
            try encodeContainer.encode(textField, forKey: .textField)
        }
        if let vectorField = self.vectorField {
            try encodeContainer.encode(vectorField, forKey: .vectorField)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let primaryKeyFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryKeyField)
        primaryKeyField = primaryKeyFieldDecoded
        let vectorFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vectorField)
        vectorField = vectorFieldDecoded
        let textFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .textField)
        textField = textFieldDecoded
        let metadataFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadataField)
        metadataField = metadataFieldDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains the names of the fields to which to map information about the vector store.
    public struct RdsFieldMapping {
        /// The name of the field in which Amazon Bedrock stores metadata about the vector store.
        /// This member is required.
        public var metadataField: Swift.String?
        /// The name of the field in which Amazon Bedrock stores the ID for each entry.
        /// This member is required.
        public var primaryKeyField: Swift.String?
        /// The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        /// This member is required.
        public var textField: Swift.String?
        /// The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        /// This member is required.
        public var vectorField: Swift.String?

        public init(
            metadataField: Swift.String? = nil,
            primaryKeyField: Swift.String? = nil,
            textField: Swift.String? = nil,
            vectorField: Swift.String? = nil
        )
        {
            self.metadataField = metadataField
            self.primaryKeyField = primaryKeyField
            self.textField = textField
            self.vectorField = vectorField
        }
    }

}

extension BedrockAgentClientTypes.RedisEnterpriseCloudConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentialsSecretArn
        case endpoint
        case fieldMapping
        case vectorIndexName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let credentialsSecretArn = self.credentialsSecretArn {
            try encodeContainer.encode(credentialsSecretArn, forKey: .credentialsSecretArn)
        }
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let fieldMapping = self.fieldMapping {
            try encodeContainer.encode(fieldMapping, forKey: .fieldMapping)
        }
        if let vectorIndexName = self.vectorIndexName {
            try encodeContainer.encode(vectorIndexName, forKey: .vectorIndexName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let vectorIndexNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vectorIndexName)
        vectorIndexName = vectorIndexNameDecoded
        let credentialsSecretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentialsSecretArn)
        credentialsSecretArn = credentialsSecretArnDecoded
        let fieldMappingDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.RedisEnterpriseCloudFieldMapping.self, forKey: .fieldMapping)
        fieldMapping = fieldMappingDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about the storage configuration of the knowledge base in Redis Enterprise Cloud. For more information, see [Create a vector index in Redis Enterprise Cloud](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-oss.html).
    public struct RedisEnterpriseCloudConfiguration {
        /// The Amazon Resource Name (ARN) of the secret that you created in Secrets Manager that is linked to your Redis Enterprise Cloud database.
        /// This member is required.
        public var credentialsSecretArn: Swift.String?
        /// The endpoint URL of the Redis Enterprise Cloud database.
        /// This member is required.
        public var endpoint: Swift.String?
        /// Contains the names of the fields to which to map information about the vector store.
        /// This member is required.
        public var fieldMapping: BedrockAgentClientTypes.RedisEnterpriseCloudFieldMapping?
        /// The name of the vector index.
        /// This member is required.
        public var vectorIndexName: Swift.String?

        public init(
            credentialsSecretArn: Swift.String? = nil,
            endpoint: Swift.String? = nil,
            fieldMapping: BedrockAgentClientTypes.RedisEnterpriseCloudFieldMapping? = nil,
            vectorIndexName: Swift.String? = nil
        )
        {
            self.credentialsSecretArn = credentialsSecretArn
            self.endpoint = endpoint
            self.fieldMapping = fieldMapping
            self.vectorIndexName = vectorIndexName
        }
    }

}

extension BedrockAgentClientTypes.RedisEnterpriseCloudFieldMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadataField
        case textField
        case vectorField
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadataField = self.metadataField {
            try encodeContainer.encode(metadataField, forKey: .metadataField)
        }
        if let textField = self.textField {
            try encodeContainer.encode(textField, forKey: .textField)
        }
        if let vectorField = self.vectorField {
            try encodeContainer.encode(vectorField, forKey: .vectorField)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vectorFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vectorField)
        vectorField = vectorFieldDecoded
        let textFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .textField)
        textField = textFieldDecoded
        let metadataFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadataField)
        metadataField = metadataFieldDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains the names of the fields to which to map information about the vector store.
    public struct RedisEnterpriseCloudFieldMapping {
        /// The name of the field in which Amazon Bedrock stores metadata about the vector store.
        /// This member is required.
        public var metadataField: Swift.String?
        /// The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        /// This member is required.
        public var textField: Swift.String?
        /// The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        /// This member is required.
        public var vectorField: Swift.String?

        public init(
            metadataField: Swift.String? = nil,
            textField: Swift.String? = nil,
            vectorField: Swift.String? = nil
        )
        {
            self.metadataField = metadataField
            self.textField = textField
            self.vectorField = vectorField
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource Amazon Resource Name (ARN) was not found. Check the Amazon Resource Name (ARN) and try your request again.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BedrockAgentClientTypes.S3DataSourceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketArn
        case bucketOwnerAccountId
        case inclusionPrefixes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketArn = self.bucketArn {
            try encodeContainer.encode(bucketArn, forKey: .bucketArn)
        }
        if let bucketOwnerAccountId = self.bucketOwnerAccountId {
            try encodeContainer.encode(bucketOwnerAccountId, forKey: .bucketOwnerAccountId)
        }
        if let inclusionPrefixes = inclusionPrefixes {
            var inclusionPrefixesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inclusionPrefixes)
            for s3prefix0 in inclusionPrefixes {
                try inclusionPrefixesContainer.encode(s3prefix0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketArn)
        bucketArn = bucketArnDecoded
        let inclusionPrefixesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .inclusionPrefixes)
        var inclusionPrefixesDecoded0:[Swift.String]? = nil
        if let inclusionPrefixesContainer = inclusionPrefixesContainer {
            inclusionPrefixesDecoded0 = [Swift.String]()
            for string0 in inclusionPrefixesContainer {
                if let string0 = string0 {
                    inclusionPrefixesDecoded0?.append(string0)
                }
            }
        }
        inclusionPrefixes = inclusionPrefixesDecoded0
        let bucketOwnerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketOwnerAccountId)
        bucketOwnerAccountId = bucketOwnerAccountIdDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains information about the S3 configuration of the data source.
    public struct S3DataSourceConfiguration {
        /// The Amazon Resource Name (ARN) of the bucket that contains the data source.
        /// This member is required.
        public var bucketArn: Swift.String?
        /// The bucket account owner ID for the S3 bucket.
        public var bucketOwnerAccountId: Swift.String?
        /// A list of S3 prefixes that define the object containing the data sources. For more information, see [Organizing objects using prefixes](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-prefixes.html).
        public var inclusionPrefixes: [Swift.String]?

        public init(
            bucketArn: Swift.String? = nil,
            bucketOwnerAccountId: Swift.String? = nil,
            inclusionPrefixes: [Swift.String]? = nil
        )
        {
            self.bucketArn = bucketArn
            self.bucketOwnerAccountId = bucketOwnerAccountId
            self.inclusionPrefixes = inclusionPrefixes
        }
    }

}

extension BedrockAgentClientTypes.S3Identifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3BucketName
        case s3ObjectKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3ObjectKey = self.s3ObjectKey {
            try encodeContainer.encode(s3ObjectKey, forKey: .s3ObjectKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3ObjectKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3ObjectKey)
        s3ObjectKey = s3ObjectKeyDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains information about the S3 object containing the resource.
    public struct S3Identifier {
        /// The name of the S3 bucket.
        public var s3BucketName: Swift.String?
        /// The S3 object key containing the resource.
        public var s3ObjectKey: Swift.String?

        public init(
            s3BucketName: Swift.String? = nil,
            s3ObjectKey: Swift.String? = nil
        )
        {
            self.s3BucketName = s3BucketName
            self.s3ObjectKey = s3ObjectKey
        }
    }

}

extension BedrockAgentClientTypes.ServerSideEncryptionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains the configuration for server-side encryption.
    public struct ServerSideEncryptionConfiguration {
        /// The Amazon Resource Name (ARN) of the KMS key used to encrypt the resource.
        public var kmsKeyArn: Swift.String?

        public init(
            kmsKeyArn: Swift.String? = nil
        )
        {
            self.kmsKeyArn = kmsKeyArn
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of requests exceeds the service quota. Resubmit your request later.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BedrockAgentClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension StartIngestionJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension StartIngestionJobInput {

    static func urlPathProvider(_ value: StartIngestionJobInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let dataSourceId = value.dataSourceId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())/ingestionjobs"
    }
}

public struct StartIngestionJobInput {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The unique identifier of the data source to ingest.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// A description of the ingestion job.
    public var description: Swift.String?
    /// The unique identifier of the knowledge base to which to add the data source.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        description: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.dataSourceId = dataSourceId
        self.description = description
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct StartIngestionJobInputBody {
    let clientToken: Swift.String?
    let description: Swift.String?
}

extension StartIngestionJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension StartIngestionJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartIngestionJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.ingestionJob = output.ingestionJob
        } else {
            self.ingestionJob = nil
        }
    }
}

public struct StartIngestionJobOutput {
    /// An object containing information about the ingestion job.
    /// This member is required.
    public var ingestionJob: BedrockAgentClientTypes.IngestionJob?

    public init(
        ingestionJob: BedrockAgentClientTypes.IngestionJob? = nil
    )
    {
        self.ingestionJob = ingestionJob
    }
}

struct StartIngestionJobOutputBody {
    let ingestionJob: BedrockAgentClientTypes.IngestionJob?
}

extension StartIngestionJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ingestionJob
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ingestionJobDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.IngestionJob.self, forKey: .ingestionJob)
        ingestionJob = ingestionJobDecoded
    }
}

enum StartIngestionJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BedrockAgentClientTypes.StorageConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mongoDbAtlasConfiguration
        case opensearchServerlessConfiguration
        case pineconeConfiguration
        case rdsConfiguration
        case redisEnterpriseCloudConfiguration
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mongoDbAtlasConfiguration = self.mongoDbAtlasConfiguration {
            try encodeContainer.encode(mongoDbAtlasConfiguration, forKey: .mongoDbAtlasConfiguration)
        }
        if let opensearchServerlessConfiguration = self.opensearchServerlessConfiguration {
            try encodeContainer.encode(opensearchServerlessConfiguration, forKey: .opensearchServerlessConfiguration)
        }
        if let pineconeConfiguration = self.pineconeConfiguration {
            try encodeContainer.encode(pineconeConfiguration, forKey: .pineconeConfiguration)
        }
        if let rdsConfiguration = self.rdsConfiguration {
            try encodeContainer.encode(rdsConfiguration, forKey: .rdsConfiguration)
        }
        if let redisEnterpriseCloudConfiguration = self.redisEnterpriseCloudConfiguration {
            try encodeContainer.encode(redisEnterpriseCloudConfiguration, forKey: .redisEnterpriseCloudConfiguration)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.KnowledgeBaseStorageType.self, forKey: .type)
        type = typeDecoded
        let opensearchServerlessConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.OpenSearchServerlessConfiguration.self, forKey: .opensearchServerlessConfiguration)
        opensearchServerlessConfiguration = opensearchServerlessConfigurationDecoded
        let pineconeConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.PineconeConfiguration.self, forKey: .pineconeConfiguration)
        pineconeConfiguration = pineconeConfigurationDecoded
        let redisEnterpriseCloudConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.RedisEnterpriseCloudConfiguration.self, forKey: .redisEnterpriseCloudConfiguration)
        redisEnterpriseCloudConfiguration = redisEnterpriseCloudConfigurationDecoded
        let rdsConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.RdsConfiguration.self, forKey: .rdsConfiguration)
        rdsConfiguration = rdsConfigurationDecoded
        let mongoDbAtlasConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.MongoDbAtlasConfiguration.self, forKey: .mongoDbAtlasConfiguration)
        mongoDbAtlasConfiguration = mongoDbAtlasConfigurationDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains the storage configuration of the knowledge base.
    public struct StorageConfiguration {
        /// Contains the storage configuration of the knowledge base in MongoDB Atlas.
        public var mongoDbAtlasConfiguration: BedrockAgentClientTypes.MongoDbAtlasConfiguration?
        /// Contains the storage configuration of the knowledge base in Amazon OpenSearch Service.
        public var opensearchServerlessConfiguration: BedrockAgentClientTypes.OpenSearchServerlessConfiguration?
        /// Contains the storage configuration of the knowledge base in Pinecone.
        public var pineconeConfiguration: BedrockAgentClientTypes.PineconeConfiguration?
        /// Contains details about the storage configuration of the knowledge base in Amazon RDS. For more information, see [Create a vector index in Amazon RDS](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-rds.html).
        public var rdsConfiguration: BedrockAgentClientTypes.RdsConfiguration?
        /// Contains the storage configuration of the knowledge base in Redis Enterprise Cloud.
        public var redisEnterpriseCloudConfiguration: BedrockAgentClientTypes.RedisEnterpriseCloudConfiguration?
        /// The vector store service in which the knowledge base is stored.
        /// This member is required.
        public var type: BedrockAgentClientTypes.KnowledgeBaseStorageType?

        public init(
            mongoDbAtlasConfiguration: BedrockAgentClientTypes.MongoDbAtlasConfiguration? = nil,
            opensearchServerlessConfiguration: BedrockAgentClientTypes.OpenSearchServerlessConfiguration? = nil,
            pineconeConfiguration: BedrockAgentClientTypes.PineconeConfiguration? = nil,
            rdsConfiguration: BedrockAgentClientTypes.RdsConfiguration? = nil,
            redisEnterpriseCloudConfiguration: BedrockAgentClientTypes.RedisEnterpriseCloudConfiguration? = nil,
            type: BedrockAgentClientTypes.KnowledgeBaseStorageType? = nil
        )
        {
            self.mongoDbAtlasConfiguration = mongoDbAtlasConfiguration
            self.opensearchServerlessConfiguration = opensearchServerlessConfiguration
            self.pineconeConfiguration = pineconeConfiguration
            self.rdsConfiguration = rdsConfiguration
            self.redisEnterpriseCloudConfiguration = redisEnterpriseCloudConfiguration
            self.type = type
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// An object containing key-value pairs that define the tags to attach to the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of requests exceeds the limit. Resubmit your request later.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BedrockAgentClientTypes {
    public enum ModelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case array
        case boolean
        case integer
        case number
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelType] {
            return [
                .array,
                .boolean,
                .integer,
                .number,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .array: return "array"
            case .boolean: return "boolean"
            case .integer: return "integer"
            case .number: return "number"
            case .string: return "string"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelType(rawValue: rawValue) ?? ModelType.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource from which to remove tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of keys of the tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAgentActionGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionGroupExecutor
        case actionGroupName
        case actionGroupState
        case apiSchema
        case description
        case functionSchema
        case parentActionGroupSignature
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionGroupExecutor = self.actionGroupExecutor {
            try encodeContainer.encode(actionGroupExecutor, forKey: .actionGroupExecutor)
        }
        if let actionGroupName = self.actionGroupName {
            try encodeContainer.encode(actionGroupName, forKey: .actionGroupName)
        }
        if let actionGroupState = self.actionGroupState {
            try encodeContainer.encode(actionGroupState.rawValue, forKey: .actionGroupState)
        }
        if let apiSchema = self.apiSchema {
            try encodeContainer.encode(apiSchema, forKey: .apiSchema)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let functionSchema = self.functionSchema {
            try encodeContainer.encode(functionSchema, forKey: .functionSchema)
        }
        if let parentActionGroupSignature = self.parentActionGroupSignature {
            try encodeContainer.encode(parentActionGroupSignature.rawValue, forKey: .parentActionGroupSignature)
        }
    }
}

extension UpdateAgentActionGroupInput {

    static func urlPathProvider(_ value: UpdateAgentActionGroupInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        guard let actionGroupId = value.actionGroupId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/actiongroups/\(actionGroupId.urlPercentEncoding())"
    }
}

public struct UpdateAgentActionGroupInput {
    /// The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action.
    public var actionGroupExecutor: BedrockAgentClientTypes.ActionGroupExecutor?
    /// The unique identifier of the action group.
    /// This member is required.
    public var actionGroupId: Swift.String?
    /// Specifies a new name for the action group.
    /// This member is required.
    public var actionGroupName: Swift.String?
    /// Specifies whether the action group is available for the agent to invoke or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
    public var actionGroupState: BedrockAgentClientTypes.ActionGroupState?
    /// The unique identifier of the agent for which to update the action group.
    /// This member is required.
    public var agentId: Swift.String?
    /// The unique identifier of the agent version for which to update the action group.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted payload defining the schema. For more information, see [Action group OpenAPI schemas](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-api-schema.html).
    public var apiSchema: BedrockAgentClientTypes.APISchema?
    /// Specifies a new name for the action group.
    public var description: Swift.String?
    /// Contains details about the function schema for the action group or the JSON or YAML-formatted payload defining the schema.
    public var functionSchema: BedrockAgentClientTypes.FunctionSchema?
    /// To allow your agent to request the user for additional information when trying to complete a task, set this field to AMAZON.UserInput. You must leave the description, apiSchema, and actionGroupExecutor fields blank for this action group. During orchestration, if your agent determines that it needs to invoke an API in an action group, but doesn't have enough information to complete the API request, it will invoke this action group instead and return an [Observation](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Observation.html) reprompting the user for more information.
    public var parentActionGroupSignature: BedrockAgentClientTypes.ActionGroupSignature?

    public init(
        actionGroupExecutor: BedrockAgentClientTypes.ActionGroupExecutor? = nil,
        actionGroupId: Swift.String? = nil,
        actionGroupName: Swift.String? = nil,
        actionGroupState: BedrockAgentClientTypes.ActionGroupState? = nil,
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        apiSchema: BedrockAgentClientTypes.APISchema? = nil,
        description: Swift.String? = nil,
        functionSchema: BedrockAgentClientTypes.FunctionSchema? = nil,
        parentActionGroupSignature: BedrockAgentClientTypes.ActionGroupSignature? = nil
    )
    {
        self.actionGroupExecutor = actionGroupExecutor
        self.actionGroupId = actionGroupId
        self.actionGroupName = actionGroupName
        self.actionGroupState = actionGroupState
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.apiSchema = apiSchema
        self.description = description
        self.functionSchema = functionSchema
        self.parentActionGroupSignature = parentActionGroupSignature
    }
}

struct UpdateAgentActionGroupInputBody {
    let actionGroupName: Swift.String?
    let description: Swift.String?
    let parentActionGroupSignature: BedrockAgentClientTypes.ActionGroupSignature?
    let actionGroupExecutor: BedrockAgentClientTypes.ActionGroupExecutor?
    let actionGroupState: BedrockAgentClientTypes.ActionGroupState?
    let apiSchema: BedrockAgentClientTypes.APISchema?
    let functionSchema: BedrockAgentClientTypes.FunctionSchema?
}

extension UpdateAgentActionGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionGroupExecutor
        case actionGroupName
        case actionGroupState
        case apiSchema
        case description
        case functionSchema
        case parentActionGroupSignature
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionGroupName)
        actionGroupName = actionGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parentActionGroupSignatureDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.ActionGroupSignature.self, forKey: .parentActionGroupSignature)
        parentActionGroupSignature = parentActionGroupSignatureDecoded
        let actionGroupExecutorDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.ActionGroupExecutor.self, forKey: .actionGroupExecutor)
        actionGroupExecutor = actionGroupExecutorDecoded
        let actionGroupStateDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.ActionGroupState.self, forKey: .actionGroupState)
        actionGroupState = actionGroupStateDecoded
        let apiSchemaDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.APISchema.self, forKey: .apiSchema)
        apiSchema = apiSchemaDecoded
        let functionSchemaDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.FunctionSchema.self, forKey: .functionSchema)
        functionSchema = functionSchemaDecoded
    }
}

extension UpdateAgentActionGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAgentActionGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentActionGroup = output.agentActionGroup
        } else {
            self.agentActionGroup = nil
        }
    }
}

public struct UpdateAgentActionGroupOutput {
    /// Contains details about the action group that was updated.
    /// This member is required.
    public var agentActionGroup: BedrockAgentClientTypes.AgentActionGroup?

    public init(
        agentActionGroup: BedrockAgentClientTypes.AgentActionGroup? = nil
    )
    {
        self.agentActionGroup = agentActionGroup
    }
}

struct UpdateAgentActionGroupOutputBody {
    let agentActionGroup: BedrockAgentClientTypes.AgentActionGroup?
}

extension UpdateAgentActionGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentActionGroup
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentActionGroupDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentActionGroup.self, forKey: .agentActionGroup)
        agentActionGroup = agentActionGroupDecoded
    }
}

enum UpdateAgentActionGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAgentAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentAliasName
        case description
        case routingConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentAliasName = self.agentAliasName {
            try encodeContainer.encode(agentAliasName, forKey: .agentAliasName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let routingConfiguration = routingConfiguration {
            var routingConfigurationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .routingConfiguration)
            for agentaliasroutingconfigurationlistitem0 in routingConfiguration {
                try routingConfigurationContainer.encode(agentaliasroutingconfigurationlistitem0)
            }
        }
    }
}

extension UpdateAgentAliasInput {

    static func urlPathProvider(_ value: UpdateAgentAliasInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentAliasId = value.agentAliasId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentaliases/\(agentAliasId.urlPercentEncoding())"
    }
}

public struct UpdateAgentAliasInput {
    /// The unique identifier of the alias.
    /// This member is required.
    public var agentAliasId: Swift.String?
    /// Specifies a new name for the alias.
    /// This member is required.
    public var agentAliasName: Swift.String?
    /// The unique identifier of the agent.
    /// This member is required.
    public var agentId: Swift.String?
    /// Specifies a new description for the alias.
    public var description: Swift.String?
    /// Contains details about the routing configuration of the alias.
    public var routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]?

    public init(
        agentAliasId: Swift.String? = nil,
        agentAliasName: Swift.String? = nil,
        agentId: Swift.String? = nil,
        description: Swift.String? = nil,
        routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]? = nil
    )
    {
        self.agentAliasId = agentAliasId
        self.agentAliasName = agentAliasName
        self.agentId = agentId
        self.description = description
        self.routingConfiguration = routingConfiguration
    }
}

struct UpdateAgentAliasInputBody {
    let agentAliasName: Swift.String?
    let description: Swift.String?
    let routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]?
}

extension UpdateAgentAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentAliasName
        case description
        case routingConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentAliasNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentAliasName)
        agentAliasName = agentAliasNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let routingConfigurationContainer = try containerValues.decodeIfPresent([BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem?].self, forKey: .routingConfiguration)
        var routingConfigurationDecoded0:[BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]? = nil
        if let routingConfigurationContainer = routingConfigurationContainer {
            routingConfigurationDecoded0 = [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]()
            for structure0 in routingConfigurationContainer {
                if let structure0 = structure0 {
                    routingConfigurationDecoded0?.append(structure0)
                }
            }
        }
        routingConfiguration = routingConfigurationDecoded0
    }
}

extension UpdateAgentAliasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAgentAliasOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentAlias = output.agentAlias
        } else {
            self.agentAlias = nil
        }
    }
}

public struct UpdateAgentAliasOutput {
    /// Contains details about the alias that was updated.
    /// This member is required.
    public var agentAlias: BedrockAgentClientTypes.AgentAlias?

    public init(
        agentAlias: BedrockAgentClientTypes.AgentAlias? = nil
    )
    {
        self.agentAlias = agentAlias
    }
}

struct UpdateAgentAliasOutputBody {
    let agentAlias: BedrockAgentClientTypes.AgentAlias?
}

extension UpdateAgentAliasOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentAlias
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentAliasDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentAlias.self, forKey: .agentAlias)
        agentAlias = agentAliasDecoded
    }
}

enum UpdateAgentAliasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAgentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAgentInput(agentId: \(Swift.String(describing: agentId)), agentName: \(Swift.String(describing: agentName)), agentResourceRoleArn: \(Swift.String(describing: agentResourceRoleArn)), customerEncryptionKeyArn: \(Swift.String(describing: customerEncryptionKeyArn)), description: \(Swift.String(describing: description)), foundationModel: \(Swift.String(describing: foundationModel)), idleSessionTTLInSeconds: \(Swift.String(describing: idleSessionTTLInSeconds)), instruction: \"CONTENT_REDACTED\", promptOverrideConfiguration: \"CONTENT_REDACTED\")"}
}

extension UpdateAgentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentName
        case agentResourceRoleArn
        case customerEncryptionKeyArn
        case description
        case foundationModel
        case idleSessionTTLInSeconds
        case instruction
        case promptOverrideConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentName = self.agentName {
            try encodeContainer.encode(agentName, forKey: .agentName)
        }
        if let agentResourceRoleArn = self.agentResourceRoleArn {
            try encodeContainer.encode(agentResourceRoleArn, forKey: .agentResourceRoleArn)
        }
        if let customerEncryptionKeyArn = self.customerEncryptionKeyArn {
            try encodeContainer.encode(customerEncryptionKeyArn, forKey: .customerEncryptionKeyArn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let foundationModel = self.foundationModel {
            try encodeContainer.encode(foundationModel, forKey: .foundationModel)
        }
        if let idleSessionTTLInSeconds = self.idleSessionTTLInSeconds {
            try encodeContainer.encode(idleSessionTTLInSeconds, forKey: .idleSessionTTLInSeconds)
        }
        if let instruction = self.instruction {
            try encodeContainer.encode(instruction, forKey: .instruction)
        }
        if let promptOverrideConfiguration = self.promptOverrideConfiguration {
            try encodeContainer.encode(promptOverrideConfiguration, forKey: .promptOverrideConfiguration)
        }
    }
}

extension UpdateAgentInput {

    static func urlPathProvider(_ value: UpdateAgentInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())"
    }
}

public struct UpdateAgentInput {
    /// The unique identifier of the agent.
    /// This member is required.
    public var agentId: Swift.String?
    /// Specifies a new name for the agent.
    /// This member is required.
    public var agentName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the agent.
    /// This member is required.
    public var agentResourceRoleArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the KMS key with which to encrypt the agent.
    public var customerEncryptionKeyArn: Swift.String?
    /// Specifies a new description of the agent.
    public var description: Swift.String?
    /// Specifies a new foundation model to be used for orchestration by the agent.
    /// This member is required.
    public var foundationModel: Swift.String?
    /// The number of seconds for which Amazon Bedrock keeps information about a user's conversation with the agent. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Bedrock deletes any data provided before the timeout.
    public var idleSessionTTLInSeconds: Swift.Int?
    /// Specifies new instructions that tell the agent what it should do and how it should interact with users.
    public var instruction: Swift.String?
    /// Contains configurations to override prompts in different parts of an agent sequence. For more information, see [Advanced prompts](https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts.html).
    public var promptOverrideConfiguration: BedrockAgentClientTypes.PromptOverrideConfiguration?

    public init(
        agentId: Swift.String? = nil,
        agentName: Swift.String? = nil,
        agentResourceRoleArn: Swift.String? = nil,
        customerEncryptionKeyArn: Swift.String? = nil,
        description: Swift.String? = nil,
        foundationModel: Swift.String? = nil,
        idleSessionTTLInSeconds: Swift.Int? = nil,
        instruction: Swift.String? = nil,
        promptOverrideConfiguration: BedrockAgentClientTypes.PromptOverrideConfiguration? = nil
    )
    {
        self.agentId = agentId
        self.agentName = agentName
        self.agentResourceRoleArn = agentResourceRoleArn
        self.customerEncryptionKeyArn = customerEncryptionKeyArn
        self.description = description
        self.foundationModel = foundationModel
        self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
        self.instruction = instruction
        self.promptOverrideConfiguration = promptOverrideConfiguration
    }
}

struct UpdateAgentInputBody {
    let agentName: Swift.String?
    let instruction: Swift.String?
    let foundationModel: Swift.String?
    let description: Swift.String?
    let idleSessionTTLInSeconds: Swift.Int?
    let agentResourceRoleArn: Swift.String?
    let customerEncryptionKeyArn: Swift.String?
    let promptOverrideConfiguration: BedrockAgentClientTypes.PromptOverrideConfiguration?
}

extension UpdateAgentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentName
        case agentResourceRoleArn
        case customerEncryptionKeyArn
        case description
        case foundationModel
        case idleSessionTTLInSeconds
        case instruction
        case promptOverrideConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentName)
        agentName = agentNameDecoded
        let instructionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instruction)
        instruction = instructionDecoded
        let foundationModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .foundationModel)
        foundationModel = foundationModelDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let idleSessionTTLInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleSessionTTLInSeconds)
        idleSessionTTLInSeconds = idleSessionTTLInSecondsDecoded
        let agentResourceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentResourceRoleArn)
        agentResourceRoleArn = agentResourceRoleArnDecoded
        let customerEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerEncryptionKeyArn)
        customerEncryptionKeyArn = customerEncryptionKeyArnDecoded
        let promptOverrideConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.PromptOverrideConfiguration.self, forKey: .promptOverrideConfiguration)
        promptOverrideConfiguration = promptOverrideConfigurationDecoded
    }
}

extension UpdateAgentKnowledgeBaseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case knowledgeBaseState
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let knowledgeBaseState = self.knowledgeBaseState {
            try encodeContainer.encode(knowledgeBaseState.rawValue, forKey: .knowledgeBaseState)
        }
    }
}

extension UpdateAgentKnowledgeBaseInput {

    static func urlPathProvider(_ value: UpdateAgentKnowledgeBaseInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())"
    }
}

public struct UpdateAgentKnowledgeBaseInput {
    /// The unique identifier of the agent associated with the knowledge base that you want to update.
    /// This member is required.
    public var agentId: Swift.String?
    /// The version of the agent associated with the knowledge base that you want to update.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// Specifies a new description for the knowledge base associated with an agent.
    public var description: Swift.String?
    /// The unique identifier of the knowledge base that has been associated with an agent.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// Specifies whether the agent uses the knowledge base or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
    public var knowledgeBaseState: BedrockAgentClientTypes.KnowledgeBaseState?

    public init(
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        description: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil,
        knowledgeBaseState: BedrockAgentClientTypes.KnowledgeBaseState? = nil
    )
    {
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.description = description
        self.knowledgeBaseId = knowledgeBaseId
        self.knowledgeBaseState = knowledgeBaseState
    }
}

struct UpdateAgentKnowledgeBaseInputBody {
    let description: Swift.String?
    let knowledgeBaseState: BedrockAgentClientTypes.KnowledgeBaseState?
}

extension UpdateAgentKnowledgeBaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case knowledgeBaseState
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let knowledgeBaseStateDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.KnowledgeBaseState.self, forKey: .knowledgeBaseState)
        knowledgeBaseState = knowledgeBaseStateDecoded
    }
}

extension UpdateAgentKnowledgeBaseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAgentKnowledgeBaseOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentKnowledgeBase = output.agentKnowledgeBase
        } else {
            self.agentKnowledgeBase = nil
        }
    }
}

public struct UpdateAgentKnowledgeBaseOutput {
    /// Contains details about the knowledge base that has been associated with an agent.
    /// This member is required.
    public var agentKnowledgeBase: BedrockAgentClientTypes.AgentKnowledgeBase?

    public init(
        agentKnowledgeBase: BedrockAgentClientTypes.AgentKnowledgeBase? = nil
    )
    {
        self.agentKnowledgeBase = agentKnowledgeBase
    }
}

struct UpdateAgentKnowledgeBaseOutputBody {
    let agentKnowledgeBase: BedrockAgentClientTypes.AgentKnowledgeBase?
}

extension UpdateAgentKnowledgeBaseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentKnowledgeBase
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentKnowledgeBaseDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentKnowledgeBase.self, forKey: .agentKnowledgeBase)
        agentKnowledgeBase = agentKnowledgeBaseDecoded
    }
}

enum UpdateAgentKnowledgeBaseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAgentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAgentOutputBody = try responseDecoder.decode(responseBody: data)
            self.agent = output.agent
        } else {
            self.agent = nil
        }
    }
}

public struct UpdateAgentOutput {
    /// Contains details about the agent that was updated.
    /// This member is required.
    public var agent: BedrockAgentClientTypes.Agent?

    public init(
        agent: BedrockAgentClientTypes.Agent? = nil
    )
    {
        self.agent = agent
    }
}

struct UpdateAgentOutputBody {
    let agent: BedrockAgentClientTypes.Agent?
}

extension UpdateAgentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agent
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.Agent.self, forKey: .agent)
        agent = agentDecoded
    }
}

enum UpdateAgentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDataSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataDeletionPolicy
        case dataSourceConfiguration
        case description
        case name
        case serverSideEncryptionConfiguration
        case vectorIngestionConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataDeletionPolicy = self.dataDeletionPolicy {
            try encodeContainer.encode(dataDeletionPolicy.rawValue, forKey: .dataDeletionPolicy)
        }
        if let dataSourceConfiguration = self.dataSourceConfiguration {
            try encodeContainer.encode(dataSourceConfiguration, forKey: .dataSourceConfiguration)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverSideEncryptionConfiguration = self.serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let vectorIngestionConfiguration = self.vectorIngestionConfiguration {
            try encodeContainer.encode(vectorIngestionConfiguration, forKey: .vectorIngestionConfiguration)
        }
    }
}

extension UpdateDataSourceInput {

    static func urlPathProvider(_ value: UpdateDataSourceInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let dataSourceId = value.dataSourceId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())"
    }
}

public struct UpdateDataSourceInput {
    /// The data deletion policy of the updated data source.
    public var dataDeletionPolicy: BedrockAgentClientTypes.DataDeletionPolicy?
    /// Contains details about the storage configuration of the data source.
    /// This member is required.
    public var dataSourceConfiguration: BedrockAgentClientTypes.DataSourceConfiguration?
    /// The unique identifier of the data source.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// Specifies a new description for the data source.
    public var description: Swift.String?
    /// The unique identifier of the knowledge base to which the data source belongs.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// Specifies a new name for the data source.
    /// This member is required.
    public var name: Swift.String?
    /// Contains details about server-side encryption of the data source.
    public var serverSideEncryptionConfiguration: BedrockAgentClientTypes.ServerSideEncryptionConfiguration?
    /// Contains details about how to ingest the documents in the data source.
    public var vectorIngestionConfiguration: BedrockAgentClientTypes.VectorIngestionConfiguration?

    public init(
        dataDeletionPolicy: BedrockAgentClientTypes.DataDeletionPolicy? = nil,
        dataSourceConfiguration: BedrockAgentClientTypes.DataSourceConfiguration? = nil,
        dataSourceId: Swift.String? = nil,
        description: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil,
        name: Swift.String? = nil,
        serverSideEncryptionConfiguration: BedrockAgentClientTypes.ServerSideEncryptionConfiguration? = nil,
        vectorIngestionConfiguration: BedrockAgentClientTypes.VectorIngestionConfiguration? = nil
    )
    {
        self.dataDeletionPolicy = dataDeletionPolicy
        self.dataSourceConfiguration = dataSourceConfiguration
        self.dataSourceId = dataSourceId
        self.description = description
        self.knowledgeBaseId = knowledgeBaseId
        self.name = name
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
        self.vectorIngestionConfiguration = vectorIngestionConfiguration
    }
}

struct UpdateDataSourceInputBody {
    let name: Swift.String?
    let description: Swift.String?
    let dataSourceConfiguration: BedrockAgentClientTypes.DataSourceConfiguration?
    let dataDeletionPolicy: BedrockAgentClientTypes.DataDeletionPolicy?
    let serverSideEncryptionConfiguration: BedrockAgentClientTypes.ServerSideEncryptionConfiguration?
    let vectorIngestionConfiguration: BedrockAgentClientTypes.VectorIngestionConfiguration?
}

extension UpdateDataSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataDeletionPolicy
        case dataSourceConfiguration
        case description
        case name
        case serverSideEncryptionConfiguration
        case vectorIngestionConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourceConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.DataSourceConfiguration.self, forKey: .dataSourceConfiguration)
        dataSourceConfiguration = dataSourceConfigurationDecoded
        let dataDeletionPolicyDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.DataDeletionPolicy.self, forKey: .dataDeletionPolicy)
        dataDeletionPolicy = dataDeletionPolicyDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let vectorIngestionConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.VectorIngestionConfiguration.self, forKey: .vectorIngestionConfiguration)
        vectorIngestionConfiguration = vectorIngestionConfigurationDecoded
    }
}

extension UpdateDataSourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateDataSourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataSource = output.dataSource
        } else {
            self.dataSource = nil
        }
    }
}

public struct UpdateDataSourceOutput {
    /// Contains details about the data source.
    /// This member is required.
    public var dataSource: BedrockAgentClientTypes.DataSource?

    public init(
        dataSource: BedrockAgentClientTypes.DataSource? = nil
    )
    {
        self.dataSource = dataSource
    }
}

struct UpdateDataSourceOutputBody {
    let dataSource: BedrockAgentClientTypes.DataSource?
}

extension UpdateDataSourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
    }
}

enum UpdateDataSourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateKnowledgeBaseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case knowledgeBaseConfiguration
        case name
        case roleArn
        case storageConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let knowledgeBaseConfiguration = self.knowledgeBaseConfiguration {
            try encodeContainer.encode(knowledgeBaseConfiguration, forKey: .knowledgeBaseConfiguration)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let storageConfiguration = self.storageConfiguration {
            try encodeContainer.encode(storageConfiguration, forKey: .storageConfiguration)
        }
    }
}

extension UpdateKnowledgeBaseInput {

    static func urlPathProvider(_ value: UpdateKnowledgeBaseInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())"
    }
}

public struct UpdateKnowledgeBaseInput {
    /// Specifies a new description for the knowledge base.
    public var description: Swift.String?
    /// Specifies the configuration for the embeddings model used for the knowledge base. You must use the same configuration as when the knowledge base was created.
    /// This member is required.
    public var knowledgeBaseConfiguration: BedrockAgentClientTypes.KnowledgeBaseConfiguration?
    /// The unique identifier of the knowledge base to update.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// Specifies a new name for the knowledge base.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies a different Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the knowledge base.
    /// This member is required.
    public var roleArn: Swift.String?
    /// Specifies the configuration for the vector store used for the knowledge base. You must use the same configuration as when the knowledge base was created.
    /// This member is required.
    public var storageConfiguration: BedrockAgentClientTypes.StorageConfiguration?

    public init(
        description: Swift.String? = nil,
        knowledgeBaseConfiguration: BedrockAgentClientTypes.KnowledgeBaseConfiguration? = nil,
        knowledgeBaseId: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        storageConfiguration: BedrockAgentClientTypes.StorageConfiguration? = nil
    )
    {
        self.description = description
        self.knowledgeBaseConfiguration = knowledgeBaseConfiguration
        self.knowledgeBaseId = knowledgeBaseId
        self.name = name
        self.roleArn = roleArn
        self.storageConfiguration = storageConfiguration
    }
}

struct UpdateKnowledgeBaseInputBody {
    let name: Swift.String?
    let description: Swift.String?
    let roleArn: Swift.String?
    let knowledgeBaseConfiguration: BedrockAgentClientTypes.KnowledgeBaseConfiguration?
    let storageConfiguration: BedrockAgentClientTypes.StorageConfiguration?
}

extension UpdateKnowledgeBaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case knowledgeBaseConfiguration
        case name
        case roleArn
        case storageConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let knowledgeBaseConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.KnowledgeBaseConfiguration.self, forKey: .knowledgeBaseConfiguration)
        knowledgeBaseConfiguration = knowledgeBaseConfigurationDecoded
        let storageConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.StorageConfiguration.self, forKey: .storageConfiguration)
        storageConfiguration = storageConfigurationDecoded
    }
}

extension UpdateKnowledgeBaseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateKnowledgeBaseOutputBody = try responseDecoder.decode(responseBody: data)
            self.knowledgeBase = output.knowledgeBase
        } else {
            self.knowledgeBase = nil
        }
    }
}

public struct UpdateKnowledgeBaseOutput {
    /// Contains details about the knowledge base.
    /// This member is required.
    public var knowledgeBase: BedrockAgentClientTypes.KnowledgeBase?

    public init(
        knowledgeBase: BedrockAgentClientTypes.KnowledgeBase? = nil
    )
    {
        self.knowledgeBase = knowledgeBase
    }
}

struct UpdateKnowledgeBaseOutputBody {
    let knowledgeBase: BedrockAgentClientTypes.KnowledgeBase?
}

extension UpdateKnowledgeBaseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knowledgeBase
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.KnowledgeBase.self, forKey: .knowledgeBase)
        knowledgeBase = knowledgeBaseDecoded
    }
}

enum UpdateKnowledgeBaseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fieldList = output.fieldList
            self.properties.message = output.message
        } else {
            self.properties.fieldList = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Input validation failed. Check your request parameters and retry the request.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A list of objects containing fields that caused validation errors and their corresponding validation error messages.
        public internal(set) var fieldList: [BedrockAgentClientTypes.ValidationExceptionField]? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [BedrockAgentClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
    }
}

struct ValidationExceptionBody {
    let message: Swift.String?
    let fieldList: [BedrockAgentClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([BedrockAgentClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[BedrockAgentClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [BedrockAgentClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension BedrockAgentClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Stores information about a field passed inside a request that resulted in an validation error.
    public struct ValidationExceptionField {
        /// A message describing why this field failed validation.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension BedrockAgentClientTypes.VectorIngestionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chunkingConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chunkingConfiguration = self.chunkingConfiguration {
            try encodeContainer.encode(chunkingConfiguration, forKey: .chunkingConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let chunkingConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.ChunkingConfiguration.self, forKey: .chunkingConfiguration)
        chunkingConfiguration = chunkingConfigurationDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about how to ingest the documents in a data source.
    public struct VectorIngestionConfiguration {
        /// Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.
        public var chunkingConfiguration: BedrockAgentClientTypes.ChunkingConfiguration?

        public init(
            chunkingConfiguration: BedrockAgentClientTypes.ChunkingConfiguration? = nil
        )
        {
            self.chunkingConfiguration = chunkingConfiguration
        }
    }

}

extension BedrockAgentClientTypes.VectorKnowledgeBaseConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case embeddingModelArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let embeddingModelArn = self.embeddingModelArn {
            try encodeContainer.encode(embeddingModelArn, forKey: .embeddingModelArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let embeddingModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .embeddingModelArn)
        embeddingModelArn = embeddingModelArnDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about the model used to create vector embeddings for the knowledge base.
    public struct VectorKnowledgeBaseConfiguration {
        /// The Amazon Resource Name (ARN) of the model used to create vector embeddings for the knowledge base.
        /// This member is required.
        public var embeddingModelArn: Swift.String?

        public init(
            embeddingModelArn: Swift.String? = nil
        )
        {
            self.embeddingModelArn = embeddingModelArn
        }
    }

}
