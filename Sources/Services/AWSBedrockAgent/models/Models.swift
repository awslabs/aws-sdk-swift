// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension BedrockAgentClientTypes.APISchema: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
        case s3
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .payload(payload):
                try container.encode(payload, forKey: .payload)
            case let .s3(s3):
                try container.encode(s3, forKey: .s3)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try values.decodeIfPresent(BedrockAgentClientTypes.S3Identifier.self, forKey: .s3)
        if let s3 = s3Decoded {
            self = .s3(s3)
            return
        }
        let payloadDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .payload)
        if let payload = payloadDecoded {
            self = .payload(payload)
            return
        }
        self = .sdkUnknown("")
    }
}

extension BedrockAgentClientTypes {
    /// Contains information about the API Schema for the Action Group
    public enum APISchema: Swift.Equatable {
        /// The identifier for the S3 resource.
        case s3(BedrockAgentClientTypes.S3Identifier)
        /// String OpenAPI Payload
        case payload(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when a request is denied per access permissions
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Non Blank String
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BedrockAgentClientTypes.ActionGroupExecutor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lambda
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .lambda(lambda):
                try container.encode(lambda, forKey: .lambda)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .lambda)
        if let lambda = lambdaDecoded {
            self = .lambda(lambda)
            return
        }
        self = .sdkUnknown("")
    }
}

extension BedrockAgentClientTypes {
    /// Type of Executors for an Action Group
    public enum ActionGroupExecutor: Swift.Equatable {
        /// ARN of a Lambda.
        case lambda(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockAgentClientTypes {
    /// Action Group Signature for a BuiltIn Action
    public enum ActionGroupSignature: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonUserinput
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionGroupSignature] {
            return [
                .amazonUserinput,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonUserinput: return "AMAZON.UserInput"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActionGroupSignature(rawValue: rawValue) ?? ActionGroupSignature.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentClientTypes {
    /// State of the action group
    public enum ActionGroupState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionGroupState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActionGroupState(rawValue: rawValue) ?? ActionGroupState.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentClientTypes.ActionGroupSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionGroupId
        case actionGroupName
        case actionGroupState
        case description
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionGroupId = self.actionGroupId {
            try encodeContainer.encode(actionGroupId, forKey: .actionGroupId)
        }
        if let actionGroupName = self.actionGroupName {
            try encodeContainer.encode(actionGroupName, forKey: .actionGroupName)
        }
        if let actionGroupState = self.actionGroupState {
            try encodeContainer.encode(actionGroupState.rawValue, forKey: .actionGroupState)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionGroupId)
        actionGroupId = actionGroupIdDecoded
        let actionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionGroupName)
        actionGroupName = actionGroupNameDecoded
        let actionGroupStateDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.ActionGroupState.self, forKey: .actionGroupState)
        actionGroupState = actionGroupStateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension BedrockAgentClientTypes {
    /// ActionGroup Summary
    public struct ActionGroupSummary: Swift.Equatable {
        /// Identifier for a resource.
        /// This member is required.
        public var actionGroupId: Swift.String?
        /// Name for a resource.
        /// This member is required.
        public var actionGroupName: Swift.String?
        /// State of the action group
        /// This member is required.
        public var actionGroupState: BedrockAgentClientTypes.ActionGroupState?
        /// Description of the Resource.
        public var description: Swift.String?
        /// Time Stamp.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            actionGroupId: Swift.String? = nil,
            actionGroupName: Swift.String? = nil,
            actionGroupState: BedrockAgentClientTypes.ActionGroupState? = nil,
            description: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.actionGroupId = actionGroupId
            self.actionGroupName = actionGroupName
            self.actionGroupState = actionGroupState
            self.description = description
            self.updatedAt = updatedAt
        }
    }

}

extension BedrockAgentClientTypes.Agent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentArn
        case agentId
        case agentName
        case agentResourceRoleArn
        case agentStatus
        case agentVersion
        case clientToken
        case createdAt
        case customerEncryptionKeyArn
        case description
        case failureReasons
        case foundationModel
        case idleSessionTTLInSeconds
        case instruction
        case preparedAt
        case promptOverrideConfiguration
        case recommendedActions
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentArn = self.agentArn {
            try encodeContainer.encode(agentArn, forKey: .agentArn)
        }
        if let agentId = self.agentId {
            try encodeContainer.encode(agentId, forKey: .agentId)
        }
        if let agentName = self.agentName {
            try encodeContainer.encode(agentName, forKey: .agentName)
        }
        if let agentResourceRoleArn = self.agentResourceRoleArn {
            try encodeContainer.encode(agentResourceRoleArn, forKey: .agentResourceRoleArn)
        }
        if let agentStatus = self.agentStatus {
            try encodeContainer.encode(agentStatus.rawValue, forKey: .agentStatus)
        }
        if let agentVersion = self.agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let customerEncryptionKeyArn = self.customerEncryptionKeyArn {
            try encodeContainer.encode(customerEncryptionKeyArn, forKey: .customerEncryptionKeyArn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let failureReasons = failureReasons {
            var failureReasonsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .failureReasons)
            for failurereason0 in failureReasons {
                try failureReasonsContainer.encode(failurereason0)
            }
        }
        if let foundationModel = self.foundationModel {
            try encodeContainer.encode(foundationModel, forKey: .foundationModel)
        }
        if let idleSessionTTLInSeconds = self.idleSessionTTLInSeconds {
            try encodeContainer.encode(idleSessionTTLInSeconds, forKey: .idleSessionTTLInSeconds)
        }
        if let instruction = self.instruction {
            try encodeContainer.encode(instruction, forKey: .instruction)
        }
        if let preparedAt = self.preparedAt {
            try encodeContainer.encodeTimestamp(preparedAt, format: .dateTime, forKey: .preparedAt)
        }
        if let promptOverrideConfiguration = self.promptOverrideConfiguration {
            try encodeContainer.encode(promptOverrideConfiguration, forKey: .promptOverrideConfiguration)
        }
        if let recommendedActions = recommendedActions {
            var recommendedActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recommendedActions)
            for recommendedaction0 in recommendedActions {
                try recommendedActionsContainer.encode(recommendedaction0)
            }
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let agentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentName)
        agentName = agentNameDecoded
        let agentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentArn)
        agentArn = agentArnDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let instructionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instruction)
        instruction = instructionDecoded
        let agentStatusDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentStatus.self, forKey: .agentStatus)
        agentStatus = agentStatusDecoded
        let foundationModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .foundationModel)
        foundationModel = foundationModelDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let idleSessionTTLInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleSessionTTLInSeconds)
        idleSessionTTLInSeconds = idleSessionTTLInSecondsDecoded
        let agentResourceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentResourceRoleArn)
        agentResourceRoleArn = agentResourceRoleArnDecoded
        let customerEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerEncryptionKeyArn)
        customerEncryptionKeyArn = customerEncryptionKeyArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let preparedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .preparedAt)
        preparedAt = preparedAtDecoded
        let failureReasonsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .failureReasons)
        var failureReasonsDecoded0:[Swift.String]? = nil
        if let failureReasonsContainer = failureReasonsContainer {
            failureReasonsDecoded0 = [Swift.String]()
            for string0 in failureReasonsContainer {
                if let string0 = string0 {
                    failureReasonsDecoded0?.append(string0)
                }
            }
        }
        failureReasons = failureReasonsDecoded0
        let recommendedActionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .recommendedActions)
        var recommendedActionsDecoded0:[Swift.String]? = nil
        if let recommendedActionsContainer = recommendedActionsContainer {
            recommendedActionsDecoded0 = [Swift.String]()
            for string0 in recommendedActionsContainer {
                if let string0 = string0 {
                    recommendedActionsDecoded0?.append(string0)
                }
            }
        }
        recommendedActions = recommendedActionsDecoded0
        let promptOverrideConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.PromptOverrideConfiguration.self, forKey: .promptOverrideConfiguration)
        promptOverrideConfiguration = promptOverrideConfigurationDecoded
    }
}

extension BedrockAgentClientTypes.Agent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Agent(agentArn: \(Swift.String(describing: agentArn)), agentId: \(Swift.String(describing: agentId)), agentName: \(Swift.String(describing: agentName)), agentResourceRoleArn: \(Swift.String(describing: agentResourceRoleArn)), agentStatus: \(Swift.String(describing: agentStatus)), agentVersion: \(Swift.String(describing: agentVersion)), clientToken: \(Swift.String(describing: clientToken)), createdAt: \(Swift.String(describing: createdAt)), customerEncryptionKeyArn: \(Swift.String(describing: customerEncryptionKeyArn)), description: \(Swift.String(describing: description)), failureReasons: \(Swift.String(describing: failureReasons)), foundationModel: \(Swift.String(describing: foundationModel)), idleSessionTTLInSeconds: \(Swift.String(describing: idleSessionTTLInSeconds)), preparedAt: \(Swift.String(describing: preparedAt)), recommendedActions: \(Swift.String(describing: recommendedActions)), updatedAt: \(Swift.String(describing: updatedAt)), instruction: \"CONTENT_REDACTED\", promptOverrideConfiguration: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentClientTypes {
    /// Contains the information of an agent
    public struct Agent: Swift.Equatable {
        /// Arn representation of the Agent.
        /// This member is required.
        public var agentArn: Swift.String?
        /// Identifier for a resource.
        /// This member is required.
        public var agentId: Swift.String?
        /// Name for a resource.
        /// This member is required.
        public var agentName: Swift.String?
        /// ARN of a IAM role.
        /// This member is required.
        public var agentResourceRoleArn: Swift.String?
        /// Schema Type for Action APIs.
        /// This member is required.
        public var agentStatus: BedrockAgentClientTypes.AgentStatus?
        /// Draft Agent Version.
        /// This member is required.
        public var agentVersion: Swift.String?
        /// Client specified token used for idempotency checks
        public var clientToken: Swift.String?
        /// Time Stamp.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// A KMS key ARN
        public var customerEncryptionKeyArn: Swift.String?
        /// Description of the Resource.
        public var description: Swift.String?
        /// Failure Reasons for Error.
        public var failureReasons: [Swift.String]?
        /// ARN or name of a Bedrock model.
        public var foundationModel: Swift.String?
        /// Max Session Time.
        /// This member is required.
        public var idleSessionTTLInSeconds: Swift.Int?
        /// Instruction for the agent.
        public var instruction: Swift.String?
        /// Time Stamp.
        public var preparedAt: ClientRuntime.Date?
        /// Configuration for prompt override.
        public var promptOverrideConfiguration: BedrockAgentClientTypes.PromptOverrideConfiguration?
        /// The recommended actions users can take to resolve an error in failureReasons.
        public var recommendedActions: [Swift.String]?
        /// Time Stamp.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            agentArn: Swift.String? = nil,
            agentId: Swift.String? = nil,
            agentName: Swift.String? = nil,
            agentResourceRoleArn: Swift.String? = nil,
            agentStatus: BedrockAgentClientTypes.AgentStatus? = nil,
            agentVersion: Swift.String? = nil,
            clientToken: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            customerEncryptionKeyArn: Swift.String? = nil,
            description: Swift.String? = nil,
            failureReasons: [Swift.String]? = nil,
            foundationModel: Swift.String? = nil,
            idleSessionTTLInSeconds: Swift.Int? = nil,
            instruction: Swift.String? = nil,
            preparedAt: ClientRuntime.Date? = nil,
            promptOverrideConfiguration: BedrockAgentClientTypes.PromptOverrideConfiguration? = nil,
            recommendedActions: [Swift.String]? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.agentArn = agentArn
            self.agentId = agentId
            self.agentName = agentName
            self.agentResourceRoleArn = agentResourceRoleArn
            self.agentStatus = agentStatus
            self.agentVersion = agentVersion
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.description = description
            self.failureReasons = failureReasons
            self.foundationModel = foundationModel
            self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
            self.instruction = instruction
            self.preparedAt = preparedAt
            self.promptOverrideConfiguration = promptOverrideConfiguration
            self.recommendedActions = recommendedActions
            self.updatedAt = updatedAt
        }
    }

}

extension BedrockAgentClientTypes.AgentActionGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionGroupExecutor
        case actionGroupId
        case actionGroupName
        case actionGroupState
        case agentId
        case agentVersion
        case apiSchema
        case clientToken
        case createdAt
        case description
        case parentActionSignature
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionGroupExecutor = self.actionGroupExecutor {
            try encodeContainer.encode(actionGroupExecutor, forKey: .actionGroupExecutor)
        }
        if let actionGroupId = self.actionGroupId {
            try encodeContainer.encode(actionGroupId, forKey: .actionGroupId)
        }
        if let actionGroupName = self.actionGroupName {
            try encodeContainer.encode(actionGroupName, forKey: .actionGroupName)
        }
        if let actionGroupState = self.actionGroupState {
            try encodeContainer.encode(actionGroupState.rawValue, forKey: .actionGroupState)
        }
        if let agentId = self.agentId {
            try encodeContainer.encode(agentId, forKey: .agentId)
        }
        if let agentVersion = self.agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let apiSchema = self.apiSchema {
            try encodeContainer.encode(apiSchema, forKey: .apiSchema)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let parentActionSignature = self.parentActionSignature {
            try encodeContainer.encode(parentActionSignature.rawValue, forKey: .parentActionSignature)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
        let actionGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionGroupId)
        actionGroupId = actionGroupIdDecoded
        let actionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionGroupName)
        actionGroupName = actionGroupNameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let parentActionSignatureDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.ActionGroupSignature.self, forKey: .parentActionSignature)
        parentActionSignature = parentActionSignatureDecoded
        let actionGroupExecutorDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.ActionGroupExecutor.self, forKey: .actionGroupExecutor)
        actionGroupExecutor = actionGroupExecutorDecoded
        let apiSchemaDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.APISchema.self, forKey: .apiSchema)
        apiSchema = apiSchemaDecoded
        let actionGroupStateDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.ActionGroupState.self, forKey: .actionGroupState)
        actionGroupState = actionGroupStateDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains the information of an Agent Action Group
    public struct AgentActionGroup: Swift.Equatable {
        /// Type of Executors for an Action Group
        public var actionGroupExecutor: BedrockAgentClientTypes.ActionGroupExecutor?
        /// Identifier for a resource.
        /// This member is required.
        public var actionGroupId: Swift.String?
        /// Name for a resource.
        /// This member is required.
        public var actionGroupName: Swift.String?
        /// State of the action group
        /// This member is required.
        public var actionGroupState: BedrockAgentClientTypes.ActionGroupState?
        /// Identifier for a resource.
        /// This member is required.
        public var agentId: Swift.String?
        /// Agent Version.
        /// This member is required.
        public var agentVersion: Swift.String?
        /// Contains information about the API Schema for the Action Group
        public var apiSchema: BedrockAgentClientTypes.APISchema?
        /// Client specified token used for idempotency checks
        public var clientToken: Swift.String?
        /// Time Stamp.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// Description of the Resource.
        public var description: Swift.String?
        /// Action Group Signature for a BuiltIn Action
        public var parentActionSignature: BedrockAgentClientTypes.ActionGroupSignature?
        /// Time Stamp.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            actionGroupExecutor: BedrockAgentClientTypes.ActionGroupExecutor? = nil,
            actionGroupId: Swift.String? = nil,
            actionGroupName: Swift.String? = nil,
            actionGroupState: BedrockAgentClientTypes.ActionGroupState? = nil,
            agentId: Swift.String? = nil,
            agentVersion: Swift.String? = nil,
            apiSchema: BedrockAgentClientTypes.APISchema? = nil,
            clientToken: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            parentActionSignature: BedrockAgentClientTypes.ActionGroupSignature? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.actionGroupExecutor = actionGroupExecutor
            self.actionGroupId = actionGroupId
            self.actionGroupName = actionGroupName
            self.actionGroupState = actionGroupState
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.apiSchema = apiSchema
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.description = description
            self.parentActionSignature = parentActionSignature
            self.updatedAt = updatedAt
        }
    }

}

extension BedrockAgentClientTypes.AgentAlias: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentAliasArn
        case agentAliasHistoryEvents
        case agentAliasId
        case agentAliasName
        case agentAliasStatus
        case agentId
        case clientToken
        case createdAt
        case description
        case routingConfiguration
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentAliasArn = self.agentAliasArn {
            try encodeContainer.encode(agentAliasArn, forKey: .agentAliasArn)
        }
        if let agentAliasHistoryEvents = agentAliasHistoryEvents {
            var agentAliasHistoryEventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .agentAliasHistoryEvents)
            for agentaliashistoryevent0 in agentAliasHistoryEvents {
                try agentAliasHistoryEventsContainer.encode(agentaliashistoryevent0)
            }
        }
        if let agentAliasId = self.agentAliasId {
            try encodeContainer.encode(agentAliasId, forKey: .agentAliasId)
        }
        if let agentAliasName = self.agentAliasName {
            try encodeContainer.encode(agentAliasName, forKey: .agentAliasName)
        }
        if let agentAliasStatus = self.agentAliasStatus {
            try encodeContainer.encode(agentAliasStatus.rawValue, forKey: .agentAliasStatus)
        }
        if let agentId = self.agentId {
            try encodeContainer.encode(agentId, forKey: .agentId)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let routingConfiguration = routingConfiguration {
            var routingConfigurationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .routingConfiguration)
            for agentaliasroutingconfigurationlistitem0 in routingConfiguration {
                try routingConfigurationContainer.encode(agentaliasroutingconfigurationlistitem0)
            }
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let agentAliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentAliasId)
        agentAliasId = agentAliasIdDecoded
        let agentAliasNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentAliasName)
        agentAliasName = agentAliasNameDecoded
        let agentAliasArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentAliasArn)
        agentAliasArn = agentAliasArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let routingConfigurationContainer = try containerValues.decodeIfPresent([BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem?].self, forKey: .routingConfiguration)
        var routingConfigurationDecoded0:[BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]? = nil
        if let routingConfigurationContainer = routingConfigurationContainer {
            routingConfigurationDecoded0 = [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]()
            for structure0 in routingConfigurationContainer {
                if let structure0 = structure0 {
                    routingConfigurationDecoded0?.append(structure0)
                }
            }
        }
        routingConfiguration = routingConfigurationDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let agentAliasHistoryEventsContainer = try containerValues.decodeIfPresent([BedrockAgentClientTypes.AgentAliasHistoryEvent?].self, forKey: .agentAliasHistoryEvents)
        var agentAliasHistoryEventsDecoded0:[BedrockAgentClientTypes.AgentAliasHistoryEvent]? = nil
        if let agentAliasHistoryEventsContainer = agentAliasHistoryEventsContainer {
            agentAliasHistoryEventsDecoded0 = [BedrockAgentClientTypes.AgentAliasHistoryEvent]()
            for structure0 in agentAliasHistoryEventsContainer {
                if let structure0 = structure0 {
                    agentAliasHistoryEventsDecoded0?.append(structure0)
                }
            }
        }
        agentAliasHistoryEvents = agentAliasHistoryEventsDecoded0
        let agentAliasStatusDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentAliasStatus.self, forKey: .agentAliasStatus)
        agentAliasStatus = agentAliasStatusDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains the information of an agent alias
    public struct AgentAlias: Swift.Equatable {
        /// Arn representation of the Agent Alias.
        /// This member is required.
        public var agentAliasArn: Swift.String?
        /// The list of history events for an alias for an Agent.
        public var agentAliasHistoryEvents: [BedrockAgentClientTypes.AgentAliasHistoryEvent]?
        /// Id for an Agent Alias generated at the server side.
        /// This member is required.
        public var agentAliasId: Swift.String?
        /// Name for a resource.
        /// This member is required.
        public var agentAliasName: Swift.String?
        /// The statuses an Agent Alias can be in.
        /// This member is required.
        public var agentAliasStatus: BedrockAgentClientTypes.AgentAliasStatus?
        /// Identifier for a resource.
        /// This member is required.
        public var agentId: Swift.String?
        /// Client specified token used for idempotency checks
        public var clientToken: Swift.String?
        /// Time Stamp.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// Description of the Resource.
        public var description: Swift.String?
        /// Routing configuration for an Agent alias.
        /// This member is required.
        public var routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]?
        /// Time Stamp.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            agentAliasArn: Swift.String? = nil,
            agentAliasHistoryEvents: [BedrockAgentClientTypes.AgentAliasHistoryEvent]? = nil,
            agentAliasId: Swift.String? = nil,
            agentAliasName: Swift.String? = nil,
            agentAliasStatus: BedrockAgentClientTypes.AgentAliasStatus? = nil,
            agentId: Swift.String? = nil,
            clientToken: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.agentAliasArn = agentAliasArn
            self.agentAliasHistoryEvents = agentAliasHistoryEvents
            self.agentAliasId = agentAliasId
            self.agentAliasName = agentAliasName
            self.agentAliasStatus = agentAliasStatus
            self.agentId = agentId
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.description = description
            self.routingConfiguration = routingConfiguration
            self.updatedAt = updatedAt
        }
    }

}

extension BedrockAgentClientTypes.AgentAliasHistoryEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endDate
        case routingConfiguration
        case startDate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endDate = self.endDate {
            try encodeContainer.encodeTimestamp(endDate, format: .dateTime, forKey: .endDate)
        }
        if let routingConfiguration = routingConfiguration {
            var routingConfigurationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .routingConfiguration)
            for agentaliasroutingconfigurationlistitem0 in routingConfiguration {
                try routingConfigurationContainer.encode(agentaliasroutingconfigurationlistitem0)
            }
        }
        if let startDate = self.startDate {
            try encodeContainer.encodeTimestamp(startDate, format: .dateTime, forKey: .startDate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routingConfigurationContainer = try containerValues.decodeIfPresent([BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem?].self, forKey: .routingConfiguration)
        var routingConfigurationDecoded0:[BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]? = nil
        if let routingConfigurationContainer = routingConfigurationContainer {
            routingConfigurationDecoded0 = [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]()
            for structure0 in routingConfigurationContainer {
                if let structure0 = structure0 {
                    routingConfigurationDecoded0?.append(structure0)
                }
            }
        }
        routingConfiguration = routingConfigurationDecoded0
        let endDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endDate)
        endDate = endDateDecoded
        let startDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startDate)
        startDate = startDateDecoded
    }
}

extension BedrockAgentClientTypes {
    /// History event for an alias for an Agent.
    public struct AgentAliasHistoryEvent: Swift.Equatable {
        /// Time Stamp.
        public var endDate: ClientRuntime.Date?
        /// Routing configuration for an Agent alias.
        public var routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]?
        /// Time Stamp.
        public var startDate: ClientRuntime.Date?

        public init(
            endDate: ClientRuntime.Date? = nil,
            routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]? = nil,
            startDate: ClientRuntime.Date? = nil
        )
        {
            self.endDate = endDate
            self.routingConfiguration = routingConfiguration
            self.startDate = startDate
        }
    }

}

extension BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentVersion = self.agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Details about the routing configuration for an Agent alias.
    public struct AgentAliasRoutingConfigurationListItem: Swift.Equatable {
        /// Agent Version.
        /// This member is required.
        public var agentVersion: Swift.String?

        public init(
            agentVersion: Swift.String? = nil
        )
        {
            self.agentVersion = agentVersion
        }
    }

}

extension BedrockAgentClientTypes {
    /// The statuses an Agent Alias can be in.
    public enum AgentAliasStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creating
        case deleting
        case failed
        case prepared
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [AgentAliasStatus] {
            return [
                .creating,
                .deleting,
                .failed,
                .prepared,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .prepared: return "PREPARED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AgentAliasStatus(rawValue: rawValue) ?? AgentAliasStatus.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentClientTypes.AgentAliasSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentAliasId
        case agentAliasName
        case agentAliasStatus
        case createdAt
        case description
        case routingConfiguration
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentAliasId = self.agentAliasId {
            try encodeContainer.encode(agentAliasId, forKey: .agentAliasId)
        }
        if let agentAliasName = self.agentAliasName {
            try encodeContainer.encode(agentAliasName, forKey: .agentAliasName)
        }
        if let agentAliasStatus = self.agentAliasStatus {
            try encodeContainer.encode(agentAliasStatus.rawValue, forKey: .agentAliasStatus)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let routingConfiguration = routingConfiguration {
            var routingConfigurationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .routingConfiguration)
            for agentaliasroutingconfigurationlistitem0 in routingConfiguration {
                try routingConfigurationContainer.encode(agentaliasroutingconfigurationlistitem0)
            }
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentAliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentAliasId)
        agentAliasId = agentAliasIdDecoded
        let agentAliasNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentAliasName)
        agentAliasName = agentAliasNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let routingConfigurationContainer = try containerValues.decodeIfPresent([BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem?].self, forKey: .routingConfiguration)
        var routingConfigurationDecoded0:[BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]? = nil
        if let routingConfigurationContainer = routingConfigurationContainer {
            routingConfigurationDecoded0 = [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]()
            for structure0 in routingConfigurationContainer {
                if let structure0 = structure0 {
                    routingConfigurationDecoded0?.append(structure0)
                }
            }
        }
        routingConfiguration = routingConfigurationDecoded0
        let agentAliasStatusDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentAliasStatus.self, forKey: .agentAliasStatus)
        agentAliasStatus = agentAliasStatusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Summary of an alias for an Agent.
    public struct AgentAliasSummary: Swift.Equatable {
        /// Id for an Agent Alias generated at the server side.
        /// This member is required.
        public var agentAliasId: Swift.String?
        /// Name for a resource.
        /// This member is required.
        public var agentAliasName: Swift.String?
        /// The statuses an Agent Alias can be in.
        /// This member is required.
        public var agentAliasStatus: BedrockAgentClientTypes.AgentAliasStatus?
        /// Time Stamp.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// Description of the Resource.
        public var description: Swift.String?
        /// Routing configuration for an Agent alias.
        public var routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]?
        /// Time Stamp.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            agentAliasId: Swift.String? = nil,
            agentAliasName: Swift.String? = nil,
            agentAliasStatus: BedrockAgentClientTypes.AgentAliasStatus? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.agentAliasId = agentAliasId
            self.agentAliasName = agentAliasName
            self.agentAliasStatus = agentAliasStatus
            self.createdAt = createdAt
            self.description = description
            self.routingConfiguration = routingConfiguration
            self.updatedAt = updatedAt
        }
    }

}

extension BedrockAgentClientTypes.AgentKnowledgeBase: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentId
        case agentVersion
        case createdAt
        case description
        case knowledgeBaseId
        case knowledgeBaseState
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentId = self.agentId {
            try encodeContainer.encode(agentId, forKey: .agentId)
        }
        if let agentVersion = self.agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let knowledgeBaseState = self.knowledgeBaseState {
            try encodeContainer.encode(knowledgeBaseState.rawValue, forKey: .knowledgeBaseState)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let knowledgeBaseStateDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.KnowledgeBaseState.self, forKey: .knowledgeBaseState)
        knowledgeBaseState = knowledgeBaseStateDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains the information of an Agent Knowledge Base.
    public struct AgentKnowledgeBase: Swift.Equatable {
        /// Identifier for a resource.
        /// This member is required.
        public var agentId: Swift.String?
        /// Agent Version.
        /// This member is required.
        public var agentVersion: Swift.String?
        /// Time Stamp.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// Description of the Resource.
        /// This member is required.
        public var description: Swift.String?
        /// Identifier for a resource.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// State of the knowledge base; whether it is enabled or disabled
        /// This member is required.
        public var knowledgeBaseState: BedrockAgentClientTypes.KnowledgeBaseState?
        /// Time Stamp.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            agentId: Swift.String? = nil,
            agentVersion: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            knowledgeBaseState: BedrockAgentClientTypes.KnowledgeBaseState? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.createdAt = createdAt
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseState = knowledgeBaseState
            self.updatedAt = updatedAt
        }
    }

}

extension BedrockAgentClientTypes.AgentKnowledgeBaseSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case knowledgeBaseId
        case knowledgeBaseState
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let knowledgeBaseState = self.knowledgeBaseState {
            try encodeContainer.encode(knowledgeBaseState.rawValue, forKey: .knowledgeBaseState)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let knowledgeBaseStateDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.KnowledgeBaseState.self, forKey: .knowledgeBaseState)
        knowledgeBaseState = knowledgeBaseStateDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Agent Knowledge Base Summary
    public struct AgentKnowledgeBaseSummary: Swift.Equatable {
        /// Description of the Resource.
        public var description: Swift.String?
        /// Identifier for a resource.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// State of the knowledge base; whether it is enabled or disabled
        /// This member is required.
        public var knowledgeBaseState: BedrockAgentClientTypes.KnowledgeBaseState?
        /// Time Stamp.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            description: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            knowledgeBaseState: BedrockAgentClientTypes.KnowledgeBaseState? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseState = knowledgeBaseState
            self.updatedAt = updatedAt
        }
    }

}

extension BedrockAgentClientTypes {
    /// Schema Type for Action APIs.
    public enum AgentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creating
        case deleting
        case failed
        case notPrepared
        case prepared
        case preparing
        case updating
        case versioning
        case sdkUnknown(Swift.String)

        public static var allCases: [AgentStatus] {
            return [
                .creating,
                .deleting,
                .failed,
                .notPrepared,
                .prepared,
                .preparing,
                .updating,
                .versioning,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .notPrepared: return "NOT_PREPARED"
            case .prepared: return "PREPARED"
            case .preparing: return "PREPARING"
            case .updating: return "UPDATING"
            case .versioning: return "VERSIONING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AgentStatus(rawValue: rawValue) ?? AgentStatus.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentClientTypes.AgentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentId
        case agentName
        case agentStatus
        case description
        case latestAgentVersion
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentId = self.agentId {
            try encodeContainer.encode(agentId, forKey: .agentId)
        }
        if let agentName = self.agentName {
            try encodeContainer.encode(agentName, forKey: .agentName)
        }
        if let agentStatus = self.agentStatus {
            try encodeContainer.encode(agentStatus.rawValue, forKey: .agentStatus)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let latestAgentVersion = self.latestAgentVersion {
            try encodeContainer.encode(latestAgentVersion, forKey: .latestAgentVersion)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let agentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentName)
        agentName = agentNameDecoded
        let agentStatusDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentStatus.self, forKey: .agentStatus)
        agentStatus = agentStatusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let latestAgentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestAgentVersion)
        latestAgentVersion = latestAgentVersionDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Summary of Agent.
    public struct AgentSummary: Swift.Equatable {
        /// Identifier for a resource.
        /// This member is required.
        public var agentId: Swift.String?
        /// Name for a resource.
        /// This member is required.
        public var agentName: Swift.String?
        /// Schema Type for Action APIs.
        /// This member is required.
        public var agentStatus: BedrockAgentClientTypes.AgentStatus?
        /// Description of the Resource.
        public var description: Swift.String?
        /// Agent Version.
        public var latestAgentVersion: Swift.String?
        /// Time Stamp.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            agentId: Swift.String? = nil,
            agentName: Swift.String? = nil,
            agentStatus: BedrockAgentClientTypes.AgentStatus? = nil,
            description: Swift.String? = nil,
            latestAgentVersion: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.agentId = agentId
            self.agentName = agentName
            self.agentStatus = agentStatus
            self.description = description
            self.latestAgentVersion = latestAgentVersion
            self.updatedAt = updatedAt
        }
    }

}

extension BedrockAgentClientTypes.AgentVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentArn
        case agentId
        case agentName
        case agentResourceRoleArn
        case agentStatus
        case createdAt
        case customerEncryptionKeyArn
        case description
        case failureReasons
        case foundationModel
        case idleSessionTTLInSeconds
        case instruction
        case promptOverrideConfiguration
        case recommendedActions
        case updatedAt
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentArn = self.agentArn {
            try encodeContainer.encode(agentArn, forKey: .agentArn)
        }
        if let agentId = self.agentId {
            try encodeContainer.encode(agentId, forKey: .agentId)
        }
        if let agentName = self.agentName {
            try encodeContainer.encode(agentName, forKey: .agentName)
        }
        if let agentResourceRoleArn = self.agentResourceRoleArn {
            try encodeContainer.encode(agentResourceRoleArn, forKey: .agentResourceRoleArn)
        }
        if let agentStatus = self.agentStatus {
            try encodeContainer.encode(agentStatus.rawValue, forKey: .agentStatus)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let customerEncryptionKeyArn = self.customerEncryptionKeyArn {
            try encodeContainer.encode(customerEncryptionKeyArn, forKey: .customerEncryptionKeyArn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let failureReasons = failureReasons {
            var failureReasonsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .failureReasons)
            for failurereason0 in failureReasons {
                try failureReasonsContainer.encode(failurereason0)
            }
        }
        if let foundationModel = self.foundationModel {
            try encodeContainer.encode(foundationModel, forKey: .foundationModel)
        }
        if let idleSessionTTLInSeconds = self.idleSessionTTLInSeconds {
            try encodeContainer.encode(idleSessionTTLInSeconds, forKey: .idleSessionTTLInSeconds)
        }
        if let instruction = self.instruction {
            try encodeContainer.encode(instruction, forKey: .instruction)
        }
        if let promptOverrideConfiguration = self.promptOverrideConfiguration {
            try encodeContainer.encode(promptOverrideConfiguration, forKey: .promptOverrideConfiguration)
        }
        if let recommendedActions = recommendedActions {
            var recommendedActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recommendedActions)
            for recommendedaction0 in recommendedActions {
                try recommendedActionsContainer.encode(recommendedaction0)
            }
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let agentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentName)
        agentName = agentNameDecoded
        let agentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentArn)
        agentArn = agentArnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let instructionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instruction)
        instruction = instructionDecoded
        let agentStatusDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentStatus.self, forKey: .agentStatus)
        agentStatus = agentStatusDecoded
        let foundationModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .foundationModel)
        foundationModel = foundationModelDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let idleSessionTTLInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleSessionTTLInSeconds)
        idleSessionTTLInSeconds = idleSessionTTLInSecondsDecoded
        let agentResourceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentResourceRoleArn)
        agentResourceRoleArn = agentResourceRoleArnDecoded
        let customerEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerEncryptionKeyArn)
        customerEncryptionKeyArn = customerEncryptionKeyArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let failureReasonsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .failureReasons)
        var failureReasonsDecoded0:[Swift.String]? = nil
        if let failureReasonsContainer = failureReasonsContainer {
            failureReasonsDecoded0 = [Swift.String]()
            for string0 in failureReasonsContainer {
                if let string0 = string0 {
                    failureReasonsDecoded0?.append(string0)
                }
            }
        }
        failureReasons = failureReasonsDecoded0
        let recommendedActionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .recommendedActions)
        var recommendedActionsDecoded0:[Swift.String]? = nil
        if let recommendedActionsContainer = recommendedActionsContainer {
            recommendedActionsDecoded0 = [Swift.String]()
            for string0 in recommendedActionsContainer {
                if let string0 = string0 {
                    recommendedActionsDecoded0?.append(string0)
                }
            }
        }
        recommendedActions = recommendedActionsDecoded0
        let promptOverrideConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.PromptOverrideConfiguration.self, forKey: .promptOverrideConfiguration)
        promptOverrideConfiguration = promptOverrideConfigurationDecoded
    }
}

extension BedrockAgentClientTypes.AgentVersion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AgentVersion(agentArn: \(Swift.String(describing: agentArn)), agentId: \(Swift.String(describing: agentId)), agentName: \(Swift.String(describing: agentName)), agentResourceRoleArn: \(Swift.String(describing: agentResourceRoleArn)), agentStatus: \(Swift.String(describing: agentStatus)), createdAt: \(Swift.String(describing: createdAt)), customerEncryptionKeyArn: \(Swift.String(describing: customerEncryptionKeyArn)), description: \(Swift.String(describing: description)), failureReasons: \(Swift.String(describing: failureReasons)), foundationModel: \(Swift.String(describing: foundationModel)), idleSessionTTLInSeconds: \(Swift.String(describing: idleSessionTTLInSeconds)), recommendedActions: \(Swift.String(describing: recommendedActions)), updatedAt: \(Swift.String(describing: updatedAt)), version: \(Swift.String(describing: version)), instruction: \"CONTENT_REDACTED\", promptOverrideConfiguration: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentClientTypes {
    /// Contains the information of an agent version.
    public struct AgentVersion: Swift.Equatable {
        /// Arn representation of the Agent.
        /// This member is required.
        public var agentArn: Swift.String?
        /// Identifier for a resource.
        /// This member is required.
        public var agentId: Swift.String?
        /// Name for a resource.
        /// This member is required.
        public var agentName: Swift.String?
        /// ARN of a IAM role.
        /// This member is required.
        public var agentResourceRoleArn: Swift.String?
        /// Schema Type for Action APIs.
        /// This member is required.
        public var agentStatus: BedrockAgentClientTypes.AgentStatus?
        /// Time Stamp.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// A KMS key ARN
        public var customerEncryptionKeyArn: Swift.String?
        /// Description of the Resource.
        public var description: Swift.String?
        /// Failure Reasons for Error.
        public var failureReasons: [Swift.String]?
        /// ARN or name of a Bedrock model.
        public var foundationModel: Swift.String?
        /// Max Session Time.
        /// This member is required.
        public var idleSessionTTLInSeconds: Swift.Int?
        /// Instruction for the agent.
        public var instruction: Swift.String?
        /// Configuration for prompt override.
        public var promptOverrideConfiguration: BedrockAgentClientTypes.PromptOverrideConfiguration?
        /// The recommended actions users can take to resolve an error in failureReasons.
        public var recommendedActions: [Swift.String]?
        /// Time Stamp.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?
        /// Numerical Agent Version.
        /// This member is required.
        public var version: Swift.String?

        public init(
            agentArn: Swift.String? = nil,
            agentId: Swift.String? = nil,
            agentName: Swift.String? = nil,
            agentResourceRoleArn: Swift.String? = nil,
            agentStatus: BedrockAgentClientTypes.AgentStatus? = nil,
            createdAt: ClientRuntime.Date? = nil,
            customerEncryptionKeyArn: Swift.String? = nil,
            description: Swift.String? = nil,
            failureReasons: [Swift.String]? = nil,
            foundationModel: Swift.String? = nil,
            idleSessionTTLInSeconds: Swift.Int? = nil,
            instruction: Swift.String? = nil,
            promptOverrideConfiguration: BedrockAgentClientTypes.PromptOverrideConfiguration? = nil,
            recommendedActions: [Swift.String]? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            version: Swift.String? = nil
        )
        {
            self.agentArn = agentArn
            self.agentId = agentId
            self.agentName = agentName
            self.agentResourceRoleArn = agentResourceRoleArn
            self.agentStatus = agentStatus
            self.createdAt = createdAt
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.description = description
            self.failureReasons = failureReasons
            self.foundationModel = foundationModel
            self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
            self.instruction = instruction
            self.promptOverrideConfiguration = promptOverrideConfiguration
            self.recommendedActions = recommendedActions
            self.updatedAt = updatedAt
            self.version = version
        }
    }

}

extension BedrockAgentClientTypes.AgentVersionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentName
        case agentStatus
        case agentVersion
        case createdAt
        case description
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentName = self.agentName {
            try encodeContainer.encode(agentName, forKey: .agentName)
        }
        if let agentStatus = self.agentStatus {
            try encodeContainer.encode(agentStatus.rawValue, forKey: .agentStatus)
        }
        if let agentVersion = self.agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentName)
        agentName = agentNameDecoded
        let agentStatusDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentStatus.self, forKey: .agentStatus)
        agentStatus = agentStatusDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Summary of agent version.
    public struct AgentVersionSummary: Swift.Equatable {
        /// Name for a resource.
        /// This member is required.
        public var agentName: Swift.String?
        /// Schema Type for Action APIs.
        /// This member is required.
        public var agentStatus: BedrockAgentClientTypes.AgentStatus?
        /// Agent Version.
        /// This member is required.
        public var agentVersion: Swift.String?
        /// Time Stamp.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// Description of the Resource.
        public var description: Swift.String?
        /// Time Stamp.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            agentName: Swift.String? = nil,
            agentStatus: BedrockAgentClientTypes.AgentStatus? = nil,
            agentVersion: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.agentName = agentName
            self.agentStatus = agentStatus
            self.agentVersion = agentVersion
            self.createdAt = createdAt
            self.description = description
            self.updatedAt = updatedAt
        }
    }

}

extension AssociateAgentKnowledgeBaseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case knowledgeBaseId
        case knowledgeBaseState
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let knowledgeBaseState = self.knowledgeBaseState {
            try encodeContainer.encode(knowledgeBaseState.rawValue, forKey: .knowledgeBaseState)
        }
    }
}

extension AssociateAgentKnowledgeBaseInput {

    static func urlPathProvider(_ value: AssociateAgentKnowledgeBaseInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/knowledgebases"
    }
}

/// Associate Agent Knowledge Base Request
public struct AssociateAgentKnowledgeBaseInput: Swift.Equatable {
    /// Id generated at the server side when an Agent is created
    /// This member is required.
    public var agentId: Swift.String?
    /// Draft Version of the Agent.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// Description of the Resource.
    /// This member is required.
    public var description: Swift.String?
    /// Identifier for a resource.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// State of the knowledge base; whether it is enabled or disabled
    public var knowledgeBaseState: BedrockAgentClientTypes.KnowledgeBaseState?

    public init(
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        description: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil,
        knowledgeBaseState: BedrockAgentClientTypes.KnowledgeBaseState? = nil
    )
    {
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.description = description
        self.knowledgeBaseId = knowledgeBaseId
        self.knowledgeBaseState = knowledgeBaseState
    }
}

struct AssociateAgentKnowledgeBaseInputBody: Swift.Equatable {
    let knowledgeBaseId: Swift.String?
    let description: Swift.String?
    let knowledgeBaseState: BedrockAgentClientTypes.KnowledgeBaseState?
}

extension AssociateAgentKnowledgeBaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case knowledgeBaseId
        case knowledgeBaseState
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let knowledgeBaseStateDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.KnowledgeBaseState.self, forKey: .knowledgeBaseState)
        knowledgeBaseState = knowledgeBaseStateDecoded
    }
}

extension AssociateAgentKnowledgeBaseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateAgentKnowledgeBaseOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentKnowledgeBase = output.agentKnowledgeBase
        } else {
            self.agentKnowledgeBase = nil
        }
    }
}

/// Associate Agent Knowledge Base Response
public struct AssociateAgentKnowledgeBaseOutput: Swift.Equatable {
    /// Contains the information of an Agent Knowledge Base.
    /// This member is required.
    public var agentKnowledgeBase: BedrockAgentClientTypes.AgentKnowledgeBase?

    public init(
        agentKnowledgeBase: BedrockAgentClientTypes.AgentKnowledgeBase? = nil
    )
    {
        self.agentKnowledgeBase = agentKnowledgeBase
    }
}

struct AssociateAgentKnowledgeBaseOutputBody: Swift.Equatable {
    let agentKnowledgeBase: BedrockAgentClientTypes.AgentKnowledgeBase?
}

extension AssociateAgentKnowledgeBaseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentKnowledgeBase
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentKnowledgeBaseDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentKnowledgeBase.self, forKey: .agentKnowledgeBase)
        agentKnowledgeBase = agentKnowledgeBaseDecoded
    }
}

enum AssociateAgentKnowledgeBaseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BedrockAgentClientTypes.ChunkingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chunkingStrategy
        case fixedSizeChunkingConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chunkingStrategy = self.chunkingStrategy {
            try encodeContainer.encode(chunkingStrategy.rawValue, forKey: .chunkingStrategy)
        }
        if let fixedSizeChunkingConfiguration = self.fixedSizeChunkingConfiguration {
            try encodeContainer.encode(fixedSizeChunkingConfiguration, forKey: .fixedSizeChunkingConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let chunkingStrategyDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.ChunkingStrategy.self, forKey: .chunkingStrategy)
        chunkingStrategy = chunkingStrategyDecoded
        let fixedSizeChunkingConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.FixedSizeChunkingConfiguration.self, forKey: .fixedSizeChunkingConfiguration)
        fixedSizeChunkingConfiguration = fixedSizeChunkingConfigurationDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Configures chunking strategy
    public struct ChunkingConfiguration: Swift.Equatable {
        /// The type of chunking strategy
        /// This member is required.
        public var chunkingStrategy: BedrockAgentClientTypes.ChunkingStrategy?
        /// Configures fixed size chunking strategy
        public var fixedSizeChunkingConfiguration: BedrockAgentClientTypes.FixedSizeChunkingConfiguration?

        public init(
            chunkingStrategy: BedrockAgentClientTypes.ChunkingStrategy? = nil,
            fixedSizeChunkingConfiguration: BedrockAgentClientTypes.FixedSizeChunkingConfiguration? = nil
        )
        {
            self.chunkingStrategy = chunkingStrategy
            self.fixedSizeChunkingConfiguration = fixedSizeChunkingConfiguration
        }
    }

}

extension BedrockAgentClientTypes {
    /// The type of chunking strategy
    public enum ChunkingStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fixedSize
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [ChunkingStrategy] {
            return [
                .fixedSize,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fixedSize: return "FIXED_SIZE"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChunkingStrategy(rawValue: rawValue) ?? ChunkingStrategy.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when there is a conflict performing an operation
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Non Blank String
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateAgentActionGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionGroupExecutor
        case actionGroupName
        case actionGroupState
        case apiSchema
        case clientToken
        case description
        case parentActionGroupSignature
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionGroupExecutor = self.actionGroupExecutor {
            try encodeContainer.encode(actionGroupExecutor, forKey: .actionGroupExecutor)
        }
        if let actionGroupName = self.actionGroupName {
            try encodeContainer.encode(actionGroupName, forKey: .actionGroupName)
        }
        if let actionGroupState = self.actionGroupState {
            try encodeContainer.encode(actionGroupState.rawValue, forKey: .actionGroupState)
        }
        if let apiSchema = self.apiSchema {
            try encodeContainer.encode(apiSchema, forKey: .apiSchema)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let parentActionGroupSignature = self.parentActionGroupSignature {
            try encodeContainer.encode(parentActionGroupSignature.rawValue, forKey: .parentActionGroupSignature)
        }
    }
}

extension CreateAgentActionGroupInput {

    static func urlPathProvider(_ value: CreateAgentActionGroupInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/actiongroups"
    }
}

/// Create Action Group Request
public struct CreateAgentActionGroupInput: Swift.Equatable {
    /// Type of Executors for an Action Group
    public var actionGroupExecutor: BedrockAgentClientTypes.ActionGroupExecutor?
    /// Name for a resource.
    /// This member is required.
    public var actionGroupName: Swift.String?
    /// State of the action group
    public var actionGroupState: BedrockAgentClientTypes.ActionGroupState?
    /// Id generated at the server side when an Agent is created
    /// This member is required.
    public var agentId: Swift.String?
    /// Draft Version of the Agent.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// Contains information about the API Schema for the Action Group
    public var apiSchema: BedrockAgentClientTypes.APISchema?
    /// Client specified token used for idempotency checks
    public var clientToken: Swift.String?
    /// Description of the Resource.
    public var description: Swift.String?
    /// Action Group Signature for a BuiltIn Action
    public var parentActionGroupSignature: BedrockAgentClientTypes.ActionGroupSignature?

    public init(
        actionGroupExecutor: BedrockAgentClientTypes.ActionGroupExecutor? = nil,
        actionGroupName: Swift.String? = nil,
        actionGroupState: BedrockAgentClientTypes.ActionGroupState? = nil,
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        apiSchema: BedrockAgentClientTypes.APISchema? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        parentActionGroupSignature: BedrockAgentClientTypes.ActionGroupSignature? = nil
    )
    {
        self.actionGroupExecutor = actionGroupExecutor
        self.actionGroupName = actionGroupName
        self.actionGroupState = actionGroupState
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.apiSchema = apiSchema
        self.clientToken = clientToken
        self.description = description
        self.parentActionGroupSignature = parentActionGroupSignature
    }
}

struct CreateAgentActionGroupInputBody: Swift.Equatable {
    let actionGroupName: Swift.String?
    let clientToken: Swift.String?
    let description: Swift.String?
    let parentActionGroupSignature: BedrockAgentClientTypes.ActionGroupSignature?
    let actionGroupExecutor: BedrockAgentClientTypes.ActionGroupExecutor?
    let apiSchema: BedrockAgentClientTypes.APISchema?
    let actionGroupState: BedrockAgentClientTypes.ActionGroupState?
}

extension CreateAgentActionGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionGroupExecutor
        case actionGroupName
        case actionGroupState
        case apiSchema
        case clientToken
        case description
        case parentActionGroupSignature
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionGroupName)
        actionGroupName = actionGroupNameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parentActionGroupSignatureDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.ActionGroupSignature.self, forKey: .parentActionGroupSignature)
        parentActionGroupSignature = parentActionGroupSignatureDecoded
        let actionGroupExecutorDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.ActionGroupExecutor.self, forKey: .actionGroupExecutor)
        actionGroupExecutor = actionGroupExecutorDecoded
        let apiSchemaDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.APISchema.self, forKey: .apiSchema)
        apiSchema = apiSchemaDecoded
        let actionGroupStateDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.ActionGroupState.self, forKey: .actionGroupState)
        actionGroupState = actionGroupStateDecoded
    }
}

extension CreateAgentActionGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAgentActionGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentActionGroup = output.agentActionGroup
        } else {
            self.agentActionGroup = nil
        }
    }
}

/// Create Action Group Response
public struct CreateAgentActionGroupOutput: Swift.Equatable {
    /// Contains the information of an Agent Action Group
    /// This member is required.
    public var agentActionGroup: BedrockAgentClientTypes.AgentActionGroup?

    public init(
        agentActionGroup: BedrockAgentClientTypes.AgentActionGroup? = nil
    )
    {
        self.agentActionGroup = agentActionGroup
    }
}

struct CreateAgentActionGroupOutputBody: Swift.Equatable {
    let agentActionGroup: BedrockAgentClientTypes.AgentActionGroup?
}

extension CreateAgentActionGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentActionGroup
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentActionGroupDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentActionGroup.self, forKey: .agentActionGroup)
        agentActionGroup = agentActionGroupDecoded
    }
}

enum CreateAgentActionGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateAgentAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentAliasName
        case clientToken
        case description
        case routingConfiguration
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentAliasName = self.agentAliasName {
            try encodeContainer.encode(agentAliasName, forKey: .agentAliasName)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let routingConfiguration = routingConfiguration {
            var routingConfigurationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .routingConfiguration)
            for agentaliasroutingconfigurationlistitem0 in routingConfiguration {
                try routingConfigurationContainer.encode(agentaliasroutingconfigurationlistitem0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAgentAliasInput {

    static func urlPathProvider(_ value: CreateAgentAliasInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentaliases"
    }
}

/// Create Agent Alias Request
public struct CreateAgentAliasInput: Swift.Equatable {
    /// Name for a resource.
    /// This member is required.
    public var agentAliasName: Swift.String?
    /// Id generated at the server side when an Agent is created
    /// This member is required.
    public var agentId: Swift.String?
    /// Client specified token used for idempotency checks
    public var clientToken: Swift.String?
    /// Description of the Resource.
    public var description: Swift.String?
    /// Routing configuration for an Agent alias.
    public var routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]?
    /// A map of tag keys and values
    public var tags: [Swift.String:Swift.String]?

    public init(
        agentAliasName: Swift.String? = nil,
        agentId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.agentAliasName = agentAliasName
        self.agentId = agentId
        self.clientToken = clientToken
        self.description = description
        self.routingConfiguration = routingConfiguration
        self.tags = tags
    }
}

struct CreateAgentAliasInputBody: Swift.Equatable {
    let agentAliasName: Swift.String?
    let clientToken: Swift.String?
    let description: Swift.String?
    let routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateAgentAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentAliasName
        case clientToken
        case description
        case routingConfiguration
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentAliasNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentAliasName)
        agentAliasName = agentAliasNameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let routingConfigurationContainer = try containerValues.decodeIfPresent([BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem?].self, forKey: .routingConfiguration)
        var routingConfigurationDecoded0:[BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]? = nil
        if let routingConfigurationContainer = routingConfigurationContainer {
            routingConfigurationDecoded0 = [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]()
            for structure0 in routingConfigurationContainer {
                if let structure0 = structure0 {
                    routingConfigurationDecoded0?.append(structure0)
                }
            }
        }
        routingConfiguration = routingConfigurationDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAgentAliasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAgentAliasOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentAlias = output.agentAlias
        } else {
            self.agentAlias = nil
        }
    }
}

/// Create Agent Alias Response
public struct CreateAgentAliasOutput: Swift.Equatable {
    /// Contains the information of an agent alias
    /// This member is required.
    public var agentAlias: BedrockAgentClientTypes.AgentAlias?

    public init(
        agentAlias: BedrockAgentClientTypes.AgentAlias? = nil
    )
    {
        self.agentAlias = agentAlias
    }
}

struct CreateAgentAliasOutputBody: Swift.Equatable {
    let agentAlias: BedrockAgentClientTypes.AgentAlias?
}

extension CreateAgentAliasOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentAlias
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentAliasDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentAlias.self, forKey: .agentAlias)
        agentAlias = agentAliasDecoded
    }
}

enum CreateAgentAliasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateAgentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAgentInput(agentName: \(Swift.String(describing: agentName)), agentResourceRoleArn: \(Swift.String(describing: agentResourceRoleArn)), clientToken: \(Swift.String(describing: clientToken)), customerEncryptionKeyArn: \(Swift.String(describing: customerEncryptionKeyArn)), description: \(Swift.String(describing: description)), foundationModel: \(Swift.String(describing: foundationModel)), idleSessionTTLInSeconds: \(Swift.String(describing: idleSessionTTLInSeconds)), tags: \(Swift.String(describing: tags)), instruction: \"CONTENT_REDACTED\", promptOverrideConfiguration: \"CONTENT_REDACTED\")"}
}

extension CreateAgentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentName
        case agentResourceRoleArn
        case clientToken
        case customerEncryptionKeyArn
        case description
        case foundationModel
        case idleSessionTTLInSeconds
        case instruction
        case promptOverrideConfiguration
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentName = self.agentName {
            try encodeContainer.encode(agentName, forKey: .agentName)
        }
        if let agentResourceRoleArn = self.agentResourceRoleArn {
            try encodeContainer.encode(agentResourceRoleArn, forKey: .agentResourceRoleArn)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let customerEncryptionKeyArn = self.customerEncryptionKeyArn {
            try encodeContainer.encode(customerEncryptionKeyArn, forKey: .customerEncryptionKeyArn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let foundationModel = self.foundationModel {
            try encodeContainer.encode(foundationModel, forKey: .foundationModel)
        }
        if let idleSessionTTLInSeconds = self.idleSessionTTLInSeconds {
            try encodeContainer.encode(idleSessionTTLInSeconds, forKey: .idleSessionTTLInSeconds)
        }
        if let instruction = self.instruction {
            try encodeContainer.encode(instruction, forKey: .instruction)
        }
        if let promptOverrideConfiguration = self.promptOverrideConfiguration {
            try encodeContainer.encode(promptOverrideConfiguration, forKey: .promptOverrideConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAgentInput {

    static func urlPathProvider(_ value: CreateAgentInput) -> Swift.String? {
        return "/agents"
    }
}

/// Create Agent Request
public struct CreateAgentInput: Swift.Equatable {
    /// Name for a resource.
    /// This member is required.
    public var agentName: Swift.String?
    /// ARN of a IAM role.
    /// This member is required.
    public var agentResourceRoleArn: Swift.String?
    /// Client specified token used for idempotency checks
    public var clientToken: Swift.String?
    /// A KMS key ARN
    public var customerEncryptionKeyArn: Swift.String?
    /// Description of the Resource.
    public var description: Swift.String?
    /// ARN or name of a Bedrock model.
    public var foundationModel: Swift.String?
    /// Max Session Time.
    public var idleSessionTTLInSeconds: Swift.Int?
    /// Instruction for the agent.
    public var instruction: Swift.String?
    /// Configuration for prompt override.
    public var promptOverrideConfiguration: BedrockAgentClientTypes.PromptOverrideConfiguration?
    /// A map of tag keys and values
    public var tags: [Swift.String:Swift.String]?

    public init(
        agentName: Swift.String? = nil,
        agentResourceRoleArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        customerEncryptionKeyArn: Swift.String? = nil,
        description: Swift.String? = nil,
        foundationModel: Swift.String? = nil,
        idleSessionTTLInSeconds: Swift.Int? = nil,
        instruction: Swift.String? = nil,
        promptOverrideConfiguration: BedrockAgentClientTypes.PromptOverrideConfiguration? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.agentName = agentName
        self.agentResourceRoleArn = agentResourceRoleArn
        self.clientToken = clientToken
        self.customerEncryptionKeyArn = customerEncryptionKeyArn
        self.description = description
        self.foundationModel = foundationModel
        self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
        self.instruction = instruction
        self.promptOverrideConfiguration = promptOverrideConfiguration
        self.tags = tags
    }
}

struct CreateAgentInputBody: Swift.Equatable {
    let agentName: Swift.String?
    let clientToken: Swift.String?
    let instruction: Swift.String?
    let foundationModel: Swift.String?
    let description: Swift.String?
    let idleSessionTTLInSeconds: Swift.Int?
    let agentResourceRoleArn: Swift.String?
    let customerEncryptionKeyArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let promptOverrideConfiguration: BedrockAgentClientTypes.PromptOverrideConfiguration?
}

extension CreateAgentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentName
        case agentResourceRoleArn
        case clientToken
        case customerEncryptionKeyArn
        case description
        case foundationModel
        case idleSessionTTLInSeconds
        case instruction
        case promptOverrideConfiguration
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentName)
        agentName = agentNameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let instructionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instruction)
        instruction = instructionDecoded
        let foundationModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .foundationModel)
        foundationModel = foundationModelDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let idleSessionTTLInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleSessionTTLInSeconds)
        idleSessionTTLInSeconds = idleSessionTTLInSecondsDecoded
        let agentResourceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentResourceRoleArn)
        agentResourceRoleArn = agentResourceRoleArnDecoded
        let customerEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerEncryptionKeyArn)
        customerEncryptionKeyArn = customerEncryptionKeyArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let promptOverrideConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.PromptOverrideConfiguration.self, forKey: .promptOverrideConfiguration)
        promptOverrideConfiguration = promptOverrideConfigurationDecoded
    }
}

extension CreateAgentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAgentOutputBody = try responseDecoder.decode(responseBody: data)
            self.agent = output.agent
        } else {
            self.agent = nil
        }
    }
}

/// Create Agent Response
public struct CreateAgentOutput: Swift.Equatable {
    /// Contains the information of an agent
    /// This member is required.
    public var agent: BedrockAgentClientTypes.Agent?

    public init(
        agent: BedrockAgentClientTypes.Agent? = nil
    )
    {
        self.agent = agent
    }
}

struct CreateAgentOutputBody: Swift.Equatable {
    let agent: BedrockAgentClientTypes.Agent?
}

extension CreateAgentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agent
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.Agent.self, forKey: .agent)
        agent = agentDecoded
    }
}

enum CreateAgentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDataSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case dataSourceConfiguration
        case description
        case name
        case serverSideEncryptionConfiguration
        case vectorIngestionConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dataSourceConfiguration = self.dataSourceConfiguration {
            try encodeContainer.encode(dataSourceConfiguration, forKey: .dataSourceConfiguration)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverSideEncryptionConfiguration = self.serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let vectorIngestionConfiguration = self.vectorIngestionConfiguration {
            try encodeContainer.encode(vectorIngestionConfiguration, forKey: .vectorIngestionConfiguration)
        }
    }
}

extension CreateDataSourceInput {

    static func urlPathProvider(_ value: CreateDataSourceInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/datasources"
    }
}

public struct CreateDataSourceInput: Swift.Equatable {
    /// Client specified token used for idempotency checks
    public var clientToken: Swift.String?
    /// Specifies a raw data source location to ingest.
    /// This member is required.
    public var dataSourceConfiguration: BedrockAgentClientTypes.DataSourceConfiguration?
    /// Description of the Resource.
    public var description: Swift.String?
    /// Identifier for a resource.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// Name for a resource.
    /// This member is required.
    public var name: Swift.String?
    /// Server-side encryption configuration.
    public var serverSideEncryptionConfiguration: BedrockAgentClientTypes.ServerSideEncryptionConfiguration?
    /// Configures ingestion for a vector knowledge base
    public var vectorIngestionConfiguration: BedrockAgentClientTypes.VectorIngestionConfiguration?

    public init(
        clientToken: Swift.String? = nil,
        dataSourceConfiguration: BedrockAgentClientTypes.DataSourceConfiguration? = nil,
        description: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil,
        name: Swift.String? = nil,
        serverSideEncryptionConfiguration: BedrockAgentClientTypes.ServerSideEncryptionConfiguration? = nil,
        vectorIngestionConfiguration: BedrockAgentClientTypes.VectorIngestionConfiguration? = nil
    )
    {
        self.clientToken = clientToken
        self.dataSourceConfiguration = dataSourceConfiguration
        self.description = description
        self.knowledgeBaseId = knowledgeBaseId
        self.name = name
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
        self.vectorIngestionConfiguration = vectorIngestionConfiguration
    }
}

struct CreateDataSourceInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let dataSourceConfiguration: BedrockAgentClientTypes.DataSourceConfiguration?
    let serverSideEncryptionConfiguration: BedrockAgentClientTypes.ServerSideEncryptionConfiguration?
    let vectorIngestionConfiguration: BedrockAgentClientTypes.VectorIngestionConfiguration?
}

extension CreateDataSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case dataSourceConfiguration
        case description
        case name
        case serverSideEncryptionConfiguration
        case vectorIngestionConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourceConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.DataSourceConfiguration.self, forKey: .dataSourceConfiguration)
        dataSourceConfiguration = dataSourceConfigurationDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let vectorIngestionConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.VectorIngestionConfiguration.self, forKey: .vectorIngestionConfiguration)
        vectorIngestionConfiguration = vectorIngestionConfigurationDecoded
    }
}

extension CreateDataSourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDataSourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataSource = output.dataSource
        } else {
            self.dataSource = nil
        }
    }
}

public struct CreateDataSourceOutput: Swift.Equatable {
    /// Contains the information of a data source.
    /// This member is required.
    public var dataSource: BedrockAgentClientTypes.DataSource?

    public init(
        dataSource: BedrockAgentClientTypes.DataSource? = nil
    )
    {
        self.dataSource = dataSource
    }
}

struct CreateDataSourceOutputBody: Swift.Equatable {
    let dataSource: BedrockAgentClientTypes.DataSource?
}

extension CreateDataSourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
    }
}

enum CreateDataSourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateKnowledgeBaseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case knowledgeBaseConfiguration
        case name
        case roleArn
        case storageConfiguration
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let knowledgeBaseConfiguration = self.knowledgeBaseConfiguration {
            try encodeContainer.encode(knowledgeBaseConfiguration, forKey: .knowledgeBaseConfiguration)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let storageConfiguration = self.storageConfiguration {
            try encodeContainer.encode(storageConfiguration, forKey: .storageConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateKnowledgeBaseInput {

    static func urlPathProvider(_ value: CreateKnowledgeBaseInput) -> Swift.String? {
        return "/knowledgebases"
    }
}

public struct CreateKnowledgeBaseInput: Swift.Equatable {
    /// Client specified token used for idempotency checks
    public var clientToken: Swift.String?
    /// Description of the Resource.
    public var description: Swift.String?
    /// Configures a bedrock knowledge base.
    /// This member is required.
    public var knowledgeBaseConfiguration: BedrockAgentClientTypes.KnowledgeBaseConfiguration?
    /// Name for a resource.
    /// This member is required.
    public var name: Swift.String?
    /// ARN of a IAM role.
    /// This member is required.
    public var roleArn: Swift.String?
    /// Configures the physical storage of ingested data in a knowledge base.
    /// This member is required.
    public var storageConfiguration: BedrockAgentClientTypes.StorageConfiguration?
    /// A map of tag keys and values
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        knowledgeBaseConfiguration: BedrockAgentClientTypes.KnowledgeBaseConfiguration? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        storageConfiguration: BedrockAgentClientTypes.StorageConfiguration? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.knowledgeBaseConfiguration = knowledgeBaseConfiguration
        self.name = name
        self.roleArn = roleArn
        self.storageConfiguration = storageConfiguration
        self.tags = tags
    }
}

struct CreateKnowledgeBaseInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let roleArn: Swift.String?
    let knowledgeBaseConfiguration: BedrockAgentClientTypes.KnowledgeBaseConfiguration?
    let storageConfiguration: BedrockAgentClientTypes.StorageConfiguration?
    let tags: [Swift.String:Swift.String]?
}

extension CreateKnowledgeBaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case knowledgeBaseConfiguration
        case name
        case roleArn
        case storageConfiguration
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let knowledgeBaseConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.KnowledgeBaseConfiguration.self, forKey: .knowledgeBaseConfiguration)
        knowledgeBaseConfiguration = knowledgeBaseConfigurationDecoded
        let storageConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.StorageConfiguration.self, forKey: .storageConfiguration)
        storageConfiguration = storageConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateKnowledgeBaseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateKnowledgeBaseOutputBody = try responseDecoder.decode(responseBody: data)
            self.knowledgeBase = output.knowledgeBase
        } else {
            self.knowledgeBase = nil
        }
    }
}

public struct CreateKnowledgeBaseOutput: Swift.Equatable {
    /// Contains the information of a knowledge base.
    /// This member is required.
    public var knowledgeBase: BedrockAgentClientTypes.KnowledgeBase?

    public init(
        knowledgeBase: BedrockAgentClientTypes.KnowledgeBase? = nil
    )
    {
        self.knowledgeBase = knowledgeBase
    }
}

struct CreateKnowledgeBaseOutputBody: Swift.Equatable {
    let knowledgeBase: BedrockAgentClientTypes.KnowledgeBase?
}

extension CreateKnowledgeBaseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knowledgeBase
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.KnowledgeBase.self, forKey: .knowledgeBase)
        knowledgeBase = knowledgeBaseDecoded
    }
}

enum CreateKnowledgeBaseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BedrockAgentClientTypes {
    /// Creation Mode for Prompt Configuration.
    public enum CreationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case overridden
        case sdkUnknown(Swift.String)

        public static var allCases: [CreationMode] {
            return [
                .default,
                .overridden,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .overridden: return "OVERRIDDEN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CreationMode(rawValue: rawValue) ?? CreationMode.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentClientTypes.DataSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case dataSourceConfiguration
        case dataSourceId
        case description
        case knowledgeBaseId
        case name
        case serverSideEncryptionConfiguration
        case status
        case updatedAt
        case vectorIngestionConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let dataSourceConfiguration = self.dataSourceConfiguration {
            try encodeContainer.encode(dataSourceConfiguration, forKey: .dataSourceConfiguration)
        }
        if let dataSourceId = self.dataSourceId {
            try encodeContainer.encode(dataSourceId, forKey: .dataSourceId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverSideEncryptionConfiguration = self.serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
        if let vectorIngestionConfiguration = self.vectorIngestionConfiguration {
            try encodeContainer.encode(vectorIngestionConfiguration, forKey: .vectorIngestionConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.DataSourceStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourceConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.DataSourceConfiguration.self, forKey: .dataSourceConfiguration)
        dataSourceConfiguration = dataSourceConfigurationDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let vectorIngestionConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.VectorIngestionConfiguration.self, forKey: .vectorIngestionConfiguration)
        vectorIngestionConfiguration = vectorIngestionConfigurationDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains the information of a data source.
    public struct DataSource: Swift.Equatable {
        /// Time Stamp.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// Specifies a raw data source location to ingest.
        /// This member is required.
        public var dataSourceConfiguration: BedrockAgentClientTypes.DataSourceConfiguration?
        /// Identifier for a resource.
        /// This member is required.
        public var dataSourceId: Swift.String?
        /// Description of the Resource.
        public var description: Swift.String?
        /// Identifier for a resource.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// Name for a resource.
        /// This member is required.
        public var name: Swift.String?
        /// Server-side encryption configuration.
        public var serverSideEncryptionConfiguration: BedrockAgentClientTypes.ServerSideEncryptionConfiguration?
        /// The status of a data source.
        /// This member is required.
        public var status: BedrockAgentClientTypes.DataSourceStatus?
        /// Time Stamp.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?
        /// Configures ingestion for a vector knowledge base
        public var vectorIngestionConfiguration: BedrockAgentClientTypes.VectorIngestionConfiguration?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            dataSourceConfiguration: BedrockAgentClientTypes.DataSourceConfiguration? = nil,
            dataSourceId: Swift.String? = nil,
            description: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            name: Swift.String? = nil,
            serverSideEncryptionConfiguration: BedrockAgentClientTypes.ServerSideEncryptionConfiguration? = nil,
            status: BedrockAgentClientTypes.DataSourceStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            vectorIngestionConfiguration: BedrockAgentClientTypes.VectorIngestionConfiguration? = nil
        )
        {
            self.createdAt = createdAt
            self.dataSourceConfiguration = dataSourceConfiguration
            self.dataSourceId = dataSourceId
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.status = status
            self.updatedAt = updatedAt
            self.vectorIngestionConfiguration = vectorIngestionConfiguration
        }
    }

}

extension BedrockAgentClientTypes.DataSourceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Configuration
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Configuration = self.s3Configuration {
            try encodeContainer.encode(s3Configuration, forKey: .s3Configuration)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.DataSourceType.self, forKey: .type)
        type = typeDecoded
        let s3ConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.S3DataSourceConfiguration.self, forKey: .s3Configuration)
        s3Configuration = s3ConfigurationDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Specifies a raw data source location to ingest.
    public struct DataSourceConfiguration: Swift.Equatable {
        /// Configures an S3 data source location.
        public var s3Configuration: BedrockAgentClientTypes.S3DataSourceConfiguration?
        /// The type of the data source location.
        /// This member is required.
        public var type: BedrockAgentClientTypes.DataSourceType?

        public init(
            s3Configuration: BedrockAgentClientTypes.S3DataSourceConfiguration? = nil,
            type: BedrockAgentClientTypes.DataSourceType? = nil
        )
        {
            self.s3Configuration = s3Configuration
            self.type = type
        }
    }

}

extension BedrockAgentClientTypes {
    /// The status of a data source.
    public enum DataSourceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceStatus] {
            return [
                .available,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSourceStatus(rawValue: rawValue) ?? DataSourceStatus.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentClientTypes.DataSourceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceId
        case description
        case knowledgeBaseId
        case name
        case status
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceId = self.dataSourceId {
            try encodeContainer.encode(dataSourceId, forKey: .dataSourceId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.DataSourceStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Summary information of a data source.
    public struct DataSourceSummary: Swift.Equatable {
        /// Identifier for a resource.
        /// This member is required.
        public var dataSourceId: Swift.String?
        /// Description of the Resource.
        public var description: Swift.String?
        /// Identifier for a resource.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// Name for a resource.
        /// This member is required.
        public var name: Swift.String?
        /// The status of a data source.
        /// This member is required.
        public var status: BedrockAgentClientTypes.DataSourceStatus?
        /// Time Stamp.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            dataSourceId: Swift.String? = nil,
            description: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            name: Swift.String? = nil,
            status: BedrockAgentClientTypes.DataSourceStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.dataSourceId = dataSourceId
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension BedrockAgentClientTypes {
    /// The type of the data source location.
    public enum DataSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceType] {
            return [
                .s3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSourceType(rawValue: rawValue) ?? DataSourceType.sdkUnknown(rawValue)
        }
    }
}

extension DeleteAgentActionGroupInput {

    static func queryItemProvider(_ value: DeleteAgentActionGroupInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let skipResourceInUseCheck = value.skipResourceInUseCheck {
            let skipResourceInUseCheckQueryItem = ClientRuntime.SDKURLQueryItem(name: "skipResourceInUseCheck".urlPercentEncoding(), value: Swift.String(skipResourceInUseCheck).urlPercentEncoding())
            items.append(skipResourceInUseCheckQueryItem)
        }
        return items
    }
}

extension DeleteAgentActionGroupInput {

    static func urlPathProvider(_ value: DeleteAgentActionGroupInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        guard let actionGroupId = value.actionGroupId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/actiongroups/\(actionGroupId.urlPercentEncoding())"
    }
}

/// Delete Action Group Request
public struct DeleteAgentActionGroupInput: Swift.Equatable {
    /// Id generated at the server side when an Agent ActionGroup is created
    /// This member is required.
    public var actionGroupId: Swift.String?
    /// Id generated at the server side when an Agent is created
    /// This member is required.
    public var agentId: Swift.String?
    /// Draft Version of the Agent.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// Skips checking if resource is in use when set to true. Defaults to false
    public var skipResourceInUseCheck: Swift.Bool?

    public init(
        actionGroupId: Swift.String? = nil,
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        skipResourceInUseCheck: Swift.Bool? = nil
    )
    {
        self.actionGroupId = actionGroupId
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.skipResourceInUseCheck = skipResourceInUseCheck
    }
}

struct DeleteAgentActionGroupInputBody: Swift.Equatable {
}

extension DeleteAgentActionGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAgentActionGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// Delete Action Group Response
public struct DeleteAgentActionGroupOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAgentActionGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAgentAliasInput {

    static func urlPathProvider(_ value: DeleteAgentAliasInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentAliasId = value.agentAliasId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentaliases/\(agentAliasId.urlPercentEncoding())"
    }
}

/// Delete Agent Alias Request
public struct DeleteAgentAliasInput: Swift.Equatable {
    /// Id generated at the server side when an Agent Alias is created
    /// This member is required.
    public var agentAliasId: Swift.String?
    /// Id generated at the server side when an Agent is created
    /// This member is required.
    public var agentId: Swift.String?

    public init(
        agentAliasId: Swift.String? = nil,
        agentId: Swift.String? = nil
    )
    {
        self.agentAliasId = agentAliasId
        self.agentId = agentId
    }
}

struct DeleteAgentAliasInputBody: Swift.Equatable {
}

extension DeleteAgentAliasInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAgentAliasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteAgentAliasOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentAliasId = output.agentAliasId
            self.agentAliasStatus = output.agentAliasStatus
            self.agentId = output.agentId
        } else {
            self.agentAliasId = nil
            self.agentAliasStatus = nil
            self.agentId = nil
        }
    }
}

/// Delete Agent Alias Response
public struct DeleteAgentAliasOutput: Swift.Equatable {
    /// Id for an Agent Alias generated at the server side.
    /// This member is required.
    public var agentAliasId: Swift.String?
    /// The statuses an Agent Alias can be in.
    /// This member is required.
    public var agentAliasStatus: BedrockAgentClientTypes.AgentAliasStatus?
    /// Identifier for a resource.
    /// This member is required.
    public var agentId: Swift.String?

    public init(
        agentAliasId: Swift.String? = nil,
        agentAliasStatus: BedrockAgentClientTypes.AgentAliasStatus? = nil,
        agentId: Swift.String? = nil
    )
    {
        self.agentAliasId = agentAliasId
        self.agentAliasStatus = agentAliasStatus
        self.agentId = agentId
    }
}

struct DeleteAgentAliasOutputBody: Swift.Equatable {
    let agentId: Swift.String?
    let agentAliasId: Swift.String?
    let agentAliasStatus: BedrockAgentClientTypes.AgentAliasStatus?
}

extension DeleteAgentAliasOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentAliasId
        case agentAliasStatus
        case agentId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let agentAliasIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentAliasId)
        agentAliasId = agentAliasIdDecoded
        let agentAliasStatusDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentAliasStatus.self, forKey: .agentAliasStatus)
        agentAliasStatus = agentAliasStatusDecoded
    }
}

enum DeleteAgentAliasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAgentInput {

    static func queryItemProvider(_ value: DeleteAgentInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let skipResourceInUseCheck = value.skipResourceInUseCheck {
            let skipResourceInUseCheckQueryItem = ClientRuntime.SDKURLQueryItem(name: "skipResourceInUseCheck".urlPercentEncoding(), value: Swift.String(skipResourceInUseCheck).urlPercentEncoding())
            items.append(skipResourceInUseCheckQueryItem)
        }
        return items
    }
}

extension DeleteAgentInput {

    static func urlPathProvider(_ value: DeleteAgentInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())"
    }
}

/// Delete Agent Request
public struct DeleteAgentInput: Swift.Equatable {
    /// Id generated at the server side when an Agent is created
    /// This member is required.
    public var agentId: Swift.String?
    /// Skips checking if resource is in use when set to true. Defaults to false
    public var skipResourceInUseCheck: Swift.Bool?

    public init(
        agentId: Swift.String? = nil,
        skipResourceInUseCheck: Swift.Bool? = nil
    )
    {
        self.agentId = agentId
        self.skipResourceInUseCheck = skipResourceInUseCheck
    }
}

struct DeleteAgentInputBody: Swift.Equatable {
}

extension DeleteAgentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAgentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteAgentOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentId = output.agentId
            self.agentStatus = output.agentStatus
        } else {
            self.agentId = nil
            self.agentStatus = nil
        }
    }
}

/// Delete Agent Response
public struct DeleteAgentOutput: Swift.Equatable {
    /// Identifier for a resource.
    /// This member is required.
    public var agentId: Swift.String?
    /// Schema Type for Action APIs.
    /// This member is required.
    public var agentStatus: BedrockAgentClientTypes.AgentStatus?

    public init(
        agentId: Swift.String? = nil,
        agentStatus: BedrockAgentClientTypes.AgentStatus? = nil
    )
    {
        self.agentId = agentId
        self.agentStatus = agentStatus
    }
}

struct DeleteAgentOutputBody: Swift.Equatable {
    let agentId: Swift.String?
    let agentStatus: BedrockAgentClientTypes.AgentStatus?
}

extension DeleteAgentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentId
        case agentStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let agentStatusDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentStatus.self, forKey: .agentStatus)
        agentStatus = agentStatusDecoded
    }
}

enum DeleteAgentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAgentVersionInput {

    static func queryItemProvider(_ value: DeleteAgentVersionInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let skipResourceInUseCheck = value.skipResourceInUseCheck {
            let skipResourceInUseCheckQueryItem = ClientRuntime.SDKURLQueryItem(name: "skipResourceInUseCheck".urlPercentEncoding(), value: Swift.String(skipResourceInUseCheck).urlPercentEncoding())
            items.append(skipResourceInUseCheckQueryItem)
        }
        return items
    }
}

extension DeleteAgentVersionInput {

    static func urlPathProvider(_ value: DeleteAgentVersionInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())"
    }
}

/// Delete Agent Version Request
public struct DeleteAgentVersionInput: Swift.Equatable {
    /// Id generated at the server side when an Agent is created
    /// This member is required.
    public var agentId: Swift.String?
    /// Numerical Agent Version.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// Skips checking if resource is in use when set to true. Defaults to false
    public var skipResourceInUseCheck: Swift.Bool?

    public init(
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        skipResourceInUseCheck: Swift.Bool? = nil
    )
    {
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.skipResourceInUseCheck = skipResourceInUseCheck
    }
}

struct DeleteAgentVersionInputBody: Swift.Equatable {
}

extension DeleteAgentVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAgentVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteAgentVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentId = output.agentId
            self.agentStatus = output.agentStatus
            self.agentVersion = output.agentVersion
        } else {
            self.agentId = nil
            self.agentStatus = nil
            self.agentVersion = nil
        }
    }
}

/// Delete Agent Version Response
public struct DeleteAgentVersionOutput: Swift.Equatable {
    /// Identifier for a resource.
    /// This member is required.
    public var agentId: Swift.String?
    /// Schema Type for Action APIs.
    /// This member is required.
    public var agentStatus: BedrockAgentClientTypes.AgentStatus?
    /// Numerical Agent Version.
    /// This member is required.
    public var agentVersion: Swift.String?

    public init(
        agentId: Swift.String? = nil,
        agentStatus: BedrockAgentClientTypes.AgentStatus? = nil,
        agentVersion: Swift.String? = nil
    )
    {
        self.agentId = agentId
        self.agentStatus = agentStatus
        self.agentVersion = agentVersion
    }
}

struct DeleteAgentVersionOutputBody: Swift.Equatable {
    let agentId: Swift.String?
    let agentVersion: Swift.String?
    let agentStatus: BedrockAgentClientTypes.AgentStatus?
}

extension DeleteAgentVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentId
        case agentStatus
        case agentVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
        let agentStatusDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentStatus.self, forKey: .agentStatus)
        agentStatus = agentStatusDecoded
    }
}

enum DeleteAgentVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDataSourceInput {

    static func urlPathProvider(_ value: DeleteDataSourceInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let dataSourceId = value.dataSourceId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())"
    }
}

public struct DeleteDataSourceInput: Swift.Equatable {
    /// Identifier for a resource.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// Identifier for a resource.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        dataSourceId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.dataSourceId = dataSourceId
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct DeleteDataSourceInputBody: Swift.Equatable {
}

extension DeleteDataSourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDataSourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteDataSourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataSourceId = output.dataSourceId
            self.knowledgeBaseId = output.knowledgeBaseId
            self.status = output.status
        } else {
            self.dataSourceId = nil
            self.knowledgeBaseId = nil
            self.status = nil
        }
    }
}

public struct DeleteDataSourceOutput: Swift.Equatable {
    /// Identifier for a resource.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// Identifier for a resource.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The status of a data source.
    /// This member is required.
    public var status: BedrockAgentClientTypes.DataSourceStatus?

    public init(
        dataSourceId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil,
        status: BedrockAgentClientTypes.DataSourceStatus? = nil
    )
    {
        self.dataSourceId = dataSourceId
        self.knowledgeBaseId = knowledgeBaseId
        self.status = status
    }
}

struct DeleteDataSourceOutputBody: Swift.Equatable {
    let knowledgeBaseId: Swift.String?
    let dataSourceId: Swift.String?
    let status: BedrockAgentClientTypes.DataSourceStatus?
}

extension DeleteDataSourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceId
        case knowledgeBaseId
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.DataSourceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum DeleteDataSourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteKnowledgeBaseInput {

    static func urlPathProvider(_ value: DeleteKnowledgeBaseInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())"
    }
}

public struct DeleteKnowledgeBaseInput: Swift.Equatable {
    /// Identifier for a resource.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct DeleteKnowledgeBaseInputBody: Swift.Equatable {
}

extension DeleteKnowledgeBaseInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteKnowledgeBaseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteKnowledgeBaseOutputBody = try responseDecoder.decode(responseBody: data)
            self.knowledgeBaseId = output.knowledgeBaseId
            self.status = output.status
        } else {
            self.knowledgeBaseId = nil
            self.status = nil
        }
    }
}

public struct DeleteKnowledgeBaseOutput: Swift.Equatable {
    /// Identifier for a resource.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The status of a knowledge base.
    /// This member is required.
    public var status: BedrockAgentClientTypes.KnowledgeBaseStatus?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        status: BedrockAgentClientTypes.KnowledgeBaseStatus? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
        self.status = status
    }
}

struct DeleteKnowledgeBaseOutputBody: Swift.Equatable {
    let knowledgeBaseId: Swift.String?
    let status: BedrockAgentClientTypes.KnowledgeBaseStatus?
}

extension DeleteKnowledgeBaseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knowledgeBaseId
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.KnowledgeBaseStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum DeleteKnowledgeBaseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateAgentKnowledgeBaseInput {

    static func urlPathProvider(_ value: DisassociateAgentKnowledgeBaseInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())"
    }
}

/// Disassociate Agent Knowledge Base Request
public struct DisassociateAgentKnowledgeBaseInput: Swift.Equatable {
    /// Id generated at the server side when an Agent is created
    /// This member is required.
    public var agentId: Swift.String?
    /// Draft Version of the Agent.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// Id generated at the server side when a Knowledge Base is associated to an Agent
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct DisassociateAgentKnowledgeBaseInputBody: Swift.Equatable {
}

extension DisassociateAgentKnowledgeBaseInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateAgentKnowledgeBaseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// Disassociate Agent Knowledge Base Response
public struct DisassociateAgentKnowledgeBaseOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateAgentKnowledgeBaseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BedrockAgentClientTypes.FixedSizeChunkingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxTokens
        case overlapPercentage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxTokens = self.maxTokens {
            try encodeContainer.encode(maxTokens, forKey: .maxTokens)
        }
        if let overlapPercentage = self.overlapPercentage {
            try encodeContainer.encode(overlapPercentage, forKey: .overlapPercentage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxTokensDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxTokens)
        maxTokens = maxTokensDecoded
        let overlapPercentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .overlapPercentage)
        overlapPercentage = overlapPercentageDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Configures fixed size chunking strategy
    public struct FixedSizeChunkingConfiguration: Swift.Equatable {
        /// The maximum number of tokens per chunk.
        /// This member is required.
        public var maxTokens: Swift.Int?
        /// The overlap percentage between adjacent chunks.
        /// This member is required.
        public var overlapPercentage: Swift.Int?

        public init(
            maxTokens: Swift.Int? = nil,
            overlapPercentage: Swift.Int? = nil
        )
        {
            self.maxTokens = maxTokens
            self.overlapPercentage = overlapPercentage
        }
    }

}

extension GetAgentActionGroupInput {

    static func urlPathProvider(_ value: GetAgentActionGroupInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        guard let actionGroupId = value.actionGroupId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/actiongroups/\(actionGroupId.urlPercentEncoding())"
    }
}

/// Get Action Group Request
public struct GetAgentActionGroupInput: Swift.Equatable {
    /// Id generated at the server side when an Agent Action Group is created
    /// This member is required.
    public var actionGroupId: Swift.String?
    /// Id generated at the server side when an Agent is created
    /// This member is required.
    public var agentId: Swift.String?
    /// Version number generated when a version is created
    /// This member is required.
    public var agentVersion: Swift.String?

    public init(
        actionGroupId: Swift.String? = nil,
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil
    )
    {
        self.actionGroupId = actionGroupId
        self.agentId = agentId
        self.agentVersion = agentVersion
    }
}

struct GetAgentActionGroupInputBody: Swift.Equatable {
}

extension GetAgentActionGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAgentActionGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAgentActionGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentActionGroup = output.agentActionGroup
        } else {
            self.agentActionGroup = nil
        }
    }
}

/// Get Action Group Response
public struct GetAgentActionGroupOutput: Swift.Equatable {
    /// Contains the information of an Agent Action Group
    /// This member is required.
    public var agentActionGroup: BedrockAgentClientTypes.AgentActionGroup?

    public init(
        agentActionGroup: BedrockAgentClientTypes.AgentActionGroup? = nil
    )
    {
        self.agentActionGroup = agentActionGroup
    }
}

struct GetAgentActionGroupOutputBody: Swift.Equatable {
    let agentActionGroup: BedrockAgentClientTypes.AgentActionGroup?
}

extension GetAgentActionGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentActionGroup
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentActionGroupDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentActionGroup.self, forKey: .agentActionGroup)
        agentActionGroup = agentActionGroupDecoded
    }
}

enum GetAgentActionGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAgentAliasInput {

    static func urlPathProvider(_ value: GetAgentAliasInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentAliasId = value.agentAliasId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentaliases/\(agentAliasId.urlPercentEncoding())"
    }
}

/// Get Agent Alias Request
public struct GetAgentAliasInput: Swift.Equatable {
    /// Id generated at the server side when an Agent Alias is created
    /// This member is required.
    public var agentAliasId: Swift.String?
    /// Id generated at the server side when an Agent is created
    /// This member is required.
    public var agentId: Swift.String?

    public init(
        agentAliasId: Swift.String? = nil,
        agentId: Swift.String? = nil
    )
    {
        self.agentAliasId = agentAliasId
        self.agentId = agentId
    }
}

struct GetAgentAliasInputBody: Swift.Equatable {
}

extension GetAgentAliasInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAgentAliasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAgentAliasOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentAlias = output.agentAlias
        } else {
            self.agentAlias = nil
        }
    }
}

/// Get Agent Alias Response
public struct GetAgentAliasOutput: Swift.Equatable {
    /// Contains the information of an agent alias
    /// This member is required.
    public var agentAlias: BedrockAgentClientTypes.AgentAlias?

    public init(
        agentAlias: BedrockAgentClientTypes.AgentAlias? = nil
    )
    {
        self.agentAlias = agentAlias
    }
}

struct GetAgentAliasOutputBody: Swift.Equatable {
    let agentAlias: BedrockAgentClientTypes.AgentAlias?
}

extension GetAgentAliasOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentAlias
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentAliasDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentAlias.self, forKey: .agentAlias)
        agentAlias = agentAliasDecoded
    }
}

enum GetAgentAliasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAgentInput {

    static func urlPathProvider(_ value: GetAgentInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())"
    }
}

/// Get Agent Request
public struct GetAgentInput: Swift.Equatable {
    /// Id generated at the server side when an Agent is created
    /// This member is required.
    public var agentId: Swift.String?

    public init(
        agentId: Swift.String? = nil
    )
    {
        self.agentId = agentId
    }
}

struct GetAgentInputBody: Swift.Equatable {
}

extension GetAgentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAgentKnowledgeBaseInput {

    static func urlPathProvider(_ value: GetAgentKnowledgeBaseInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())"
    }
}

/// Get Agent Knowledge Base Request
public struct GetAgentKnowledgeBaseInput: Swift.Equatable {
    /// Id generated at the server side when an Agent is created
    /// This member is required.
    public var agentId: Swift.String?
    /// Version number generated when a version is created
    /// This member is required.
    public var agentVersion: Swift.String?
    /// Id generated at the server side when a Knowledge Base is associated
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct GetAgentKnowledgeBaseInputBody: Swift.Equatable {
}

extension GetAgentKnowledgeBaseInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAgentKnowledgeBaseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAgentKnowledgeBaseOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentKnowledgeBase = output.agentKnowledgeBase
        } else {
            self.agentKnowledgeBase = nil
        }
    }
}

/// Get Agent Knowledge Base Response
public struct GetAgentKnowledgeBaseOutput: Swift.Equatable {
    /// Contains the information of an Agent Knowledge Base.
    /// This member is required.
    public var agentKnowledgeBase: BedrockAgentClientTypes.AgentKnowledgeBase?

    public init(
        agentKnowledgeBase: BedrockAgentClientTypes.AgentKnowledgeBase? = nil
    )
    {
        self.agentKnowledgeBase = agentKnowledgeBase
    }
}

struct GetAgentKnowledgeBaseOutputBody: Swift.Equatable {
    let agentKnowledgeBase: BedrockAgentClientTypes.AgentKnowledgeBase?
}

extension GetAgentKnowledgeBaseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentKnowledgeBase
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentKnowledgeBaseDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentKnowledgeBase.self, forKey: .agentKnowledgeBase)
        agentKnowledgeBase = agentKnowledgeBaseDecoded
    }
}

enum GetAgentKnowledgeBaseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAgentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAgentOutputBody = try responseDecoder.decode(responseBody: data)
            self.agent = output.agent
        } else {
            self.agent = nil
        }
    }
}

/// Get Agent Response
public struct GetAgentOutput: Swift.Equatable {
    /// Contains the information of an agent
    /// This member is required.
    public var agent: BedrockAgentClientTypes.Agent?

    public init(
        agent: BedrockAgentClientTypes.Agent? = nil
    )
    {
        self.agent = agent
    }
}

struct GetAgentOutputBody: Swift.Equatable {
    let agent: BedrockAgentClientTypes.Agent?
}

extension GetAgentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agent
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.Agent.self, forKey: .agent)
        agent = agentDecoded
    }
}

enum GetAgentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAgentVersionInput {

    static func urlPathProvider(_ value: GetAgentVersionInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())"
    }
}

/// Get Agent Version Request
public struct GetAgentVersionInput: Swift.Equatable {
    /// Id generated at the server side when an Agent is created
    /// This member is required.
    public var agentId: Swift.String?
    /// Numerical Agent Version.
    /// This member is required.
    public var agentVersion: Swift.String?

    public init(
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil
    )
    {
        self.agentId = agentId
        self.agentVersion = agentVersion
    }
}

struct GetAgentVersionInputBody: Swift.Equatable {
}

extension GetAgentVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAgentVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAgentVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentVersion = output.agentVersion
        } else {
            self.agentVersion = nil
        }
    }
}

/// Get Agent Version Response
public struct GetAgentVersionOutput: Swift.Equatable {
    /// Contains the information of an agent version.
    /// This member is required.
    public var agentVersion: BedrockAgentClientTypes.AgentVersion?

    public init(
        agentVersion: BedrockAgentClientTypes.AgentVersion? = nil
    )
    {
        self.agentVersion = agentVersion
    }
}

struct GetAgentVersionOutputBody: Swift.Equatable {
    let agentVersion: BedrockAgentClientTypes.AgentVersion?
}

extension GetAgentVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentVersionDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentVersion.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
    }
}

enum GetAgentVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDataSourceInput {

    static func urlPathProvider(_ value: GetDataSourceInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let dataSourceId = value.dataSourceId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())"
    }
}

public struct GetDataSourceInput: Swift.Equatable {
    /// Identifier for a resource.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// Identifier for a resource.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        dataSourceId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.dataSourceId = dataSourceId
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct GetDataSourceInputBody: Swift.Equatable {
}

extension GetDataSourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDataSourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDataSourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataSource = output.dataSource
        } else {
            self.dataSource = nil
        }
    }
}

public struct GetDataSourceOutput: Swift.Equatable {
    /// Contains the information of a data source.
    /// This member is required.
    public var dataSource: BedrockAgentClientTypes.DataSource?

    public init(
        dataSource: BedrockAgentClientTypes.DataSource? = nil
    )
    {
        self.dataSource = dataSource
    }
}

struct GetDataSourceOutputBody: Swift.Equatable {
    let dataSource: BedrockAgentClientTypes.DataSource?
}

extension GetDataSourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
    }
}

enum GetDataSourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetIngestionJobInput {

    static func urlPathProvider(_ value: GetIngestionJobInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let dataSourceId = value.dataSourceId else {
            return nil
        }
        guard let ingestionJobId = value.ingestionJobId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())/ingestionjobs/\(ingestionJobId.urlPercentEncoding())"
    }
}

public struct GetIngestionJobInput: Swift.Equatable {
    /// Identifier for a resource.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// Identifier for a resource.
    /// This member is required.
    public var ingestionJobId: Swift.String?
    /// Identifier for a resource.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        dataSourceId: Swift.String? = nil,
        ingestionJobId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.dataSourceId = dataSourceId
        self.ingestionJobId = ingestionJobId
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct GetIngestionJobInputBody: Swift.Equatable {
}

extension GetIngestionJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetIngestionJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetIngestionJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.ingestionJob = output.ingestionJob
        } else {
            self.ingestionJob = nil
        }
    }
}

public struct GetIngestionJobOutput: Swift.Equatable {
    /// Contains the information of an ingestion job.
    /// This member is required.
    public var ingestionJob: BedrockAgentClientTypes.IngestionJob?

    public init(
        ingestionJob: BedrockAgentClientTypes.IngestionJob? = nil
    )
    {
        self.ingestionJob = ingestionJob
    }
}

struct GetIngestionJobOutputBody: Swift.Equatable {
    let ingestionJob: BedrockAgentClientTypes.IngestionJob?
}

extension GetIngestionJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ingestionJob
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ingestionJobDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.IngestionJob.self, forKey: .ingestionJob)
        ingestionJob = ingestionJobDecoded
    }
}

enum GetIngestionJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetKnowledgeBaseInput {

    static func urlPathProvider(_ value: GetKnowledgeBaseInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())"
    }
}

public struct GetKnowledgeBaseInput: Swift.Equatable {
    /// Identifier for a resource.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct GetKnowledgeBaseInputBody: Swift.Equatable {
}

extension GetKnowledgeBaseInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetKnowledgeBaseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetKnowledgeBaseOutputBody = try responseDecoder.decode(responseBody: data)
            self.knowledgeBase = output.knowledgeBase
        } else {
            self.knowledgeBase = nil
        }
    }
}

public struct GetKnowledgeBaseOutput: Swift.Equatable {
    /// Contains the information of a knowledge base.
    /// This member is required.
    public var knowledgeBase: BedrockAgentClientTypes.KnowledgeBase?

    public init(
        knowledgeBase: BedrockAgentClientTypes.KnowledgeBase? = nil
    )
    {
        self.knowledgeBase = knowledgeBase
    }
}

struct GetKnowledgeBaseOutputBody: Swift.Equatable {
    let knowledgeBase: BedrockAgentClientTypes.KnowledgeBase?
}

extension GetKnowledgeBaseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knowledgeBase
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.KnowledgeBase.self, forKey: .knowledgeBase)
        knowledgeBase = knowledgeBaseDecoded
    }
}

enum GetKnowledgeBaseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BedrockAgentClientTypes.InferenceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maximumLength
        case stopSequences
        case temperature
        case topk = "topK"
        case topp = "topP"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maximumLength = self.maximumLength {
            try encodeContainer.encode(maximumLength, forKey: .maximumLength)
        }
        if let stopSequences = stopSequences {
            var stopSequencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stopSequences)
            for string0 in stopSequences {
                try stopSequencesContainer.encode(string0)
            }
        }
        if let temperature = self.temperature {
            try encodeContainer.encode(temperature, forKey: .temperature)
        }
        if let topk = self.topk {
            try encodeContainer.encode(topk, forKey: .topk)
        }
        if let topp = self.topp {
            try encodeContainer.encode(topp, forKey: .topp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let temperatureDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .temperature)
        temperature = temperatureDecoded
        let toppDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .topp)
        topp = toppDecoded
        let topkDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .topk)
        topk = topkDecoded
        let maximumLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximumLength)
        maximumLength = maximumLengthDecoded
        let stopSequencesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stopSequences)
        var stopSequencesDecoded0:[Swift.String]? = nil
        if let stopSequencesContainer = stopSequencesContainer {
            stopSequencesDecoded0 = [Swift.String]()
            for string0 in stopSequencesContainer {
                if let string0 = string0 {
                    stopSequencesDecoded0?.append(string0)
                }
            }
        }
        stopSequences = stopSequencesDecoded0
    }
}

extension BedrockAgentClientTypes {
    /// Configuration for inference in prompt configuration
    public struct InferenceConfiguration: Swift.Equatable {
        /// Maximum length of output
        public var maximumLength: Swift.Int?
        /// List of stop sequences
        public var stopSequences: [Swift.String]?
        /// Controls randomness, higher values increase diversity
        public var temperature: Swift.Float?
        /// Sample from the k most likely next tokens
        public var topk: Swift.Int?
        /// Cumulative probability cutoff for token selection
        public var topp: Swift.Float?

        public init(
            maximumLength: Swift.Int? = nil,
            stopSequences: [Swift.String]? = nil,
            temperature: Swift.Float? = nil,
            topk: Swift.Int? = nil,
            topp: Swift.Float? = nil
        )
        {
            self.maximumLength = maximumLength
            self.stopSequences = stopSequences
            self.temperature = temperature
            self.topk = topk
            self.topp = topp
        }
    }

}

extension BedrockAgentClientTypes.IngestionJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceId
        case description
        case failureReasons
        case ingestionJobId
        case knowledgeBaseId
        case startedAt
        case statistics
        case status
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceId = self.dataSourceId {
            try encodeContainer.encode(dataSourceId, forKey: .dataSourceId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let failureReasons = failureReasons {
            var failureReasonsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .failureReasons)
            for failurereason0 in failureReasons {
                try failureReasonsContainer.encode(failurereason0)
            }
        }
        if let ingestionJobId = self.ingestionJobId {
            try encodeContainer.encode(ingestionJobId, forKey: .ingestionJobId)
        }
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let startedAt = self.startedAt {
            try encodeContainer.encodeTimestamp(startedAt, format: .dateTime, forKey: .startedAt)
        }
        if let statistics = self.statistics {
            try encodeContainer.encode(statistics, forKey: .statistics)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let ingestionJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ingestionJobId)
        ingestionJobId = ingestionJobIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.IngestionJobStatus.self, forKey: .status)
        status = statusDecoded
        let statisticsDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.IngestionJobStatistics.self, forKey: .statistics)
        statistics = statisticsDecoded
        let failureReasonsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .failureReasons)
        var failureReasonsDecoded0:[Swift.String]? = nil
        if let failureReasonsContainer = failureReasonsContainer {
            failureReasonsDecoded0 = [Swift.String]()
            for string0 in failureReasonsContainer {
                if let string0 = string0 {
                    failureReasonsDecoded0?.append(string0)
                }
            }
        }
        failureReasons = failureReasonsDecoded0
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedAt)
        startedAt = startedAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains the information of an ingestion job.
    public struct IngestionJob: Swift.Equatable {
        /// Identifier for a resource.
        /// This member is required.
        public var dataSourceId: Swift.String?
        /// Description of the Resource.
        public var description: Swift.String?
        /// Failure Reasons for Error.
        public var failureReasons: [Swift.String]?
        /// Identifier for a resource.
        /// This member is required.
        public var ingestionJobId: Swift.String?
        /// Identifier for a resource.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// Time Stamp.
        /// This member is required.
        public var startedAt: ClientRuntime.Date?
        /// The document level statistics of an ingestion job
        public var statistics: BedrockAgentClientTypes.IngestionJobStatistics?
        /// The status of an ingestion job.
        /// This member is required.
        public var status: BedrockAgentClientTypes.IngestionJobStatus?
        /// Time Stamp.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            dataSourceId: Swift.String? = nil,
            description: Swift.String? = nil,
            failureReasons: [Swift.String]? = nil,
            ingestionJobId: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            startedAt: ClientRuntime.Date? = nil,
            statistics: BedrockAgentClientTypes.IngestionJobStatistics? = nil,
            status: BedrockAgentClientTypes.IngestionJobStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.dataSourceId = dataSourceId
            self.description = description
            self.failureReasons = failureReasons
            self.ingestionJobId = ingestionJobId
            self.knowledgeBaseId = knowledgeBaseId
            self.startedAt = startedAt
            self.statistics = statistics
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension BedrockAgentClientTypes.IngestionJobFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute
        case `operator` = "operator"
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = self.attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let `operator` = self.`operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for ingestionjobfiltervalue0 in values {
                try valuesContainer.encode(ingestionjobfiltervalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.IngestionJobFilterAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.IngestionJobFilterOperator.self, forKey: .operator)
        `operator` = operatorDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension BedrockAgentClientTypes {
    /// Filters the response returned by ListIngestionJobs operation.
    public struct IngestionJobFilter: Swift.Equatable {
        /// The name of the field to filter ingestion jobs.
        /// This member is required.
        public var attribute: BedrockAgentClientTypes.IngestionJobFilterAttribute?
        /// The operator used to filter ingestion jobs.
        /// This member is required.
        public var `operator`: BedrockAgentClientTypes.IngestionJobFilterOperator?
        /// The list of values used to filter ingestion jobs.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            attribute: BedrockAgentClientTypes.IngestionJobFilterAttribute? = nil,
            `operator`: BedrockAgentClientTypes.IngestionJobFilterOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.attribute = attribute
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension BedrockAgentClientTypes {
    /// The name of the field to filter ingestion jobs.
    public enum IngestionJobFilterAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionJobFilterAttribute] {
            return [
                .status,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .status: return "STATUS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IngestionJobFilterAttribute(rawValue: rawValue) ?? IngestionJobFilterAttribute.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentClientTypes {
    /// The operator used to filter ingestion jobs.
    public enum IngestionJobFilterOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case eq
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionJobFilterOperator] {
            return [
                .eq,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .eq: return "EQ"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IngestionJobFilterOperator(rawValue: rawValue) ?? IngestionJobFilterOperator.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentClientTypes.IngestionJobSortBy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute
        case order
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = self.attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let order = self.order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.IngestionJobSortByAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let orderDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.SortOrder.self, forKey: .order)
        order = orderDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Sorts the response returned by ListIngestionJobs operation.
    public struct IngestionJobSortBy: Swift.Equatable {
        /// The name of the field to sort ingestion jobs.
        /// This member is required.
        public var attribute: BedrockAgentClientTypes.IngestionJobSortByAttribute?
        /// Order to sort results by.
        /// This member is required.
        public var order: BedrockAgentClientTypes.SortOrder?

        public init(
            attribute: BedrockAgentClientTypes.IngestionJobSortByAttribute? = nil,
            order: BedrockAgentClientTypes.SortOrder? = nil
        )
        {
            self.attribute = attribute
            self.order = order
        }
    }

}

extension BedrockAgentClientTypes {
    /// The name of the field to sort ingestion jobs.
    public enum IngestionJobSortByAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case startedAt
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionJobSortByAttribute] {
            return [
                .startedAt,
                .status,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .startedAt: return "STARTED_AT"
            case .status: return "STATUS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IngestionJobSortByAttribute(rawValue: rawValue) ?? IngestionJobSortByAttribute.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentClientTypes.IngestionJobStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case numberOfDocumentsDeleted
        case numberOfDocumentsFailed
        case numberOfDocumentsScanned
        case numberOfModifiedDocumentsIndexed
        case numberOfNewDocumentsIndexed
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if numberOfDocumentsDeleted != 0 {
            try encodeContainer.encode(numberOfDocumentsDeleted, forKey: .numberOfDocumentsDeleted)
        }
        if numberOfDocumentsFailed != 0 {
            try encodeContainer.encode(numberOfDocumentsFailed, forKey: .numberOfDocumentsFailed)
        }
        if numberOfDocumentsScanned != 0 {
            try encodeContainer.encode(numberOfDocumentsScanned, forKey: .numberOfDocumentsScanned)
        }
        if numberOfModifiedDocumentsIndexed != 0 {
            try encodeContainer.encode(numberOfModifiedDocumentsIndexed, forKey: .numberOfModifiedDocumentsIndexed)
        }
        if numberOfNewDocumentsIndexed != 0 {
            try encodeContainer.encode(numberOfNewDocumentsIndexed, forKey: .numberOfNewDocumentsIndexed)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberOfDocumentsScannedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfDocumentsScanned) ?? 0
        numberOfDocumentsScanned = numberOfDocumentsScannedDecoded
        let numberOfNewDocumentsIndexedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfNewDocumentsIndexed) ?? 0
        numberOfNewDocumentsIndexed = numberOfNewDocumentsIndexedDecoded
        let numberOfModifiedDocumentsIndexedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfModifiedDocumentsIndexed) ?? 0
        numberOfModifiedDocumentsIndexed = numberOfModifiedDocumentsIndexedDecoded
        let numberOfDocumentsDeletedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfDocumentsDeleted) ?? 0
        numberOfDocumentsDeleted = numberOfDocumentsDeletedDecoded
        let numberOfDocumentsFailedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfDocumentsFailed) ?? 0
        numberOfDocumentsFailed = numberOfDocumentsFailedDecoded
    }
}

extension BedrockAgentClientTypes {
    /// The document level statistics of an ingestion job
    public struct IngestionJobStatistics: Swift.Equatable {
        /// Number of deleted documents
        public var numberOfDocumentsDeleted: Swift.Int
        /// Number of failed documents
        public var numberOfDocumentsFailed: Swift.Int
        /// Number of scanned documents
        public var numberOfDocumentsScanned: Swift.Int
        /// Number of modified documents indexed
        public var numberOfModifiedDocumentsIndexed: Swift.Int
        /// Number of indexed documents
        public var numberOfNewDocumentsIndexed: Swift.Int

        public init(
            numberOfDocumentsDeleted: Swift.Int = 0,
            numberOfDocumentsFailed: Swift.Int = 0,
            numberOfDocumentsScanned: Swift.Int = 0,
            numberOfModifiedDocumentsIndexed: Swift.Int = 0,
            numberOfNewDocumentsIndexed: Swift.Int = 0
        )
        {
            self.numberOfDocumentsDeleted = numberOfDocumentsDeleted
            self.numberOfDocumentsFailed = numberOfDocumentsFailed
            self.numberOfDocumentsScanned = numberOfDocumentsScanned
            self.numberOfModifiedDocumentsIndexed = numberOfModifiedDocumentsIndexed
            self.numberOfNewDocumentsIndexed = numberOfNewDocumentsIndexed
        }
    }

}

extension BedrockAgentClientTypes {
    /// The status of an ingestion job.
    public enum IngestionJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case failed
        case inProgress
        case starting
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionJobStatus] {
            return [
                .complete,
                .failed,
                .inProgress,
                .starting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .starting: return "STARTING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IngestionJobStatus(rawValue: rawValue) ?? IngestionJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentClientTypes.IngestionJobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceId
        case description
        case ingestionJobId
        case knowledgeBaseId
        case startedAt
        case statistics
        case status
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceId = self.dataSourceId {
            try encodeContainer.encode(dataSourceId, forKey: .dataSourceId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ingestionJobId = self.ingestionJobId {
            try encodeContainer.encode(ingestionJobId, forKey: .ingestionJobId)
        }
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let startedAt = self.startedAt {
            try encodeContainer.encodeTimestamp(startedAt, format: .dateTime, forKey: .startedAt)
        }
        if let statistics = self.statistics {
            try encodeContainer.encode(statistics, forKey: .statistics)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let dataSourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceId)
        dataSourceId = dataSourceIdDecoded
        let ingestionJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ingestionJobId)
        ingestionJobId = ingestionJobIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.IngestionJobStatus.self, forKey: .status)
        status = statusDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedAt)
        startedAt = startedAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let statisticsDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.IngestionJobStatistics.self, forKey: .statistics)
        statistics = statisticsDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Summary information of an ingestion job.
    public struct IngestionJobSummary: Swift.Equatable {
        /// Identifier for a resource.
        /// This member is required.
        public var dataSourceId: Swift.String?
        /// Description of the Resource.
        public var description: Swift.String?
        /// Identifier for a resource.
        /// This member is required.
        public var ingestionJobId: Swift.String?
        /// Identifier for a resource.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// Time Stamp.
        /// This member is required.
        public var startedAt: ClientRuntime.Date?
        /// The document level statistics of an ingestion job
        public var statistics: BedrockAgentClientTypes.IngestionJobStatistics?
        /// The status of an ingestion job.
        /// This member is required.
        public var status: BedrockAgentClientTypes.IngestionJobStatus?
        /// Time Stamp.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            dataSourceId: Swift.String? = nil,
            description: Swift.String? = nil,
            ingestionJobId: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            startedAt: ClientRuntime.Date? = nil,
            statistics: BedrockAgentClientTypes.IngestionJobStatistics? = nil,
            status: BedrockAgentClientTypes.IngestionJobStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.dataSourceId = dataSourceId
            self.description = description
            self.ingestionJobId = ingestionJobId
            self.knowledgeBaseId = knowledgeBaseId
            self.startedAt = startedAt
            self.statistics = statistics
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown if there was an unexpected error during processing of request
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Non Blank String
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BedrockAgentClientTypes.KnowledgeBase: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case description
        case failureReasons
        case knowledgeBaseArn
        case knowledgeBaseConfiguration
        case knowledgeBaseId
        case name
        case roleArn
        case status
        case storageConfiguration
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let failureReasons = failureReasons {
            var failureReasonsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .failureReasons)
            for failurereason0 in failureReasons {
                try failureReasonsContainer.encode(failurereason0)
            }
        }
        if let knowledgeBaseArn = self.knowledgeBaseArn {
            try encodeContainer.encode(knowledgeBaseArn, forKey: .knowledgeBaseArn)
        }
        if let knowledgeBaseConfiguration = self.knowledgeBaseConfiguration {
            try encodeContainer.encode(knowledgeBaseConfiguration, forKey: .knowledgeBaseConfiguration)
        }
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let storageConfiguration = self.storageConfiguration {
            try encodeContainer.encode(storageConfiguration, forKey: .storageConfiguration)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let knowledgeBaseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseArn)
        knowledgeBaseArn = knowledgeBaseArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let knowledgeBaseConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.KnowledgeBaseConfiguration.self, forKey: .knowledgeBaseConfiguration)
        knowledgeBaseConfiguration = knowledgeBaseConfigurationDecoded
        let storageConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.StorageConfiguration.self, forKey: .storageConfiguration)
        storageConfiguration = storageConfigurationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.KnowledgeBaseStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let failureReasonsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .failureReasons)
        var failureReasonsDecoded0:[Swift.String]? = nil
        if let failureReasonsContainer = failureReasonsContainer {
            failureReasonsDecoded0 = [Swift.String]()
            for string0 in failureReasonsContainer {
                if let string0 = string0 {
                    failureReasonsDecoded0?.append(string0)
                }
            }
        }
        failureReasons = failureReasonsDecoded0
    }
}

extension BedrockAgentClientTypes {
    /// Contains the information of a knowledge base.
    public struct KnowledgeBase: Swift.Equatable {
        /// Time Stamp.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// Description of the Resource.
        public var description: Swift.String?
        /// Failure Reasons for Error.
        public var failureReasons: [Swift.String]?
        /// ARN of a KnowledgeBase
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// Configures a bedrock knowledge base.
        /// This member is required.
        public var knowledgeBaseConfiguration: BedrockAgentClientTypes.KnowledgeBaseConfiguration?
        /// Identifier for a resource.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// Name for a resource.
        /// This member is required.
        public var name: Swift.String?
        /// ARN of a IAM role.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The status of a knowledge base.
        /// This member is required.
        public var status: BedrockAgentClientTypes.KnowledgeBaseStatus?
        /// Configures the physical storage of ingested data in a knowledge base.
        /// This member is required.
        public var storageConfiguration: BedrockAgentClientTypes.StorageConfiguration?
        /// Time Stamp.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            failureReasons: [Swift.String]? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseConfiguration: BedrockAgentClientTypes.KnowledgeBaseConfiguration? = nil,
            knowledgeBaseId: Swift.String? = nil,
            name: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            status: BedrockAgentClientTypes.KnowledgeBaseStatus? = nil,
            storageConfiguration: BedrockAgentClientTypes.StorageConfiguration? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.failureReasons = failureReasons
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseConfiguration = knowledgeBaseConfiguration
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.roleArn = roleArn
            self.status = status
            self.storageConfiguration = storageConfiguration
            self.updatedAt = updatedAt
        }
    }

}

extension BedrockAgentClientTypes.KnowledgeBaseConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type
        case vectorKnowledgeBaseConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let vectorKnowledgeBaseConfiguration = self.vectorKnowledgeBaseConfiguration {
            try encodeContainer.encode(vectorKnowledgeBaseConfiguration, forKey: .vectorKnowledgeBaseConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.KnowledgeBaseType.self, forKey: .type)
        type = typeDecoded
        let vectorKnowledgeBaseConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.VectorKnowledgeBaseConfiguration.self, forKey: .vectorKnowledgeBaseConfiguration)
        vectorKnowledgeBaseConfiguration = vectorKnowledgeBaseConfigurationDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Configures a bedrock knowledge base.
    public struct KnowledgeBaseConfiguration: Swift.Equatable {
        /// The type of a knowledge base.
        /// This member is required.
        public var type: BedrockAgentClientTypes.KnowledgeBaseType?
        /// Configurations for a vector knowledge base.
        public var vectorKnowledgeBaseConfiguration: BedrockAgentClientTypes.VectorKnowledgeBaseConfiguration?

        public init(
            type: BedrockAgentClientTypes.KnowledgeBaseType? = nil,
            vectorKnowledgeBaseConfiguration: BedrockAgentClientTypes.VectorKnowledgeBaseConfiguration? = nil
        )
        {
            self.type = type
            self.vectorKnowledgeBaseConfiguration = vectorKnowledgeBaseConfiguration
        }
    }

}

extension BedrockAgentClientTypes {
    /// State of the knowledge base; whether it is enabled or disabled
    public enum KnowledgeBaseState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [KnowledgeBaseState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KnowledgeBaseState(rawValue: rawValue) ?? KnowledgeBaseState.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentClientTypes {
    /// The status of a knowledge base.
    public enum KnowledgeBaseStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [KnowledgeBaseStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KnowledgeBaseStatus(rawValue: rawValue) ?? KnowledgeBaseStatus.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentClientTypes {
    /// The storage type of a knowledge base.
    public enum KnowledgeBaseStorageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case opensearchServerless
        case pinecone
        case rds
        case redisEnterpriseCloud
        case sdkUnknown(Swift.String)

        public static var allCases: [KnowledgeBaseStorageType] {
            return [
                .opensearchServerless,
                .pinecone,
                .rds,
                .redisEnterpriseCloud,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .opensearchServerless: return "OPENSEARCH_SERVERLESS"
            case .pinecone: return "PINECONE"
            case .rds: return "RDS"
            case .redisEnterpriseCloud: return "REDIS_ENTERPRISE_CLOUD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KnowledgeBaseStorageType(rawValue: rawValue) ?? KnowledgeBaseStorageType.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentClientTypes.KnowledgeBaseSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case knowledgeBaseId
        case name
        case status
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let knowledgeBaseId = self.knowledgeBaseId {
            try encodeContainer.encode(knowledgeBaseId, forKey: .knowledgeBaseId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .knowledgeBaseId)
        knowledgeBaseId = knowledgeBaseIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.KnowledgeBaseStatus.self, forKey: .status)
        status = statusDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Summary information of a knowledge base.
    public struct KnowledgeBaseSummary: Swift.Equatable {
        /// Description of the Resource.
        public var description: Swift.String?
        /// Identifier for a resource.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// Name for a resource.
        /// This member is required.
        public var name: Swift.String?
        /// The status of a knowledge base.
        /// This member is required.
        public var status: BedrockAgentClientTypes.KnowledgeBaseStatus?
        /// Time Stamp.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            description: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            name: Swift.String? = nil,
            status: BedrockAgentClientTypes.KnowledgeBaseStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension BedrockAgentClientTypes {
    /// The type of a knowledge base.
    public enum KnowledgeBaseType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case vector
        case sdkUnknown(Swift.String)

        public static var allCases: [KnowledgeBaseType] {
            return [
                .vector,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .vector: return "VECTOR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KnowledgeBaseType(rawValue: rawValue) ?? KnowledgeBaseType.sdkUnknown(rawValue)
        }
    }
}

extension ListAgentActionGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAgentActionGroupsInput {

    static func urlPathProvider(_ value: ListAgentActionGroupsInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/actiongroups"
    }
}

/// List Action Groups Request
public struct ListAgentActionGroupsInput: Swift.Equatable {
    /// Id generated at the server side when an Agent is Listed
    /// This member is required.
    public var agentId: Swift.String?
    /// Id generated at the server side when an Agent is Listed
    /// This member is required.
    public var agentVersion: Swift.String?
    /// Max Results.
    public var maxResults: Swift.Int?
    /// Opaque continuation token of previous paginated response.
    public var nextToken: Swift.String?

    public init(
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAgentActionGroupsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAgentActionGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAgentActionGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAgentActionGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.actionGroupSummaries = output.actionGroupSummaries
            self.nextToken = output.nextToken
        } else {
            self.actionGroupSummaries = nil
            self.nextToken = nil
        }
    }
}

/// List Action Groups Response
public struct ListAgentActionGroupsOutput: Swift.Equatable {
    /// List of ActionGroup Summaries
    /// This member is required.
    public var actionGroupSummaries: [BedrockAgentClientTypes.ActionGroupSummary]?
    /// Opaque continuation token of previous paginated response.
    public var nextToken: Swift.String?

    public init(
        actionGroupSummaries: [BedrockAgentClientTypes.ActionGroupSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actionGroupSummaries = actionGroupSummaries
        self.nextToken = nextToken
    }
}

struct ListAgentActionGroupsOutputBody: Swift.Equatable {
    let actionGroupSummaries: [BedrockAgentClientTypes.ActionGroupSummary]?
    let nextToken: Swift.String?
}

extension ListAgentActionGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionGroupSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionGroupSummariesContainer = try containerValues.decodeIfPresent([BedrockAgentClientTypes.ActionGroupSummary?].self, forKey: .actionGroupSummaries)
        var actionGroupSummariesDecoded0:[BedrockAgentClientTypes.ActionGroupSummary]? = nil
        if let actionGroupSummariesContainer = actionGroupSummariesContainer {
            actionGroupSummariesDecoded0 = [BedrockAgentClientTypes.ActionGroupSummary]()
            for structure0 in actionGroupSummariesContainer {
                if let structure0 = structure0 {
                    actionGroupSummariesDecoded0?.append(structure0)
                }
            }
        }
        actionGroupSummaries = actionGroupSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAgentActionGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAgentAliasesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAgentAliasesInput {

    static func urlPathProvider(_ value: ListAgentAliasesInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentaliases"
    }
}

/// List Agent Aliases Request
public struct ListAgentAliasesInput: Swift.Equatable {
    /// Id generated at the server side when an Agent is created
    /// This member is required.
    public var agentId: Swift.String?
    /// Max Results.
    public var maxResults: Swift.Int?
    /// Opaque continuation token of previous paginated response.
    public var nextToken: Swift.String?

    public init(
        agentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentId = agentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAgentAliasesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAgentAliasesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAgentAliasesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAgentAliasesOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentAliasSummaries = output.agentAliasSummaries
            self.nextToken = output.nextToken
        } else {
            self.agentAliasSummaries = nil
            self.nextToken = nil
        }
    }
}

/// List Agent Aliases Response
public struct ListAgentAliasesOutput: Swift.Equatable {
    /// The list of summaries of all the aliases for an Agent.
    /// This member is required.
    public var agentAliasSummaries: [BedrockAgentClientTypes.AgentAliasSummary]?
    /// Opaque continuation token of previous paginated response.
    public var nextToken: Swift.String?

    public init(
        agentAliasSummaries: [BedrockAgentClientTypes.AgentAliasSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentAliasSummaries = agentAliasSummaries
        self.nextToken = nextToken
    }
}

struct ListAgentAliasesOutputBody: Swift.Equatable {
    let agentAliasSummaries: [BedrockAgentClientTypes.AgentAliasSummary]?
    let nextToken: Swift.String?
}

extension ListAgentAliasesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentAliasSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentAliasSummariesContainer = try containerValues.decodeIfPresent([BedrockAgentClientTypes.AgentAliasSummary?].self, forKey: .agentAliasSummaries)
        var agentAliasSummariesDecoded0:[BedrockAgentClientTypes.AgentAliasSummary]? = nil
        if let agentAliasSummariesContainer = agentAliasSummariesContainer {
            agentAliasSummariesDecoded0 = [BedrockAgentClientTypes.AgentAliasSummary]()
            for structure0 in agentAliasSummariesContainer {
                if let structure0 = structure0 {
                    agentAliasSummariesDecoded0?.append(structure0)
                }
            }
        }
        agentAliasSummaries = agentAliasSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAgentAliasesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAgentKnowledgeBasesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAgentKnowledgeBasesInput {

    static func urlPathProvider(_ value: ListAgentKnowledgeBasesInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/knowledgebases"
    }
}

/// List Agent Knowledge Bases Request
public struct ListAgentKnowledgeBasesInput: Swift.Equatable {
    /// Id generated at the server side when an Agent is created
    /// This member is required.
    public var agentId: Swift.String?
    /// Version number generated when a version is created
    /// This member is required.
    public var agentVersion: Swift.String?
    /// Max Results.
    public var maxResults: Swift.Int?
    /// Opaque continuation token of previous paginated response.
    public var nextToken: Swift.String?

    public init(
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAgentKnowledgeBasesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAgentKnowledgeBasesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAgentKnowledgeBasesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAgentKnowledgeBasesOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentKnowledgeBaseSummaries = output.agentKnowledgeBaseSummaries
            self.nextToken = output.nextToken
        } else {
            self.agentKnowledgeBaseSummaries = nil
            self.nextToken = nil
        }
    }
}

/// List Agent Knowledge Bases Response
public struct ListAgentKnowledgeBasesOutput: Swift.Equatable {
    /// List of Agent Knowledge Base Summaries
    /// This member is required.
    public var agentKnowledgeBaseSummaries: [BedrockAgentClientTypes.AgentKnowledgeBaseSummary]?
    /// Opaque continuation token of previous paginated response.
    public var nextToken: Swift.String?

    public init(
        agentKnowledgeBaseSummaries: [BedrockAgentClientTypes.AgentKnowledgeBaseSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentKnowledgeBaseSummaries = agentKnowledgeBaseSummaries
        self.nextToken = nextToken
    }
}

struct ListAgentKnowledgeBasesOutputBody: Swift.Equatable {
    let agentKnowledgeBaseSummaries: [BedrockAgentClientTypes.AgentKnowledgeBaseSummary]?
    let nextToken: Swift.String?
}

extension ListAgentKnowledgeBasesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentKnowledgeBaseSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentKnowledgeBaseSummariesContainer = try containerValues.decodeIfPresent([BedrockAgentClientTypes.AgentKnowledgeBaseSummary?].self, forKey: .agentKnowledgeBaseSummaries)
        var agentKnowledgeBaseSummariesDecoded0:[BedrockAgentClientTypes.AgentKnowledgeBaseSummary]? = nil
        if let agentKnowledgeBaseSummariesContainer = agentKnowledgeBaseSummariesContainer {
            agentKnowledgeBaseSummariesDecoded0 = [BedrockAgentClientTypes.AgentKnowledgeBaseSummary]()
            for structure0 in agentKnowledgeBaseSummariesContainer {
                if let structure0 = structure0 {
                    agentKnowledgeBaseSummariesDecoded0?.append(structure0)
                }
            }
        }
        agentKnowledgeBaseSummaries = agentKnowledgeBaseSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAgentKnowledgeBasesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAgentVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAgentVersionsInput {

    static func urlPathProvider(_ value: ListAgentVersionsInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions"
    }
}

/// List Agent Versions Request
public struct ListAgentVersionsInput: Swift.Equatable {
    /// Id generated at the server side when an Agent is created
    /// This member is required.
    public var agentId: Swift.String?
    /// Max Results.
    public var maxResults: Swift.Int?
    /// Opaque continuation token of previous paginated response.
    public var nextToken: Swift.String?

    public init(
        agentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentId = agentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAgentVersionsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAgentVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAgentVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAgentVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentVersionSummaries = output.agentVersionSummaries
            self.nextToken = output.nextToken
        } else {
            self.agentVersionSummaries = nil
            self.nextToken = nil
        }
    }
}

/// List Agent Versions Response
public struct ListAgentVersionsOutput: Swift.Equatable {
    /// List of AgentVersionSummary.
    /// This member is required.
    public var agentVersionSummaries: [BedrockAgentClientTypes.AgentVersionSummary]?
    /// Opaque continuation token of previous paginated response.
    public var nextToken: Swift.String?

    public init(
        agentVersionSummaries: [BedrockAgentClientTypes.AgentVersionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentVersionSummaries = agentVersionSummaries
        self.nextToken = nextToken
    }
}

struct ListAgentVersionsOutputBody: Swift.Equatable {
    let agentVersionSummaries: [BedrockAgentClientTypes.AgentVersionSummary]?
    let nextToken: Swift.String?
}

extension ListAgentVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentVersionSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentVersionSummariesContainer = try containerValues.decodeIfPresent([BedrockAgentClientTypes.AgentVersionSummary?].self, forKey: .agentVersionSummaries)
        var agentVersionSummariesDecoded0:[BedrockAgentClientTypes.AgentVersionSummary]? = nil
        if let agentVersionSummariesContainer = agentVersionSummariesContainer {
            agentVersionSummariesDecoded0 = [BedrockAgentClientTypes.AgentVersionSummary]()
            for structure0 in agentVersionSummariesContainer {
                if let structure0 = structure0 {
                    agentVersionSummariesDecoded0?.append(structure0)
                }
            }
        }
        agentVersionSummaries = agentVersionSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAgentVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAgentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAgentsInput {

    static func urlPathProvider(_ value: ListAgentsInput) -> Swift.String? {
        return "/agents"
    }
}

/// List Agent Request
public struct ListAgentsInput: Swift.Equatable {
    /// Max Results.
    public var maxResults: Swift.Int?
    /// Opaque continuation token of previous paginated response.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAgentsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAgentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAgentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAgentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentSummaries = output.agentSummaries
            self.nextToken = output.nextToken
        } else {
            self.agentSummaries = nil
            self.nextToken = nil
        }
    }
}

/// List Agent Response
public struct ListAgentsOutput: Swift.Equatable {
    /// List of AgentSummary.
    /// This member is required.
    public var agentSummaries: [BedrockAgentClientTypes.AgentSummary]?
    /// Opaque continuation token of previous paginated response.
    public var nextToken: Swift.String?

    public init(
        agentSummaries: [BedrockAgentClientTypes.AgentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentSummaries = agentSummaries
        self.nextToken = nextToken
    }
}

struct ListAgentsOutputBody: Swift.Equatable {
    let agentSummaries: [BedrockAgentClientTypes.AgentSummary]?
    let nextToken: Swift.String?
}

extension ListAgentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentSummariesContainer = try containerValues.decodeIfPresent([BedrockAgentClientTypes.AgentSummary?].self, forKey: .agentSummaries)
        var agentSummariesDecoded0:[BedrockAgentClientTypes.AgentSummary]? = nil
        if let agentSummariesContainer = agentSummariesContainer {
            agentSummariesDecoded0 = [BedrockAgentClientTypes.AgentSummary]()
            for structure0 in agentSummariesContainer {
                if let structure0 = structure0 {
                    agentSummariesDecoded0?.append(structure0)
                }
            }
        }
        agentSummaries = agentSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAgentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDataSourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDataSourcesInput {

    static func urlPathProvider(_ value: ListDataSourcesInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/datasources"
    }
}

public struct ListDataSourcesInput: Swift.Equatable {
    /// Identifier for a resource.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// Max Results.
    public var maxResults: Swift.Int?
    /// Opaque continuation token of previous paginated response.
    public var nextToken: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDataSourcesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListDataSourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDataSourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDataSourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataSourceSummaries = output.dataSourceSummaries
            self.nextToken = output.nextToken
        } else {
            self.dataSourceSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListDataSourcesOutput: Swift.Equatable {
    /// list of data source summaries
    /// This member is required.
    public var dataSourceSummaries: [BedrockAgentClientTypes.DataSourceSummary]?
    /// Opaque continuation token of previous paginated response.
    public var nextToken: Swift.String?

    public init(
        dataSourceSummaries: [BedrockAgentClientTypes.DataSourceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataSourceSummaries = dataSourceSummaries
        self.nextToken = nextToken
    }
}

struct ListDataSourcesOutputBody: Swift.Equatable {
    let dataSourceSummaries: [BedrockAgentClientTypes.DataSourceSummary]?
    let nextToken: Swift.String?
}

extension ListDataSourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceSummariesContainer = try containerValues.decodeIfPresent([BedrockAgentClientTypes.DataSourceSummary?].self, forKey: .dataSourceSummaries)
        var dataSourceSummariesDecoded0:[BedrockAgentClientTypes.DataSourceSummary]? = nil
        if let dataSourceSummariesContainer = dataSourceSummariesContainer {
            dataSourceSummariesDecoded0 = [BedrockAgentClientTypes.DataSourceSummary]()
            for structure0 in dataSourceSummariesContainer {
                if let structure0 = structure0 {
                    dataSourceSummariesDecoded0?.append(structure0)
                }
            }
        }
        dataSourceSummaries = dataSourceSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDataSourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListIngestionJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case sortBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for ingestionjobfilter0 in filters {
                try filtersContainer.encode(ingestionjobfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
    }
}

extension ListIngestionJobsInput {

    static func urlPathProvider(_ value: ListIngestionJobsInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let dataSourceId = value.dataSourceId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())/ingestionjobs"
    }
}

public struct ListIngestionJobsInput: Swift.Equatable {
    /// Identifier for a resource.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// List of IngestionJobFilters
    public var filters: [BedrockAgentClientTypes.IngestionJobFilter]?
    /// Identifier for a resource.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// Max Results.
    public var maxResults: Swift.Int?
    /// Opaque continuation token of previous paginated response.
    public var nextToken: Swift.String?
    /// Sorts the response returned by ListIngestionJobs operation.
    public var sortBy: BedrockAgentClientTypes.IngestionJobSortBy?

    public init(
        dataSourceId: Swift.String? = nil,
        filters: [BedrockAgentClientTypes.IngestionJobFilter]? = nil,
        knowledgeBaseId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: BedrockAgentClientTypes.IngestionJobSortBy? = nil
    )
    {
        self.dataSourceId = dataSourceId
        self.filters = filters
        self.knowledgeBaseId = knowledgeBaseId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
    }
}

struct ListIngestionJobsInputBody: Swift.Equatable {
    let filters: [BedrockAgentClientTypes.IngestionJobFilter]?
    let sortBy: BedrockAgentClientTypes.IngestionJobSortBy?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListIngestionJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case sortBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([BedrockAgentClientTypes.IngestionJobFilter?].self, forKey: .filters)
        var filtersDecoded0:[BedrockAgentClientTypes.IngestionJobFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [BedrockAgentClientTypes.IngestionJobFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortByDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.IngestionJobSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListIngestionJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListIngestionJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.ingestionJobSummaries = output.ingestionJobSummaries
            self.nextToken = output.nextToken
        } else {
            self.ingestionJobSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListIngestionJobsOutput: Swift.Equatable {
    /// List of IngestionJobSummaries
    /// This member is required.
    public var ingestionJobSummaries: [BedrockAgentClientTypes.IngestionJobSummary]?
    /// Opaque continuation token of previous paginated response.
    public var nextToken: Swift.String?

    public init(
        ingestionJobSummaries: [BedrockAgentClientTypes.IngestionJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ingestionJobSummaries = ingestionJobSummaries
        self.nextToken = nextToken
    }
}

struct ListIngestionJobsOutputBody: Swift.Equatable {
    let ingestionJobSummaries: [BedrockAgentClientTypes.IngestionJobSummary]?
    let nextToken: Swift.String?
}

extension ListIngestionJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ingestionJobSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ingestionJobSummariesContainer = try containerValues.decodeIfPresent([BedrockAgentClientTypes.IngestionJobSummary?].self, forKey: .ingestionJobSummaries)
        var ingestionJobSummariesDecoded0:[BedrockAgentClientTypes.IngestionJobSummary]? = nil
        if let ingestionJobSummariesContainer = ingestionJobSummariesContainer {
            ingestionJobSummariesDecoded0 = [BedrockAgentClientTypes.IngestionJobSummary]()
            for structure0 in ingestionJobSummariesContainer {
                if let structure0 = structure0 {
                    ingestionJobSummariesDecoded0?.append(structure0)
                }
            }
        }
        ingestionJobSummaries = ingestionJobSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListIngestionJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListKnowledgeBasesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListKnowledgeBasesInput {

    static func urlPathProvider(_ value: ListKnowledgeBasesInput) -> Swift.String? {
        return "/knowledgebases"
    }
}

public struct ListKnowledgeBasesInput: Swift.Equatable {
    /// Max Results.
    public var maxResults: Swift.Int?
    /// Opaque continuation token of previous paginated response.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListKnowledgeBasesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListKnowledgeBasesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListKnowledgeBasesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListKnowledgeBasesOutputBody = try responseDecoder.decode(responseBody: data)
            self.knowledgeBaseSummaries = output.knowledgeBaseSummaries
            self.nextToken = output.nextToken
        } else {
            self.knowledgeBaseSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListKnowledgeBasesOutput: Swift.Equatable {
    /// List of KnowledgeBaseSummaries
    /// This member is required.
    public var knowledgeBaseSummaries: [BedrockAgentClientTypes.KnowledgeBaseSummary]?
    /// Opaque continuation token of previous paginated response.
    public var nextToken: Swift.String?

    public init(
        knowledgeBaseSummaries: [BedrockAgentClientTypes.KnowledgeBaseSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.knowledgeBaseSummaries = knowledgeBaseSummaries
        self.nextToken = nextToken
    }
}

struct ListKnowledgeBasesOutputBody: Swift.Equatable {
    let knowledgeBaseSummaries: [BedrockAgentClientTypes.KnowledgeBaseSummary]?
    let nextToken: Swift.String?
}

extension ListKnowledgeBasesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knowledgeBaseSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseSummariesContainer = try containerValues.decodeIfPresent([BedrockAgentClientTypes.KnowledgeBaseSummary?].self, forKey: .knowledgeBaseSummaries)
        var knowledgeBaseSummariesDecoded0:[BedrockAgentClientTypes.KnowledgeBaseSummary]? = nil
        if let knowledgeBaseSummariesContainer = knowledgeBaseSummariesContainer {
            knowledgeBaseSummariesDecoded0 = [BedrockAgentClientTypes.KnowledgeBaseSummary]()
            for structure0 in knowledgeBaseSummariesContainer {
                if let structure0 = structure0 {
                    knowledgeBaseSummariesDecoded0?.append(structure0)
                }
            }
        }
        knowledgeBaseSummaries = knowledgeBaseSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListKnowledgeBasesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// ARN of Taggable resources: [Agent, AgentAlias, Knowledge-Base]
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A map of tag keys and values
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BedrockAgentClientTypes.OpenSearchServerlessConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectionArn
        case fieldMapping
        case vectorIndexName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collectionArn = self.collectionArn {
            try encodeContainer.encode(collectionArn, forKey: .collectionArn)
        }
        if let fieldMapping = self.fieldMapping {
            try encodeContainer.encode(fieldMapping, forKey: .fieldMapping)
        }
        if let vectorIndexName = self.vectorIndexName {
            try encodeContainer.encode(vectorIndexName, forKey: .vectorIndexName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectionArn)
        collectionArn = collectionArnDecoded
        let vectorIndexNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vectorIndexName)
        vectorIndexName = vectorIndexNameDecoded
        let fieldMappingDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.OpenSearchServerlessFieldMapping.self, forKey: .fieldMapping)
        fieldMapping = fieldMappingDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains the configurations to use OpenSearch Serverless to store knowledge base data.
    public struct OpenSearchServerlessConfiguration: Swift.Equatable {
        /// Arn of an OpenSearch Serverless collection.
        /// This member is required.
        public var collectionArn: Swift.String?
        /// A mapping of Bedrock Knowledge Base fields to OpenSearch Serverless field names
        /// This member is required.
        public var fieldMapping: BedrockAgentClientTypes.OpenSearchServerlessFieldMapping?
        /// Arn of an OpenSearch Serverless index.
        /// This member is required.
        public var vectorIndexName: Swift.String?

        public init(
            collectionArn: Swift.String? = nil,
            fieldMapping: BedrockAgentClientTypes.OpenSearchServerlessFieldMapping? = nil,
            vectorIndexName: Swift.String? = nil
        )
        {
            self.collectionArn = collectionArn
            self.fieldMapping = fieldMapping
            self.vectorIndexName = vectorIndexName
        }
    }

}

extension BedrockAgentClientTypes.OpenSearchServerlessFieldMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadataField
        case textField
        case vectorField
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadataField = self.metadataField {
            try encodeContainer.encode(metadataField, forKey: .metadataField)
        }
        if let textField = self.textField {
            try encodeContainer.encode(textField, forKey: .textField)
        }
        if let vectorField = self.vectorField {
            try encodeContainer.encode(vectorField, forKey: .vectorField)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vectorFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vectorField)
        vectorField = vectorFieldDecoded
        let textFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .textField)
        textField = textFieldDecoded
        let metadataFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadataField)
        metadataField = metadataFieldDecoded
    }
}

extension BedrockAgentClientTypes {
    /// A mapping of Bedrock Knowledge Base fields to OpenSearch Serverless field names
    public struct OpenSearchServerlessFieldMapping: Swift.Equatable {
        /// Name of the field
        /// This member is required.
        public var metadataField: Swift.String?
        /// Name of the field
        /// This member is required.
        public var textField: Swift.String?
        /// Name of the field
        /// This member is required.
        public var vectorField: Swift.String?

        public init(
            metadataField: Swift.String? = nil,
            textField: Swift.String? = nil,
            vectorField: Swift.String? = nil
        )
        {
            self.metadataField = metadataField
            self.textField = textField
            self.vectorField = vectorField
        }
    }

}

extension BedrockAgentClientTypes.PineconeConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionString
        case credentialsSecretArn
        case fieldMapping
        case namespace
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionString = self.connectionString {
            try encodeContainer.encode(connectionString, forKey: .connectionString)
        }
        if let credentialsSecretArn = self.credentialsSecretArn {
            try encodeContainer.encode(credentialsSecretArn, forKey: .credentialsSecretArn)
        }
        if let fieldMapping = self.fieldMapping {
            try encodeContainer.encode(fieldMapping, forKey: .fieldMapping)
        }
        if let namespace = self.namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionString)
        connectionString = connectionStringDecoded
        let credentialsSecretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentialsSecretArn)
        credentialsSecretArn = credentialsSecretArnDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let fieldMappingDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.PineconeFieldMapping.self, forKey: .fieldMapping)
        fieldMapping = fieldMappingDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains the configurations to use Pinecone to store knowledge base data.
    public struct PineconeConfiguration: Swift.Equatable {
        /// Pinecone connection string
        /// This member is required.
        public var connectionString: Swift.String?
        /// Arn of a SecretsManager Secret.
        /// This member is required.
        public var credentialsSecretArn: Swift.String?
        /// A mapping of Bedrock Knowledge Base fields to Pinecone field names
        /// This member is required.
        public var fieldMapping: BedrockAgentClientTypes.PineconeFieldMapping?
        /// Pinecone namespace
        public var namespace: Swift.String?

        public init(
            connectionString: Swift.String? = nil,
            credentialsSecretArn: Swift.String? = nil,
            fieldMapping: BedrockAgentClientTypes.PineconeFieldMapping? = nil,
            namespace: Swift.String? = nil
        )
        {
            self.connectionString = connectionString
            self.credentialsSecretArn = credentialsSecretArn
            self.fieldMapping = fieldMapping
            self.namespace = namespace
        }
    }

}

extension BedrockAgentClientTypes.PineconeFieldMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadataField
        case textField
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadataField = self.metadataField {
            try encodeContainer.encode(metadataField, forKey: .metadataField)
        }
        if let textField = self.textField {
            try encodeContainer.encode(textField, forKey: .textField)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .textField)
        textField = textFieldDecoded
        let metadataFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadataField)
        metadataField = metadataFieldDecoded
    }
}

extension BedrockAgentClientTypes {
    /// A mapping of Bedrock Knowledge Base fields to Pinecone field names
    public struct PineconeFieldMapping: Swift.Equatable {
        /// Name of the field
        /// This member is required.
        public var metadataField: Swift.String?
        /// Name of the field
        /// This member is required.
        public var textField: Swift.String?

        public init(
            metadataField: Swift.String? = nil,
            textField: Swift.String? = nil
        )
        {
            self.metadataField = metadataField
            self.textField = textField
        }
    }

}

extension PrepareAgentInput {

    static func urlPathProvider(_ value: PrepareAgentInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())"
    }
}

/// PrepareAgent Request
public struct PrepareAgentInput: Swift.Equatable {
    /// Id generated at the server side when an Agent is created
    /// This member is required.
    public var agentId: Swift.String?

    public init(
        agentId: Swift.String? = nil
    )
    {
        self.agentId = agentId
    }
}

struct PrepareAgentInputBody: Swift.Equatable {
}

extension PrepareAgentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension PrepareAgentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PrepareAgentOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentId = output.agentId
            self.agentStatus = output.agentStatus
            self.agentVersion = output.agentVersion
            self.preparedAt = output.preparedAt
        } else {
            self.agentId = nil
            self.agentStatus = nil
            self.agentVersion = nil
            self.preparedAt = nil
        }
    }
}

/// PrepareAgent Response
public struct PrepareAgentOutput: Swift.Equatable {
    /// Identifier for a resource.
    /// This member is required.
    public var agentId: Swift.String?
    /// Schema Type for Action APIs.
    /// This member is required.
    public var agentStatus: BedrockAgentClientTypes.AgentStatus?
    /// Agent Version.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// Time Stamp.
    /// This member is required.
    public var preparedAt: ClientRuntime.Date?

    public init(
        agentId: Swift.String? = nil,
        agentStatus: BedrockAgentClientTypes.AgentStatus? = nil,
        agentVersion: Swift.String? = nil,
        preparedAt: ClientRuntime.Date? = nil
    )
    {
        self.agentId = agentId
        self.agentStatus = agentStatus
        self.agentVersion = agentVersion
        self.preparedAt = preparedAt
    }
}

struct PrepareAgentOutputBody: Swift.Equatable {
    let agentId: Swift.String?
    let agentStatus: BedrockAgentClientTypes.AgentStatus?
    let agentVersion: Swift.String?
    let preparedAt: ClientRuntime.Date?
}

extension PrepareAgentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentId
        case agentStatus
        case agentVersion
        case preparedAt
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let agentStatusDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentStatus.self, forKey: .agentStatus)
        agentStatus = agentStatusDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
        let preparedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .preparedAt)
        preparedAt = preparedAtDecoded
    }
}

enum PrepareAgentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BedrockAgentClientTypes.PromptConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case basePromptTemplate
        case inferenceConfiguration
        case parserMode
        case promptCreationMode
        case promptState
        case promptType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let basePromptTemplate = self.basePromptTemplate {
            try encodeContainer.encode(basePromptTemplate, forKey: .basePromptTemplate)
        }
        if let inferenceConfiguration = self.inferenceConfiguration {
            try encodeContainer.encode(inferenceConfiguration, forKey: .inferenceConfiguration)
        }
        if let parserMode = self.parserMode {
            try encodeContainer.encode(parserMode.rawValue, forKey: .parserMode)
        }
        if let promptCreationMode = self.promptCreationMode {
            try encodeContainer.encode(promptCreationMode.rawValue, forKey: .promptCreationMode)
        }
        if let promptState = self.promptState {
            try encodeContainer.encode(promptState.rawValue, forKey: .promptState)
        }
        if let promptType = self.promptType {
            try encodeContainer.encode(promptType.rawValue, forKey: .promptType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let promptTypeDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.PromptType.self, forKey: .promptType)
        promptType = promptTypeDecoded
        let promptCreationModeDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.CreationMode.self, forKey: .promptCreationMode)
        promptCreationMode = promptCreationModeDecoded
        let promptStateDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.PromptState.self, forKey: .promptState)
        promptState = promptStateDecoded
        let basePromptTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .basePromptTemplate)
        basePromptTemplate = basePromptTemplateDecoded
        let inferenceConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.InferenceConfiguration.self, forKey: .inferenceConfiguration)
        inferenceConfiguration = inferenceConfigurationDecoded
        let parserModeDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.CreationMode.self, forKey: .parserMode)
        parserMode = parserModeDecoded
    }
}

extension BedrockAgentClientTypes {
    /// BasePromptConfiguration per Prompt Type.
    public struct PromptConfiguration: Swift.Equatable {
        /// Base Prompt Template.
        public var basePromptTemplate: Swift.String?
        /// Configuration for inference in prompt configuration
        public var inferenceConfiguration: BedrockAgentClientTypes.InferenceConfiguration?
        /// Creation Mode for Prompt Configuration.
        public var parserMode: BedrockAgentClientTypes.CreationMode?
        /// Creation Mode for Prompt Configuration.
        public var promptCreationMode: BedrockAgentClientTypes.CreationMode?
        /// Prompt State.
        public var promptState: BedrockAgentClientTypes.PromptState?
        /// Prompt Type.
        public var promptType: BedrockAgentClientTypes.PromptType?

        public init(
            basePromptTemplate: Swift.String? = nil,
            inferenceConfiguration: BedrockAgentClientTypes.InferenceConfiguration? = nil,
            parserMode: BedrockAgentClientTypes.CreationMode? = nil,
            promptCreationMode: BedrockAgentClientTypes.CreationMode? = nil,
            promptState: BedrockAgentClientTypes.PromptState? = nil,
            promptType: BedrockAgentClientTypes.PromptType? = nil
        )
        {
            self.basePromptTemplate = basePromptTemplate
            self.inferenceConfiguration = inferenceConfiguration
            self.parserMode = parserMode
            self.promptCreationMode = promptCreationMode
            self.promptState = promptState
            self.promptType = promptType
        }
    }

}

extension BedrockAgentClientTypes.PromptOverrideConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case overrideLambda
        case promptConfigurations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let overrideLambda = self.overrideLambda {
            try encodeContainer.encode(overrideLambda, forKey: .overrideLambda)
        }
        if let promptConfigurations = promptConfigurations {
            var promptConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .promptConfigurations)
            for promptconfiguration0 in promptConfigurations {
                try promptConfigurationsContainer.encode(promptconfiguration0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let promptConfigurationsContainer = try containerValues.decodeIfPresent([BedrockAgentClientTypes.PromptConfiguration?].self, forKey: .promptConfigurations)
        var promptConfigurationsDecoded0:[BedrockAgentClientTypes.PromptConfiguration]? = nil
        if let promptConfigurationsContainer = promptConfigurationsContainer {
            promptConfigurationsDecoded0 = [BedrockAgentClientTypes.PromptConfiguration]()
            for structure0 in promptConfigurationsContainer {
                if let structure0 = structure0 {
                    promptConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        promptConfigurations = promptConfigurationsDecoded0
        let overrideLambdaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .overrideLambda)
        overrideLambda = overrideLambdaDecoded
    }
}

extension BedrockAgentClientTypes.PromptOverrideConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentClientTypes {
    /// Configuration for prompt override.
    public struct PromptOverrideConfiguration: Swift.Equatable {
        /// ARN of a Lambda.
        public var overrideLambda: Swift.String?
        /// List of BasePromptConfiguration
        /// This member is required.
        public var promptConfigurations: [BedrockAgentClientTypes.PromptConfiguration]?

        public init(
            overrideLambda: Swift.String? = nil,
            promptConfigurations: [BedrockAgentClientTypes.PromptConfiguration]? = nil
        )
        {
            self.overrideLambda = overrideLambda
            self.promptConfigurations = promptConfigurations
        }
    }

}

extension BedrockAgentClientTypes {
    /// Prompt State.
    public enum PromptState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PromptState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PromptState(rawValue: rawValue) ?? PromptState.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentClientTypes {
    /// Prompt Type.
    public enum PromptType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case knowledgeBaseResponseGeneration
        case orchestration
        case postProcessing
        case preProcessing
        case sdkUnknown(Swift.String)

        public static var allCases: [PromptType] {
            return [
                .knowledgeBaseResponseGeneration,
                .orchestration,
                .postProcessing,
                .preProcessing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .knowledgeBaseResponseGeneration: return "KNOWLEDGE_BASE_RESPONSE_GENERATION"
            case .orchestration: return "ORCHESTRATION"
            case .postProcessing: return "POST_PROCESSING"
            case .preProcessing: return "PRE_PROCESSING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PromptType(rawValue: rawValue) ?? PromptType.sdkUnknown(rawValue)
        }
    }
}

extension BedrockAgentClientTypes.RdsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentialsSecretArn
        case databaseName
        case fieldMapping
        case resourceArn
        case tableName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let credentialsSecretArn = self.credentialsSecretArn {
            try encodeContainer.encode(credentialsSecretArn, forKey: .credentialsSecretArn)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let fieldMapping = self.fieldMapping {
            try encodeContainer.encode(fieldMapping, forKey: .fieldMapping)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let credentialsSecretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentialsSecretArn)
        credentialsSecretArn = credentialsSecretArnDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let fieldMappingDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.RdsFieldMapping.self, forKey: .fieldMapping)
        fieldMapping = fieldMappingDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains the configurations to use RDS to store knowledge base data.
    public struct RdsConfiguration: Swift.Equatable {
        /// Arn of a SecretsManager Secret.
        /// This member is required.
        public var credentialsSecretArn: Swift.String?
        /// Name of the database within RDS
        /// This member is required.
        public var databaseName: Swift.String?
        /// A mapping of Bedrock Knowledge Base fields to RDS column names
        /// This member is required.
        public var fieldMapping: BedrockAgentClientTypes.RdsFieldMapping?
        /// Arn of a RDS Resource.
        /// This member is required.
        public var resourceArn: Swift.String?
        /// Name of the table within RDS
        /// This member is required.
        public var tableName: Swift.String?

        public init(
            credentialsSecretArn: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            fieldMapping: BedrockAgentClientTypes.RdsFieldMapping? = nil,
            resourceArn: Swift.String? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.credentialsSecretArn = credentialsSecretArn
            self.databaseName = databaseName
            self.fieldMapping = fieldMapping
            self.resourceArn = resourceArn
            self.tableName = tableName
        }
    }

}

extension BedrockAgentClientTypes.RdsFieldMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadataField
        case primaryKeyField
        case textField
        case vectorField
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadataField = self.metadataField {
            try encodeContainer.encode(metadataField, forKey: .metadataField)
        }
        if let primaryKeyField = self.primaryKeyField {
            try encodeContainer.encode(primaryKeyField, forKey: .primaryKeyField)
        }
        if let textField = self.textField {
            try encodeContainer.encode(textField, forKey: .textField)
        }
        if let vectorField = self.vectorField {
            try encodeContainer.encode(vectorField, forKey: .vectorField)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let primaryKeyFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryKeyField)
        primaryKeyField = primaryKeyFieldDecoded
        let vectorFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vectorField)
        vectorField = vectorFieldDecoded
        let textFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .textField)
        textField = textFieldDecoded
        let metadataFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadataField)
        metadataField = metadataFieldDecoded
    }
}

extension BedrockAgentClientTypes {
    /// A mapping of Bedrock Knowledge Base fields to RDS column names
    public struct RdsFieldMapping: Swift.Equatable {
        /// Name of the column
        /// This member is required.
        public var metadataField: Swift.String?
        /// Name of the column
        /// This member is required.
        public var primaryKeyField: Swift.String?
        /// Name of the column
        /// This member is required.
        public var textField: Swift.String?
        /// Name of the column
        /// This member is required.
        public var vectorField: Swift.String?

        public init(
            metadataField: Swift.String? = nil,
            primaryKeyField: Swift.String? = nil,
            textField: Swift.String? = nil,
            vectorField: Swift.String? = nil
        )
        {
            self.metadataField = metadataField
            self.primaryKeyField = primaryKeyField
            self.textField = textField
            self.vectorField = vectorField
        }
    }

}

extension BedrockAgentClientTypes.RedisEnterpriseCloudConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentialsSecretArn
        case endpoint
        case fieldMapping
        case vectorIndexName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let credentialsSecretArn = self.credentialsSecretArn {
            try encodeContainer.encode(credentialsSecretArn, forKey: .credentialsSecretArn)
        }
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let fieldMapping = self.fieldMapping {
            try encodeContainer.encode(fieldMapping, forKey: .fieldMapping)
        }
        if let vectorIndexName = self.vectorIndexName {
            try encodeContainer.encode(vectorIndexName, forKey: .vectorIndexName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let vectorIndexNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vectorIndexName)
        vectorIndexName = vectorIndexNameDecoded
        let credentialsSecretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentialsSecretArn)
        credentialsSecretArn = credentialsSecretArnDecoded
        let fieldMappingDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.RedisEnterpriseCloudFieldMapping.self, forKey: .fieldMapping)
        fieldMapping = fieldMappingDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Contains the configurations to use Redis Enterprise Cloud to store knowledge base data.
    public struct RedisEnterpriseCloudConfiguration: Swift.Equatable {
        /// Arn of a SecretsManager Secret.
        /// This member is required.
        public var credentialsSecretArn: Swift.String?
        /// Redis enterprise cloud endpoint
        /// This member is required.
        public var endpoint: Swift.String?
        /// A mapping of Bedrock Knowledge Base fields to Redis Cloud field names
        /// This member is required.
        public var fieldMapping: BedrockAgentClientTypes.RedisEnterpriseCloudFieldMapping?
        /// Name of a redis enterprise cloud index
        /// This member is required.
        public var vectorIndexName: Swift.String?

        public init(
            credentialsSecretArn: Swift.String? = nil,
            endpoint: Swift.String? = nil,
            fieldMapping: BedrockAgentClientTypes.RedisEnterpriseCloudFieldMapping? = nil,
            vectorIndexName: Swift.String? = nil
        )
        {
            self.credentialsSecretArn = credentialsSecretArn
            self.endpoint = endpoint
            self.fieldMapping = fieldMapping
            self.vectorIndexName = vectorIndexName
        }
    }

}

extension BedrockAgentClientTypes.RedisEnterpriseCloudFieldMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadataField
        case textField
        case vectorField
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadataField = self.metadataField {
            try encodeContainer.encode(metadataField, forKey: .metadataField)
        }
        if let textField = self.textField {
            try encodeContainer.encode(textField, forKey: .textField)
        }
        if let vectorField = self.vectorField {
            try encodeContainer.encode(vectorField, forKey: .vectorField)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vectorFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vectorField)
        vectorField = vectorFieldDecoded
        let textFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .textField)
        textField = textFieldDecoded
        let metadataFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadataField)
        metadataField = metadataFieldDecoded
    }
}

extension BedrockAgentClientTypes {
    /// A mapping of Bedrock Knowledge Base fields to Redis Cloud field names
    public struct RedisEnterpriseCloudFieldMapping: Swift.Equatable {
        /// Name of the field
        /// This member is required.
        public var metadataField: Swift.String?
        /// Name of the field
        /// This member is required.
        public var textField: Swift.String?
        /// Name of the field
        /// This member is required.
        public var vectorField: Swift.String?

        public init(
            metadataField: Swift.String? = nil,
            textField: Swift.String? = nil,
            vectorField: Swift.String? = nil
        )
        {
            self.metadataField = metadataField
            self.textField = textField
            self.vectorField = vectorField
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when a resource referenced by the operation does not exist
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Non Blank String
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BedrockAgentClientTypes.S3DataSourceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketArn
        case inclusionPrefixes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketArn = self.bucketArn {
            try encodeContainer.encode(bucketArn, forKey: .bucketArn)
        }
        if let inclusionPrefixes = inclusionPrefixes {
            var inclusionPrefixesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inclusionPrefixes)
            for s3prefix0 in inclusionPrefixes {
                try inclusionPrefixesContainer.encode(s3prefix0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketArn)
        bucketArn = bucketArnDecoded
        let inclusionPrefixesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .inclusionPrefixes)
        var inclusionPrefixesDecoded0:[Swift.String]? = nil
        if let inclusionPrefixesContainer = inclusionPrefixesContainer {
            inclusionPrefixesDecoded0 = [Swift.String]()
            for string0 in inclusionPrefixesContainer {
                if let string0 = string0 {
                    inclusionPrefixesDecoded0?.append(string0)
                }
            }
        }
        inclusionPrefixes = inclusionPrefixesDecoded0
    }
}

extension BedrockAgentClientTypes {
    /// Configures an S3 data source location.
    public struct S3DataSourceConfiguration: Swift.Equatable {
        /// A S3 bucket ARN
        /// This member is required.
        public var bucketArn: Swift.String?
        /// A list of S3 prefixes.
        public var inclusionPrefixes: [Swift.String]?

        public init(
            bucketArn: Swift.String? = nil,
            inclusionPrefixes: [Swift.String]? = nil
        )
        {
            self.bucketArn = bucketArn
            self.inclusionPrefixes = inclusionPrefixes
        }
    }

}

extension BedrockAgentClientTypes.S3Identifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3BucketName
        case s3ObjectKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3ObjectKey = self.s3ObjectKey {
            try encodeContainer.encode(s3ObjectKey, forKey: .s3ObjectKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3ObjectKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3ObjectKey)
        s3ObjectKey = s3ObjectKeyDecoded
    }
}

extension BedrockAgentClientTypes {
    /// The identifier for the S3 resource.
    public struct S3Identifier: Swift.Equatable {
        /// A bucket in S3.
        public var s3BucketName: Swift.String?
        /// A object key in S3.
        public var s3ObjectKey: Swift.String?

        public init(
            s3BucketName: Swift.String? = nil,
            s3ObjectKey: Swift.String? = nil
        )
        {
            self.s3BucketName = s3BucketName
            self.s3ObjectKey = s3ObjectKey
        }
    }

}

extension BedrockAgentClientTypes.ServerSideEncryptionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Server-side encryption configuration.
    public struct ServerSideEncryptionConfiguration: Swift.Equatable {
        /// A KMS key ARN
        public var kmsKeyArn: Swift.String?

        public init(
            kmsKeyArn: Swift.String? = nil
        )
        {
            self.kmsKeyArn = kmsKeyArn
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when a request is made beyond the service quota
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Non Blank String
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Order to sort results by.
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension StartIngestionJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension StartIngestionJobInput {

    static func urlPathProvider(_ value: StartIngestionJobInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let dataSourceId = value.dataSourceId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())/ingestionjobs"
    }
}

public struct StartIngestionJobInput: Swift.Equatable {
    /// Client specified token used for idempotency checks
    public var clientToken: Swift.String?
    /// Identifier for a resource.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// Description of the Resource.
    public var description: Swift.String?
    /// Identifier for a resource.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        description: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.dataSourceId = dataSourceId
        self.description = description
        self.knowledgeBaseId = knowledgeBaseId
    }
}

struct StartIngestionJobInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let description: Swift.String?
}

extension StartIngestionJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension StartIngestionJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartIngestionJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.ingestionJob = output.ingestionJob
        } else {
            self.ingestionJob = nil
        }
    }
}

public struct StartIngestionJobOutput: Swift.Equatable {
    /// Contains the information of an ingestion job.
    /// This member is required.
    public var ingestionJob: BedrockAgentClientTypes.IngestionJob?

    public init(
        ingestionJob: BedrockAgentClientTypes.IngestionJob? = nil
    )
    {
        self.ingestionJob = ingestionJob
    }
}

struct StartIngestionJobOutputBody: Swift.Equatable {
    let ingestionJob: BedrockAgentClientTypes.IngestionJob?
}

extension StartIngestionJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ingestionJob
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ingestionJobDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.IngestionJob.self, forKey: .ingestionJob)
        ingestionJob = ingestionJobDecoded
    }
}

enum StartIngestionJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BedrockAgentClientTypes.StorageConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case opensearchServerlessConfiguration
        case pineconeConfiguration
        case rdsConfiguration
        case redisEnterpriseCloudConfiguration
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let opensearchServerlessConfiguration = self.opensearchServerlessConfiguration {
            try encodeContainer.encode(opensearchServerlessConfiguration, forKey: .opensearchServerlessConfiguration)
        }
        if let pineconeConfiguration = self.pineconeConfiguration {
            try encodeContainer.encode(pineconeConfiguration, forKey: .pineconeConfiguration)
        }
        if let rdsConfiguration = self.rdsConfiguration {
            try encodeContainer.encode(rdsConfiguration, forKey: .rdsConfiguration)
        }
        if let redisEnterpriseCloudConfiguration = self.redisEnterpriseCloudConfiguration {
            try encodeContainer.encode(redisEnterpriseCloudConfiguration, forKey: .redisEnterpriseCloudConfiguration)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.KnowledgeBaseStorageType.self, forKey: .type)
        type = typeDecoded
        let opensearchServerlessConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.OpenSearchServerlessConfiguration.self, forKey: .opensearchServerlessConfiguration)
        opensearchServerlessConfiguration = opensearchServerlessConfigurationDecoded
        let pineconeConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.PineconeConfiguration.self, forKey: .pineconeConfiguration)
        pineconeConfiguration = pineconeConfigurationDecoded
        let redisEnterpriseCloudConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.RedisEnterpriseCloudConfiguration.self, forKey: .redisEnterpriseCloudConfiguration)
        redisEnterpriseCloudConfiguration = redisEnterpriseCloudConfigurationDecoded
        let rdsConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.RdsConfiguration.self, forKey: .rdsConfiguration)
        rdsConfiguration = rdsConfigurationDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Configures the physical storage of ingested data in a knowledge base.
    public struct StorageConfiguration: Swift.Equatable {
        /// Contains the configurations to use OpenSearch Serverless to store knowledge base data.
        public var opensearchServerlessConfiguration: BedrockAgentClientTypes.OpenSearchServerlessConfiguration?
        /// Contains the configurations to use Pinecone to store knowledge base data.
        public var pineconeConfiguration: BedrockAgentClientTypes.PineconeConfiguration?
        /// Contains the configurations to use RDS to store knowledge base data.
        public var rdsConfiguration: BedrockAgentClientTypes.RdsConfiguration?
        /// Contains the configurations to use Redis Enterprise Cloud to store knowledge base data.
        public var redisEnterpriseCloudConfiguration: BedrockAgentClientTypes.RedisEnterpriseCloudConfiguration?
        /// The storage type of a knowledge base.
        /// This member is required.
        public var type: BedrockAgentClientTypes.KnowledgeBaseStorageType?

        public init(
            opensearchServerlessConfiguration: BedrockAgentClientTypes.OpenSearchServerlessConfiguration? = nil,
            pineconeConfiguration: BedrockAgentClientTypes.PineconeConfiguration? = nil,
            rdsConfiguration: BedrockAgentClientTypes.RdsConfiguration? = nil,
            redisEnterpriseCloudConfiguration: BedrockAgentClientTypes.RedisEnterpriseCloudConfiguration? = nil,
            type: BedrockAgentClientTypes.KnowledgeBaseStorageType? = nil
        )
        {
            self.opensearchServerlessConfiguration = opensearchServerlessConfiguration
            self.pineconeConfiguration = pineconeConfiguration
            self.rdsConfiguration = rdsConfiguration
            self.redisEnterpriseCloudConfiguration = redisEnterpriseCloudConfiguration
            self.type = type
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// ARN of Taggable resources: [Agent, AgentAlias, Knowledge-Base]
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A map of tag keys and values
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the number of requests exceeds the limit
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Non Blank String
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// ARN of Taggable resources: [Agent, AgentAlias, Knowledge-Base]
    /// This member is required.
    public var resourceArn: Swift.String?
    /// List of Tag Keys
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAgentActionGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionGroupExecutor
        case actionGroupName
        case actionGroupState
        case apiSchema
        case description
        case parentActionGroupSignature
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionGroupExecutor = self.actionGroupExecutor {
            try encodeContainer.encode(actionGroupExecutor, forKey: .actionGroupExecutor)
        }
        if let actionGroupName = self.actionGroupName {
            try encodeContainer.encode(actionGroupName, forKey: .actionGroupName)
        }
        if let actionGroupState = self.actionGroupState {
            try encodeContainer.encode(actionGroupState.rawValue, forKey: .actionGroupState)
        }
        if let apiSchema = self.apiSchema {
            try encodeContainer.encode(apiSchema, forKey: .apiSchema)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let parentActionGroupSignature = self.parentActionGroupSignature {
            try encodeContainer.encode(parentActionGroupSignature.rawValue, forKey: .parentActionGroupSignature)
        }
    }
}

extension UpdateAgentActionGroupInput {

    static func urlPathProvider(_ value: UpdateAgentActionGroupInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        guard let actionGroupId = value.actionGroupId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/actiongroups/\(actionGroupId.urlPercentEncoding())"
    }
}

/// Update Action Group Request
public struct UpdateAgentActionGroupInput: Swift.Equatable {
    /// Type of Executors for an Action Group
    public var actionGroupExecutor: BedrockAgentClientTypes.ActionGroupExecutor?
    /// Id generated at the server side when an Action Group is created under Agent
    /// This member is required.
    public var actionGroupId: Swift.String?
    /// Name for a resource.
    /// This member is required.
    public var actionGroupName: Swift.String?
    /// State of the action group
    public var actionGroupState: BedrockAgentClientTypes.ActionGroupState?
    /// Id generated at the server side when an Agent is created
    /// This member is required.
    public var agentId: Swift.String?
    /// Draft Version of the Agent.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// Contains information about the API Schema for the Action Group
    public var apiSchema: BedrockAgentClientTypes.APISchema?
    /// Description of the Resource.
    public var description: Swift.String?
    /// Action Group Signature for a BuiltIn Action
    public var parentActionGroupSignature: BedrockAgentClientTypes.ActionGroupSignature?

    public init(
        actionGroupExecutor: BedrockAgentClientTypes.ActionGroupExecutor? = nil,
        actionGroupId: Swift.String? = nil,
        actionGroupName: Swift.String? = nil,
        actionGroupState: BedrockAgentClientTypes.ActionGroupState? = nil,
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        apiSchema: BedrockAgentClientTypes.APISchema? = nil,
        description: Swift.String? = nil,
        parentActionGroupSignature: BedrockAgentClientTypes.ActionGroupSignature? = nil
    )
    {
        self.actionGroupExecutor = actionGroupExecutor
        self.actionGroupId = actionGroupId
        self.actionGroupName = actionGroupName
        self.actionGroupState = actionGroupState
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.apiSchema = apiSchema
        self.description = description
        self.parentActionGroupSignature = parentActionGroupSignature
    }
}

struct UpdateAgentActionGroupInputBody: Swift.Equatable {
    let actionGroupName: Swift.String?
    let description: Swift.String?
    let parentActionGroupSignature: BedrockAgentClientTypes.ActionGroupSignature?
    let actionGroupExecutor: BedrockAgentClientTypes.ActionGroupExecutor?
    let actionGroupState: BedrockAgentClientTypes.ActionGroupState?
    let apiSchema: BedrockAgentClientTypes.APISchema?
}

extension UpdateAgentActionGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionGroupExecutor
        case actionGroupName
        case actionGroupState
        case apiSchema
        case description
        case parentActionGroupSignature
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionGroupName)
        actionGroupName = actionGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parentActionGroupSignatureDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.ActionGroupSignature.self, forKey: .parentActionGroupSignature)
        parentActionGroupSignature = parentActionGroupSignatureDecoded
        let actionGroupExecutorDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.ActionGroupExecutor.self, forKey: .actionGroupExecutor)
        actionGroupExecutor = actionGroupExecutorDecoded
        let actionGroupStateDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.ActionGroupState.self, forKey: .actionGroupState)
        actionGroupState = actionGroupStateDecoded
        let apiSchemaDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.APISchema.self, forKey: .apiSchema)
        apiSchema = apiSchemaDecoded
    }
}

extension UpdateAgentActionGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAgentActionGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentActionGroup = output.agentActionGroup
        } else {
            self.agentActionGroup = nil
        }
    }
}

/// Update Action Group Response
public struct UpdateAgentActionGroupOutput: Swift.Equatable {
    /// Contains the information of an Agent Action Group
    /// This member is required.
    public var agentActionGroup: BedrockAgentClientTypes.AgentActionGroup?

    public init(
        agentActionGroup: BedrockAgentClientTypes.AgentActionGroup? = nil
    )
    {
        self.agentActionGroup = agentActionGroup
    }
}

struct UpdateAgentActionGroupOutputBody: Swift.Equatable {
    let agentActionGroup: BedrockAgentClientTypes.AgentActionGroup?
}

extension UpdateAgentActionGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentActionGroup
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentActionGroupDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentActionGroup.self, forKey: .agentActionGroup)
        agentActionGroup = agentActionGroupDecoded
    }
}

enum UpdateAgentActionGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAgentAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentAliasName
        case description
        case routingConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentAliasName = self.agentAliasName {
            try encodeContainer.encode(agentAliasName, forKey: .agentAliasName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let routingConfiguration = routingConfiguration {
            var routingConfigurationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .routingConfiguration)
            for agentaliasroutingconfigurationlistitem0 in routingConfiguration {
                try routingConfigurationContainer.encode(agentaliasroutingconfigurationlistitem0)
            }
        }
    }
}

extension UpdateAgentAliasInput {

    static func urlPathProvider(_ value: UpdateAgentAliasInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentAliasId = value.agentAliasId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentaliases/\(agentAliasId.urlPercentEncoding())"
    }
}

/// Update Agent Alias Request
public struct UpdateAgentAliasInput: Swift.Equatable {
    /// Id generated at the server side when an Agent Alias is created
    /// This member is required.
    public var agentAliasId: Swift.String?
    /// Name for a resource.
    /// This member is required.
    public var agentAliasName: Swift.String?
    /// Id generated at the server side when an Agent is created
    /// This member is required.
    public var agentId: Swift.String?
    /// Description of the Resource.
    public var description: Swift.String?
    /// Routing configuration for an Agent alias.
    public var routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]?

    public init(
        agentAliasId: Swift.String? = nil,
        agentAliasName: Swift.String? = nil,
        agentId: Swift.String? = nil,
        description: Swift.String? = nil,
        routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]? = nil
    )
    {
        self.agentAliasId = agentAliasId
        self.agentAliasName = agentAliasName
        self.agentId = agentId
        self.description = description
        self.routingConfiguration = routingConfiguration
    }
}

struct UpdateAgentAliasInputBody: Swift.Equatable {
    let agentAliasName: Swift.String?
    let description: Swift.String?
    let routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]?
}

extension UpdateAgentAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentAliasName
        case description
        case routingConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentAliasNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentAliasName)
        agentAliasName = agentAliasNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let routingConfigurationContainer = try containerValues.decodeIfPresent([BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem?].self, forKey: .routingConfiguration)
        var routingConfigurationDecoded0:[BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]? = nil
        if let routingConfigurationContainer = routingConfigurationContainer {
            routingConfigurationDecoded0 = [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]()
            for structure0 in routingConfigurationContainer {
                if let structure0 = structure0 {
                    routingConfigurationDecoded0?.append(structure0)
                }
            }
        }
        routingConfiguration = routingConfigurationDecoded0
    }
}

extension UpdateAgentAliasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAgentAliasOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentAlias = output.agentAlias
        } else {
            self.agentAlias = nil
        }
    }
}

/// Update Agent Alias Response
public struct UpdateAgentAliasOutput: Swift.Equatable {
    /// Contains the information of an agent alias
    /// This member is required.
    public var agentAlias: BedrockAgentClientTypes.AgentAlias?

    public init(
        agentAlias: BedrockAgentClientTypes.AgentAlias? = nil
    )
    {
        self.agentAlias = agentAlias
    }
}

struct UpdateAgentAliasOutputBody: Swift.Equatable {
    let agentAlias: BedrockAgentClientTypes.AgentAlias?
}

extension UpdateAgentAliasOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentAlias
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentAliasDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentAlias.self, forKey: .agentAlias)
        agentAlias = agentAliasDecoded
    }
}

enum UpdateAgentAliasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAgentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAgentInput(agentId: \(Swift.String(describing: agentId)), agentName: \(Swift.String(describing: agentName)), agentResourceRoleArn: \(Swift.String(describing: agentResourceRoleArn)), customerEncryptionKeyArn: \(Swift.String(describing: customerEncryptionKeyArn)), description: \(Swift.String(describing: description)), foundationModel: \(Swift.String(describing: foundationModel)), idleSessionTTLInSeconds: \(Swift.String(describing: idleSessionTTLInSeconds)), instruction: \"CONTENT_REDACTED\", promptOverrideConfiguration: \"CONTENT_REDACTED\")"}
}

extension UpdateAgentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentName
        case agentResourceRoleArn
        case customerEncryptionKeyArn
        case description
        case foundationModel
        case idleSessionTTLInSeconds
        case instruction
        case promptOverrideConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentName = self.agentName {
            try encodeContainer.encode(agentName, forKey: .agentName)
        }
        if let agentResourceRoleArn = self.agentResourceRoleArn {
            try encodeContainer.encode(agentResourceRoleArn, forKey: .agentResourceRoleArn)
        }
        if let customerEncryptionKeyArn = self.customerEncryptionKeyArn {
            try encodeContainer.encode(customerEncryptionKeyArn, forKey: .customerEncryptionKeyArn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let foundationModel = self.foundationModel {
            try encodeContainer.encode(foundationModel, forKey: .foundationModel)
        }
        if let idleSessionTTLInSeconds = self.idleSessionTTLInSeconds {
            try encodeContainer.encode(idleSessionTTLInSeconds, forKey: .idleSessionTTLInSeconds)
        }
        if let instruction = self.instruction {
            try encodeContainer.encode(instruction, forKey: .instruction)
        }
        if let promptOverrideConfiguration = self.promptOverrideConfiguration {
            try encodeContainer.encode(promptOverrideConfiguration, forKey: .promptOverrideConfiguration)
        }
    }
}

extension UpdateAgentInput {

    static func urlPathProvider(_ value: UpdateAgentInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())"
    }
}

/// Update Agent Request
public struct UpdateAgentInput: Swift.Equatable {
    /// Id generated at the server side when an Agent is created
    /// This member is required.
    public var agentId: Swift.String?
    /// Name for a resource.
    /// This member is required.
    public var agentName: Swift.String?
    /// ARN of a IAM role.
    /// This member is required.
    public var agentResourceRoleArn: Swift.String?
    /// A KMS key ARN
    public var customerEncryptionKeyArn: Swift.String?
    /// Description of the Resource.
    public var description: Swift.String?
    /// ARN or name of a Bedrock model.
    public var foundationModel: Swift.String?
    /// Max Session Time.
    public var idleSessionTTLInSeconds: Swift.Int?
    /// Instruction for the agent.
    public var instruction: Swift.String?
    /// Configuration for prompt override.
    public var promptOverrideConfiguration: BedrockAgentClientTypes.PromptOverrideConfiguration?

    public init(
        agentId: Swift.String? = nil,
        agentName: Swift.String? = nil,
        agentResourceRoleArn: Swift.String? = nil,
        customerEncryptionKeyArn: Swift.String? = nil,
        description: Swift.String? = nil,
        foundationModel: Swift.String? = nil,
        idleSessionTTLInSeconds: Swift.Int? = nil,
        instruction: Swift.String? = nil,
        promptOverrideConfiguration: BedrockAgentClientTypes.PromptOverrideConfiguration? = nil
    )
    {
        self.agentId = agentId
        self.agentName = agentName
        self.agentResourceRoleArn = agentResourceRoleArn
        self.customerEncryptionKeyArn = customerEncryptionKeyArn
        self.description = description
        self.foundationModel = foundationModel
        self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
        self.instruction = instruction
        self.promptOverrideConfiguration = promptOverrideConfiguration
    }
}

struct UpdateAgentInputBody: Swift.Equatable {
    let agentName: Swift.String?
    let instruction: Swift.String?
    let foundationModel: Swift.String?
    let description: Swift.String?
    let idleSessionTTLInSeconds: Swift.Int?
    let agentResourceRoleArn: Swift.String?
    let customerEncryptionKeyArn: Swift.String?
    let promptOverrideConfiguration: BedrockAgentClientTypes.PromptOverrideConfiguration?
}

extension UpdateAgentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentName
        case agentResourceRoleArn
        case customerEncryptionKeyArn
        case description
        case foundationModel
        case idleSessionTTLInSeconds
        case instruction
        case promptOverrideConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentName)
        agentName = agentNameDecoded
        let instructionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instruction)
        instruction = instructionDecoded
        let foundationModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .foundationModel)
        foundationModel = foundationModelDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let idleSessionTTLInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleSessionTTLInSeconds)
        idleSessionTTLInSeconds = idleSessionTTLInSecondsDecoded
        let agentResourceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentResourceRoleArn)
        agentResourceRoleArn = agentResourceRoleArnDecoded
        let customerEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerEncryptionKeyArn)
        customerEncryptionKeyArn = customerEncryptionKeyArnDecoded
        let promptOverrideConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.PromptOverrideConfiguration.self, forKey: .promptOverrideConfiguration)
        promptOverrideConfiguration = promptOverrideConfigurationDecoded
    }
}

extension UpdateAgentKnowledgeBaseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case knowledgeBaseState
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let knowledgeBaseState = self.knowledgeBaseState {
            try encodeContainer.encode(knowledgeBaseState.rawValue, forKey: .knowledgeBaseState)
        }
    }
}

extension UpdateAgentKnowledgeBaseInput {

    static func urlPathProvider(_ value: UpdateAgentKnowledgeBaseInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())"
    }
}

/// Update Agent Knowledge Base Request
public struct UpdateAgentKnowledgeBaseInput: Swift.Equatable {
    /// Id generated at the server side when an Agent is created
    /// This member is required.
    public var agentId: Swift.String?
    /// Draft Version of the Agent.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// Description of the Resource.
    public var description: Swift.String?
    /// Id generated at the server side when a Knowledge Base is associated to an Agent
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// State of the knowledge base; whether it is enabled or disabled
    public var knowledgeBaseState: BedrockAgentClientTypes.KnowledgeBaseState?

    public init(
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        description: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil,
        knowledgeBaseState: BedrockAgentClientTypes.KnowledgeBaseState? = nil
    )
    {
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.description = description
        self.knowledgeBaseId = knowledgeBaseId
        self.knowledgeBaseState = knowledgeBaseState
    }
}

struct UpdateAgentKnowledgeBaseInputBody: Swift.Equatable {
    let description: Swift.String?
    let knowledgeBaseState: BedrockAgentClientTypes.KnowledgeBaseState?
}

extension UpdateAgentKnowledgeBaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case knowledgeBaseState
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let knowledgeBaseStateDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.KnowledgeBaseState.self, forKey: .knowledgeBaseState)
        knowledgeBaseState = knowledgeBaseStateDecoded
    }
}

extension UpdateAgentKnowledgeBaseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAgentKnowledgeBaseOutputBody = try responseDecoder.decode(responseBody: data)
            self.agentKnowledgeBase = output.agentKnowledgeBase
        } else {
            self.agentKnowledgeBase = nil
        }
    }
}

/// Update Agent Knowledge Base Response
public struct UpdateAgentKnowledgeBaseOutput: Swift.Equatable {
    /// Contains the information of an Agent Knowledge Base.
    /// This member is required.
    public var agentKnowledgeBase: BedrockAgentClientTypes.AgentKnowledgeBase?

    public init(
        agentKnowledgeBase: BedrockAgentClientTypes.AgentKnowledgeBase? = nil
    )
    {
        self.agentKnowledgeBase = agentKnowledgeBase
    }
}

struct UpdateAgentKnowledgeBaseOutputBody: Swift.Equatable {
    let agentKnowledgeBase: BedrockAgentClientTypes.AgentKnowledgeBase?
}

extension UpdateAgentKnowledgeBaseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentKnowledgeBase
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentKnowledgeBaseDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.AgentKnowledgeBase.self, forKey: .agentKnowledgeBase)
        agentKnowledgeBase = agentKnowledgeBaseDecoded
    }
}

enum UpdateAgentKnowledgeBaseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAgentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAgentOutputBody = try responseDecoder.decode(responseBody: data)
            self.agent = output.agent
        } else {
            self.agent = nil
        }
    }
}

/// Update Agent Response
public struct UpdateAgentOutput: Swift.Equatable {
    /// Contains the information of an agent
    /// This member is required.
    public var agent: BedrockAgentClientTypes.Agent?

    public init(
        agent: BedrockAgentClientTypes.Agent? = nil
    )
    {
        self.agent = agent
    }
}

struct UpdateAgentOutputBody: Swift.Equatable {
    let agent: BedrockAgentClientTypes.Agent?
}

extension UpdateAgentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agent
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.Agent.self, forKey: .agent)
        agent = agentDecoded
    }
}

enum UpdateAgentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDataSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceConfiguration
        case description
        case name
        case serverSideEncryptionConfiguration
        case vectorIngestionConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceConfiguration = self.dataSourceConfiguration {
            try encodeContainer.encode(dataSourceConfiguration, forKey: .dataSourceConfiguration)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverSideEncryptionConfiguration = self.serverSideEncryptionConfiguration {
            try encodeContainer.encode(serverSideEncryptionConfiguration, forKey: .serverSideEncryptionConfiguration)
        }
        if let vectorIngestionConfiguration = self.vectorIngestionConfiguration {
            try encodeContainer.encode(vectorIngestionConfiguration, forKey: .vectorIngestionConfiguration)
        }
    }
}

extension UpdateDataSourceInput {

    static func urlPathProvider(_ value: UpdateDataSourceInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let dataSourceId = value.dataSourceId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())"
    }
}

public struct UpdateDataSourceInput: Swift.Equatable {
    /// Specifies a raw data source location to ingest.
    /// This member is required.
    public var dataSourceConfiguration: BedrockAgentClientTypes.DataSourceConfiguration?
    /// Identifier for a resource.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// Description of the Resource.
    public var description: Swift.String?
    /// Identifier for a resource.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// Name for a resource.
    /// This member is required.
    public var name: Swift.String?
    /// Server-side encryption configuration.
    public var serverSideEncryptionConfiguration: BedrockAgentClientTypes.ServerSideEncryptionConfiguration?
    /// Configures ingestion for a vector knowledge base
    public var vectorIngestionConfiguration: BedrockAgentClientTypes.VectorIngestionConfiguration?

    public init(
        dataSourceConfiguration: BedrockAgentClientTypes.DataSourceConfiguration? = nil,
        dataSourceId: Swift.String? = nil,
        description: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil,
        name: Swift.String? = nil,
        serverSideEncryptionConfiguration: BedrockAgentClientTypes.ServerSideEncryptionConfiguration? = nil,
        vectorIngestionConfiguration: BedrockAgentClientTypes.VectorIngestionConfiguration? = nil
    )
    {
        self.dataSourceConfiguration = dataSourceConfiguration
        self.dataSourceId = dataSourceId
        self.description = description
        self.knowledgeBaseId = knowledgeBaseId
        self.name = name
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
        self.vectorIngestionConfiguration = vectorIngestionConfiguration
    }
}

struct UpdateDataSourceInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let dataSourceConfiguration: BedrockAgentClientTypes.DataSourceConfiguration?
    let serverSideEncryptionConfiguration: BedrockAgentClientTypes.ServerSideEncryptionConfiguration?
    let vectorIngestionConfiguration: BedrockAgentClientTypes.VectorIngestionConfiguration?
}

extension UpdateDataSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceConfiguration
        case description
        case name
        case serverSideEncryptionConfiguration
        case vectorIngestionConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourceConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.DataSourceConfiguration.self, forKey: .dataSourceConfiguration)
        dataSourceConfiguration = dataSourceConfigurationDecoded
        let serverSideEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.ServerSideEncryptionConfiguration.self, forKey: .serverSideEncryptionConfiguration)
        serverSideEncryptionConfiguration = serverSideEncryptionConfigurationDecoded
        let vectorIngestionConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.VectorIngestionConfiguration.self, forKey: .vectorIngestionConfiguration)
        vectorIngestionConfiguration = vectorIngestionConfigurationDecoded
    }
}

extension UpdateDataSourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateDataSourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataSource = output.dataSource
        } else {
            self.dataSource = nil
        }
    }
}

public struct UpdateDataSourceOutput: Swift.Equatable {
    /// Contains the information of a data source.
    /// This member is required.
    public var dataSource: BedrockAgentClientTypes.DataSource?

    public init(
        dataSource: BedrockAgentClientTypes.DataSource? = nil
    )
    {
        self.dataSource = dataSource
    }
}

struct UpdateDataSourceOutputBody: Swift.Equatable {
    let dataSource: BedrockAgentClientTypes.DataSource?
}

extension UpdateDataSourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
    }
}

enum UpdateDataSourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateKnowledgeBaseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case knowledgeBaseConfiguration
        case name
        case roleArn
        case storageConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let knowledgeBaseConfiguration = self.knowledgeBaseConfiguration {
            try encodeContainer.encode(knowledgeBaseConfiguration, forKey: .knowledgeBaseConfiguration)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let storageConfiguration = self.storageConfiguration {
            try encodeContainer.encode(storageConfiguration, forKey: .storageConfiguration)
        }
    }
}

extension UpdateKnowledgeBaseInput {

    static func urlPathProvider(_ value: UpdateKnowledgeBaseInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())"
    }
}

public struct UpdateKnowledgeBaseInput: Swift.Equatable {
    /// Description of the Resource.
    public var description: Swift.String?
    /// Configures a bedrock knowledge base.
    /// This member is required.
    public var knowledgeBaseConfiguration: BedrockAgentClientTypes.KnowledgeBaseConfiguration?
    /// Identifier for a resource.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// Name for a resource.
    /// This member is required.
    public var name: Swift.String?
    /// ARN of a IAM role.
    /// This member is required.
    public var roleArn: Swift.String?
    /// Configures the physical storage of ingested data in a knowledge base.
    /// This member is required.
    public var storageConfiguration: BedrockAgentClientTypes.StorageConfiguration?

    public init(
        description: Swift.String? = nil,
        knowledgeBaseConfiguration: BedrockAgentClientTypes.KnowledgeBaseConfiguration? = nil,
        knowledgeBaseId: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        storageConfiguration: BedrockAgentClientTypes.StorageConfiguration? = nil
    )
    {
        self.description = description
        self.knowledgeBaseConfiguration = knowledgeBaseConfiguration
        self.knowledgeBaseId = knowledgeBaseId
        self.name = name
        self.roleArn = roleArn
        self.storageConfiguration = storageConfiguration
    }
}

struct UpdateKnowledgeBaseInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let roleArn: Swift.String?
    let knowledgeBaseConfiguration: BedrockAgentClientTypes.KnowledgeBaseConfiguration?
    let storageConfiguration: BedrockAgentClientTypes.StorageConfiguration?
}

extension UpdateKnowledgeBaseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case knowledgeBaseConfiguration
        case name
        case roleArn
        case storageConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let knowledgeBaseConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.KnowledgeBaseConfiguration.self, forKey: .knowledgeBaseConfiguration)
        knowledgeBaseConfiguration = knowledgeBaseConfigurationDecoded
        let storageConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.StorageConfiguration.self, forKey: .storageConfiguration)
        storageConfiguration = storageConfigurationDecoded
    }
}

extension UpdateKnowledgeBaseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateKnowledgeBaseOutputBody = try responseDecoder.decode(responseBody: data)
            self.knowledgeBase = output.knowledgeBase
        } else {
            self.knowledgeBase = nil
        }
    }
}

public struct UpdateKnowledgeBaseOutput: Swift.Equatable {
    /// Contains the information of a knowledge base.
    /// This member is required.
    public var knowledgeBase: BedrockAgentClientTypes.KnowledgeBase?

    public init(
        knowledgeBase: BedrockAgentClientTypes.KnowledgeBase? = nil
    )
    {
        self.knowledgeBase = knowledgeBase
    }
}

struct UpdateKnowledgeBaseOutputBody: Swift.Equatable {
    let knowledgeBase: BedrockAgentClientTypes.KnowledgeBase?
}

extension UpdateKnowledgeBaseOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case knowledgeBase
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let knowledgeBaseDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.KnowledgeBase.self, forKey: .knowledgeBase)
        knowledgeBase = knowledgeBaseDecoded
    }
}

enum UpdateKnowledgeBaseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fieldList = output.fieldList
            self.properties.message = output.message
        } else {
            self.properties.fieldList = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when the request's input validation fails
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// list of ValidationExceptionField
        public internal(set) var fieldList: [BedrockAgentClientTypes.ValidationExceptionField]? = nil
        /// Non Blank String
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [BedrockAgentClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let fieldList: [BedrockAgentClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([BedrockAgentClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[BedrockAgentClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [BedrockAgentClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension BedrockAgentClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Stores information about a field passed inside a request that resulted in an exception
    public struct ValidationExceptionField: Swift.Equatable {
        /// Non Blank String
        /// This member is required.
        public var message: Swift.String?
        /// Non Blank String
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension BedrockAgentClientTypes.VectorIngestionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case chunkingConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let chunkingConfiguration = self.chunkingConfiguration {
            try encodeContainer.encode(chunkingConfiguration, forKey: .chunkingConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let chunkingConfigurationDecoded = try containerValues.decodeIfPresent(BedrockAgentClientTypes.ChunkingConfiguration.self, forKey: .chunkingConfiguration)
        chunkingConfiguration = chunkingConfigurationDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Configures ingestion for a vector knowledge base
    public struct VectorIngestionConfiguration: Swift.Equatable {
        /// Configures chunking strategy
        public var chunkingConfiguration: BedrockAgentClientTypes.ChunkingConfiguration?

        public init(
            chunkingConfiguration: BedrockAgentClientTypes.ChunkingConfiguration? = nil
        )
        {
            self.chunkingConfiguration = chunkingConfiguration
        }
    }

}

extension BedrockAgentClientTypes.VectorKnowledgeBaseConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case embeddingModelArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let embeddingModelArn = self.embeddingModelArn {
            try encodeContainer.encode(embeddingModelArn, forKey: .embeddingModelArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let embeddingModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .embeddingModelArn)
        embeddingModelArn = embeddingModelArnDecoded
    }
}

extension BedrockAgentClientTypes {
    /// Configurations for a vector knowledge base.
    public struct VectorKnowledgeBaseConfiguration: Swift.Equatable {
        /// Arn of a Bedrock model.
        /// This member is required.
        public var embeddingModelArn: Swift.String?

        public init(
            embeddingModelArn: Swift.String? = nil
        )
        {
            self.embeddingModelArn = embeddingModelArn
        }
    }

}
