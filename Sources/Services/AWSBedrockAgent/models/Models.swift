// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime
import SmithyJSON
import SmithyReadWrite

extension BedrockAgentClientTypes.APISchema {

    static func write(value: BedrockAgentClientTypes.APISchema?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .payload(payload):
                try writer["payload"].write(payload)
            case let .s3(s3):
                try writer["s3"].write(s3, with: BedrockAgentClientTypes.S3Identifier.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.APISchema {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "s3":
                return .s3(try reader["s3"].read(with: BedrockAgentClientTypes.S3Identifier.read(from:)))
            case "payload":
                return .payload(try reader["payload"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about the OpenAPI schema for the action group. For more information, see [Action group OpenAPI schemas](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-api-schema.html). You can either include the schema directly in the payload field or you can upload it to an S3 bucket and specify the S3 bucket location in the s3 field.
    public enum APISchema {
        /// Contains details about the S3 object containing the OpenAPI schema for the action group. For more information, see [Action group OpenAPI schemas](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-api-schema.html).
        case s3(BedrockAgentClientTypes.S3Identifier)
        /// The JSON or YAML-formatted payload defining the OpenAPI schema for the action group. For more information, see [Action group OpenAPI schemas](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-api-schema.html).
        case payload(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The request is denied because of missing access permissions.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BedrockAgentClientTypes.ActionGroupExecutor {

    static func write(value: BedrockAgentClientTypes.ActionGroupExecutor?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .customcontrol(customcontrol):
                try writer["customControl"].write(customcontrol)
            case let .lambda(lambda):
                try writer["lambda"].write(lambda)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.ActionGroupExecutor {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "lambda":
                return .lambda(try reader["lambda"].read())
            case "customControl":
                return .customcontrol(try reader["customControl"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about the Lambda function containing the business logic that is carried out upon invoking the action or the custom control method for handling the information elicited from the user.
    public enum ActionGroupExecutor {
        /// The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action.
        case lambda(Swift.String)
        /// To return the action group invocation results directly in the InvokeAgent response, specify RETURN_CONTROL.
        case customcontrol(BedrockAgentClientTypes.CustomControlMethod)
        case sdkUnknown(Swift.String)
    }

}

extension BedrockAgentClientTypes {

    public enum ActionGroupSignature: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case amazonUserinput
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionGroupSignature] {
            return [
                .amazonUserinput,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .amazonUserinput: return "AMAZON.UserInput"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    public enum ActionGroupState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionGroupState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes.ActionGroupSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.ActionGroupSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.ActionGroupSummary()
        value.actionGroupId = try reader["actionGroupId"].readIfPresent()
        value.actionGroupName = try reader["actionGroupName"].readIfPresent()
        value.actionGroupState = try reader["actionGroupState"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about an action group.
    public struct ActionGroupSummary {
        /// The unique identifier of the action group.
        /// This member is required.
        public var actionGroupId: Swift.String?
        /// The name of the action group.
        /// This member is required.
        public var actionGroupName: Swift.String?
        /// Specifies whether the action group is available for the agent to invoke or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
        /// This member is required.
        public var actionGroupState: BedrockAgentClientTypes.ActionGroupState?
        /// The description of the action group.
        public var description: Swift.String?
        /// The time at which the action group was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            actionGroupId: Swift.String? = nil,
            actionGroupName: Swift.String? = nil,
            actionGroupState: BedrockAgentClientTypes.ActionGroupState? = nil,
            description: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.actionGroupId = actionGroupId
            self.actionGroupName = actionGroupName
            self.actionGroupState = actionGroupState
            self.description = description
            self.updatedAt = updatedAt
        }
    }

}

extension BedrockAgentClientTypes.Agent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Agent(agentArn: \(Swift.String(describing: agentArn)), agentId: \(Swift.String(describing: agentId)), agentName: \(Swift.String(describing: agentName)), agentResourceRoleArn: \(Swift.String(describing: agentResourceRoleArn)), agentStatus: \(Swift.String(describing: agentStatus)), agentVersion: \(Swift.String(describing: agentVersion)), clientToken: \(Swift.String(describing: clientToken)), createdAt: \(Swift.String(describing: createdAt)), customerEncryptionKeyArn: \(Swift.String(describing: customerEncryptionKeyArn)), description: \(Swift.String(describing: description)), failureReasons: \(Swift.String(describing: failureReasons)), foundationModel: \(Swift.String(describing: foundationModel)), idleSessionTTLInSeconds: \(Swift.String(describing: idleSessionTTLInSeconds)), preparedAt: \(Swift.String(describing: preparedAt)), recommendedActions: \(Swift.String(describing: recommendedActions)), updatedAt: \(Swift.String(describing: updatedAt)), instruction: \"CONTENT_REDACTED\", promptOverrideConfiguration: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentClientTypes.Agent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.Agent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.Agent()
        value.agentId = try reader["agentId"].readIfPresent()
        value.agentName = try reader["agentName"].readIfPresent()
        value.agentArn = try reader["agentArn"].readIfPresent()
        value.agentVersion = try reader["agentVersion"].readIfPresent()
        value.clientToken = try reader["clientToken"].readIfPresent()
        value.instruction = try reader["instruction"].readIfPresent()
        value.agentStatus = try reader["agentStatus"].readIfPresent()
        value.foundationModel = try reader["foundationModel"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.idleSessionTTLInSeconds = try reader["idleSessionTTLInSeconds"].readIfPresent()
        value.agentResourceRoleArn = try reader["agentResourceRoleArn"].readIfPresent()
        value.customerEncryptionKeyArn = try reader["customerEncryptionKeyArn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        value.preparedAt = try reader["preparedAt"].readTimestampIfPresent(format: .dateTime)
        value.failureReasons = try reader["failureReasons"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.recommendedActions = try reader["recommendedActions"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.promptOverrideConfiguration = try reader["promptOverrideConfiguration"].readIfPresent(with: BedrockAgentClientTypes.PromptOverrideConfiguration.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about an agent.
    public struct Agent {
        /// The Amazon Resource Name (ARN) of the agent.
        /// This member is required.
        public var agentArn: Swift.String?
        /// The unique identifier of the agent.
        /// This member is required.
        public var agentId: Swift.String?
        /// The name of the agent.
        /// This member is required.
        public var agentName: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the agent.
        /// This member is required.
        public var agentResourceRoleArn: Swift.String?
        /// The status of the agent and whether it is ready for use. The following statuses are possible:
        ///
        /// * CREATING – The agent is being created.
        ///
        /// * PREPARING – The agent is being prepared.
        ///
        /// * PREPARED – The agent is prepared and ready to be invoked.
        ///
        /// * NOT_PREPARED – The agent has been created but not yet prepared.
        ///
        /// * FAILED – The agent API operation failed.
        ///
        /// * UPDATING – The agent is being updated.
        ///
        /// * DELETING – The agent is being deleted.
        /// This member is required.
        public var agentStatus: BedrockAgentClientTypes.AgentStatus?
        /// The version of the agent.
        /// This member is required.
        public var agentVersion: Swift.String?
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
        public var clientToken: Swift.String?
        /// The time at which the agent was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the KMS key that encrypts the agent.
        public var customerEncryptionKeyArn: Swift.String?
        /// The description of the agent.
        public var description: Swift.String?
        /// Contains reasons that the agent-related API that you invoked failed.
        public var failureReasons: [Swift.String]?
        /// The foundation model used for orchestration by the agent.
        public var foundationModel: Swift.String?
        /// The number of seconds for which Amazon Bedrock keeps information about a user's conversation with the agent. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Bedrock deletes any data provided before the timeout.
        /// This member is required.
        public var idleSessionTTLInSeconds: Swift.Int?
        /// Instructions that tell the agent what it should do and how it should interact with users.
        public var instruction: Swift.String?
        /// The time at which the agent was last prepared.
        public var preparedAt: ClientRuntime.Date?
        /// Contains configurations to override prompt templates in different parts of an agent sequence. For more information, see [Advanced prompts](https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts.html).
        public var promptOverrideConfiguration: BedrockAgentClientTypes.PromptOverrideConfiguration?
        /// Contains recommended actions to take for the agent-related API that you invoked to succeed.
        public var recommendedActions: [Swift.String]?
        /// The time at which the agent was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            agentArn: Swift.String? = nil,
            agentId: Swift.String? = nil,
            agentName: Swift.String? = nil,
            agentResourceRoleArn: Swift.String? = nil,
            agentStatus: BedrockAgentClientTypes.AgentStatus? = nil,
            agentVersion: Swift.String? = nil,
            clientToken: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            customerEncryptionKeyArn: Swift.String? = nil,
            description: Swift.String? = nil,
            failureReasons: [Swift.String]? = nil,
            foundationModel: Swift.String? = nil,
            idleSessionTTLInSeconds: Swift.Int? = nil,
            instruction: Swift.String? = nil,
            preparedAt: ClientRuntime.Date? = nil,
            promptOverrideConfiguration: BedrockAgentClientTypes.PromptOverrideConfiguration? = nil,
            recommendedActions: [Swift.String]? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.agentArn = agentArn
            self.agentId = agentId
            self.agentName = agentName
            self.agentResourceRoleArn = agentResourceRoleArn
            self.agentStatus = agentStatus
            self.agentVersion = agentVersion
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.description = description
            self.failureReasons = failureReasons
            self.foundationModel = foundationModel
            self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
            self.instruction = instruction
            self.preparedAt = preparedAt
            self.promptOverrideConfiguration = promptOverrideConfiguration
            self.recommendedActions = recommendedActions
            self.updatedAt = updatedAt
        }
    }

}

extension BedrockAgentClientTypes.AgentActionGroup {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.AgentActionGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.AgentActionGroup()
        value.agentId = try reader["agentId"].readIfPresent()
        value.agentVersion = try reader["agentVersion"].readIfPresent()
        value.actionGroupId = try reader["actionGroupId"].readIfPresent()
        value.actionGroupName = try reader["actionGroupName"].readIfPresent()
        value.clientToken = try reader["clientToken"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        value.parentActionSignature = try reader["parentActionSignature"].readIfPresent()
        value.actionGroupExecutor = try reader["actionGroupExecutor"].readIfPresent(with: BedrockAgentClientTypes.ActionGroupExecutor.read(from:))
        value.apiSchema = try reader["apiSchema"].readIfPresent(with: BedrockAgentClientTypes.APISchema.read(from:))
        value.functionSchema = try reader["functionSchema"].readIfPresent(with: BedrockAgentClientTypes.FunctionSchema.read(from:))
        value.actionGroupState = try reader["actionGroupState"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about an action group.
    public struct AgentActionGroup {
        /// The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action or the custom control method for handling the information elicited from the user.
        public var actionGroupExecutor: BedrockAgentClientTypes.ActionGroupExecutor?
        /// The unique identifier of the action group.
        /// This member is required.
        public var actionGroupId: Swift.String?
        /// The name of the action group.
        /// This member is required.
        public var actionGroupName: Swift.String?
        /// Specifies whether the action group is available for the agent to invoke or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
        /// This member is required.
        public var actionGroupState: BedrockAgentClientTypes.ActionGroupState?
        /// The unique identifier of the agent to which the action group belongs.
        /// This member is required.
        public var agentId: Swift.String?
        /// The version of the agent to which the action group belongs.
        /// This member is required.
        public var agentVersion: Swift.String?
        /// Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted payload defining the schema. For more information, see [Action group OpenAPI schemas](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-api-schema.html).
        public var apiSchema: BedrockAgentClientTypes.APISchema?
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
        public var clientToken: Swift.String?
        /// The time at which the action group was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The description of the action group.
        public var description: Swift.String?
        /// Defines functions that each define parameters that the agent needs to invoke from the user. Each function represents an action in an action group.
        public var functionSchema: BedrockAgentClientTypes.FunctionSchema?
        /// If this field is set as AMAZON.UserInput, the agent can request the user for additional information when trying to complete a task. The description, apiSchema, and actionGroupExecutor fields must be blank for this action group. During orchestration, if the agent determines that it needs to invoke an API in an action group, but doesn't have enough information to complete the API request, it will invoke this action group instead and return an [Observation](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Observation.html) reprompting the user for more information.
        public var parentActionSignature: BedrockAgentClientTypes.ActionGroupSignature?
        /// The time at which the action group was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            actionGroupExecutor: BedrockAgentClientTypes.ActionGroupExecutor? = nil,
            actionGroupId: Swift.String? = nil,
            actionGroupName: Swift.String? = nil,
            actionGroupState: BedrockAgentClientTypes.ActionGroupState? = nil,
            agentId: Swift.String? = nil,
            agentVersion: Swift.String? = nil,
            apiSchema: BedrockAgentClientTypes.APISchema? = nil,
            clientToken: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            functionSchema: BedrockAgentClientTypes.FunctionSchema? = nil,
            parentActionSignature: BedrockAgentClientTypes.ActionGroupSignature? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.actionGroupExecutor = actionGroupExecutor
            self.actionGroupId = actionGroupId
            self.actionGroupName = actionGroupName
            self.actionGroupState = actionGroupState
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.apiSchema = apiSchema
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.description = description
            self.functionSchema = functionSchema
            self.parentActionSignature = parentActionSignature
            self.updatedAt = updatedAt
        }
    }

}

extension BedrockAgentClientTypes.AgentAlias {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.AgentAlias {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.AgentAlias()
        value.agentId = try reader["agentId"].readIfPresent()
        value.agentAliasId = try reader["agentAliasId"].readIfPresent()
        value.agentAliasName = try reader["agentAliasName"].readIfPresent()
        value.agentAliasArn = try reader["agentAliasArn"].readIfPresent()
        value.clientToken = try reader["clientToken"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.routingConfiguration = try reader["routingConfiguration"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        value.agentAliasHistoryEvents = try reader["agentAliasHistoryEvents"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.AgentAliasHistoryEvent.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.agentAliasStatus = try reader["agentAliasStatus"].readIfPresent()
        value.failureReasons = try reader["failureReasons"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about an alias of an agent.
    public struct AgentAlias {
        /// The Amazon Resource Name (ARN) of the alias of the agent.
        /// This member is required.
        public var agentAliasArn: Swift.String?
        /// Contains details about the history of the alias.
        public var agentAliasHistoryEvents: [BedrockAgentClientTypes.AgentAliasHistoryEvent]?
        /// The unique identifier of the alias of the agent.
        /// This member is required.
        public var agentAliasId: Swift.String?
        /// The name of the alias of the agent.
        /// This member is required.
        public var agentAliasName: Swift.String?
        /// The status of the alias of the agent and whether it is ready for use. The following statuses are possible:
        ///
        /// * CREATING – The agent alias is being created.
        ///
        /// * PREPARED – The agent alias is finished being created or updated and is ready to be invoked.
        ///
        /// * FAILED – The agent alias API operation failed.
        ///
        /// * UPDATING – The agent alias is being updated.
        ///
        /// * DELETING – The agent alias is being deleted.
        /// This member is required.
        public var agentAliasStatus: BedrockAgentClientTypes.AgentAliasStatus?
        /// The unique identifier of the agent.
        /// This member is required.
        public var agentId: Swift.String?
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
        public var clientToken: Swift.String?
        /// The time at which the alias of the agent was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The description of the alias of the agent.
        public var description: Swift.String?
        /// Information on the failure of Provisioned Throughput assigned to an agent alias.
        public var failureReasons: [Swift.String]?
        /// Contains details about the routing configuration of the alias.
        /// This member is required.
        public var routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]?
        /// The time at which the alias was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            agentAliasArn: Swift.String? = nil,
            agentAliasHistoryEvents: [BedrockAgentClientTypes.AgentAliasHistoryEvent]? = nil,
            agentAliasId: Swift.String? = nil,
            agentAliasName: Swift.String? = nil,
            agentAliasStatus: BedrockAgentClientTypes.AgentAliasStatus? = nil,
            agentId: Swift.String? = nil,
            clientToken: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            failureReasons: [Swift.String]? = nil,
            routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.agentAliasArn = agentAliasArn
            self.agentAliasHistoryEvents = agentAliasHistoryEvents
            self.agentAliasId = agentAliasId
            self.agentAliasName = agentAliasName
            self.agentAliasStatus = agentAliasStatus
            self.agentId = agentId
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.description = description
            self.failureReasons = failureReasons
            self.routingConfiguration = routingConfiguration
            self.updatedAt = updatedAt
        }
    }

}

extension BedrockAgentClientTypes.AgentAliasHistoryEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.AgentAliasHistoryEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.AgentAliasHistoryEvent()
        value.routingConfiguration = try reader["routingConfiguration"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.endDate = try reader["endDate"].readTimestampIfPresent(format: .dateTime)
        value.startDate = try reader["startDate"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about the history of the alias.
    public struct AgentAliasHistoryEvent {
        /// The date that the alias stopped being associated to the version in the routingConfiguration object
        public var endDate: ClientRuntime.Date?
        /// Contains details about the version of the agent with which the alias is associated.
        public var routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]?
        /// The date that the alias began being associated to the version in the routingConfiguration object.
        public var startDate: ClientRuntime.Date?

        public init(
            endDate: ClientRuntime.Date? = nil,
            routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]? = nil,
            startDate: ClientRuntime.Date? = nil
        )
        {
            self.endDate = endDate
            self.routingConfiguration = routingConfiguration
            self.startDate = startDate
        }
    }

}

extension BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem {

    static func write(value: BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["agentVersion"].write(value.agentVersion)
        try writer["provisionedThroughput"].write(value.provisionedThroughput)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem()
        value.agentVersion = try reader["agentVersion"].readIfPresent()
        value.provisionedThroughput = try reader["provisionedThroughput"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about the routing configuration of the alias.
    public struct AgentAliasRoutingConfigurationListItem {
        /// The version of the agent with which the alias is associated.
        public var agentVersion: Swift.String?
        /// Information on the Provisioned Throughput assigned to an agent alias.
        public var provisionedThroughput: Swift.String?

        public init(
            agentVersion: Swift.String? = nil,
            provisionedThroughput: Swift.String? = nil
        )
        {
            self.agentVersion = agentVersion
            self.provisionedThroughput = provisionedThroughput
        }
    }

}

extension BedrockAgentClientTypes {

    public enum AgentAliasStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creating
        case deleting
        case failed
        case prepared
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [AgentAliasStatus] {
            return [
                .creating,
                .deleting,
                .failed,
                .prepared,
                .updating,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .prepared: return "PREPARED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes.AgentAliasSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.AgentAliasSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.AgentAliasSummary()
        value.agentAliasId = try reader["agentAliasId"].readIfPresent()
        value.agentAliasName = try reader["agentAliasName"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.routingConfiguration = try reader["routingConfiguration"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.agentAliasStatus = try reader["agentAliasStatus"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about an alias of an agent.
    public struct AgentAliasSummary {
        /// Contains details about
        /// This member is required.
        public var agentAliasId: Swift.String?
        /// The name of the alias.
        /// This member is required.
        public var agentAliasName: Swift.String?
        /// The status of the alias.
        /// This member is required.
        public var agentAliasStatus: BedrockAgentClientTypes.AgentAliasStatus?
        /// The time at which the alias of the agent was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The description of the alias.
        public var description: Swift.String?
        /// Contains details about the version of the agent with which the alias is associated.
        public var routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]?
        /// The time at which the alias was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            agentAliasId: Swift.String? = nil,
            agentAliasName: Swift.String? = nil,
            agentAliasStatus: BedrockAgentClientTypes.AgentAliasStatus? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.agentAliasId = agentAliasId
            self.agentAliasName = agentAliasName
            self.agentAliasStatus = agentAliasStatus
            self.createdAt = createdAt
            self.description = description
            self.routingConfiguration = routingConfiguration
            self.updatedAt = updatedAt
        }
    }

}

extension BedrockAgentClientTypes.AgentKnowledgeBase {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.AgentKnowledgeBase {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.AgentKnowledgeBase()
        value.agentId = try reader["agentId"].readIfPresent()
        value.agentVersion = try reader["agentVersion"].readIfPresent()
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        value.knowledgeBaseState = try reader["knowledgeBaseState"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about a knowledge base that is associated with an agent.
    public struct AgentKnowledgeBase {
        /// The unique identifier of the agent with which the knowledge base is associated.
        /// This member is required.
        public var agentId: Swift.String?
        /// The version of the agent with which the knowledge base is associated.
        /// This member is required.
        public var agentVersion: Swift.String?
        /// The time at which the association between the agent and the knowledge base was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The description of the association between the agent and the knowledge base.
        /// This member is required.
        public var description: Swift.String?
        /// The unique identifier of the association between the agent and the knowledge base.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// Specifies whether to use the knowledge base or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
        /// This member is required.
        public var knowledgeBaseState: BedrockAgentClientTypes.KnowledgeBaseState?
        /// The time at which the association between the agent and the knowledge base was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            agentId: Swift.String? = nil,
            agentVersion: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            knowledgeBaseState: BedrockAgentClientTypes.KnowledgeBaseState? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.createdAt = createdAt
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseState = knowledgeBaseState
            self.updatedAt = updatedAt
        }
    }

}

extension BedrockAgentClientTypes.AgentKnowledgeBaseSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.AgentKnowledgeBaseSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.AgentKnowledgeBaseSummary()
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.knowledgeBaseState = try reader["knowledgeBaseState"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about a knowledge base associated with an agent.
    public struct AgentKnowledgeBaseSummary {
        /// The description of the knowledge base associated with an agent.
        public var description: Swift.String?
        /// The unique identifier of the knowledge base associated with an agent.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// Specifies whether the agent uses the knowledge base or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
        /// This member is required.
        public var knowledgeBaseState: BedrockAgentClientTypes.KnowledgeBaseState?
        /// The time at which the knowledge base associated with an agent was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            description: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            knowledgeBaseState: BedrockAgentClientTypes.KnowledgeBaseState? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseState = knowledgeBaseState
            self.updatedAt = updatedAt
        }
    }

}

extension BedrockAgentClientTypes {

    public enum AgentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creating
        case deleting
        case failed
        case notPrepared
        case prepared
        case preparing
        case updating
        case versioning
        case sdkUnknown(Swift.String)

        public static var allCases: [AgentStatus] {
            return [
                .creating,
                .deleting,
                .failed,
                .notPrepared,
                .prepared,
                .preparing,
                .updating,
                .versioning,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .notPrepared: return "NOT_PREPARED"
            case .prepared: return "PREPARED"
            case .preparing: return "PREPARING"
            case .updating: return "UPDATING"
            case .versioning: return "VERSIONING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes.AgentSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.AgentSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.AgentSummary()
        value.agentId = try reader["agentId"].readIfPresent()
        value.agentName = try reader["agentName"].readIfPresent()
        value.agentStatus = try reader["agentStatus"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        value.latestAgentVersion = try reader["latestAgentVersion"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about an agent.
    public struct AgentSummary {
        /// The unique identifier of the agent.
        /// This member is required.
        public var agentId: Swift.String?
        /// The name of the agent.
        /// This member is required.
        public var agentName: Swift.String?
        /// The status of the agent.
        /// This member is required.
        public var agentStatus: BedrockAgentClientTypes.AgentStatus?
        /// The description of the agent.
        public var description: Swift.String?
        /// The latest version of the agent.
        public var latestAgentVersion: Swift.String?
        /// The time at which the agent was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            agentId: Swift.String? = nil,
            agentName: Swift.String? = nil,
            agentStatus: BedrockAgentClientTypes.AgentStatus? = nil,
            description: Swift.String? = nil,
            latestAgentVersion: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.agentId = agentId
            self.agentName = agentName
            self.agentStatus = agentStatus
            self.description = description
            self.latestAgentVersion = latestAgentVersion
            self.updatedAt = updatedAt
        }
    }

}

extension BedrockAgentClientTypes.AgentVersion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AgentVersion(agentArn: \(Swift.String(describing: agentArn)), agentId: \(Swift.String(describing: agentId)), agentName: \(Swift.String(describing: agentName)), agentResourceRoleArn: \(Swift.String(describing: agentResourceRoleArn)), agentStatus: \(Swift.String(describing: agentStatus)), createdAt: \(Swift.String(describing: createdAt)), customerEncryptionKeyArn: \(Swift.String(describing: customerEncryptionKeyArn)), description: \(Swift.String(describing: description)), failureReasons: \(Swift.String(describing: failureReasons)), foundationModel: \(Swift.String(describing: foundationModel)), idleSessionTTLInSeconds: \(Swift.String(describing: idleSessionTTLInSeconds)), recommendedActions: \(Swift.String(describing: recommendedActions)), updatedAt: \(Swift.String(describing: updatedAt)), version: \(Swift.String(describing: version)), instruction: \"CONTENT_REDACTED\", promptOverrideConfiguration: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentClientTypes.AgentVersion {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.AgentVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.AgentVersion()
        value.agentId = try reader["agentId"].readIfPresent()
        value.agentName = try reader["agentName"].readIfPresent()
        value.agentArn = try reader["agentArn"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        value.instruction = try reader["instruction"].readIfPresent()
        value.agentStatus = try reader["agentStatus"].readIfPresent()
        value.foundationModel = try reader["foundationModel"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.idleSessionTTLInSeconds = try reader["idleSessionTTLInSeconds"].readIfPresent()
        value.agentResourceRoleArn = try reader["agentResourceRoleArn"].readIfPresent()
        value.customerEncryptionKeyArn = try reader["customerEncryptionKeyArn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        value.failureReasons = try reader["failureReasons"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.recommendedActions = try reader["recommendedActions"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.promptOverrideConfiguration = try reader["promptOverrideConfiguration"].readIfPresent(with: BedrockAgentClientTypes.PromptOverrideConfiguration.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about a version of an agent.
    public struct AgentVersion {
        /// The Amazon Resource Name (ARN) of the agent that the version belongs to.
        /// This member is required.
        public var agentArn: Swift.String?
        /// The unique identifier of the agent that the version belongs to.
        /// This member is required.
        public var agentId: Swift.String?
        /// The name of the agent that the version belongs to.
        /// This member is required.
        public var agentName: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the agent.
        /// This member is required.
        public var agentResourceRoleArn: Swift.String?
        /// The status of the agent that the version belongs to.
        /// This member is required.
        public var agentStatus: BedrockAgentClientTypes.AgentStatus?
        /// The time at which the version was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the KMS key that encrypts the agent.
        public var customerEncryptionKeyArn: Swift.String?
        /// The description of the version.
        public var description: Swift.String?
        /// A list of reasons that the API operation on the version failed.
        public var failureReasons: [Swift.String]?
        /// The foundation model that the version invokes.
        public var foundationModel: Swift.String?
        /// The number of seconds for which Amazon Bedrock keeps information about a user's conversation with the agent. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Bedrock deletes any data provided before the timeout.
        /// This member is required.
        public var idleSessionTTLInSeconds: Swift.Int?
        /// The instructions provided to the agent.
        public var instruction: Swift.String?
        /// Contains configurations to override prompt templates in different parts of an agent sequence. For more information, see [Advanced prompts](https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts.html).
        public var promptOverrideConfiguration: BedrockAgentClientTypes.PromptOverrideConfiguration?
        /// A list of recommended actions to take for the failed API operation on the version to succeed.
        public var recommendedActions: [Swift.String]?
        /// The time at which the version was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?
        /// The version number.
        /// This member is required.
        public var version: Swift.String?

        public init(
            agentArn: Swift.String? = nil,
            agentId: Swift.String? = nil,
            agentName: Swift.String? = nil,
            agentResourceRoleArn: Swift.String? = nil,
            agentStatus: BedrockAgentClientTypes.AgentStatus? = nil,
            createdAt: ClientRuntime.Date? = nil,
            customerEncryptionKeyArn: Swift.String? = nil,
            description: Swift.String? = nil,
            failureReasons: [Swift.String]? = nil,
            foundationModel: Swift.String? = nil,
            idleSessionTTLInSeconds: Swift.Int? = nil,
            instruction: Swift.String? = nil,
            promptOverrideConfiguration: BedrockAgentClientTypes.PromptOverrideConfiguration? = nil,
            recommendedActions: [Swift.String]? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            version: Swift.String? = nil
        )
        {
            self.agentArn = agentArn
            self.agentId = agentId
            self.agentName = agentName
            self.agentResourceRoleArn = agentResourceRoleArn
            self.agentStatus = agentStatus
            self.createdAt = createdAt
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.description = description
            self.failureReasons = failureReasons
            self.foundationModel = foundationModel
            self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
            self.instruction = instruction
            self.promptOverrideConfiguration = promptOverrideConfiguration
            self.recommendedActions = recommendedActions
            self.updatedAt = updatedAt
            self.version = version
        }
    }

}

extension BedrockAgentClientTypes.AgentVersionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.AgentVersionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.AgentVersionSummary()
        value.agentName = try reader["agentName"].readIfPresent()
        value.agentStatus = try reader["agentStatus"].readIfPresent()
        value.agentVersion = try reader["agentVersion"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about a version of an agent.
    public struct AgentVersionSummary {
        /// The name of the agent to which the version belongs.
        /// This member is required.
        public var agentName: Swift.String?
        /// The status of the agent to which the version belongs.
        /// This member is required.
        public var agentStatus: BedrockAgentClientTypes.AgentStatus?
        /// The version of the agent.
        /// This member is required.
        public var agentVersion: Swift.String?
        /// The time at which the version was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The description of the version of the agent.
        public var description: Swift.String?
        /// The time at which the version was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            agentName: Swift.String? = nil,
            agentStatus: BedrockAgentClientTypes.AgentStatus? = nil,
            agentVersion: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.agentName = agentName
            self.agentStatus = agentStatus
            self.agentVersion = agentVersion
            self.createdAt = createdAt
            self.description = description
            self.updatedAt = updatedAt
        }
    }

}

extension AssociateAgentKnowledgeBaseInput {

    static func urlPathProvider(_ value: AssociateAgentKnowledgeBaseInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/knowledgebases"
    }
}

extension AssociateAgentKnowledgeBaseInput {

    static func write(value: AssociateAgentKnowledgeBaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["knowledgeBaseId"].write(value.knowledgeBaseId)
        try writer["knowledgeBaseState"].write(value.knowledgeBaseState)
    }
}

public struct AssociateAgentKnowledgeBaseInput {
    /// The unique identifier of the agent with which you want to associate the knowledge base.
    /// This member is required.
    public var agentId: Swift.String?
    /// The version of the agent with which you want to associate the knowledge base.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// A description of what the agent should use the knowledge base for.
    /// This member is required.
    public var description: Swift.String?
    /// The unique identifier of the knowledge base to associate with the agent.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// Specifies whether to use the knowledge base or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
    public var knowledgeBaseState: BedrockAgentClientTypes.KnowledgeBaseState?

    public init(
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        description: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil,
        knowledgeBaseState: BedrockAgentClientTypes.KnowledgeBaseState? = nil
    )
    {
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.description = description
        self.knowledgeBaseId = knowledgeBaseId
        self.knowledgeBaseState = knowledgeBaseState
    }
}

extension AssociateAgentKnowledgeBaseOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> AssociateAgentKnowledgeBaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateAgentKnowledgeBaseOutput()
        value.agentKnowledgeBase = try reader["agentKnowledgeBase"].readIfPresent(with: BedrockAgentClientTypes.AgentKnowledgeBase.read(from:))
        return value
    }
}

public struct AssociateAgentKnowledgeBaseOutput {
    /// Contains details about the knowledge base that has been associated with the agent.
    /// This member is required.
    public var agentKnowledgeBase: BedrockAgentClientTypes.AgentKnowledgeBase?

    public init(
        agentKnowledgeBase: BedrockAgentClientTypes.AgentKnowledgeBase? = nil
    )
    {
        self.agentKnowledgeBase = agentKnowledgeBase
    }
}

enum AssociateAgentKnowledgeBaseOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

public enum BedrockAgentClientTypes {}

extension BedrockAgentClientTypes.ChunkingConfiguration {

    static func write(value: BedrockAgentClientTypes.ChunkingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["chunkingStrategy"].write(value.chunkingStrategy)
        try writer["fixedSizeChunkingConfiguration"].write(value.fixedSizeChunkingConfiguration, with: BedrockAgentClientTypes.FixedSizeChunkingConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.ChunkingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.ChunkingConfiguration()
        value.chunkingStrategy = try reader["chunkingStrategy"].readIfPresent()
        value.fixedSizeChunkingConfiguration = try reader["fixedSizeChunkingConfiguration"].readIfPresent(with: BedrockAgentClientTypes.FixedSizeChunkingConfiguration.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.
    public struct ChunkingConfiguration {
        /// Knowledge base can split your source data into chunks. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. You have the following options for chunking your data. If you opt for NONE, then you may want to pre-process your files by splitting them up such that each file corresponds to a chunk.
        ///
        /// * FIXED_SIZE – Amazon Bedrock splits your source data into chunks of the approximate size that you set in the fixedSizeChunkingConfiguration.
        ///
        /// * NONE – Amazon Bedrock treats each file as one chunk. If you choose this option, you may want to pre-process your documents by splitting them into separate files.
        /// This member is required.
        public var chunkingStrategy: BedrockAgentClientTypes.ChunkingStrategy?
        /// Configurations for when you choose fixed-size chunking. If you set the chunkingStrategy as NONE, exclude this field.
        public var fixedSizeChunkingConfiguration: BedrockAgentClientTypes.FixedSizeChunkingConfiguration?

        public init(
            chunkingStrategy: BedrockAgentClientTypes.ChunkingStrategy? = nil,
            fixedSizeChunkingConfiguration: BedrockAgentClientTypes.FixedSizeChunkingConfiguration? = nil
        )
        {
            self.chunkingStrategy = chunkingStrategy
            self.fixedSizeChunkingConfiguration = fixedSizeChunkingConfiguration
        }
    }

}

extension BedrockAgentClientTypes {

    public enum ChunkingStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fixedSize
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [ChunkingStrategy] {
            return [
                .fixedSize,
                .none,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fixedSize: return "FIXED_SIZE"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// There was a conflict performing an operation.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CreateAgentActionGroupInput {

    static func urlPathProvider(_ value: CreateAgentActionGroupInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/actiongroups"
    }
}

extension CreateAgentActionGroupInput {

    static func write(value: CreateAgentActionGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionGroupExecutor"].write(value.actionGroupExecutor, with: BedrockAgentClientTypes.ActionGroupExecutor.write(value:to:))
        try writer["actionGroupName"].write(value.actionGroupName)
        try writer["actionGroupState"].write(value.actionGroupState)
        try writer["apiSchema"].write(value.apiSchema, with: BedrockAgentClientTypes.APISchema.write(value:to:))
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["functionSchema"].write(value.functionSchema, with: BedrockAgentClientTypes.FunctionSchema.write(value:to:))
        try writer["parentActionGroupSignature"].write(value.parentActionGroupSignature)
    }
}

public struct CreateAgentActionGroupInput {
    /// The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action or the custom control method for handling the information elicited from the user.
    public var actionGroupExecutor: BedrockAgentClientTypes.ActionGroupExecutor?
    /// The name to give the action group.
    /// This member is required.
    public var actionGroupName: Swift.String?
    /// Specifies whether the action group is available for the agent to invoke or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
    public var actionGroupState: BedrockAgentClientTypes.ActionGroupState?
    /// The unique identifier of the agent for which to create the action group.
    /// This member is required.
    public var agentId: Swift.String?
    /// The version of the agent for which to create the action group.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted payload defining the schema. For more information, see [Action group OpenAPI schemas](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-api-schema.html).
    public var apiSchema: BedrockAgentClientTypes.APISchema?
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// A description of the action group.
    public var description: Swift.String?
    /// Contains details about the function schema for the action group or the JSON or YAML-formatted payload defining the schema.
    public var functionSchema: BedrockAgentClientTypes.FunctionSchema?
    /// To allow your agent to request the user for additional information when trying to complete a task, set this field to AMAZON.UserInput. You must leave the description, apiSchema, and actionGroupExecutor fields blank for this action group. During orchestration, if your agent determines that it needs to invoke an API in an action group, but doesn't have enough information to complete the API request, it will invoke this action group instead and return an [Observation](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Observation.html) reprompting the user for more information.
    public var parentActionGroupSignature: BedrockAgentClientTypes.ActionGroupSignature?

    public init(
        actionGroupExecutor: BedrockAgentClientTypes.ActionGroupExecutor? = nil,
        actionGroupName: Swift.String? = nil,
        actionGroupState: BedrockAgentClientTypes.ActionGroupState? = nil,
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        apiSchema: BedrockAgentClientTypes.APISchema? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        functionSchema: BedrockAgentClientTypes.FunctionSchema? = nil,
        parentActionGroupSignature: BedrockAgentClientTypes.ActionGroupSignature? = nil
    )
    {
        self.actionGroupExecutor = actionGroupExecutor
        self.actionGroupName = actionGroupName
        self.actionGroupState = actionGroupState
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.apiSchema = apiSchema
        self.clientToken = clientToken
        self.description = description
        self.functionSchema = functionSchema
        self.parentActionGroupSignature = parentActionGroupSignature
    }
}

extension CreateAgentActionGroupOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateAgentActionGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAgentActionGroupOutput()
        value.agentActionGroup = try reader["agentActionGroup"].readIfPresent(with: BedrockAgentClientTypes.AgentActionGroup.read(from:))
        return value
    }
}

public struct CreateAgentActionGroupOutput {
    /// Contains details about the action group that was created.
    /// This member is required.
    public var agentActionGroup: BedrockAgentClientTypes.AgentActionGroup?

    public init(
        agentActionGroup: BedrockAgentClientTypes.AgentActionGroup? = nil
    )
    {
        self.agentActionGroup = agentActionGroup
    }
}

enum CreateAgentActionGroupOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateAgentAliasInput {

    static func urlPathProvider(_ value: CreateAgentAliasInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentaliases"
    }
}

extension CreateAgentAliasInput {

    static func write(value: CreateAgentAliasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["agentAliasName"].write(value.agentAliasName)
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["routingConfiguration"].writeList(value.routingConfiguration, memberWritingClosure: BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateAgentAliasInput {
    /// The name of the alias.
    /// This member is required.
    public var agentAliasName: Swift.String?
    /// The unique identifier of the agent.
    /// This member is required.
    public var agentId: Swift.String?
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// A description of the alias of the agent.
    public var description: Swift.String?
    /// Contains details about the routing configuration of the alias.
    public var routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]?
    /// Any tags that you want to attach to the alias of the agent.
    public var tags: [Swift.String:Swift.String]?

    public init(
        agentAliasName: Swift.String? = nil,
        agentId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.agentAliasName = agentAliasName
        self.agentId = agentId
        self.clientToken = clientToken
        self.description = description
        self.routingConfiguration = routingConfiguration
        self.tags = tags
    }
}

extension CreateAgentAliasOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateAgentAliasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAgentAliasOutput()
        value.agentAlias = try reader["agentAlias"].readIfPresent(with: BedrockAgentClientTypes.AgentAlias.read(from:))
        return value
    }
}

public struct CreateAgentAliasOutput {
    /// Contains details about the alias that was created.
    /// This member is required.
    public var agentAlias: BedrockAgentClientTypes.AgentAlias?

    public init(
        agentAlias: BedrockAgentClientTypes.AgentAlias? = nil
    )
    {
        self.agentAlias = agentAlias
    }
}

enum CreateAgentAliasOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateAgentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAgentInput(agentName: \(Swift.String(describing: agentName)), agentResourceRoleArn: \(Swift.String(describing: agentResourceRoleArn)), clientToken: \(Swift.String(describing: clientToken)), customerEncryptionKeyArn: \(Swift.String(describing: customerEncryptionKeyArn)), description: \(Swift.String(describing: description)), foundationModel: \(Swift.String(describing: foundationModel)), idleSessionTTLInSeconds: \(Swift.String(describing: idleSessionTTLInSeconds)), tags: \(Swift.String(describing: tags)), instruction: \"CONTENT_REDACTED\", promptOverrideConfiguration: \"CONTENT_REDACTED\")"}
}

extension CreateAgentInput {

    static func urlPathProvider(_ value: CreateAgentInput) -> Swift.String? {
        return "/agents"
    }
}

extension CreateAgentInput {

    static func write(value: CreateAgentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["agentName"].write(value.agentName)
        try writer["agentResourceRoleArn"].write(value.agentResourceRoleArn)
        try writer["clientToken"].write(value.clientToken)
        try writer["customerEncryptionKeyArn"].write(value.customerEncryptionKeyArn)
        try writer["description"].write(value.description)
        try writer["foundationModel"].write(value.foundationModel)
        try writer["idleSessionTTLInSeconds"].write(value.idleSessionTTLInSeconds)
        try writer["instruction"].write(value.instruction)
        try writer["promptOverrideConfiguration"].write(value.promptOverrideConfiguration, with: BedrockAgentClientTypes.PromptOverrideConfiguration.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateAgentInput {
    /// A name for the agent that you create.
    /// This member is required.
    public var agentName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the agent.
    public var agentResourceRoleArn: Swift.String?
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the KMS key with which to encrypt the agent.
    public var customerEncryptionKeyArn: Swift.String?
    /// A description of the agent.
    public var description: Swift.String?
    /// The foundation model to be used for orchestration by the agent you create.
    public var foundationModel: Swift.String?
    /// The number of seconds for which Amazon Bedrock keeps information about a user's conversation with the agent. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Bedrock deletes any data provided before the timeout.
    public var idleSessionTTLInSeconds: Swift.Int?
    /// Instructions that tell the agent what it should do and how it should interact with users.
    public var instruction: Swift.String?
    /// Contains configurations to override prompts in different parts of an agent sequence. For more information, see [Advanced prompts](https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts.html).
    public var promptOverrideConfiguration: BedrockAgentClientTypes.PromptOverrideConfiguration?
    /// Any tags that you want to attach to the agent.
    public var tags: [Swift.String:Swift.String]?

    public init(
        agentName: Swift.String? = nil,
        agentResourceRoleArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        customerEncryptionKeyArn: Swift.String? = nil,
        description: Swift.String? = nil,
        foundationModel: Swift.String? = nil,
        idleSessionTTLInSeconds: Swift.Int? = nil,
        instruction: Swift.String? = nil,
        promptOverrideConfiguration: BedrockAgentClientTypes.PromptOverrideConfiguration? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.agentName = agentName
        self.agentResourceRoleArn = agentResourceRoleArn
        self.clientToken = clientToken
        self.customerEncryptionKeyArn = customerEncryptionKeyArn
        self.description = description
        self.foundationModel = foundationModel
        self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
        self.instruction = instruction
        self.promptOverrideConfiguration = promptOverrideConfiguration
        self.tags = tags
    }
}

extension CreateAgentOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateAgentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAgentOutput()
        value.agent = try reader["agent"].readIfPresent(with: BedrockAgentClientTypes.Agent.read(from:))
        return value
    }
}

public struct CreateAgentOutput {
    /// Contains details about the agent created.
    /// This member is required.
    public var agent: BedrockAgentClientTypes.Agent?

    public init(
        agent: BedrockAgentClientTypes.Agent? = nil
    )
    {
        self.agent = agent
    }
}

enum CreateAgentOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateDataSourceInput {

    static func urlPathProvider(_ value: CreateDataSourceInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/datasources"
    }
}

extension CreateDataSourceInput {

    static func write(value: CreateDataSourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["dataDeletionPolicy"].write(value.dataDeletionPolicy)
        try writer["dataSourceConfiguration"].write(value.dataSourceConfiguration, with: BedrockAgentClientTypes.DataSourceConfiguration.write(value:to:))
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["serverSideEncryptionConfiguration"].write(value.serverSideEncryptionConfiguration, with: BedrockAgentClientTypes.ServerSideEncryptionConfiguration.write(value:to:))
        try writer["vectorIngestionConfiguration"].write(value.vectorIngestionConfiguration, with: BedrockAgentClientTypes.VectorIngestionConfiguration.write(value:to:))
    }
}

public struct CreateDataSourceInput {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The data deletion policy assigned to the data source.
    public var dataDeletionPolicy: BedrockAgentClientTypes.DataDeletionPolicy?
    /// Contains metadata about where the data source is stored.
    /// This member is required.
    public var dataSourceConfiguration: BedrockAgentClientTypes.DataSourceConfiguration?
    /// A description of the data source.
    public var description: Swift.String?
    /// The unique identifier of the knowledge base to which to add the data source.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The name of the data source.
    /// This member is required.
    public var name: Swift.String?
    /// Contains details about the server-side encryption for the data source.
    public var serverSideEncryptionConfiguration: BedrockAgentClientTypes.ServerSideEncryptionConfiguration?
    /// Contains details about how to ingest the documents in the data source.
    public var vectorIngestionConfiguration: BedrockAgentClientTypes.VectorIngestionConfiguration?

    public init(
        clientToken: Swift.String? = nil,
        dataDeletionPolicy: BedrockAgentClientTypes.DataDeletionPolicy? = nil,
        dataSourceConfiguration: BedrockAgentClientTypes.DataSourceConfiguration? = nil,
        description: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil,
        name: Swift.String? = nil,
        serverSideEncryptionConfiguration: BedrockAgentClientTypes.ServerSideEncryptionConfiguration? = nil,
        vectorIngestionConfiguration: BedrockAgentClientTypes.VectorIngestionConfiguration? = nil
    )
    {
        self.clientToken = clientToken
        self.dataDeletionPolicy = dataDeletionPolicy
        self.dataSourceConfiguration = dataSourceConfiguration
        self.description = description
        self.knowledgeBaseId = knowledgeBaseId
        self.name = name
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
        self.vectorIngestionConfiguration = vectorIngestionConfiguration
    }
}

extension CreateDataSourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateDataSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDataSourceOutput()
        value.dataSource = try reader["dataSource"].readIfPresent(with: BedrockAgentClientTypes.DataSource.read(from:))
        return value
    }
}

public struct CreateDataSourceOutput {
    /// Contains details about the data source.
    /// This member is required.
    public var dataSource: BedrockAgentClientTypes.DataSource?

    public init(
        dataSource: BedrockAgentClientTypes.DataSource? = nil
    )
    {
        self.dataSource = dataSource
    }
}

enum CreateDataSourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateKnowledgeBaseInput {

    static func urlPathProvider(_ value: CreateKnowledgeBaseInput) -> Swift.String? {
        return "/knowledgebases"
    }
}

extension CreateKnowledgeBaseInput {

    static func write(value: CreateKnowledgeBaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["knowledgeBaseConfiguration"].write(value.knowledgeBaseConfiguration, with: BedrockAgentClientTypes.KnowledgeBaseConfiguration.write(value:to:))
        try writer["name"].write(value.name)
        try writer["roleArn"].write(value.roleArn)
        try writer["storageConfiguration"].write(value.storageConfiguration, with: BedrockAgentClientTypes.StorageConfiguration.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateKnowledgeBaseInput {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// A description of the knowledge base.
    public var description: Swift.String?
    /// Contains details about the embeddings model used for the knowledge base.
    /// This member is required.
    public var knowledgeBaseConfiguration: BedrockAgentClientTypes.KnowledgeBaseConfiguration?
    /// A name for the knowledge base.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the knowledge base.
    /// This member is required.
    public var roleArn: Swift.String?
    /// Contains details about the configuration of the vector database used for the knowledge base.
    /// This member is required.
    public var storageConfiguration: BedrockAgentClientTypes.StorageConfiguration?
    /// Specify the key-value pairs for the tags that you want to attach to your knowledge base in this object.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        knowledgeBaseConfiguration: BedrockAgentClientTypes.KnowledgeBaseConfiguration? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        storageConfiguration: BedrockAgentClientTypes.StorageConfiguration? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.knowledgeBaseConfiguration = knowledgeBaseConfiguration
        self.name = name
        self.roleArn = roleArn
        self.storageConfiguration = storageConfiguration
        self.tags = tags
    }
}

extension CreateKnowledgeBaseOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateKnowledgeBaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateKnowledgeBaseOutput()
        value.knowledgeBase = try reader["knowledgeBase"].readIfPresent(with: BedrockAgentClientTypes.KnowledgeBase.read(from:))
        return value
    }
}

public struct CreateKnowledgeBaseOutput {
    /// Contains details about the knowledge base.
    /// This member is required.
    public var knowledgeBase: BedrockAgentClientTypes.KnowledgeBase?

    public init(
        knowledgeBase: BedrockAgentClientTypes.KnowledgeBase? = nil
    )
    {
        self.knowledgeBase = knowledgeBase
    }
}

enum CreateKnowledgeBaseOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension BedrockAgentClientTypes {

    public enum CreationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `default`
        case overridden
        case sdkUnknown(Swift.String)

        public static var allCases: [CreationMode] {
            return [
                .default,
                .overridden,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .overridden: return "OVERRIDDEN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    public enum CustomControlMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case returnControl
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomControlMethod] {
            return [
                .returnControl,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .returnControl: return "RETURN_CONTROL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    public enum DataDeletionPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case delete
        case retain
        case sdkUnknown(Swift.String)

        public static var allCases: [DataDeletionPolicy] {
            return [
                .delete,
                .retain,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case .retain: return "RETAIN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes.DataSource {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.DataSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.DataSource()
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent()
        value.dataSourceId = try reader["dataSourceId"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.dataSourceConfiguration = try reader["dataSourceConfiguration"].readIfPresent(with: BedrockAgentClientTypes.DataSourceConfiguration.read(from:))
        value.serverSideEncryptionConfiguration = try reader["serverSideEncryptionConfiguration"].readIfPresent(with: BedrockAgentClientTypes.ServerSideEncryptionConfiguration.read(from:))
        value.vectorIngestionConfiguration = try reader["vectorIngestionConfiguration"].readIfPresent(with: BedrockAgentClientTypes.VectorIngestionConfiguration.read(from:))
        value.dataDeletionPolicy = try reader["dataDeletionPolicy"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        value.failureReasons = try reader["failureReasons"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about a data source.
    public struct DataSource {
        /// The time at which the data source was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The data deletion policy for a data source.
        public var dataDeletionPolicy: BedrockAgentClientTypes.DataDeletionPolicy?
        /// Contains details about how the data source is stored.
        /// This member is required.
        public var dataSourceConfiguration: BedrockAgentClientTypes.DataSourceConfiguration?
        /// The unique identifier of the data source.
        /// This member is required.
        public var dataSourceId: Swift.String?
        /// The description of the data source.
        public var description: Swift.String?
        /// The detailed reasons on the failure to delete a data source.
        public var failureReasons: [Swift.String]?
        /// The unique identifier of the knowledge base to which the data source belongs.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The name of the data source.
        /// This member is required.
        public var name: Swift.String?
        /// Contains details about the configuration of the server-side encryption.
        public var serverSideEncryptionConfiguration: BedrockAgentClientTypes.ServerSideEncryptionConfiguration?
        /// The status of the data source. The following statuses are possible:
        ///
        /// * Available – The data source has been created and is ready for ingestion into the knowledge base.
        ///
        /// * Deleting – The data source is being deleted.
        /// This member is required.
        public var status: BedrockAgentClientTypes.DataSourceStatus?
        /// The time at which the data source was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?
        /// Contains details about how to ingest the documents in the data source.
        public var vectorIngestionConfiguration: BedrockAgentClientTypes.VectorIngestionConfiguration?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            dataDeletionPolicy: BedrockAgentClientTypes.DataDeletionPolicy? = nil,
            dataSourceConfiguration: BedrockAgentClientTypes.DataSourceConfiguration? = nil,
            dataSourceId: Swift.String? = nil,
            description: Swift.String? = nil,
            failureReasons: [Swift.String]? = nil,
            knowledgeBaseId: Swift.String? = nil,
            name: Swift.String? = nil,
            serverSideEncryptionConfiguration: BedrockAgentClientTypes.ServerSideEncryptionConfiguration? = nil,
            status: BedrockAgentClientTypes.DataSourceStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            vectorIngestionConfiguration: BedrockAgentClientTypes.VectorIngestionConfiguration? = nil
        )
        {
            self.createdAt = createdAt
            self.dataDeletionPolicy = dataDeletionPolicy
            self.dataSourceConfiguration = dataSourceConfiguration
            self.dataSourceId = dataSourceId
            self.description = description
            self.failureReasons = failureReasons
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.status = status
            self.updatedAt = updatedAt
            self.vectorIngestionConfiguration = vectorIngestionConfiguration
        }
    }

}

extension BedrockAgentClientTypes.DataSourceConfiguration {

    static func write(value: BedrockAgentClientTypes.DataSourceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Configuration"].write(value.s3Configuration, with: BedrockAgentClientTypes.S3DataSourceConfiguration.write(value:to:))
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.DataSourceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.DataSourceConfiguration()
        value.type = try reader["type"].readIfPresent()
        value.s3Configuration = try reader["s3Configuration"].readIfPresent(with: BedrockAgentClientTypes.S3DataSourceConfiguration.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about how a data source is stored.
    public struct DataSourceConfiguration {
        /// Contains details about the configuration of the S3 object containing the data source.
        public var s3Configuration: BedrockAgentClientTypes.S3DataSourceConfiguration?
        /// The type of storage for the data source.
        /// This member is required.
        public var type: BedrockAgentClientTypes.DataSourceType?

        public init(
            s3Configuration: BedrockAgentClientTypes.S3DataSourceConfiguration? = nil,
            type: BedrockAgentClientTypes.DataSourceType? = nil
        )
        {
            self.s3Configuration = s3Configuration
            self.type = type
        }
    }

}

extension BedrockAgentClientTypes {

    public enum DataSourceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case deleteUnsuccessful
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceStatus] {
            return [
                .available,
                .deleteUnsuccessful,
                .deleting,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleteUnsuccessful: return "DELETE_UNSUCCESSFUL"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes.DataSourceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.DataSourceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.DataSourceSummary()
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent()
        value.dataSourceId = try reader["dataSourceId"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about a data source.
    public struct DataSourceSummary {
        /// The unique identifier of the data source.
        /// This member is required.
        public var dataSourceId: Swift.String?
        /// The description of the data source.
        public var description: Swift.String?
        /// The unique identifier of the knowledge base to which the data source belongs.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The name of the data source.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the data source.
        /// This member is required.
        public var status: BedrockAgentClientTypes.DataSourceStatus?
        /// The time at which the data source was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            dataSourceId: Swift.String? = nil,
            description: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            name: Swift.String? = nil,
            status: BedrockAgentClientTypes.DataSourceStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.dataSourceId = dataSourceId
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension BedrockAgentClientTypes {

    public enum DataSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceType] {
            return [
                .s3,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeleteAgentActionGroupInput {

    static func queryItemProvider(_ value: DeleteAgentActionGroupInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let skipResourceInUseCheck = value.skipResourceInUseCheck {
            let skipResourceInUseCheckQueryItem = ClientRuntime.SDKURLQueryItem(name: "skipResourceInUseCheck".urlPercentEncoding(), value: Swift.String(skipResourceInUseCheck).urlPercentEncoding())
            items.append(skipResourceInUseCheckQueryItem)
        }
        return items
    }
}

extension DeleteAgentActionGroupInput {

    static func urlPathProvider(_ value: DeleteAgentActionGroupInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        guard let actionGroupId = value.actionGroupId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/actiongroups/\(actionGroupId.urlPercentEncoding())"
    }
}

public struct DeleteAgentActionGroupInput {
    /// The unique identifier of the action group to delete.
    /// This member is required.
    public var actionGroupId: Swift.String?
    /// The unique identifier of the agent that the action group belongs to.
    /// This member is required.
    public var agentId: Swift.String?
    /// The version of the agent that the action group belongs to.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// By default, this value is false and deletion is stopped if the resource is in use. If you set it to true, the resource will be deleted even if the resource is in use.
    public var skipResourceInUseCheck: Swift.Bool?

    public init(
        actionGroupId: Swift.String? = nil,
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        skipResourceInUseCheck: Swift.Bool? = nil
    )
    {
        self.actionGroupId = actionGroupId
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.skipResourceInUseCheck = skipResourceInUseCheck
    }
}

extension DeleteAgentActionGroupOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteAgentActionGroupOutput {
        return DeleteAgentActionGroupOutput()
    }
}

public struct DeleteAgentActionGroupOutput {

    public init() { }
}

enum DeleteAgentActionGroupOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteAgentAliasInput {

    static func urlPathProvider(_ value: DeleteAgentAliasInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentAliasId = value.agentAliasId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentaliases/\(agentAliasId.urlPercentEncoding())"
    }
}

public struct DeleteAgentAliasInput {
    /// The unique identifier of the alias to delete.
    /// This member is required.
    public var agentAliasId: Swift.String?
    /// The unique identifier of the agent that the alias belongs to.
    /// This member is required.
    public var agentId: Swift.String?

    public init(
        agentAliasId: Swift.String? = nil,
        agentId: Swift.String? = nil
    )
    {
        self.agentAliasId = agentAliasId
        self.agentId = agentId
    }
}

extension DeleteAgentAliasOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteAgentAliasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteAgentAliasOutput()
        value.agentAliasId = try reader["agentAliasId"].readIfPresent()
        value.agentAliasStatus = try reader["agentAliasStatus"].readIfPresent()
        value.agentId = try reader["agentId"].readIfPresent()
        return value
    }
}

public struct DeleteAgentAliasOutput {
    /// The unique identifier of the alias that was deleted.
    /// This member is required.
    public var agentAliasId: Swift.String?
    /// The status of the alias.
    /// This member is required.
    public var agentAliasStatus: BedrockAgentClientTypes.AgentAliasStatus?
    /// The unique identifier of the agent that the alias belongs to.
    /// This member is required.
    public var agentId: Swift.String?

    public init(
        agentAliasId: Swift.String? = nil,
        agentAliasStatus: BedrockAgentClientTypes.AgentAliasStatus? = nil,
        agentId: Swift.String? = nil
    )
    {
        self.agentAliasId = agentAliasId
        self.agentAliasStatus = agentAliasStatus
        self.agentId = agentId
    }
}

enum DeleteAgentAliasOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteAgentInput {

    static func queryItemProvider(_ value: DeleteAgentInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let skipResourceInUseCheck = value.skipResourceInUseCheck {
            let skipResourceInUseCheckQueryItem = ClientRuntime.SDKURLQueryItem(name: "skipResourceInUseCheck".urlPercentEncoding(), value: Swift.String(skipResourceInUseCheck).urlPercentEncoding())
            items.append(skipResourceInUseCheckQueryItem)
        }
        return items
    }
}

extension DeleteAgentInput {

    static func urlPathProvider(_ value: DeleteAgentInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())"
    }
}

public struct DeleteAgentInput {
    /// The unique identifier of the agent to delete.
    /// This member is required.
    public var agentId: Swift.String?
    /// By default, this value is false and deletion is stopped if the resource is in use. If you set it to true, the resource will be deleted even if the resource is in use.
    public var skipResourceInUseCheck: Swift.Bool?

    public init(
        agentId: Swift.String? = nil,
        skipResourceInUseCheck: Swift.Bool? = nil
    )
    {
        self.agentId = agentId
        self.skipResourceInUseCheck = skipResourceInUseCheck
    }
}

extension DeleteAgentOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteAgentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteAgentOutput()
        value.agentId = try reader["agentId"].readIfPresent()
        value.agentStatus = try reader["agentStatus"].readIfPresent()
        return value
    }
}

public struct DeleteAgentOutput {
    /// The unique identifier of the agent that was deleted.
    /// This member is required.
    public var agentId: Swift.String?
    /// The status of the agent.
    /// This member is required.
    public var agentStatus: BedrockAgentClientTypes.AgentStatus?

    public init(
        agentId: Swift.String? = nil,
        agentStatus: BedrockAgentClientTypes.AgentStatus? = nil
    )
    {
        self.agentId = agentId
        self.agentStatus = agentStatus
    }
}

enum DeleteAgentOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteAgentVersionInput {

    static func queryItemProvider(_ value: DeleteAgentVersionInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let skipResourceInUseCheck = value.skipResourceInUseCheck {
            let skipResourceInUseCheckQueryItem = ClientRuntime.SDKURLQueryItem(name: "skipResourceInUseCheck".urlPercentEncoding(), value: Swift.String(skipResourceInUseCheck).urlPercentEncoding())
            items.append(skipResourceInUseCheckQueryItem)
        }
        return items
    }
}

extension DeleteAgentVersionInput {

    static func urlPathProvider(_ value: DeleteAgentVersionInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())"
    }
}

public struct DeleteAgentVersionInput {
    /// The unique identifier of the agent that the version belongs to.
    /// This member is required.
    public var agentId: Swift.String?
    /// The version of the agent to delete.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// By default, this value is false and deletion is stopped if the resource is in use. If you set it to true, the resource will be deleted even if the resource is in use.
    public var skipResourceInUseCheck: Swift.Bool?

    public init(
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        skipResourceInUseCheck: Swift.Bool? = nil
    )
    {
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.skipResourceInUseCheck = skipResourceInUseCheck
    }
}

extension DeleteAgentVersionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteAgentVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteAgentVersionOutput()
        value.agentId = try reader["agentId"].readIfPresent()
        value.agentStatus = try reader["agentStatus"].readIfPresent()
        value.agentVersion = try reader["agentVersion"].readIfPresent()
        return value
    }
}

public struct DeleteAgentVersionOutput {
    /// The unique identifier of the agent that the version belongs to.
    /// This member is required.
    public var agentId: Swift.String?
    /// The status of the agent version.
    /// This member is required.
    public var agentStatus: BedrockAgentClientTypes.AgentStatus?
    /// The version that was deleted.
    /// This member is required.
    public var agentVersion: Swift.String?

    public init(
        agentId: Swift.String? = nil,
        agentStatus: BedrockAgentClientTypes.AgentStatus? = nil,
        agentVersion: Swift.String? = nil
    )
    {
        self.agentId = agentId
        self.agentStatus = agentStatus
        self.agentVersion = agentVersion
    }
}

enum DeleteAgentVersionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteDataSourceInput {

    static func urlPathProvider(_ value: DeleteDataSourceInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let dataSourceId = value.dataSourceId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())"
    }
}

public struct DeleteDataSourceInput {
    /// The unique identifier of the data source to delete.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The unique identifier of the knowledge base from which to delete the data source.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        dataSourceId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.dataSourceId = dataSourceId
        self.knowledgeBaseId = knowledgeBaseId
    }
}

extension DeleteDataSourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteDataSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDataSourceOutput()
        value.dataSourceId = try reader["dataSourceId"].readIfPresent()
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

public struct DeleteDataSourceOutput {
    /// The unique identifier of the data source that was deleted.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The unique identifier of the knowledge base to which the data source that was deleted belonged.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The status of the data source.
    /// This member is required.
    public var status: BedrockAgentClientTypes.DataSourceStatus?

    public init(
        dataSourceId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil,
        status: BedrockAgentClientTypes.DataSourceStatus? = nil
    )
    {
        self.dataSourceId = dataSourceId
        self.knowledgeBaseId = knowledgeBaseId
        self.status = status
    }
}

enum DeleteDataSourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteKnowledgeBaseInput {

    static func urlPathProvider(_ value: DeleteKnowledgeBaseInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())"
    }
}

public struct DeleteKnowledgeBaseInput {
    /// The unique identifier of the knowledge base to delete.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
    }
}

extension DeleteKnowledgeBaseOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteKnowledgeBaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteKnowledgeBaseOutput()
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

public struct DeleteKnowledgeBaseOutput {
    /// The unique identifier of the knowledge base that was deleted.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The status of the knowledge base and whether it has been successfully deleted.
    /// This member is required.
    public var status: BedrockAgentClientTypes.KnowledgeBaseStatus?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        status: BedrockAgentClientTypes.KnowledgeBaseStatus? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
        self.status = status
    }
}

enum DeleteKnowledgeBaseOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DisassociateAgentKnowledgeBaseInput {

    static func urlPathProvider(_ value: DisassociateAgentKnowledgeBaseInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())"
    }
}

public struct DisassociateAgentKnowledgeBaseInput {
    /// The unique identifier of the agent from which to disassociate the knowledge base.
    /// This member is required.
    public var agentId: Swift.String?
    /// The version of the agent from which to disassociate the knowledge base.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// The unique identifier of the knowledge base to disassociate.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.knowledgeBaseId = knowledgeBaseId
    }
}

extension DisassociateAgentKnowledgeBaseOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DisassociateAgentKnowledgeBaseOutput {
        return DisassociateAgentKnowledgeBaseOutput()
    }
}

public struct DisassociateAgentKnowledgeBaseOutput {

    public init() { }
}

enum DisassociateAgentKnowledgeBaseOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension BedrockAgentClientTypes.FixedSizeChunkingConfiguration {

    static func write(value: BedrockAgentClientTypes.FixedSizeChunkingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxTokens"].write(value.maxTokens)
        try writer["overlapPercentage"].write(value.overlapPercentage)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.FixedSizeChunkingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.FixedSizeChunkingConfiguration()
        value.maxTokens = try reader["maxTokens"].readIfPresent()
        value.overlapPercentage = try reader["overlapPercentage"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Configurations for when you choose fixed-size chunking. If you set the chunkingStrategy as NONE, exclude this field.
    public struct FixedSizeChunkingConfiguration {
        /// The maximum number of tokens to include in a chunk.
        /// This member is required.
        public var maxTokens: Swift.Int?
        /// The percentage of overlap between adjacent chunks of a data source.
        /// This member is required.
        public var overlapPercentage: Swift.Int?

        public init(
            maxTokens: Swift.Int? = nil,
            overlapPercentage: Swift.Int? = nil
        )
        {
            self.maxTokens = maxTokens
            self.overlapPercentage = overlapPercentage
        }
    }

}

extension BedrockAgentClientTypes.Function {

    static func write(value: BedrockAgentClientTypes.Function?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["parameters"].writeMap(value.parameters, valueWritingClosure: BedrockAgentClientTypes.ParameterDetail.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.Function {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.Function()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.parameters = try reader["parameters"].readMapIfPresent(valueReadingClosure: BedrockAgentClientTypes.ParameterDetail.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Defines parameters that the agent needs to invoke from the user to complete the function. Corresponds to an action in an action group. This data type is used in the following API operations:
    ///
    /// * [CreateAgentActionGroup request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_CreateAgentActionGroup.html#API_agent_CreateAgentActionGroup_RequestSyntax)
    ///
    /// * [CreateAgentActionGroup response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_CreateAgentActionGroup.html#API_agent_CreateAgentActionGroup_ResponseSyntax)
    ///
    /// * [UpdateAgentActionGroup request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_UpdateAgentActionGroup.html#API_agent_UpdateAgentActionGroup_RequestSyntax)
    ///
    /// * [UpdateAgentActionGroup response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_UpdateAgentActionGroup.html#API_agent_UpdateAgentActionGroup_ResponseSyntax)
    ///
    /// * [GetAgentActionGroup response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_GetAgentActionGroup.html#API_agent_GetAgentActionGroup_ResponseSyntax)
    public struct Function {
        /// A description of the function and its purpose.
        public var description: Swift.String?
        /// A name for the function.
        /// This member is required.
        public var name: Swift.String?
        /// The parameters that the agent elicits from the user to fulfill the function.
        public var parameters: [Swift.String:BedrockAgentClientTypes.ParameterDetail]?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            parameters: [Swift.String:BedrockAgentClientTypes.ParameterDetail]? = nil
        )
        {
            self.description = description
            self.name = name
            self.parameters = parameters
        }
    }

}

extension BedrockAgentClientTypes.FunctionSchema {

    static func write(value: BedrockAgentClientTypes.FunctionSchema?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .functions(functions):
                try writer["functions"].writeList(functions, memberWritingClosure: BedrockAgentClientTypes.Function.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.FunctionSchema {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "functions":
                return .functions(try reader["functions"].readList(memberReadingClosure: BedrockAgentClientTypes.Function.read(from:), memberNodeInfo: "member", isFlattened: false))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentClientTypes {
    /// Defines functions that each define parameters that the agent needs to invoke from the user. Each function represents an action in an action group. This data type is used in the following API operations:
    ///
    /// * [CreateAgentActionGroup request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_CreateAgentActionGroup.html#API_agent_CreateAgentActionGroup_RequestSyntax)
    ///
    /// * [CreateAgentActionGroup response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_CreateAgentActionGroup.html#API_agent_CreateAgentActionGroup_ResponseSyntax)
    ///
    /// * [UpdateAgentActionGroup request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_UpdateAgentActionGroup.html#API_agent_UpdateAgentActionGroup_RequestSyntax)
    ///
    /// * [UpdateAgentActionGroup response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_UpdateAgentActionGroup.html#API_agent_UpdateAgentActionGroup_ResponseSyntax)
    ///
    /// * [GetAgentActionGroup response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_GetAgentActionGroup.html#API_agent_GetAgentActionGroup_ResponseSyntax)
    public enum FunctionSchema {
        /// A list of functions that each define an action in the action group.
        case functions([BedrockAgentClientTypes.Function])
        case sdkUnknown(Swift.String)
    }

}

extension GetAgentActionGroupInput {

    static func urlPathProvider(_ value: GetAgentActionGroupInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        guard let actionGroupId = value.actionGroupId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/actiongroups/\(actionGroupId.urlPercentEncoding())"
    }
}

public struct GetAgentActionGroupInput {
    /// The unique identifier of the action group for which to get information.
    /// This member is required.
    public var actionGroupId: Swift.String?
    /// The unique identifier of the agent that the action group belongs to.
    /// This member is required.
    public var agentId: Swift.String?
    /// The version of the agent that the action group belongs to.
    /// This member is required.
    public var agentVersion: Swift.String?

    public init(
        actionGroupId: Swift.String? = nil,
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil
    )
    {
        self.actionGroupId = actionGroupId
        self.agentId = agentId
        self.agentVersion = agentVersion
    }
}

extension GetAgentActionGroupOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetAgentActionGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAgentActionGroupOutput()
        value.agentActionGroup = try reader["agentActionGroup"].readIfPresent(with: BedrockAgentClientTypes.AgentActionGroup.read(from:))
        return value
    }
}

public struct GetAgentActionGroupOutput {
    /// Contains details about the action group.
    /// This member is required.
    public var agentActionGroup: BedrockAgentClientTypes.AgentActionGroup?

    public init(
        agentActionGroup: BedrockAgentClientTypes.AgentActionGroup? = nil
    )
    {
        self.agentActionGroup = agentActionGroup
    }
}

enum GetAgentActionGroupOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetAgentAliasInput {

    static func urlPathProvider(_ value: GetAgentAliasInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentAliasId = value.agentAliasId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentaliases/\(agentAliasId.urlPercentEncoding())"
    }
}

public struct GetAgentAliasInput {
    /// The unique identifier of the alias for which to get information.
    /// This member is required.
    public var agentAliasId: Swift.String?
    /// The unique identifier of the agent to which the alias to get information belongs.
    /// This member is required.
    public var agentId: Swift.String?

    public init(
        agentAliasId: Swift.String? = nil,
        agentId: Swift.String? = nil
    )
    {
        self.agentAliasId = agentAliasId
        self.agentId = agentId
    }
}

extension GetAgentAliasOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetAgentAliasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAgentAliasOutput()
        value.agentAlias = try reader["agentAlias"].readIfPresent(with: BedrockAgentClientTypes.AgentAlias.read(from:))
        return value
    }
}

public struct GetAgentAliasOutput {
    /// Contains information about the alias.
    /// This member is required.
    public var agentAlias: BedrockAgentClientTypes.AgentAlias?

    public init(
        agentAlias: BedrockAgentClientTypes.AgentAlias? = nil
    )
    {
        self.agentAlias = agentAlias
    }
}

enum GetAgentAliasOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetAgentInput {

    static func urlPathProvider(_ value: GetAgentInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())"
    }
}

public struct GetAgentInput {
    /// The unique identifier of the agent.
    /// This member is required.
    public var agentId: Swift.String?

    public init(
        agentId: Swift.String? = nil
    )
    {
        self.agentId = agentId
    }
}

extension GetAgentKnowledgeBaseInput {

    static func urlPathProvider(_ value: GetAgentKnowledgeBaseInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())"
    }
}

public struct GetAgentKnowledgeBaseInput {
    /// The unique identifier of the agent with which the knowledge base is associated.
    /// This member is required.
    public var agentId: Swift.String?
    /// The version of the agent with which the knowledge base is associated.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// The unique identifier of the knowledge base associated with the agent.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.knowledgeBaseId = knowledgeBaseId
    }
}

extension GetAgentKnowledgeBaseOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetAgentKnowledgeBaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAgentKnowledgeBaseOutput()
        value.agentKnowledgeBase = try reader["agentKnowledgeBase"].readIfPresent(with: BedrockAgentClientTypes.AgentKnowledgeBase.read(from:))
        return value
    }
}

public struct GetAgentKnowledgeBaseOutput {
    /// Contains details about a knowledge base attached to an agent.
    /// This member is required.
    public var agentKnowledgeBase: BedrockAgentClientTypes.AgentKnowledgeBase?

    public init(
        agentKnowledgeBase: BedrockAgentClientTypes.AgentKnowledgeBase? = nil
    )
    {
        self.agentKnowledgeBase = agentKnowledgeBase
    }
}

enum GetAgentKnowledgeBaseOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetAgentOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetAgentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAgentOutput()
        value.agent = try reader["agent"].readIfPresent(with: BedrockAgentClientTypes.Agent.read(from:))
        return value
    }
}

public struct GetAgentOutput {
    /// Contains details about the agent.
    /// This member is required.
    public var agent: BedrockAgentClientTypes.Agent?

    public init(
        agent: BedrockAgentClientTypes.Agent? = nil
    )
    {
        self.agent = agent
    }
}

enum GetAgentOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetAgentVersionInput {

    static func urlPathProvider(_ value: GetAgentVersionInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())"
    }
}

public struct GetAgentVersionInput {
    /// The unique identifier of the agent.
    /// This member is required.
    public var agentId: Swift.String?
    /// The version of the agent.
    /// This member is required.
    public var agentVersion: Swift.String?

    public init(
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil
    )
    {
        self.agentId = agentId
        self.agentVersion = agentVersion
    }
}

extension GetAgentVersionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetAgentVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAgentVersionOutput()
        value.agentVersion = try reader["agentVersion"].readIfPresent(with: BedrockAgentClientTypes.AgentVersion.read(from:))
        return value
    }
}

public struct GetAgentVersionOutput {
    /// Contains details about the version of the agent.
    /// This member is required.
    public var agentVersion: BedrockAgentClientTypes.AgentVersion?

    public init(
        agentVersion: BedrockAgentClientTypes.AgentVersion? = nil
    )
    {
        self.agentVersion = agentVersion
    }
}

enum GetAgentVersionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetDataSourceInput {

    static func urlPathProvider(_ value: GetDataSourceInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let dataSourceId = value.dataSourceId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())"
    }
}

public struct GetDataSourceInput {
    /// The unique identifier of the data source.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The unique identifier of the knowledge base that the data source was added to.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        dataSourceId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.dataSourceId = dataSourceId
        self.knowledgeBaseId = knowledgeBaseId
    }
}

extension GetDataSourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetDataSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataSourceOutput()
        value.dataSource = try reader["dataSource"].readIfPresent(with: BedrockAgentClientTypes.DataSource.read(from:))
        return value
    }
}

public struct GetDataSourceOutput {
    /// Contains details about the data source.
    /// This member is required.
    public var dataSource: BedrockAgentClientTypes.DataSource?

    public init(
        dataSource: BedrockAgentClientTypes.DataSource? = nil
    )
    {
        self.dataSource = dataSource
    }
}

enum GetDataSourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetIngestionJobInput {

    static func urlPathProvider(_ value: GetIngestionJobInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let dataSourceId = value.dataSourceId else {
            return nil
        }
        guard let ingestionJobId = value.ingestionJobId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())/ingestionjobs/\(ingestionJobId.urlPercentEncoding())"
    }
}

public struct GetIngestionJobInput {
    /// The unique identifier of the data source in the ingestion job.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The unique identifier of the ingestion job.
    /// This member is required.
    public var ingestionJobId: Swift.String?
    /// The unique identifier of the knowledge base for which the ingestion job applies.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        dataSourceId: Swift.String? = nil,
        ingestionJobId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.dataSourceId = dataSourceId
        self.ingestionJobId = ingestionJobId
        self.knowledgeBaseId = knowledgeBaseId
    }
}

extension GetIngestionJobOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetIngestionJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIngestionJobOutput()
        value.ingestionJob = try reader["ingestionJob"].readIfPresent(with: BedrockAgentClientTypes.IngestionJob.read(from:))
        return value
    }
}

public struct GetIngestionJobOutput {
    /// Contains details about the ingestion job.
    /// This member is required.
    public var ingestionJob: BedrockAgentClientTypes.IngestionJob?

    public init(
        ingestionJob: BedrockAgentClientTypes.IngestionJob? = nil
    )
    {
        self.ingestionJob = ingestionJob
    }
}

enum GetIngestionJobOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetKnowledgeBaseInput {

    static func urlPathProvider(_ value: GetKnowledgeBaseInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())"
    }
}

public struct GetKnowledgeBaseInput {
    /// The unique identifier of the knowledge base for which to get information.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
    }
}

extension GetKnowledgeBaseOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetKnowledgeBaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetKnowledgeBaseOutput()
        value.knowledgeBase = try reader["knowledgeBase"].readIfPresent(with: BedrockAgentClientTypes.KnowledgeBase.read(from:))
        return value
    }
}

public struct GetKnowledgeBaseOutput {
    /// Contains details about the knowledge base.
    /// This member is required.
    public var knowledgeBase: BedrockAgentClientTypes.KnowledgeBase?

    public init(
        knowledgeBase: BedrockAgentClientTypes.KnowledgeBase? = nil
    )
    {
        self.knowledgeBase = knowledgeBase
    }
}

enum GetKnowledgeBaseOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension BedrockAgentClientTypes.InferenceConfiguration {

    static func write(value: BedrockAgentClientTypes.InferenceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maximumLength"].write(value.maximumLength)
        try writer["stopSequences"].writeList(value.stopSequences, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["temperature"].write(value.temperature)
        try writer["topK"].write(value.topk)
        try writer["topP"].write(value.topp)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.InferenceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.InferenceConfiguration()
        value.temperature = try reader["temperature"].readIfPresent()
        value.topp = try reader["topP"].readIfPresent()
        value.topk = try reader["topK"].readIfPresent()
        value.maximumLength = try reader["maximumLength"].readIfPresent()
        value.stopSequences = try reader["stopSequences"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the promptType. For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html).
    public struct InferenceConfiguration {
        /// The maximum number of tokens to allow in the generated response.
        public var maximumLength: Swift.Int?
        /// A list of stop sequences. A stop sequence is a sequence of characters that causes the model to stop generating the response.
        public var stopSequences: [Swift.String]?
        /// The likelihood of the model selecting higher-probability options while generating a response. A lower value makes the model more likely to choose higher-probability options, while a higher value makes the model more likely to choose lower-probability options.
        public var temperature: Swift.Float?
        /// While generating a response, the model determines the probability of the following token at each point of generation. The value that you set for topK is the number of most-likely candidates from which the model chooses the next token in the sequence. For example, if you set topK to 50, the model selects the next token from among the top 50 most likely choices.
        public var topk: Swift.Int?
        /// While generating a response, the model determines the probability of the following token at each point of generation. The value that you set for Top P determines the number of most-likely candidates from which the model chooses the next token in the sequence. For example, if you set topP to 80, the model only selects the next token from the top 80% of the probability distribution of next tokens.
        public var topp: Swift.Float?

        public init(
            maximumLength: Swift.Int? = nil,
            stopSequences: [Swift.String]? = nil,
            temperature: Swift.Float? = nil,
            topk: Swift.Int? = nil,
            topp: Swift.Float? = nil
        )
        {
            self.maximumLength = maximumLength
            self.stopSequences = stopSequences
            self.temperature = temperature
            self.topk = topk
            self.topp = topp
        }
    }

}

extension BedrockAgentClientTypes.IngestionJob {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.IngestionJob {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.IngestionJob()
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent()
        value.dataSourceId = try reader["dataSourceId"].readIfPresent()
        value.ingestionJobId = try reader["ingestionJobId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statistics = try reader["statistics"].readIfPresent(with: BedrockAgentClientTypes.IngestionJobStatistics.read(from:))
        value.failureReasons = try reader["failureReasons"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: .dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about an ingestion job, which converts a data source to embeddings for a vector store in knowledge base. This data type is used in the following API operations:
    ///
    /// * [StartIngestionJob response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_StartIngestionJob.html#API_agent_StartIngestionJob_ResponseSyntax)
    ///
    /// * [GetIngestionJob response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_GetIngestionJob.html#API_agent_GetIngestionJob_ResponseSyntax)
    ///
    /// * [ListIngestionJob response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_ListIngestionJobs.html#API_agent_ListIngestionJobs_ResponseSyntax)
    public struct IngestionJob {
        /// The unique identifier of the ingested data source.
        /// This member is required.
        public var dataSourceId: Swift.String?
        /// The description of the ingestion job.
        public var description: Swift.String?
        /// A list of reasons that the ingestion job failed.
        public var failureReasons: [Swift.String]?
        /// The unique identifier of the ingestion job.
        /// This member is required.
        public var ingestionJobId: Swift.String?
        /// The unique identifier of the knowledge base to which the data source is being added.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The time at which the ingestion job started.
        /// This member is required.
        public var startedAt: ClientRuntime.Date?
        /// Contains statistics about the ingestion job.
        public var statistics: BedrockAgentClientTypes.IngestionJobStatistics?
        /// The status of the ingestion job.
        /// This member is required.
        public var status: BedrockAgentClientTypes.IngestionJobStatus?
        /// The time at which the ingestion job was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            dataSourceId: Swift.String? = nil,
            description: Swift.String? = nil,
            failureReasons: [Swift.String]? = nil,
            ingestionJobId: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            startedAt: ClientRuntime.Date? = nil,
            statistics: BedrockAgentClientTypes.IngestionJobStatistics? = nil,
            status: BedrockAgentClientTypes.IngestionJobStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.dataSourceId = dataSourceId
            self.description = description
            self.failureReasons = failureReasons
            self.ingestionJobId = ingestionJobId
            self.knowledgeBaseId = knowledgeBaseId
            self.startedAt = startedAt
            self.statistics = statistics
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension BedrockAgentClientTypes.IngestionJobFilter {

    static func write(value: BedrockAgentClientTypes.IngestionJobFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attribute"].write(value.attribute)
        try writer["operator"].write(value.`operator`)
        try writer["values"].writeList(value.values, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BedrockAgentClientTypes {
    /// Defines a filter by which to filter the results.
    public struct IngestionJobFilter {
        /// The attribute by which to filter the results.
        /// This member is required.
        public var attribute: BedrockAgentClientTypes.IngestionJobFilterAttribute?
        /// The operation to carry out between the attribute and the values.
        /// This member is required.
        public var `operator`: BedrockAgentClientTypes.IngestionJobFilterOperator?
        /// A list of values for the attribute.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            attribute: BedrockAgentClientTypes.IngestionJobFilterAttribute? = nil,
            `operator`: BedrockAgentClientTypes.IngestionJobFilterOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.attribute = attribute
            self.`operator` = `operator`
            self.values = values
        }
    }

}

extension BedrockAgentClientTypes {

    public enum IngestionJobFilterAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionJobFilterAttribute] {
            return [
                .status,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .status: return "STATUS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    public enum IngestionJobFilterOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case eq
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionJobFilterOperator] {
            return [
                .eq,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .eq: return "EQ"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes.IngestionJobSortBy {

    static func write(value: BedrockAgentClientTypes.IngestionJobSortBy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attribute"].write(value.attribute)
        try writer["order"].write(value.order)
    }
}

extension BedrockAgentClientTypes {
    /// Parameters by which to sort the results.
    public struct IngestionJobSortBy {
        /// The attribute by which to sort the results.
        /// This member is required.
        public var attribute: BedrockAgentClientTypes.IngestionJobSortByAttribute?
        /// The order by which to sort the results.
        /// This member is required.
        public var order: BedrockAgentClientTypes.SortOrder?

        public init(
            attribute: BedrockAgentClientTypes.IngestionJobSortByAttribute? = nil,
            order: BedrockAgentClientTypes.SortOrder? = nil
        )
        {
            self.attribute = attribute
            self.order = order
        }
    }

}

extension BedrockAgentClientTypes {

    public enum IngestionJobSortByAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case startedAt
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionJobSortByAttribute] {
            return [
                .startedAt,
                .status,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .startedAt: return "STARTED_AT"
            case .status: return "STATUS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes.IngestionJobStatistics {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.IngestionJobStatistics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.IngestionJobStatistics()
        value.numberOfDocumentsScanned = try reader["numberOfDocumentsScanned"].readIfPresent() ?? 0
        value.numberOfMetadataDocumentsScanned = try reader["numberOfMetadataDocumentsScanned"].readIfPresent() ?? 0
        value.numberOfNewDocumentsIndexed = try reader["numberOfNewDocumentsIndexed"].readIfPresent() ?? 0
        value.numberOfModifiedDocumentsIndexed = try reader["numberOfModifiedDocumentsIndexed"].readIfPresent() ?? 0
        value.numberOfMetadataDocumentsModified = try reader["numberOfMetadataDocumentsModified"].readIfPresent() ?? 0
        value.numberOfDocumentsDeleted = try reader["numberOfDocumentsDeleted"].readIfPresent() ?? 0
        value.numberOfDocumentsFailed = try reader["numberOfDocumentsFailed"].readIfPresent() ?? 0
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains the statistics for the ingestion job.
    public struct IngestionJobStatistics {
        /// The number of source documents that was deleted.
        public var numberOfDocumentsDeleted: Swift.Int
        /// The number of source documents that failed to be ingested.
        public var numberOfDocumentsFailed: Swift.Int
        /// The total number of source documents that were scanned. Includes new, updated, and unchanged documents.
        public var numberOfDocumentsScanned: Swift.Int
        /// The number of metadata files that were updated or deleted.
        public var numberOfMetadataDocumentsModified: Swift.Int
        /// The total number of metadata files that were scanned. Includes new, updated, and unchanged files.
        public var numberOfMetadataDocumentsScanned: Swift.Int
        /// The number of modified source documents in the data source that were successfully indexed.
        public var numberOfModifiedDocumentsIndexed: Swift.Int
        /// The number of new source documents in the data source that were successfully indexed.
        public var numberOfNewDocumentsIndexed: Swift.Int

        public init(
            numberOfDocumentsDeleted: Swift.Int = 0,
            numberOfDocumentsFailed: Swift.Int = 0,
            numberOfDocumentsScanned: Swift.Int = 0,
            numberOfMetadataDocumentsModified: Swift.Int = 0,
            numberOfMetadataDocumentsScanned: Swift.Int = 0,
            numberOfModifiedDocumentsIndexed: Swift.Int = 0,
            numberOfNewDocumentsIndexed: Swift.Int = 0
        )
        {
            self.numberOfDocumentsDeleted = numberOfDocumentsDeleted
            self.numberOfDocumentsFailed = numberOfDocumentsFailed
            self.numberOfDocumentsScanned = numberOfDocumentsScanned
            self.numberOfMetadataDocumentsModified = numberOfMetadataDocumentsModified
            self.numberOfMetadataDocumentsScanned = numberOfMetadataDocumentsScanned
            self.numberOfModifiedDocumentsIndexed = numberOfModifiedDocumentsIndexed
            self.numberOfNewDocumentsIndexed = numberOfNewDocumentsIndexed
        }
    }

}

extension BedrockAgentClientTypes {

    public enum IngestionJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case complete
        case failed
        case inProgress
        case starting
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionJobStatus] {
            return [
                .complete,
                .failed,
                .inProgress,
                .starting,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .starting: return "STARTING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes.IngestionJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.IngestionJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.IngestionJobSummary()
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent()
        value.dataSourceId = try reader["dataSourceId"].readIfPresent()
        value.ingestionJobId = try reader["ingestionJobId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: .dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        value.statistics = try reader["statistics"].readIfPresent(with: BedrockAgentClientTypes.IngestionJobStatistics.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about an ingestion job.
    public struct IngestionJobSummary {
        /// The unique identifier of the data source in the ingestion job.
        /// This member is required.
        public var dataSourceId: Swift.String?
        /// The description of the ingestion job.
        public var description: Swift.String?
        /// The unique identifier of the ingestion job.
        /// This member is required.
        public var ingestionJobId: Swift.String?
        /// The unique identifier of the knowledge base to which the data source is added.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The time at which the ingestion job was started.
        /// This member is required.
        public var startedAt: ClientRuntime.Date?
        /// Contains statistics for the ingestion job.
        public var statistics: BedrockAgentClientTypes.IngestionJobStatistics?
        /// The status of the ingestion job.
        /// This member is required.
        public var status: BedrockAgentClientTypes.IngestionJobStatus?
        /// The time at which the ingestion job was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            dataSourceId: Swift.String? = nil,
            description: Swift.String? = nil,
            ingestionJobId: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            startedAt: ClientRuntime.Date? = nil,
            statistics: BedrockAgentClientTypes.IngestionJobStatistics? = nil,
            status: BedrockAgentClientTypes.IngestionJobStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.dataSourceId = dataSourceId
            self.description = description
            self.ingestionJobId = ingestionJobId
            self.knowledgeBaseId = knowledgeBaseId
            self.startedAt = startedAt
            self.statistics = statistics
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// An internal server error occurred. Retry your request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BedrockAgentClientTypes.KnowledgeBase {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.KnowledgeBase {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.KnowledgeBase()
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.knowledgeBaseArn = try reader["knowledgeBaseArn"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.knowledgeBaseConfiguration = try reader["knowledgeBaseConfiguration"].readIfPresent(with: BedrockAgentClientTypes.KnowledgeBaseConfiguration.read(from:))
        value.storageConfiguration = try reader["storageConfiguration"].readIfPresent(with: BedrockAgentClientTypes.StorageConfiguration.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        value.failureReasons = try reader["failureReasons"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains information about a knowledge base.
    public struct KnowledgeBase {
        /// The time at which the knowledge base was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The description of the knowledge base.
        public var description: Swift.String?
        /// A list of reasons that the API operation on the knowledge base failed.
        public var failureReasons: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// Contains details about the embeddings configuration of the knowledge base.
        /// This member is required.
        public var knowledgeBaseConfiguration: BedrockAgentClientTypes.KnowledgeBaseConfiguration?
        /// The unique identifier of the knowledge base.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The name of the knowledge base.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the knowledge base.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The status of the knowledge base. The following statuses are possible:
        ///
        /// * CREATING – The knowledge base is being created.
        ///
        /// * ACTIVE – The knowledge base is ready to be queried.
        ///
        /// * DELETING – The knowledge base is being deleted.
        ///
        /// * UPDATING – The knowledge base is being updated.
        ///
        /// * FAILED – The knowledge base API operation failed.
        /// This member is required.
        public var status: BedrockAgentClientTypes.KnowledgeBaseStatus?
        /// Contains details about the storage configuration of the knowledge base.
        /// This member is required.
        public var storageConfiguration: BedrockAgentClientTypes.StorageConfiguration?
        /// The time at which the knowledge base was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            failureReasons: [Swift.String]? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseConfiguration: BedrockAgentClientTypes.KnowledgeBaseConfiguration? = nil,
            knowledgeBaseId: Swift.String? = nil,
            name: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            status: BedrockAgentClientTypes.KnowledgeBaseStatus? = nil,
            storageConfiguration: BedrockAgentClientTypes.StorageConfiguration? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.failureReasons = failureReasons
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseConfiguration = knowledgeBaseConfiguration
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.roleArn = roleArn
            self.status = status
            self.storageConfiguration = storageConfiguration
            self.updatedAt = updatedAt
        }
    }

}

extension BedrockAgentClientTypes.KnowledgeBaseConfiguration {

    static func write(value: BedrockAgentClientTypes.KnowledgeBaseConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["type"].write(value.type)
        try writer["vectorKnowledgeBaseConfiguration"].write(value.vectorKnowledgeBaseConfiguration, with: BedrockAgentClientTypes.VectorKnowledgeBaseConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.KnowledgeBaseConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.KnowledgeBaseConfiguration()
        value.type = try reader["type"].readIfPresent()
        value.vectorKnowledgeBaseConfiguration = try reader["vectorKnowledgeBaseConfiguration"].readIfPresent(with: BedrockAgentClientTypes.VectorKnowledgeBaseConfiguration.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about the embeddings configuration of the knowledge base.
    public struct KnowledgeBaseConfiguration {
        /// The type of data that the data source is converted into for the knowledge base.
        /// This member is required.
        public var type: BedrockAgentClientTypes.KnowledgeBaseType?
        /// Contains details about the embeddings model that'sused to convert the data source.
        public var vectorKnowledgeBaseConfiguration: BedrockAgentClientTypes.VectorKnowledgeBaseConfiguration?

        public init(
            type: BedrockAgentClientTypes.KnowledgeBaseType? = nil,
            vectorKnowledgeBaseConfiguration: BedrockAgentClientTypes.VectorKnowledgeBaseConfiguration? = nil
        )
        {
            self.type = type
            self.vectorKnowledgeBaseConfiguration = vectorKnowledgeBaseConfiguration
        }
    }

}

extension BedrockAgentClientTypes {

    public enum KnowledgeBaseState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [KnowledgeBaseState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    public enum KnowledgeBaseStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleteUnsuccessful
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [KnowledgeBaseStatus] {
            return [
                .active,
                .creating,
                .deleteUnsuccessful,
                .deleting,
                .failed,
                .updating,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleteUnsuccessful: return "DELETE_UNSUCCESSFUL"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    public enum KnowledgeBaseStorageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case mongoDbAtlas
        case opensearchServerless
        case pinecone
        case rds
        case redisEnterpriseCloud
        case sdkUnknown(Swift.String)

        public static var allCases: [KnowledgeBaseStorageType] {
            return [
                .mongoDbAtlas,
                .opensearchServerless,
                .pinecone,
                .rds,
                .redisEnterpriseCloud,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .mongoDbAtlas: return "MONGO_DB_ATLAS"
            case .opensearchServerless: return "OPENSEARCH_SERVERLESS"
            case .pinecone: return "PINECONE"
            case .rds: return "RDS"
            case .redisEnterpriseCloud: return "REDIS_ENTERPRISE_CLOUD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes.KnowledgeBaseSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.KnowledgeBaseSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.KnowledgeBaseSummary()
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about a knowledge base.
    public struct KnowledgeBaseSummary {
        /// The description of the knowledge base.
        public var description: Swift.String?
        /// The unique identifier of the knowledge base.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The name of the knowledge base.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the knowledge base.
        /// This member is required.
        public var status: BedrockAgentClientTypes.KnowledgeBaseStatus?
        /// The time at which the knowledge base was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init(
            description: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            name: Swift.String? = nil,
            status: BedrockAgentClientTypes.KnowledgeBaseStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension BedrockAgentClientTypes {

    public enum KnowledgeBaseType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case vector
        case sdkUnknown(Swift.String)

        public static var allCases: [KnowledgeBaseType] {
            return [
                .vector,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .vector: return "VECTOR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ListAgentActionGroupsInput {

    static func urlPathProvider(_ value: ListAgentActionGroupsInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/actiongroups"
    }
}

extension ListAgentActionGroupsInput {

    static func write(value: ListAgentActionGroupsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

public struct ListAgentActionGroupsInput {
    /// The unique identifier of the agent.
    /// This member is required.
    public var agentId: Swift.String?
    /// The version of the agent.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListAgentActionGroupsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListAgentActionGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAgentActionGroupsOutput()
        value.actionGroupSummaries = try reader["actionGroupSummaries"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.ActionGroupSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListAgentActionGroupsOutput {
    /// A list of objects, each of which contains information about an action group.
    /// This member is required.
    public var actionGroupSummaries: [BedrockAgentClientTypes.ActionGroupSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        actionGroupSummaries: [BedrockAgentClientTypes.ActionGroupSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actionGroupSummaries = actionGroupSummaries
        self.nextToken = nextToken
    }
}

enum ListAgentActionGroupsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListAgentAliasesInput {

    static func urlPathProvider(_ value: ListAgentAliasesInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentaliases"
    }
}

extension ListAgentAliasesInput {

    static func write(value: ListAgentAliasesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

public struct ListAgentAliasesInput {
    /// The unique identifier of the agent.
    /// This member is required.
    public var agentId: Swift.String?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        agentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentId = agentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListAgentAliasesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListAgentAliasesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAgentAliasesOutput()
        value.agentAliasSummaries = try reader["agentAliasSummaries"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.AgentAliasSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListAgentAliasesOutput {
    /// A list of objects, each of which contains information about an alias of the agent.
    /// This member is required.
    public var agentAliasSummaries: [BedrockAgentClientTypes.AgentAliasSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        agentAliasSummaries: [BedrockAgentClientTypes.AgentAliasSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentAliasSummaries = agentAliasSummaries
        self.nextToken = nextToken
    }
}

enum ListAgentAliasesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListAgentKnowledgeBasesInput {

    static func urlPathProvider(_ value: ListAgentKnowledgeBasesInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/knowledgebases"
    }
}

extension ListAgentKnowledgeBasesInput {

    static func write(value: ListAgentKnowledgeBasesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

public struct ListAgentKnowledgeBasesInput {
    /// The unique identifier of the agent for which to return information about knowledge bases associated with it.
    /// This member is required.
    public var agentId: Swift.String?
    /// The version of the agent for which to return information about knowledge bases associated with it.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListAgentKnowledgeBasesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListAgentKnowledgeBasesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAgentKnowledgeBasesOutput()
        value.agentKnowledgeBaseSummaries = try reader["agentKnowledgeBaseSummaries"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.AgentKnowledgeBaseSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListAgentKnowledgeBasesOutput {
    /// A list of objects, each of which contains information about a knowledge base associated with the agent.
    /// This member is required.
    public var agentKnowledgeBaseSummaries: [BedrockAgentClientTypes.AgentKnowledgeBaseSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        agentKnowledgeBaseSummaries: [BedrockAgentClientTypes.AgentKnowledgeBaseSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentKnowledgeBaseSummaries = agentKnowledgeBaseSummaries
        self.nextToken = nextToken
    }
}

enum ListAgentKnowledgeBasesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListAgentVersionsInput {

    static func urlPathProvider(_ value: ListAgentVersionsInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions"
    }
}

extension ListAgentVersionsInput {

    static func write(value: ListAgentVersionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

public struct ListAgentVersionsInput {
    /// The unique identifier of the agent.
    /// This member is required.
    public var agentId: Swift.String?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        agentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentId = agentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListAgentVersionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListAgentVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAgentVersionsOutput()
        value.agentVersionSummaries = try reader["agentVersionSummaries"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.AgentVersionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListAgentVersionsOutput {
    /// A list of objects, each of which contains information about a version of the agent.
    /// This member is required.
    public var agentVersionSummaries: [BedrockAgentClientTypes.AgentVersionSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        agentVersionSummaries: [BedrockAgentClientTypes.AgentVersionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentVersionSummaries = agentVersionSummaries
        self.nextToken = nextToken
    }
}

enum ListAgentVersionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListAgentsInput {

    static func urlPathProvider(_ value: ListAgentsInput) -> Swift.String? {
        return "/agents"
    }
}

extension ListAgentsInput {

    static func write(value: ListAgentsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

public struct ListAgentsInput {
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListAgentsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListAgentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAgentsOutput()
        value.agentSummaries = try reader["agentSummaries"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.AgentSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListAgentsOutput {
    /// A list of objects, each of which contains information about an agent.
    /// This member is required.
    public var agentSummaries: [BedrockAgentClientTypes.AgentSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        agentSummaries: [BedrockAgentClientTypes.AgentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentSummaries = agentSummaries
        self.nextToken = nextToken
    }
}

enum ListAgentsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListDataSourcesInput {

    static func urlPathProvider(_ value: ListDataSourcesInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/datasources"
    }
}

extension ListDataSourcesInput {

    static func write(value: ListDataSourcesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

public struct ListDataSourcesInput {
    /// The unique identifier of the knowledge base for which to return a list of information.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListDataSourcesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListDataSourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDataSourcesOutput()
        value.dataSourceSummaries = try reader["dataSourceSummaries"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.DataSourceSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListDataSourcesOutput {
    /// A list of objects, each of which contains information about a data source.
    /// This member is required.
    public var dataSourceSummaries: [BedrockAgentClientTypes.DataSourceSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        dataSourceSummaries: [BedrockAgentClientTypes.DataSourceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataSourceSummaries = dataSourceSummaries
        self.nextToken = nextToken
    }
}

enum ListDataSourcesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListIngestionJobsInput {

    static func urlPathProvider(_ value: ListIngestionJobsInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let dataSourceId = value.dataSourceId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())/ingestionjobs"
    }
}

extension ListIngestionJobsInput {

    static func write(value: ListIngestionJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: BedrockAgentClientTypes.IngestionJobFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["sortBy"].write(value.sortBy, with: BedrockAgentClientTypes.IngestionJobSortBy.write(value:to:))
    }
}

public struct ListIngestionJobsInput {
    /// The unique identifier of the data source for which to return ingestion jobs.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// Contains a definition of a filter for which to filter the results.
    public var filters: [BedrockAgentClientTypes.IngestionJobFilter]?
    /// The unique identifier of the knowledge base for which to return ingestion jobs.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?
    /// Contains details about how to sort the results.
    public var sortBy: BedrockAgentClientTypes.IngestionJobSortBy?

    public init(
        dataSourceId: Swift.String? = nil,
        filters: [BedrockAgentClientTypes.IngestionJobFilter]? = nil,
        knowledgeBaseId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: BedrockAgentClientTypes.IngestionJobSortBy? = nil
    )
    {
        self.dataSourceId = dataSourceId
        self.filters = filters
        self.knowledgeBaseId = knowledgeBaseId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
    }
}

extension ListIngestionJobsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListIngestionJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIngestionJobsOutput()
        value.ingestionJobSummaries = try reader["ingestionJobSummaries"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.IngestionJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListIngestionJobsOutput {
    /// A list of objects, each of which contains information about an ingestion job.
    /// This member is required.
    public var ingestionJobSummaries: [BedrockAgentClientTypes.IngestionJobSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        ingestionJobSummaries: [BedrockAgentClientTypes.IngestionJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ingestionJobSummaries = ingestionJobSummaries
        self.nextToken = nextToken
    }
}

enum ListIngestionJobsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListKnowledgeBasesInput {

    static func urlPathProvider(_ value: ListKnowledgeBasesInput) -> Swift.String? {
        return "/knowledgebases"
    }
}

extension ListKnowledgeBasesInput {

    static func write(value: ListKnowledgeBasesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

public struct ListKnowledgeBasesInput {
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListKnowledgeBasesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListKnowledgeBasesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListKnowledgeBasesOutput()
        value.knowledgeBaseSummaries = try reader["knowledgeBaseSummaries"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.KnowledgeBaseSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListKnowledgeBasesOutput {
    /// A list of objects, each of which contains information about a knowledge base.
    /// This member is required.
    public var knowledgeBaseSummaries: [BedrockAgentClientTypes.KnowledgeBaseSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        knowledgeBaseSummaries: [BedrockAgentClientTypes.KnowledgeBaseSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.knowledgeBaseSummaries = knowledgeBaseSummaries
        self.nextToken = nextToken
    }
}

enum ListKnowledgeBasesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) of the resource for which to list tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct ListTagsForResourceOutput {
    /// The key-value pairs for the tags associated with the resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension BedrockAgentClientTypes.MongoDbAtlasConfiguration {

    static func write(value: BedrockAgentClientTypes.MongoDbAtlasConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["collectionName"].write(value.collectionName)
        try writer["credentialsSecretArn"].write(value.credentialsSecretArn)
        try writer["databaseName"].write(value.databaseName)
        try writer["endpoint"].write(value.endpoint)
        try writer["endpointServiceName"].write(value.endpointServiceName)
        try writer["fieldMapping"].write(value.fieldMapping, with: BedrockAgentClientTypes.MongoDbAtlasFieldMapping.write(value:to:))
        try writer["vectorIndexName"].write(value.vectorIndexName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.MongoDbAtlasConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.MongoDbAtlasConfiguration()
        value.endpoint = try reader["endpoint"].readIfPresent()
        value.databaseName = try reader["databaseName"].readIfPresent()
        value.collectionName = try reader["collectionName"].readIfPresent()
        value.vectorIndexName = try reader["vectorIndexName"].readIfPresent()
        value.credentialsSecretArn = try reader["credentialsSecretArn"].readIfPresent()
        value.fieldMapping = try reader["fieldMapping"].readIfPresent(with: BedrockAgentClientTypes.MongoDbAtlasFieldMapping.read(from:))
        value.endpointServiceName = try reader["endpointServiceName"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about the storage configuration of the knowledge base in MongoDB Atlas.
    public struct MongoDbAtlasConfiguration {
        /// The collection name of the knowledge base in MongoDB Atlas.
        /// This member is required.
        public var collectionName: Swift.String?
        /// The Amazon Resource Name (ARN) of the secret that you created in Secrets Manager that contains user credentials for your MongoDB Atlas cluster.
        /// This member is required.
        public var credentialsSecretArn: Swift.String?
        /// The database name in your MongoDB Atlas cluster for your knowledge base.
        /// This member is required.
        public var databaseName: Swift.String?
        /// The endpoint URL of your MongoDB Atlas cluster for your knowledge base.
        /// This member is required.
        public var endpoint: Swift.String?
        /// The name of the VPC endpoint service in your account that is connected to your MongoDB Atlas cluster.
        public var endpointServiceName: Swift.String?
        /// Contains the names of the fields to which to map information about the vector store.
        /// This member is required.
        public var fieldMapping: BedrockAgentClientTypes.MongoDbAtlasFieldMapping?
        /// The name of the MongoDB Atlas vector search index.
        /// This member is required.
        public var vectorIndexName: Swift.String?

        public init(
            collectionName: Swift.String? = nil,
            credentialsSecretArn: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            endpoint: Swift.String? = nil,
            endpointServiceName: Swift.String? = nil,
            fieldMapping: BedrockAgentClientTypes.MongoDbAtlasFieldMapping? = nil,
            vectorIndexName: Swift.String? = nil
        )
        {
            self.collectionName = collectionName
            self.credentialsSecretArn = credentialsSecretArn
            self.databaseName = databaseName
            self.endpoint = endpoint
            self.endpointServiceName = endpointServiceName
            self.fieldMapping = fieldMapping
            self.vectorIndexName = vectorIndexName
        }
    }

}

extension BedrockAgentClientTypes.MongoDbAtlasFieldMapping {

    static func write(value: BedrockAgentClientTypes.MongoDbAtlasFieldMapping?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["metadataField"].write(value.metadataField)
        try writer["textField"].write(value.textField)
        try writer["vectorField"].write(value.vectorField)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.MongoDbAtlasFieldMapping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.MongoDbAtlasFieldMapping()
        value.vectorField = try reader["vectorField"].readIfPresent()
        value.textField = try reader["textField"].readIfPresent()
        value.metadataField = try reader["metadataField"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains the names of the fields to which to map information about the vector store.
    public struct MongoDbAtlasFieldMapping {
        /// The name of the field in which Amazon Bedrock stores metadata about the vector store.
        /// This member is required.
        public var metadataField: Swift.String?
        /// The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        /// This member is required.
        public var textField: Swift.String?
        /// The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        /// This member is required.
        public var vectorField: Swift.String?

        public init(
            metadataField: Swift.String? = nil,
            textField: Swift.String? = nil,
            vectorField: Swift.String? = nil
        )
        {
            self.metadataField = metadataField
            self.textField = textField
            self.vectorField = vectorField
        }
    }

}

extension BedrockAgentClientTypes.OpenSearchServerlessConfiguration {

    static func write(value: BedrockAgentClientTypes.OpenSearchServerlessConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["collectionArn"].write(value.collectionArn)
        try writer["fieldMapping"].write(value.fieldMapping, with: BedrockAgentClientTypes.OpenSearchServerlessFieldMapping.write(value:to:))
        try writer["vectorIndexName"].write(value.vectorIndexName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.OpenSearchServerlessConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.OpenSearchServerlessConfiguration()
        value.collectionArn = try reader["collectionArn"].readIfPresent()
        value.vectorIndexName = try reader["vectorIndexName"].readIfPresent()
        value.fieldMapping = try reader["fieldMapping"].readIfPresent(with: BedrockAgentClientTypes.OpenSearchServerlessFieldMapping.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about the storage configuration of the knowledge base in Amazon OpenSearch Service. For more information, see [Create a vector index in Amazon OpenSearch Service](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-oss.html).
    public struct OpenSearchServerlessConfiguration {
        /// The Amazon Resource Name (ARN) of the OpenSearch Service vector store.
        /// This member is required.
        public var collectionArn: Swift.String?
        /// Contains the names of the fields to which to map information about the vector store.
        /// This member is required.
        public var fieldMapping: BedrockAgentClientTypes.OpenSearchServerlessFieldMapping?
        /// The name of the vector store.
        /// This member is required.
        public var vectorIndexName: Swift.String?

        public init(
            collectionArn: Swift.String? = nil,
            fieldMapping: BedrockAgentClientTypes.OpenSearchServerlessFieldMapping? = nil,
            vectorIndexName: Swift.String? = nil
        )
        {
            self.collectionArn = collectionArn
            self.fieldMapping = fieldMapping
            self.vectorIndexName = vectorIndexName
        }
    }

}

extension BedrockAgentClientTypes.OpenSearchServerlessFieldMapping {

    static func write(value: BedrockAgentClientTypes.OpenSearchServerlessFieldMapping?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["metadataField"].write(value.metadataField)
        try writer["textField"].write(value.textField)
        try writer["vectorField"].write(value.vectorField)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.OpenSearchServerlessFieldMapping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.OpenSearchServerlessFieldMapping()
        value.vectorField = try reader["vectorField"].readIfPresent()
        value.textField = try reader["textField"].readIfPresent()
        value.metadataField = try reader["metadataField"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains the names of the fields to which to map information about the vector store.
    public struct OpenSearchServerlessFieldMapping {
        /// The name of the field in which Amazon Bedrock stores metadata about the vector store.
        /// This member is required.
        public var metadataField: Swift.String?
        /// The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        /// This member is required.
        public var textField: Swift.String?
        /// The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        /// This member is required.
        public var vectorField: Swift.String?

        public init(
            metadataField: Swift.String? = nil,
            textField: Swift.String? = nil,
            vectorField: Swift.String? = nil
        )
        {
            self.metadataField = metadataField
            self.textField = textField
            self.vectorField = vectorField
        }
    }

}

extension BedrockAgentClientTypes.ParameterDetail {

    static func write(value: BedrockAgentClientTypes.ParameterDetail?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["required"].write(value.`required`)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.ParameterDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.ParameterDetail()
        value.description = try reader["description"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.`required` = try reader["required"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about a parameter in a function for an action group. This data type is used in the following API operations:
    ///
    /// * [CreateAgentActionGroup request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_CreateAgentActionGroup.html#API_agent_CreateAgentActionGroup_RequestSyntax)
    ///
    /// * [CreateAgentActionGroup response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_CreateAgentActionGroup.html#API_agent_CreateAgentActionGroup_ResponseSyntax)
    ///
    /// * [UpdateAgentActionGroup request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_UpdateAgentActionGroup.html#API_agent_UpdateAgentActionGroup_RequestSyntax)
    ///
    /// * [UpdateAgentActionGroup response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_UpdateAgentActionGroup.html#API_agent_UpdateAgentActionGroup_ResponseSyntax)
    ///
    /// * [GetAgentActionGroup response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_GetAgentActionGroup.html#API_agent_GetAgentActionGroup_ResponseSyntax)
    public struct ParameterDetail {
        /// A description of the parameter. Helps the foundation model determine how to elicit the parameters from the user.
        public var description: Swift.String?
        /// Whether the parameter is required for the agent to complete the function for action group invocation.
        public var `required`: Swift.Bool?
        /// The data type of the parameter.
        /// This member is required.
        public var type: BedrockAgentClientTypes.ModelType?

        public init(
            description: Swift.String? = nil,
            `required`: Swift.Bool? = nil,
            type: BedrockAgentClientTypes.ModelType? = nil
        )
        {
            self.description = description
            self.`required` = `required`
            self.type = type
        }
    }

}

extension BedrockAgentClientTypes.PineconeConfiguration {

    static func write(value: BedrockAgentClientTypes.PineconeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectionString"].write(value.connectionString)
        try writer["credentialsSecretArn"].write(value.credentialsSecretArn)
        try writer["fieldMapping"].write(value.fieldMapping, with: BedrockAgentClientTypes.PineconeFieldMapping.write(value:to:))
        try writer["namespace"].write(value.namespace)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.PineconeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.PineconeConfiguration()
        value.connectionString = try reader["connectionString"].readIfPresent()
        value.credentialsSecretArn = try reader["credentialsSecretArn"].readIfPresent()
        value.namespace = try reader["namespace"].readIfPresent()
        value.fieldMapping = try reader["fieldMapping"].readIfPresent(with: BedrockAgentClientTypes.PineconeFieldMapping.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about the storage configuration of the knowledge base in Pinecone. For more information, see [Create a vector index in Pinecone](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-pinecone.html).
    public struct PineconeConfiguration {
        /// The endpoint URL for your index management page.
        /// This member is required.
        public var connectionString: Swift.String?
        /// The Amazon Resource Name (ARN) of the secret that you created in Secrets Manager that is linked to your Pinecone API key.
        /// This member is required.
        public var credentialsSecretArn: Swift.String?
        /// Contains the names of the fields to which to map information about the vector store.
        /// This member is required.
        public var fieldMapping: BedrockAgentClientTypes.PineconeFieldMapping?
        /// The namespace to be used to write new data to your database.
        public var namespace: Swift.String?

        public init(
            connectionString: Swift.String? = nil,
            credentialsSecretArn: Swift.String? = nil,
            fieldMapping: BedrockAgentClientTypes.PineconeFieldMapping? = nil,
            namespace: Swift.String? = nil
        )
        {
            self.connectionString = connectionString
            self.credentialsSecretArn = credentialsSecretArn
            self.fieldMapping = fieldMapping
            self.namespace = namespace
        }
    }

}

extension BedrockAgentClientTypes.PineconeFieldMapping {

    static func write(value: BedrockAgentClientTypes.PineconeFieldMapping?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["metadataField"].write(value.metadataField)
        try writer["textField"].write(value.textField)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.PineconeFieldMapping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.PineconeFieldMapping()
        value.textField = try reader["textField"].readIfPresent()
        value.metadataField = try reader["metadataField"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains the names of the fields to which to map information about the vector store.
    public struct PineconeFieldMapping {
        /// The name of the field in which Amazon Bedrock stores metadata about the vector store.
        /// This member is required.
        public var metadataField: Swift.String?
        /// The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        /// This member is required.
        public var textField: Swift.String?

        public init(
            metadataField: Swift.String? = nil,
            textField: Swift.String? = nil
        )
        {
            self.metadataField = metadataField
            self.textField = textField
        }
    }

}

extension PrepareAgentInput {

    static func urlPathProvider(_ value: PrepareAgentInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())"
    }
}

public struct PrepareAgentInput {
    /// The unique identifier of the agent for which to create a DRAFT version.
    /// This member is required.
    public var agentId: Swift.String?

    public init(
        agentId: Swift.String? = nil
    )
    {
        self.agentId = agentId
    }
}

extension PrepareAgentOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> PrepareAgentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PrepareAgentOutput()
        value.agentId = try reader["agentId"].readIfPresent()
        value.agentStatus = try reader["agentStatus"].readIfPresent()
        value.agentVersion = try reader["agentVersion"].readIfPresent()
        value.preparedAt = try reader["preparedAt"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

public struct PrepareAgentOutput {
    /// The unique identifier of the agent for which the DRAFT version was created.
    /// This member is required.
    public var agentId: Swift.String?
    /// The status of the DRAFT version and whether it is ready for use.
    /// This member is required.
    public var agentStatus: BedrockAgentClientTypes.AgentStatus?
    /// The version of the agent.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// The time at which the DRAFT version of the agent was last prepared.
    /// This member is required.
    public var preparedAt: ClientRuntime.Date?

    public init(
        agentId: Swift.String? = nil,
        agentStatus: BedrockAgentClientTypes.AgentStatus? = nil,
        agentVersion: Swift.String? = nil,
        preparedAt: ClientRuntime.Date? = nil
    )
    {
        self.agentId = agentId
        self.agentStatus = agentStatus
        self.agentVersion = agentVersion
        self.preparedAt = preparedAt
    }
}

enum PrepareAgentOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension BedrockAgentClientTypes.PromptConfiguration {

    static func write(value: BedrockAgentClientTypes.PromptConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["basePromptTemplate"].write(value.basePromptTemplate)
        try writer["inferenceConfiguration"].write(value.inferenceConfiguration, with: BedrockAgentClientTypes.InferenceConfiguration.write(value:to:))
        try writer["parserMode"].write(value.parserMode)
        try writer["promptCreationMode"].write(value.promptCreationMode)
        try writer["promptState"].write(value.promptState)
        try writer["promptType"].write(value.promptType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.PromptConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.PromptConfiguration()
        value.promptType = try reader["promptType"].readIfPresent()
        value.promptCreationMode = try reader["promptCreationMode"].readIfPresent()
        value.promptState = try reader["promptState"].readIfPresent()
        value.basePromptTemplate = try reader["basePromptTemplate"].readIfPresent()
        value.inferenceConfiguration = try reader["inferenceConfiguration"].readIfPresent(with: BedrockAgentClientTypes.InferenceConfiguration.read(from:))
        value.parserMode = try reader["parserMode"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains configurations to override a prompt template in one part of an agent sequence. For more information, see [Advanced prompts](https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts.html).
    public struct PromptConfiguration {
        /// Defines the prompt template with which to replace the default prompt template. You can use placeholder variables in the base prompt template to customize the prompt. For more information, see [Prompt template placeholder variables](https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-placeholders.html).
        public var basePromptTemplate: Swift.String?
        /// Contains inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the promptType. For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html).
        public var inferenceConfiguration: BedrockAgentClientTypes.InferenceConfiguration?
        /// Specifies whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the promptType. If you set the field as OVERRIDEN, the overrideLambda field in the [PromptOverrideConfiguration](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptOverrideConfiguration.html) must be specified with the ARN of a Lambda function.
        public var parserMode: BedrockAgentClientTypes.CreationMode?
        /// Specifies whether to override the default prompt template for this promptType. Set this value to OVERRIDDEN to use the prompt that you provide in the basePromptTemplate. If you leave it as DEFAULT, the agent uses a default prompt template.
        public var promptCreationMode: BedrockAgentClientTypes.CreationMode?
        /// Specifies whether to allow the agent to carry out the step specified in the promptType. If you set this value to DISABLED, the agent skips that step. The default state for each promptType is as follows.
        ///
        /// * PRE_PROCESSING – ENABLED
        ///
        /// * ORCHESTRATION – ENABLED
        ///
        /// * KNOWLEDGE_BASE_RESPONSE_GENERATION – ENABLED
        ///
        /// * POST_PROCESSING – DISABLED
        public var promptState: BedrockAgentClientTypes.PromptState?
        /// The step in the agent sequence that this prompt configuration applies to.
        public var promptType: BedrockAgentClientTypes.PromptType?

        public init(
            basePromptTemplate: Swift.String? = nil,
            inferenceConfiguration: BedrockAgentClientTypes.InferenceConfiguration? = nil,
            parserMode: BedrockAgentClientTypes.CreationMode? = nil,
            promptCreationMode: BedrockAgentClientTypes.CreationMode? = nil,
            promptState: BedrockAgentClientTypes.PromptState? = nil,
            promptType: BedrockAgentClientTypes.PromptType? = nil
        )
        {
            self.basePromptTemplate = basePromptTemplate
            self.inferenceConfiguration = inferenceConfiguration
            self.parserMode = parserMode
            self.promptCreationMode = promptCreationMode
            self.promptState = promptState
            self.promptType = promptType
        }
    }

}

extension BedrockAgentClientTypes.PromptOverrideConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentClientTypes.PromptOverrideConfiguration {

    static func write(value: BedrockAgentClientTypes.PromptOverrideConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["overrideLambda"].write(value.overrideLambda)
        try writer["promptConfigurations"].writeList(value.promptConfigurations, memberWritingClosure: BedrockAgentClientTypes.PromptConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.PromptOverrideConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.PromptOverrideConfiguration()
        value.promptConfigurations = try reader["promptConfigurations"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.PromptConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.overrideLambda = try reader["overrideLambda"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains configurations to override prompts in different parts of an agent sequence. For more information, see [Advanced prompts](https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts.html).
    public struct PromptOverrideConfiguration {
        /// The ARN of the Lambda function to use when parsing the raw foundation model output in parts of the agent sequence. If you specify this field, at least one of the promptConfigurations must contain a parserMode value that is set to OVERRIDDEN.
        public var overrideLambda: Swift.String?
        /// Contains configurations to override a prompt template in one part of an agent sequence. For more information, see [Advanced prompts](https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts.html).
        /// This member is required.
        public var promptConfigurations: [BedrockAgentClientTypes.PromptConfiguration]?

        public init(
            overrideLambda: Swift.String? = nil,
            promptConfigurations: [BedrockAgentClientTypes.PromptConfiguration]? = nil
        )
        {
            self.overrideLambda = overrideLambda
            self.promptConfigurations = promptConfigurations
        }
    }

}

extension BedrockAgentClientTypes {

    public enum PromptState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PromptState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    public enum PromptType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case knowledgeBaseResponseGeneration
        case orchestration
        case postProcessing
        case preProcessing
        case sdkUnknown(Swift.String)

        public static var allCases: [PromptType] {
            return [
                .knowledgeBaseResponseGeneration,
                .orchestration,
                .postProcessing,
                .preProcessing,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .knowledgeBaseResponseGeneration: return "KNOWLEDGE_BASE_RESPONSE_GENERATION"
            case .orchestration: return "ORCHESTRATION"
            case .postProcessing: return "POST_PROCESSING"
            case .preProcessing: return "PRE_PROCESSING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes.RdsConfiguration {

    static func write(value: BedrockAgentClientTypes.RdsConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["credentialsSecretArn"].write(value.credentialsSecretArn)
        try writer["databaseName"].write(value.databaseName)
        try writer["fieldMapping"].write(value.fieldMapping, with: BedrockAgentClientTypes.RdsFieldMapping.write(value:to:))
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tableName"].write(value.tableName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.RdsConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.RdsConfiguration()
        value.resourceArn = try reader["resourceArn"].readIfPresent()
        value.credentialsSecretArn = try reader["credentialsSecretArn"].readIfPresent()
        value.databaseName = try reader["databaseName"].readIfPresent()
        value.tableName = try reader["tableName"].readIfPresent()
        value.fieldMapping = try reader["fieldMapping"].readIfPresent(with: BedrockAgentClientTypes.RdsFieldMapping.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about the storage configuration of the knowledge base in Amazon RDS. For more information, see [Create a vector index in Amazon RDS](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-rds.html).
    public struct RdsConfiguration {
        /// The Amazon Resource Name (ARN) of the secret that you created in Secrets Manager that is linked to your Amazon RDS database.
        /// This member is required.
        public var credentialsSecretArn: Swift.String?
        /// The name of your Amazon RDS database.
        /// This member is required.
        public var databaseName: Swift.String?
        /// Contains the names of the fields to which to map information about the vector store.
        /// This member is required.
        public var fieldMapping: BedrockAgentClientTypes.RdsFieldMapping?
        /// The Amazon Resource Name (ARN) of the vector store.
        /// This member is required.
        public var resourceArn: Swift.String?
        /// The name of the table in the database.
        /// This member is required.
        public var tableName: Swift.String?

        public init(
            credentialsSecretArn: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            fieldMapping: BedrockAgentClientTypes.RdsFieldMapping? = nil,
            resourceArn: Swift.String? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.credentialsSecretArn = credentialsSecretArn
            self.databaseName = databaseName
            self.fieldMapping = fieldMapping
            self.resourceArn = resourceArn
            self.tableName = tableName
        }
    }

}

extension BedrockAgentClientTypes.RdsFieldMapping {

    static func write(value: BedrockAgentClientTypes.RdsFieldMapping?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["metadataField"].write(value.metadataField)
        try writer["primaryKeyField"].write(value.primaryKeyField)
        try writer["textField"].write(value.textField)
        try writer["vectorField"].write(value.vectorField)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.RdsFieldMapping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.RdsFieldMapping()
        value.primaryKeyField = try reader["primaryKeyField"].readIfPresent()
        value.vectorField = try reader["vectorField"].readIfPresent()
        value.textField = try reader["textField"].readIfPresent()
        value.metadataField = try reader["metadataField"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains the names of the fields to which to map information about the vector store.
    public struct RdsFieldMapping {
        /// The name of the field in which Amazon Bedrock stores metadata about the vector store.
        /// This member is required.
        public var metadataField: Swift.String?
        /// The name of the field in which Amazon Bedrock stores the ID for each entry.
        /// This member is required.
        public var primaryKeyField: Swift.String?
        /// The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        /// This member is required.
        public var textField: Swift.String?
        /// The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        /// This member is required.
        public var vectorField: Swift.String?

        public init(
            metadataField: Swift.String? = nil,
            primaryKeyField: Swift.String? = nil,
            textField: Swift.String? = nil,
            vectorField: Swift.String? = nil
        )
        {
            self.metadataField = metadataField
            self.primaryKeyField = primaryKeyField
            self.textField = textField
            self.vectorField = vectorField
        }
    }

}

extension BedrockAgentClientTypes.RedisEnterpriseCloudConfiguration {

    static func write(value: BedrockAgentClientTypes.RedisEnterpriseCloudConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["credentialsSecretArn"].write(value.credentialsSecretArn)
        try writer["endpoint"].write(value.endpoint)
        try writer["fieldMapping"].write(value.fieldMapping, with: BedrockAgentClientTypes.RedisEnterpriseCloudFieldMapping.write(value:to:))
        try writer["vectorIndexName"].write(value.vectorIndexName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.RedisEnterpriseCloudConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.RedisEnterpriseCloudConfiguration()
        value.endpoint = try reader["endpoint"].readIfPresent()
        value.vectorIndexName = try reader["vectorIndexName"].readIfPresent()
        value.credentialsSecretArn = try reader["credentialsSecretArn"].readIfPresent()
        value.fieldMapping = try reader["fieldMapping"].readIfPresent(with: BedrockAgentClientTypes.RedisEnterpriseCloudFieldMapping.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about the storage configuration of the knowledge base in Redis Enterprise Cloud. For more information, see [Create a vector index in Redis Enterprise Cloud](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-oss.html).
    public struct RedisEnterpriseCloudConfiguration {
        /// The Amazon Resource Name (ARN) of the secret that you created in Secrets Manager that is linked to your Redis Enterprise Cloud database.
        /// This member is required.
        public var credentialsSecretArn: Swift.String?
        /// The endpoint URL of the Redis Enterprise Cloud database.
        /// This member is required.
        public var endpoint: Swift.String?
        /// Contains the names of the fields to which to map information about the vector store.
        /// This member is required.
        public var fieldMapping: BedrockAgentClientTypes.RedisEnterpriseCloudFieldMapping?
        /// The name of the vector index.
        /// This member is required.
        public var vectorIndexName: Swift.String?

        public init(
            credentialsSecretArn: Swift.String? = nil,
            endpoint: Swift.String? = nil,
            fieldMapping: BedrockAgentClientTypes.RedisEnterpriseCloudFieldMapping? = nil,
            vectorIndexName: Swift.String? = nil
        )
        {
            self.credentialsSecretArn = credentialsSecretArn
            self.endpoint = endpoint
            self.fieldMapping = fieldMapping
            self.vectorIndexName = vectorIndexName
        }
    }

}

extension BedrockAgentClientTypes.RedisEnterpriseCloudFieldMapping {

    static func write(value: BedrockAgentClientTypes.RedisEnterpriseCloudFieldMapping?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["metadataField"].write(value.metadataField)
        try writer["textField"].write(value.textField)
        try writer["vectorField"].write(value.vectorField)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.RedisEnterpriseCloudFieldMapping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.RedisEnterpriseCloudFieldMapping()
        value.vectorField = try reader["vectorField"].readIfPresent()
        value.textField = try reader["textField"].readIfPresent()
        value.metadataField = try reader["metadataField"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains the names of the fields to which to map information about the vector store.
    public struct RedisEnterpriseCloudFieldMapping {
        /// The name of the field in which Amazon Bedrock stores metadata about the vector store.
        /// This member is required.
        public var metadataField: Swift.String?
        /// The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        /// This member is required.
        public var textField: Swift.String?
        /// The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        /// This member is required.
        public var vectorField: Swift.String?

        public init(
            metadataField: Swift.String? = nil,
            textField: Swift.String? = nil,
            vectorField: Swift.String? = nil
        )
        {
            self.metadataField = metadataField
            self.textField = textField
            self.vectorField = vectorField
        }
    }

}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The specified resource Amazon Resource Name (ARN) was not found. Check the Amazon Resource Name (ARN) and try your request again.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BedrockAgentClientTypes.S3DataSourceConfiguration {

    static func write(value: BedrockAgentClientTypes.S3DataSourceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketArn"].write(value.bucketArn)
        try writer["bucketOwnerAccountId"].write(value.bucketOwnerAccountId)
        try writer["inclusionPrefixes"].writeList(value.inclusionPrefixes, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.S3DataSourceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.S3DataSourceConfiguration()
        value.bucketArn = try reader["bucketArn"].readIfPresent()
        value.inclusionPrefixes = try reader["inclusionPrefixes"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.bucketOwnerAccountId = try reader["bucketOwnerAccountId"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains information about the S3 configuration of the data source.
    public struct S3DataSourceConfiguration {
        /// The Amazon Resource Name (ARN) of the bucket that contains the data source.
        /// This member is required.
        public var bucketArn: Swift.String?
        /// The bucket account owner ID for the S3 bucket.
        public var bucketOwnerAccountId: Swift.String?
        /// A list of S3 prefixes that define the object containing the data sources. For more information, see [Organizing objects using prefixes](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-prefixes.html).
        public var inclusionPrefixes: [Swift.String]?

        public init(
            bucketArn: Swift.String? = nil,
            bucketOwnerAccountId: Swift.String? = nil,
            inclusionPrefixes: [Swift.String]? = nil
        )
        {
            self.bucketArn = bucketArn
            self.bucketOwnerAccountId = bucketOwnerAccountId
            self.inclusionPrefixes = inclusionPrefixes
        }
    }

}

extension BedrockAgentClientTypes.S3Identifier {

    static func write(value: BedrockAgentClientTypes.S3Identifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3BucketName"].write(value.s3BucketName)
        try writer["s3ObjectKey"].write(value.s3ObjectKey)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.S3Identifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.S3Identifier()
        value.s3BucketName = try reader["s3BucketName"].readIfPresent()
        value.s3ObjectKey = try reader["s3ObjectKey"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains information about the S3 object containing the resource.
    public struct S3Identifier {
        /// The name of the S3 bucket.
        public var s3BucketName: Swift.String?
        /// The S3 object key containing the resource.
        public var s3ObjectKey: Swift.String?

        public init(
            s3BucketName: Swift.String? = nil,
            s3ObjectKey: Swift.String? = nil
        )
        {
            self.s3BucketName = s3BucketName
            self.s3ObjectKey = s3ObjectKey
        }
    }

}

extension BedrockAgentClientTypes.ServerSideEncryptionConfiguration {

    static func write(value: BedrockAgentClientTypes.ServerSideEncryptionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["kmsKeyArn"].write(value.kmsKeyArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.ServerSideEncryptionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.ServerSideEncryptionConfiguration()
        value.kmsKeyArn = try reader["kmsKeyArn"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains the configuration for server-side encryption.
    public struct ServerSideEncryptionConfiguration {
        /// The Amazon Resource Name (ARN) of the KMS key used to encrypt the resource.
        public var kmsKeyArn: Swift.String?

        public init(
            kmsKeyArn: Swift.String? = nil
        )
        {
            self.kmsKeyArn = kmsKeyArn
        }
    }

}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The number of requests exceeds the service quota. Resubmit your request later.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BedrockAgentClientTypes {

    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension StartIngestionJobInput {

    static func urlPathProvider(_ value: StartIngestionJobInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let dataSourceId = value.dataSourceId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())/ingestionjobs"
    }
}

extension StartIngestionJobInput {

    static func write(value: StartIngestionJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
    }
}

public struct StartIngestionJobInput {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The unique identifier of the data source to ingest.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// A description of the ingestion job.
    public var description: Swift.String?
    /// The unique identifier of the knowledge base to which to add the data source.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        description: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.dataSourceId = dataSourceId
        self.description = description
        self.knowledgeBaseId = knowledgeBaseId
    }
}

extension StartIngestionJobOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> StartIngestionJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartIngestionJobOutput()
        value.ingestionJob = try reader["ingestionJob"].readIfPresent(with: BedrockAgentClientTypes.IngestionJob.read(from:))
        return value
    }
}

public struct StartIngestionJobOutput {
    /// An object containing information about the ingestion job.
    /// This member is required.
    public var ingestionJob: BedrockAgentClientTypes.IngestionJob?

    public init(
        ingestionJob: BedrockAgentClientTypes.IngestionJob? = nil
    )
    {
        self.ingestionJob = ingestionJob
    }
}

enum StartIngestionJobOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension BedrockAgentClientTypes.StorageConfiguration {

    static func write(value: BedrockAgentClientTypes.StorageConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["mongoDbAtlasConfiguration"].write(value.mongoDbAtlasConfiguration, with: BedrockAgentClientTypes.MongoDbAtlasConfiguration.write(value:to:))
        try writer["opensearchServerlessConfiguration"].write(value.opensearchServerlessConfiguration, with: BedrockAgentClientTypes.OpenSearchServerlessConfiguration.write(value:to:))
        try writer["pineconeConfiguration"].write(value.pineconeConfiguration, with: BedrockAgentClientTypes.PineconeConfiguration.write(value:to:))
        try writer["rdsConfiguration"].write(value.rdsConfiguration, with: BedrockAgentClientTypes.RdsConfiguration.write(value:to:))
        try writer["redisEnterpriseCloudConfiguration"].write(value.redisEnterpriseCloudConfiguration, with: BedrockAgentClientTypes.RedisEnterpriseCloudConfiguration.write(value:to:))
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.StorageConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.StorageConfiguration()
        value.type = try reader["type"].readIfPresent()
        value.opensearchServerlessConfiguration = try reader["opensearchServerlessConfiguration"].readIfPresent(with: BedrockAgentClientTypes.OpenSearchServerlessConfiguration.read(from:))
        value.pineconeConfiguration = try reader["pineconeConfiguration"].readIfPresent(with: BedrockAgentClientTypes.PineconeConfiguration.read(from:))
        value.redisEnterpriseCloudConfiguration = try reader["redisEnterpriseCloudConfiguration"].readIfPresent(with: BedrockAgentClientTypes.RedisEnterpriseCloudConfiguration.read(from:))
        value.rdsConfiguration = try reader["rdsConfiguration"].readIfPresent(with: BedrockAgentClientTypes.RdsConfiguration.read(from:))
        value.mongoDbAtlasConfiguration = try reader["mongoDbAtlasConfiguration"].readIfPresent(with: BedrockAgentClientTypes.MongoDbAtlasConfiguration.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains the storage configuration of the knowledge base.
    public struct StorageConfiguration {
        /// Contains the storage configuration of the knowledge base in MongoDB Atlas.
        public var mongoDbAtlasConfiguration: BedrockAgentClientTypes.MongoDbAtlasConfiguration?
        /// Contains the storage configuration of the knowledge base in Amazon OpenSearch Service.
        public var opensearchServerlessConfiguration: BedrockAgentClientTypes.OpenSearchServerlessConfiguration?
        /// Contains the storage configuration of the knowledge base in Pinecone.
        public var pineconeConfiguration: BedrockAgentClientTypes.PineconeConfiguration?
        /// Contains details about the storage configuration of the knowledge base in Amazon RDS. For more information, see [Create a vector index in Amazon RDS](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-rds.html).
        public var rdsConfiguration: BedrockAgentClientTypes.RdsConfiguration?
        /// Contains the storage configuration of the knowledge base in Redis Enterprise Cloud.
        public var redisEnterpriseCloudConfiguration: BedrockAgentClientTypes.RedisEnterpriseCloudConfiguration?
        /// The vector store service in which the knowledge base is stored.
        /// This member is required.
        public var type: BedrockAgentClientTypes.KnowledgeBaseStorageType?

        public init(
            mongoDbAtlasConfiguration: BedrockAgentClientTypes.MongoDbAtlasConfiguration? = nil,
            opensearchServerlessConfiguration: BedrockAgentClientTypes.OpenSearchServerlessConfiguration? = nil,
            pineconeConfiguration: BedrockAgentClientTypes.PineconeConfiguration? = nil,
            rdsConfiguration: BedrockAgentClientTypes.RdsConfiguration? = nil,
            redisEnterpriseCloudConfiguration: BedrockAgentClientTypes.RedisEnterpriseCloudConfiguration? = nil,
            type: BedrockAgentClientTypes.KnowledgeBaseStorageType? = nil
        )
        {
            self.mongoDbAtlasConfiguration = mongoDbAtlasConfiguration
            self.opensearchServerlessConfiguration = opensearchServerlessConfiguration
            self.pineconeConfiguration = pineconeConfiguration
            self.rdsConfiguration = rdsConfiguration
            self.redisEnterpriseCloudConfiguration = redisEnterpriseCloudConfiguration
            self.type = type
        }
    }

}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// An object containing key-value pairs that define the tags to attach to the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

public struct TagResourceOutput {

    public init() { }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The number of requests exceeds the limit. Resubmit your request later.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BedrockAgentClientTypes {

    public enum ModelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case array
        case boolean
        case integer
        case number
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelType] {
            return [
                .array,
                .boolean,
                .integer,
                .number,
                .string,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .array: return "array"
            case .boolean: return "boolean"
            case .integer: return "integer"
            case .number: return "number"
            case .string: return "string"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource from which to remove tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of keys of the tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

public struct UntagResourceOutput {

    public init() { }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateAgentActionGroupInput {

    static func urlPathProvider(_ value: UpdateAgentActionGroupInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        guard let actionGroupId = value.actionGroupId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/actiongroups/\(actionGroupId.urlPercentEncoding())"
    }
}

extension UpdateAgentActionGroupInput {

    static func write(value: UpdateAgentActionGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionGroupExecutor"].write(value.actionGroupExecutor, with: BedrockAgentClientTypes.ActionGroupExecutor.write(value:to:))
        try writer["actionGroupName"].write(value.actionGroupName)
        try writer["actionGroupState"].write(value.actionGroupState)
        try writer["apiSchema"].write(value.apiSchema, with: BedrockAgentClientTypes.APISchema.write(value:to:))
        try writer["description"].write(value.description)
        try writer["functionSchema"].write(value.functionSchema, with: BedrockAgentClientTypes.FunctionSchema.write(value:to:))
        try writer["parentActionGroupSignature"].write(value.parentActionGroupSignature)
    }
}

public struct UpdateAgentActionGroupInput {
    /// The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action.
    public var actionGroupExecutor: BedrockAgentClientTypes.ActionGroupExecutor?
    /// The unique identifier of the action group.
    /// This member is required.
    public var actionGroupId: Swift.String?
    /// Specifies a new name for the action group.
    /// This member is required.
    public var actionGroupName: Swift.String?
    /// Specifies whether the action group is available for the agent to invoke or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
    public var actionGroupState: BedrockAgentClientTypes.ActionGroupState?
    /// The unique identifier of the agent for which to update the action group.
    /// This member is required.
    public var agentId: Swift.String?
    /// The unique identifier of the agent version for which to update the action group.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted payload defining the schema. For more information, see [Action group OpenAPI schemas](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-api-schema.html).
    public var apiSchema: BedrockAgentClientTypes.APISchema?
    /// Specifies a new name for the action group.
    public var description: Swift.String?
    /// Contains details about the function schema for the action group or the JSON or YAML-formatted payload defining the schema.
    public var functionSchema: BedrockAgentClientTypes.FunctionSchema?
    /// To allow your agent to request the user for additional information when trying to complete a task, set this field to AMAZON.UserInput. You must leave the description, apiSchema, and actionGroupExecutor fields blank for this action group. During orchestration, if your agent determines that it needs to invoke an API in an action group, but doesn't have enough information to complete the API request, it will invoke this action group instead and return an [Observation](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Observation.html) reprompting the user for more information.
    public var parentActionGroupSignature: BedrockAgentClientTypes.ActionGroupSignature?

    public init(
        actionGroupExecutor: BedrockAgentClientTypes.ActionGroupExecutor? = nil,
        actionGroupId: Swift.String? = nil,
        actionGroupName: Swift.String? = nil,
        actionGroupState: BedrockAgentClientTypes.ActionGroupState? = nil,
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        apiSchema: BedrockAgentClientTypes.APISchema? = nil,
        description: Swift.String? = nil,
        functionSchema: BedrockAgentClientTypes.FunctionSchema? = nil,
        parentActionGroupSignature: BedrockAgentClientTypes.ActionGroupSignature? = nil
    )
    {
        self.actionGroupExecutor = actionGroupExecutor
        self.actionGroupId = actionGroupId
        self.actionGroupName = actionGroupName
        self.actionGroupState = actionGroupState
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.apiSchema = apiSchema
        self.description = description
        self.functionSchema = functionSchema
        self.parentActionGroupSignature = parentActionGroupSignature
    }
}

extension UpdateAgentActionGroupOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateAgentActionGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAgentActionGroupOutput()
        value.agentActionGroup = try reader["agentActionGroup"].readIfPresent(with: BedrockAgentClientTypes.AgentActionGroup.read(from:))
        return value
    }
}

public struct UpdateAgentActionGroupOutput {
    /// Contains details about the action group that was updated.
    /// This member is required.
    public var agentActionGroup: BedrockAgentClientTypes.AgentActionGroup?

    public init(
        agentActionGroup: BedrockAgentClientTypes.AgentActionGroup? = nil
    )
    {
        self.agentActionGroup = agentActionGroup
    }
}

enum UpdateAgentActionGroupOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateAgentAliasInput {

    static func urlPathProvider(_ value: UpdateAgentAliasInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentAliasId = value.agentAliasId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentaliases/\(agentAliasId.urlPercentEncoding())"
    }
}

extension UpdateAgentAliasInput {

    static func write(value: UpdateAgentAliasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["agentAliasName"].write(value.agentAliasName)
        try writer["description"].write(value.description)
        try writer["routingConfiguration"].writeList(value.routingConfiguration, memberWritingClosure: BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct UpdateAgentAliasInput {
    /// The unique identifier of the alias.
    /// This member is required.
    public var agentAliasId: Swift.String?
    /// Specifies a new name for the alias.
    /// This member is required.
    public var agentAliasName: Swift.String?
    /// The unique identifier of the agent.
    /// This member is required.
    public var agentId: Swift.String?
    /// Specifies a new description for the alias.
    public var description: Swift.String?
    /// Contains details about the routing configuration of the alias.
    public var routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]?

    public init(
        agentAliasId: Swift.String? = nil,
        agentAliasName: Swift.String? = nil,
        agentId: Swift.String? = nil,
        description: Swift.String? = nil,
        routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]? = nil
    )
    {
        self.agentAliasId = agentAliasId
        self.agentAliasName = agentAliasName
        self.agentId = agentId
        self.description = description
        self.routingConfiguration = routingConfiguration
    }
}

extension UpdateAgentAliasOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateAgentAliasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAgentAliasOutput()
        value.agentAlias = try reader["agentAlias"].readIfPresent(with: BedrockAgentClientTypes.AgentAlias.read(from:))
        return value
    }
}

public struct UpdateAgentAliasOutput {
    /// Contains details about the alias that was updated.
    /// This member is required.
    public var agentAlias: BedrockAgentClientTypes.AgentAlias?

    public init(
        agentAlias: BedrockAgentClientTypes.AgentAlias? = nil
    )
    {
        self.agentAlias = agentAlias
    }
}

enum UpdateAgentAliasOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateAgentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAgentInput(agentId: \(Swift.String(describing: agentId)), agentName: \(Swift.String(describing: agentName)), agentResourceRoleArn: \(Swift.String(describing: agentResourceRoleArn)), customerEncryptionKeyArn: \(Swift.String(describing: customerEncryptionKeyArn)), description: \(Swift.String(describing: description)), foundationModel: \(Swift.String(describing: foundationModel)), idleSessionTTLInSeconds: \(Swift.String(describing: idleSessionTTLInSeconds)), instruction: \"CONTENT_REDACTED\", promptOverrideConfiguration: \"CONTENT_REDACTED\")"}
}

extension UpdateAgentInput {

    static func urlPathProvider(_ value: UpdateAgentInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())"
    }
}

extension UpdateAgentInput {

    static func write(value: UpdateAgentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["agentName"].write(value.agentName)
        try writer["agentResourceRoleArn"].write(value.agentResourceRoleArn)
        try writer["customerEncryptionKeyArn"].write(value.customerEncryptionKeyArn)
        try writer["description"].write(value.description)
        try writer["foundationModel"].write(value.foundationModel)
        try writer["idleSessionTTLInSeconds"].write(value.idleSessionTTLInSeconds)
        try writer["instruction"].write(value.instruction)
        try writer["promptOverrideConfiguration"].write(value.promptOverrideConfiguration, with: BedrockAgentClientTypes.PromptOverrideConfiguration.write(value:to:))
    }
}

public struct UpdateAgentInput {
    /// The unique identifier of the agent.
    /// This member is required.
    public var agentId: Swift.String?
    /// Specifies a new name for the agent.
    /// This member is required.
    public var agentName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the agent.
    /// This member is required.
    public var agentResourceRoleArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the KMS key with which to encrypt the agent.
    public var customerEncryptionKeyArn: Swift.String?
    /// Specifies a new description of the agent.
    public var description: Swift.String?
    /// Specifies a new foundation model to be used for orchestration by the agent.
    /// This member is required.
    public var foundationModel: Swift.String?
    /// The number of seconds for which Amazon Bedrock keeps information about a user's conversation with the agent. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Bedrock deletes any data provided before the timeout.
    public var idleSessionTTLInSeconds: Swift.Int?
    /// Specifies new instructions that tell the agent what it should do and how it should interact with users.
    public var instruction: Swift.String?
    /// Contains configurations to override prompts in different parts of an agent sequence. For more information, see [Advanced prompts](https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts.html).
    public var promptOverrideConfiguration: BedrockAgentClientTypes.PromptOverrideConfiguration?

    public init(
        agentId: Swift.String? = nil,
        agentName: Swift.String? = nil,
        agentResourceRoleArn: Swift.String? = nil,
        customerEncryptionKeyArn: Swift.String? = nil,
        description: Swift.String? = nil,
        foundationModel: Swift.String? = nil,
        idleSessionTTLInSeconds: Swift.Int? = nil,
        instruction: Swift.String? = nil,
        promptOverrideConfiguration: BedrockAgentClientTypes.PromptOverrideConfiguration? = nil
    )
    {
        self.agentId = agentId
        self.agentName = agentName
        self.agentResourceRoleArn = agentResourceRoleArn
        self.customerEncryptionKeyArn = customerEncryptionKeyArn
        self.description = description
        self.foundationModel = foundationModel
        self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
        self.instruction = instruction
        self.promptOverrideConfiguration = promptOverrideConfiguration
    }
}

extension UpdateAgentKnowledgeBaseInput {

    static func urlPathProvider(_ value: UpdateAgentKnowledgeBaseInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())"
    }
}

extension UpdateAgentKnowledgeBaseInput {

    static func write(value: UpdateAgentKnowledgeBaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["knowledgeBaseState"].write(value.knowledgeBaseState)
    }
}

public struct UpdateAgentKnowledgeBaseInput {
    /// The unique identifier of the agent associated with the knowledge base that you want to update.
    /// This member is required.
    public var agentId: Swift.String?
    /// The version of the agent associated with the knowledge base that you want to update.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// Specifies a new description for the knowledge base associated with an agent.
    public var description: Swift.String?
    /// The unique identifier of the knowledge base that has been associated with an agent.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// Specifies whether the agent uses the knowledge base or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
    public var knowledgeBaseState: BedrockAgentClientTypes.KnowledgeBaseState?

    public init(
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        description: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil,
        knowledgeBaseState: BedrockAgentClientTypes.KnowledgeBaseState? = nil
    )
    {
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.description = description
        self.knowledgeBaseId = knowledgeBaseId
        self.knowledgeBaseState = knowledgeBaseState
    }
}

extension UpdateAgentKnowledgeBaseOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateAgentKnowledgeBaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAgentKnowledgeBaseOutput()
        value.agentKnowledgeBase = try reader["agentKnowledgeBase"].readIfPresent(with: BedrockAgentClientTypes.AgentKnowledgeBase.read(from:))
        return value
    }
}

public struct UpdateAgentKnowledgeBaseOutput {
    /// Contains details about the knowledge base that has been associated with an agent.
    /// This member is required.
    public var agentKnowledgeBase: BedrockAgentClientTypes.AgentKnowledgeBase?

    public init(
        agentKnowledgeBase: BedrockAgentClientTypes.AgentKnowledgeBase? = nil
    )
    {
        self.agentKnowledgeBase = agentKnowledgeBase
    }
}

enum UpdateAgentKnowledgeBaseOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateAgentOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateAgentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAgentOutput()
        value.agent = try reader["agent"].readIfPresent(with: BedrockAgentClientTypes.Agent.read(from:))
        return value
    }
}

public struct UpdateAgentOutput {
    /// Contains details about the agent that was updated.
    /// This member is required.
    public var agent: BedrockAgentClientTypes.Agent?

    public init(
        agent: BedrockAgentClientTypes.Agent? = nil
    )
    {
        self.agent = agent
    }
}

enum UpdateAgentOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateDataSourceInput {

    static func urlPathProvider(_ value: UpdateDataSourceInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let dataSourceId = value.dataSourceId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())"
    }
}

extension UpdateDataSourceInput {

    static func write(value: UpdateDataSourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataDeletionPolicy"].write(value.dataDeletionPolicy)
        try writer["dataSourceConfiguration"].write(value.dataSourceConfiguration, with: BedrockAgentClientTypes.DataSourceConfiguration.write(value:to:))
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["serverSideEncryptionConfiguration"].write(value.serverSideEncryptionConfiguration, with: BedrockAgentClientTypes.ServerSideEncryptionConfiguration.write(value:to:))
        try writer["vectorIngestionConfiguration"].write(value.vectorIngestionConfiguration, with: BedrockAgentClientTypes.VectorIngestionConfiguration.write(value:to:))
    }
}

public struct UpdateDataSourceInput {
    /// The data deletion policy of the updated data source.
    public var dataDeletionPolicy: BedrockAgentClientTypes.DataDeletionPolicy?
    /// Contains details about the storage configuration of the data source.
    /// This member is required.
    public var dataSourceConfiguration: BedrockAgentClientTypes.DataSourceConfiguration?
    /// The unique identifier of the data source.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// Specifies a new description for the data source.
    public var description: Swift.String?
    /// The unique identifier of the knowledge base to which the data source belongs.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// Specifies a new name for the data source.
    /// This member is required.
    public var name: Swift.String?
    /// Contains details about server-side encryption of the data source.
    public var serverSideEncryptionConfiguration: BedrockAgentClientTypes.ServerSideEncryptionConfiguration?
    /// Contains details about how to ingest the documents in the data source.
    public var vectorIngestionConfiguration: BedrockAgentClientTypes.VectorIngestionConfiguration?

    public init(
        dataDeletionPolicy: BedrockAgentClientTypes.DataDeletionPolicy? = nil,
        dataSourceConfiguration: BedrockAgentClientTypes.DataSourceConfiguration? = nil,
        dataSourceId: Swift.String? = nil,
        description: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil,
        name: Swift.String? = nil,
        serverSideEncryptionConfiguration: BedrockAgentClientTypes.ServerSideEncryptionConfiguration? = nil,
        vectorIngestionConfiguration: BedrockAgentClientTypes.VectorIngestionConfiguration? = nil
    )
    {
        self.dataDeletionPolicy = dataDeletionPolicy
        self.dataSourceConfiguration = dataSourceConfiguration
        self.dataSourceId = dataSourceId
        self.description = description
        self.knowledgeBaseId = knowledgeBaseId
        self.name = name
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
        self.vectorIngestionConfiguration = vectorIngestionConfiguration
    }
}

extension UpdateDataSourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateDataSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDataSourceOutput()
        value.dataSource = try reader["dataSource"].readIfPresent(with: BedrockAgentClientTypes.DataSource.read(from:))
        return value
    }
}

public struct UpdateDataSourceOutput {
    /// Contains details about the data source.
    /// This member is required.
    public var dataSource: BedrockAgentClientTypes.DataSource?

    public init(
        dataSource: BedrockAgentClientTypes.DataSource? = nil
    )
    {
        self.dataSource = dataSource
    }
}

enum UpdateDataSourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateKnowledgeBaseInput {

    static func urlPathProvider(_ value: UpdateKnowledgeBaseInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())"
    }
}

extension UpdateKnowledgeBaseInput {

    static func write(value: UpdateKnowledgeBaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["knowledgeBaseConfiguration"].write(value.knowledgeBaseConfiguration, with: BedrockAgentClientTypes.KnowledgeBaseConfiguration.write(value:to:))
        try writer["name"].write(value.name)
        try writer["roleArn"].write(value.roleArn)
        try writer["storageConfiguration"].write(value.storageConfiguration, with: BedrockAgentClientTypes.StorageConfiguration.write(value:to:))
    }
}

public struct UpdateKnowledgeBaseInput {
    /// Specifies a new description for the knowledge base.
    public var description: Swift.String?
    /// Specifies the configuration for the embeddings model used for the knowledge base. You must use the same configuration as when the knowledge base was created.
    /// This member is required.
    public var knowledgeBaseConfiguration: BedrockAgentClientTypes.KnowledgeBaseConfiguration?
    /// The unique identifier of the knowledge base to update.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// Specifies a new name for the knowledge base.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies a different Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the knowledge base.
    /// This member is required.
    public var roleArn: Swift.String?
    /// Specifies the configuration for the vector store used for the knowledge base. You must use the same configuration as when the knowledge base was created.
    /// This member is required.
    public var storageConfiguration: BedrockAgentClientTypes.StorageConfiguration?

    public init(
        description: Swift.String? = nil,
        knowledgeBaseConfiguration: BedrockAgentClientTypes.KnowledgeBaseConfiguration? = nil,
        knowledgeBaseId: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        storageConfiguration: BedrockAgentClientTypes.StorageConfiguration? = nil
    )
    {
        self.description = description
        self.knowledgeBaseConfiguration = knowledgeBaseConfiguration
        self.knowledgeBaseId = knowledgeBaseId
        self.name = name
        self.roleArn = roleArn
        self.storageConfiguration = storageConfiguration
    }
}

extension UpdateKnowledgeBaseOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateKnowledgeBaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateKnowledgeBaseOutput()
        value.knowledgeBase = try reader["knowledgeBase"].readIfPresent(with: BedrockAgentClientTypes.KnowledgeBase.read(from:))
        return value
    }
}

public struct UpdateKnowledgeBaseOutput {
    /// Contains details about the knowledge base.
    /// This member is required.
    public var knowledgeBase: BedrockAgentClientTypes.KnowledgeBase?

    public init(
        knowledgeBase: BedrockAgentClientTypes.KnowledgeBase? = nil
    )
    {
        self.knowledgeBase = knowledgeBase
    }
}

enum UpdateKnowledgeBaseOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Input validation failed. Check your request parameters and retry the request.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A list of objects containing fields that caused validation errors and their corresponding validation error messages.
        public internal(set) var fieldList: [BedrockAgentClientTypes.ValidationExceptionField]? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [BedrockAgentClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
    }
}

extension BedrockAgentClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Stores information about a field passed inside a request that resulted in an validation error.
    public struct ValidationExceptionField {
        /// A message describing why this field failed validation.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension BedrockAgentClientTypes.VectorIngestionConfiguration {

    static func write(value: BedrockAgentClientTypes.VectorIngestionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["chunkingConfiguration"].write(value.chunkingConfiguration, with: BedrockAgentClientTypes.ChunkingConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.VectorIngestionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.VectorIngestionConfiguration()
        value.chunkingConfiguration = try reader["chunkingConfiguration"].readIfPresent(with: BedrockAgentClientTypes.ChunkingConfiguration.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about how to ingest the documents in a data source.
    public struct VectorIngestionConfiguration {
        /// Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.
        public var chunkingConfiguration: BedrockAgentClientTypes.ChunkingConfiguration?

        public init(
            chunkingConfiguration: BedrockAgentClientTypes.ChunkingConfiguration? = nil
        )
        {
            self.chunkingConfiguration = chunkingConfiguration
        }
    }

}

extension BedrockAgentClientTypes.VectorKnowledgeBaseConfiguration {

    static func write(value: BedrockAgentClientTypes.VectorKnowledgeBaseConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["embeddingModelArn"].write(value.embeddingModelArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.VectorKnowledgeBaseConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.VectorKnowledgeBaseConfiguration()
        value.embeddingModelArn = try reader["embeddingModelArn"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes {
    /// Contains details about the model used to create vector embeddings for the knowledge base.
    public struct VectorKnowledgeBaseConfiguration {
        /// The Amazon Resource Name (ARN) of the model used to create vector embeddings for the knowledge base.
        /// This member is required.
        public var embeddingModelArn: Swift.String?

        public init(
            embeddingModelArn: Swift.String? = nil
        )
        {
            self.embeddingModelArn = embeddingModelArn
        }
    }

}
