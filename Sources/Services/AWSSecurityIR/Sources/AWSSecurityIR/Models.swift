//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

///
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SecurityIRClientTypes {

    public enum AwsRegion: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case afSouth1
        case apEast1
        case apNortheast1
        case apNortheast2
        case apNortheast3
        case apSoutheast1
        case apSoutheast2
        case apSoutheast3
        case apSoutheast4
        case apSoutheast5
        case apSouth1
        case apSouth2
        case caCentral1
        case caWest1
        case cnNorthwest1
        case cnNorth1
        case euCentral1
        case euCentral2
        case euNorth1
        case euSouth1
        case euSouth2
        case euWest1
        case euWest2
        case euWest3
        case ilCentral1
        case meCentral1
        case meSouth1
        case saEast1
        case usEast1
        case usEast2
        case usWest1
        case usWest2
        case sdkUnknown(Swift.String)

        public static var allCases: [AwsRegion] {
            return [
                .afSouth1,
                .apEast1,
                .apNortheast1,
                .apNortheast2,
                .apNortheast3,
                .apSoutheast1,
                .apSoutheast2,
                .apSoutheast3,
                .apSoutheast4,
                .apSoutheast5,
                .apSouth1,
                .apSouth2,
                .caCentral1,
                .caWest1,
                .cnNorthwest1,
                .cnNorth1,
                .euCentral1,
                .euCentral2,
                .euNorth1,
                .euSouth1,
                .euSouth2,
                .euWest1,
                .euWest2,
                .euWest3,
                .ilCentral1,
                .meCentral1,
                .meSouth1,
                .saEast1,
                .usEast1,
                .usEast2,
                .usWest1,
                .usWest2
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .afSouth1: return "af-south-1"
            case .apEast1: return "ap-east-1"
            case .apNortheast1: return "ap-northeast-1"
            case .apNortheast2: return "ap-northeast-2"
            case .apNortheast3: return "ap-northeast-3"
            case .apSoutheast1: return "ap-southeast-1"
            case .apSoutheast2: return "ap-southeast-2"
            case .apSoutheast3: return "ap-southeast-3"
            case .apSoutheast4: return "ap-southeast-4"
            case .apSoutheast5: return "ap-southeast-5"
            case .apSouth1: return "ap-south-1"
            case .apSouth2: return "ap-south-2"
            case .caCentral1: return "ca-central-1"
            case .caWest1: return "ca-west-1"
            case .cnNorthwest1: return "cn-northwest-1"
            case .cnNorth1: return "cn-north-1"
            case .euCentral1: return "eu-central-1"
            case .euCentral2: return "eu-central-2"
            case .euNorth1: return "eu-north-1"
            case .euSouth1: return "eu-south-1"
            case .euSouth2: return "eu-south-2"
            case .euWest1: return "eu-west-1"
            case .euWest2: return "eu-west-2"
            case .euWest3: return "eu-west-3"
            case .ilCentral1: return "il-central-1"
            case .meCentral1: return "me-central-1"
            case .meSouth1: return "me-south-1"
            case .saEast1: return "sa-east-1"
            case .usEast1: return "us-east-1"
            case .usEast2: return "us-east-2"
            case .usWest1: return "us-west-1"
            case .usWest2: return "us-west-2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct BatchGetMemberAccountDetailsInput: Swift.Sendable {
    /// Optional element to query the membership relationship status to a provided list of account IDs.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// Required element used in combination with BatchGetMemberAccountDetails to identify the membership ID to query.
    /// This member is required.
    public var membershipId: Swift.String?

    public init(
        accountIds: [Swift.String]? = nil,
        membershipId: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.membershipId = membershipId
    }
}

extension SecurityIRClientTypes {

    ///
    public struct GetMembershipAccountDetailError: Swift.Sendable {
        ///
        /// This member is required.
        public var accountId: Swift.String?
        ///
        /// This member is required.
        public var error: Swift.String?
        ///
        /// This member is required.
        public var message: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            error: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.error = error
            self.message = message
        }
    }
}

extension SecurityIRClientTypes {

    public enum MembershipAccountRelationshipStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case associated
        case disassociated
        case sdkUnknown(Swift.String)

        public static var allCases: [MembershipAccountRelationshipStatus] {
            return [
                .associated,
                .disassociated
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .associated: return "Associated"
            case .disassociated: return "Disassociated"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityIRClientTypes {

    public enum MembershipAccountRelationshipType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case organization
        case sdkUnknown(Swift.String)

        public static var allCases: [MembershipAccountRelationshipType] {
            return [
                .organization
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .organization: return "Organization"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityIRClientTypes {

    ///
    public struct GetMembershipAccountDetailItem: Swift.Sendable {
        ///
        public var accountId: Swift.String?
        ///
        public var relationshipStatus: SecurityIRClientTypes.MembershipAccountRelationshipStatus?
        ///
        public var relationshipType: SecurityIRClientTypes.MembershipAccountRelationshipType?

        public init(
            accountId: Swift.String? = nil,
            relationshipStatus: SecurityIRClientTypes.MembershipAccountRelationshipStatus? = nil,
            relationshipType: SecurityIRClientTypes.MembershipAccountRelationshipType? = nil
        )
        {
            self.accountId = accountId
            self.relationshipStatus = relationshipStatus
            self.relationshipType = relationshipType
        }
    }
}

public struct BatchGetMemberAccountDetailsOutput: Swift.Sendable {
    /// The response element providing errors messages for requests to GetMembershipAccountDetails.
    public var errors: [SecurityIRClientTypes.GetMembershipAccountDetailError]?
    /// The response element providing responses for requests to GetMembershipAccountDetails.
    public var items: [SecurityIRClientTypes.GetMembershipAccountDetailItem]?

    public init(
        errors: [SecurityIRClientTypes.GetMembershipAccountDetailError]? = nil,
        items: [SecurityIRClientTypes.GetMembershipAccountDetailItem]? = nil
    )
    {
        self.errors = errors
        self.items = items
    }
}

public struct CancelMembershipInput: Swift.Sendable {
    /// Required element used in combination with CancelMembershipRequest to identify the membership ID to cancel.
    /// This member is required.
    public var membershipId: Swift.String?

    public init(
        membershipId: Swift.String? = nil
    )
    {
        self.membershipId = membershipId
    }
}

public struct CancelMembershipOutput: Swift.Sendable {
    /// The response element providing responses for requests to CancelMembershipRequest.
    /// This member is required.
    public var membershipId: Swift.String?

    public init(
        membershipId: Swift.String? = nil
    )
    {
        self.membershipId = membershipId
    }
}

public struct CloseCaseInput: Swift.Sendable {
    /// Required element used in combination with CloseCase to identify the case ID to close.
    /// This member is required.
    public var caseId: Swift.String?

    public init(
        caseId: Swift.String? = nil
    )
    {
        self.caseId = caseId
    }
}

extension SecurityIRClientTypes {

    public enum CaseStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case acknowledged
        case closed
        case containmentEradicationAndRecovery
        case detectionAndAnalysis
        case postIncidentActivities
        case readyToClose
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [CaseStatus] {
            return [
                .acknowledged,
                .closed,
                .containmentEradicationAndRecovery,
                .detectionAndAnalysis,
                .postIncidentActivities,
                .readyToClose,
                .submitted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .acknowledged: return "Acknowledged"
            case .closed: return "Closed"
            case .containmentEradicationAndRecovery: return "Containment, Eradication and Recovery"
            case .detectionAndAnalysis: return "Detection and Analysis"
            case .postIncidentActivities: return "Post-incident Activities"
            case .readyToClose: return "Ready to Close"
            case .submitted: return "Submitted"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CloseCaseOutput: Swift.Sendable {
    /// A response element providing responses for requests to CloseCase. This element responds with the case status following the action.
    public var caseStatus: SecurityIRClientTypes.CaseStatus?
    /// A response element providing responses for requests to CloseCase. This element responds with the case closure date following the action.
    public var closedDate: Foundation.Date?

    public init(
        caseStatus: SecurityIRClientTypes.CaseStatus? = nil,
        closedDate: Foundation.Date? = nil
    )
    {
        self.caseStatus = caseStatus
        self.closedDate = closedDate
    }
}

extension SecurityIRClientTypes {

    public enum EngagementType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case investigation
        case securityIncident
        case sdkUnknown(Swift.String)

        public static var allCases: [EngagementType] {
            return [
                .investigation,
                .securityIncident
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .investigation: return "Investigation"
            case .securityIncident: return "Security Incident"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityIRClientTypes {

    ///
    public struct ImpactedAwsRegion: Swift.Sendable {
        ///
        /// This member is required.
        public var region: SecurityIRClientTypes.AwsRegion?

        public init(
            region: SecurityIRClientTypes.AwsRegion? = nil
        )
        {
            self.region = region
        }
    }
}

extension SecurityIRClientTypes {

    public enum ResolverType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aws
        case `self`
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolverType] {
            return [
                .aws,
                .self
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aws: return "AWS"
            case .self: return "Self"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityIRClientTypes {

    ///
    public struct ThreatActorIp: Swift.Sendable {
        ///
        /// This member is required.
        public var ipAddress: Swift.String?
        ///
        public var userAgent: Swift.String?

        public init(
            ipAddress: Swift.String? = nil,
            userAgent: Swift.String? = nil
        )
        {
            self.ipAddress = ipAddress
            self.userAgent = userAgent
        }
    }
}

extension SecurityIRClientTypes.ThreatActorIp: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThreatActorIp(userAgent: \(Swift.String(describing: userAgent)), ipAddress: \"CONTENT_REDACTED\")"}
}

extension SecurityIRClientTypes {

    ///
    public struct Watcher: Swift.Sendable {
        ///
        /// This member is required.
        public var email: Swift.String?
        ///
        public var jobTitle: Swift.String?
        ///
        public var name: Swift.String?

        public init(
            email: Swift.String? = nil,
            jobTitle: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.email = email
            self.jobTitle = jobTitle
            self.name = name
        }
    }
}

extension SecurityIRClientTypes.Watcher: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Watcher(email: \"CONTENT_REDACTED\", jobTitle: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct CreateCaseInput: Swift.Sendable {
    /// Required element used in combination with CreateCase.
    public var clientToken: Swift.String?
    /// Required element used in combination with CreateCase to provide a description for the new case.
    /// This member is required.
    public var description: Swift.String?
    /// Required element used in combination with CreateCase to provide an engagement type for the new cases. Available engagement types include Security Incident | Investigation
    /// This member is required.
    public var engagementType: SecurityIRClientTypes.EngagementType?
    /// Required element used in combination with CreateCase to provide a list of impacted accounts.
    /// This member is required.
    public var impactedAccounts: [Swift.String]?
    /// An optional element used in combination with CreateCase to provide a list of impacted regions.
    public var impactedAwsRegions: [SecurityIRClientTypes.ImpactedAwsRegion]?
    /// An optional element used in combination with CreateCase to provide a list of services impacted.
    public var impactedServices: [Swift.String]?
    /// Required element used in combination with CreateCase to provide an initial start date for the unauthorized activity.
    /// This member is required.
    public var reportedIncidentStartDate: Foundation.Date?
    /// Required element used in combination with CreateCase to identify the resolver type. Available resolvers include self-supported | aws-supported.
    /// This member is required.
    public var resolverType: SecurityIRClientTypes.ResolverType?
    /// An optional element used in combination with CreateCase to add customer specified tags to a case.
    public var tags: [Swift.String: Swift.String]?
    /// An optional element used in combination with CreateCase to provide a list of suspicious internet protocol addresses associated with unauthorized activity.
    public var threatActorIpAddresses: [SecurityIRClientTypes.ThreatActorIp]?
    /// Required element used in combination with CreateCase to provide a title for the new case.
    /// This member is required.
    public var title: Swift.String?
    /// Required element used in combination with CreateCase to provide a list of entities to receive notifications for case updates.
    /// This member is required.
    public var watchers: [SecurityIRClientTypes.Watcher]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        engagementType: SecurityIRClientTypes.EngagementType? = nil,
        impactedAccounts: [Swift.String]? = nil,
        impactedAwsRegions: [SecurityIRClientTypes.ImpactedAwsRegion]? = nil,
        impactedServices: [Swift.String]? = nil,
        reportedIncidentStartDate: Foundation.Date? = nil,
        resolverType: SecurityIRClientTypes.ResolverType? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        threatActorIpAddresses: [SecurityIRClientTypes.ThreatActorIp]? = nil,
        title: Swift.String? = nil,
        watchers: [SecurityIRClientTypes.Watcher]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.engagementType = engagementType
        self.impactedAccounts = impactedAccounts
        self.impactedAwsRegions = impactedAwsRegions
        self.impactedServices = impactedServices
        self.reportedIncidentStartDate = reportedIncidentStartDate
        self.resolverType = resolverType
        self.tags = tags
        self.threatActorIpAddresses = threatActorIpAddresses
        self.title = title
        self.watchers = watchers
    }
}

extension CreateCaseInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCaseInput(clientToken: \(Swift.String(describing: clientToken)), engagementType: \(Swift.String(describing: engagementType)), impactedAccounts: \(Swift.String(describing: impactedAccounts)), impactedAwsRegions: \(Swift.String(describing: impactedAwsRegions)), impactedServices: \(Swift.String(describing: impactedServices)), reportedIncidentStartDate: \(Swift.String(describing: reportedIncidentStartDate)), resolverType: \(Swift.String(describing: resolverType)), tags: \(Swift.String(describing: tags)), threatActorIpAddresses: \(Swift.String(describing: threatActorIpAddresses)), watchers: \(Swift.String(describing: watchers)), description: \"CONTENT_REDACTED\", title: \"CONTENT_REDACTED\")"}
}

public struct CreateCaseOutput: Swift.Sendable {
    /// A response element providing responses for requests to CreateCase. This element responds with the case ID.
    /// This member is required.
    public var caseId: Swift.String?

    public init(
        caseId: Swift.String? = nil
    )
    {
        self.caseId = caseId
    }
}

public struct CreateCaseCommentInput: Swift.Sendable {
    /// Required element used in combination with CreateCaseComment to add content for the new comment.
    /// This member is required.
    public var body: Swift.String?
    /// Required element used in combination with CreateCaseComment to specify a case ID.
    /// This member is required.
    public var caseId: Swift.String?
    /// An optional element used in combination with CreateCaseComment.
    public var clientToken: Swift.String?

    public init(
        body: Swift.String? = nil,
        caseId: Swift.String? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.body = body
        self.caseId = caseId
        self.clientToken = clientToken
    }
}

extension CreateCaseCommentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCaseCommentInput(caseId: \(Swift.String(describing: caseId)), clientToken: \(Swift.String(describing: clientToken)), body: \"CONTENT_REDACTED\")"}
}

public struct CreateCaseCommentOutput: Swift.Sendable {
    /// Response element indicating the new comment ID.
    /// This member is required.
    public var commentId: Swift.String?

    public init(
        commentId: Swift.String? = nil
    )
    {
        self.commentId = commentId
    }
}

public struct GetCaseInput: Swift.Sendable {
    /// Required element for GetCase to identify the requested case ID.
    /// This member is required.
    public var caseId: Swift.String?

    public init(
        caseId: Swift.String? = nil
    )
    {
        self.caseId = caseId
    }
}

extension SecurityIRClientTypes {

    public enum CaseAttachmentStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case pending
        case verified
        case sdkUnknown(Swift.String)

        public static var allCases: [CaseAttachmentStatus] {
            return [
                .failed,
                .pending,
                .verified
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .pending: return "Pending"
            case .verified: return "Verified"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityIRClientTypes {

    ///
    public struct CaseAttachmentAttributes: Swift.Sendable {
        ///
        /// This member is required.
        public var attachmentId: Swift.String?
        ///
        /// This member is required.
        public var attachmentStatus: SecurityIRClientTypes.CaseAttachmentStatus?
        ///
        /// This member is required.
        public var createdDate: Foundation.Date?
        ///
        /// This member is required.
        public var creator: Swift.String?
        ///
        /// This member is required.
        public var fileName: Swift.String?

        public init(
            attachmentId: Swift.String? = nil,
            attachmentStatus: SecurityIRClientTypes.CaseAttachmentStatus? = nil,
            createdDate: Foundation.Date? = nil,
            creator: Swift.String? = nil,
            fileName: Swift.String? = nil
        )
        {
            self.attachmentId = attachmentId
            self.attachmentStatus = attachmentStatus
            self.createdDate = createdDate
            self.creator = creator
            self.fileName = fileName
        }
    }
}

extension SecurityIRClientTypes.CaseAttachmentAttributes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CaseAttachmentAttributes(attachmentId: \(Swift.String(describing: attachmentId)), attachmentStatus: \(Swift.String(describing: attachmentStatus)), createdDate: \(Swift.String(describing: createdDate)), creator: \(Swift.String(describing: creator)), fileName: \"CONTENT_REDACTED\")"}
}

extension SecurityIRClientTypes {

    public enum ClosureCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case duplicate
        case falsePositive
        case investigationCompleted
        case notResolved
        case sdkUnknown(Swift.String)

        public static var allCases: [ClosureCode] {
            return [
                .duplicate,
                .falsePositive,
                .investigationCompleted,
                .notResolved
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .duplicate: return "Duplicate"
            case .falsePositive: return "False Positive"
            case .investigationCompleted: return "Investigation Completed"
            case .notResolved: return "Not Resolved"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityIRClientTypes {

    public enum PendingAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case customer
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [PendingAction] {
            return [
                .customer,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .customer: return "Customer"
            case .none: return "None"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetCaseOutput: Swift.Sendable {
    /// Response element for GetCase that provides the actual incident start date as identified by data analysis during the investigation.
    public var actualIncidentStartDate: Foundation.Date?
    /// Response element for GetCase that provides the case ARN
    public var caseArn: Swift.String?
    /// Response element for GetCase that provides a list of current case attachments.
    public var caseAttachments: [SecurityIRClientTypes.CaseAttachmentAttributes]?
    /// Response element for GetCase that provides the case status. Options for statuses include Submitted | Detection and Analysis | Eradication, Containment and Recovery | Post-Incident Activities | Closed
    public var caseStatus: SecurityIRClientTypes.CaseStatus?
    /// Response element for GetCase that provides the date a specified case was closed.
    public var closedDate: Foundation.Date?
    /// Response element for GetCase that provides the summary code for why a case was closed.
    public var closureCode: SecurityIRClientTypes.ClosureCode?
    /// Response element for GetCase that provides the date the case was created.
    public var createdDate: Foundation.Date?
    /// Response element for GetCase that provides contents of the case description.
    public var description: Swift.String?
    /// Response element for GetCase that provides the engagement type. Options for engagement type include Active Security Event | Investigations
    public var engagementType: SecurityIRClientTypes.EngagementType?
    /// Response element for GetCase that provides a list of impacted accounts.
    public var impactedAccounts: [Swift.String]?
    /// Response element for GetCase that provides the impacted regions.
    public var impactedAwsRegions: [SecurityIRClientTypes.ImpactedAwsRegion]?
    /// Response element for GetCase that provides a list of impacted services.
    public var impactedServices: [Swift.String]?
    /// Response element for GetCase that provides the date a case was last modified.
    public var lastUpdatedDate: Foundation.Date?
    /// Response element for GetCase that provides identifies the case is waiting on customer input.
    public var pendingAction: SecurityIRClientTypes.PendingAction?
    /// Response element for GetCase that provides the customer provided incident start date.
    public var reportedIncidentStartDate: Foundation.Date?
    /// Response element for GetCase that provides the current resolver types. Options include  self-supported | AWS-supported.
    public var resolverType: SecurityIRClientTypes.ResolverType?
    /// Response element for GetCase that provides a list of suspicious IP addresses associated with unauthorized activity.
    public var threatActorIpAddresses: [SecurityIRClientTypes.ThreatActorIp]?
    /// Response element for GetCase that provides the case title.
    public var title: Swift.String?
    /// Response element for GetCase that provides a list of Watchers added to the case.
    public var watchers: [SecurityIRClientTypes.Watcher]?

    public init(
        actualIncidentStartDate: Foundation.Date? = nil,
        caseArn: Swift.String? = nil,
        caseAttachments: [SecurityIRClientTypes.CaseAttachmentAttributes]? = nil,
        caseStatus: SecurityIRClientTypes.CaseStatus? = nil,
        closedDate: Foundation.Date? = nil,
        closureCode: SecurityIRClientTypes.ClosureCode? = nil,
        createdDate: Foundation.Date? = nil,
        description: Swift.String? = nil,
        engagementType: SecurityIRClientTypes.EngagementType? = nil,
        impactedAccounts: [Swift.String]? = nil,
        impactedAwsRegions: [SecurityIRClientTypes.ImpactedAwsRegion]? = nil,
        impactedServices: [Swift.String]? = nil,
        lastUpdatedDate: Foundation.Date? = nil,
        pendingAction: SecurityIRClientTypes.PendingAction? = nil,
        reportedIncidentStartDate: Foundation.Date? = nil,
        resolverType: SecurityIRClientTypes.ResolverType? = nil,
        threatActorIpAddresses: [SecurityIRClientTypes.ThreatActorIp]? = nil,
        title: Swift.String? = nil,
        watchers: [SecurityIRClientTypes.Watcher]? = nil
    )
    {
        self.actualIncidentStartDate = actualIncidentStartDate
        self.caseArn = caseArn
        self.caseAttachments = caseAttachments
        self.caseStatus = caseStatus
        self.closedDate = closedDate
        self.closureCode = closureCode
        self.createdDate = createdDate
        self.description = description
        self.engagementType = engagementType
        self.impactedAccounts = impactedAccounts
        self.impactedAwsRegions = impactedAwsRegions
        self.impactedServices = impactedServices
        self.lastUpdatedDate = lastUpdatedDate
        self.pendingAction = pendingAction
        self.reportedIncidentStartDate = reportedIncidentStartDate
        self.resolverType = resolverType
        self.threatActorIpAddresses = threatActorIpAddresses
        self.title = title
        self.watchers = watchers
    }
}

extension GetCaseOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCaseOutput(actualIncidentStartDate: \(Swift.String(describing: actualIncidentStartDate)), caseArn: \(Swift.String(describing: caseArn)), caseAttachments: \(Swift.String(describing: caseAttachments)), caseStatus: \(Swift.String(describing: caseStatus)), closedDate: \(Swift.String(describing: closedDate)), closureCode: \(Swift.String(describing: closureCode)), createdDate: \(Swift.String(describing: createdDate)), engagementType: \(Swift.String(describing: engagementType)), impactedAccounts: \(Swift.String(describing: impactedAccounts)), impactedAwsRegions: \(Swift.String(describing: impactedAwsRegions)), impactedServices: \(Swift.String(describing: impactedServices)), lastUpdatedDate: \(Swift.String(describing: lastUpdatedDate)), pendingAction: \(Swift.String(describing: pendingAction)), reportedIncidentStartDate: \(Swift.String(describing: reportedIncidentStartDate)), resolverType: \(Swift.String(describing: resolverType)), threatActorIpAddresses: \(Swift.String(describing: threatActorIpAddresses)), watchers: \(Swift.String(describing: watchers)), description: \"CONTENT_REDACTED\", title: \"CONTENT_REDACTED\")"}
}

public struct GetCaseAttachmentDownloadUrlInput: Swift.Sendable {
    /// Required element for GetCaseAttachmentDownloadUrl to identify the attachment ID for downloading an attachment.
    /// This member is required.
    public var attachmentId: Swift.String?
    /// Required element for GetCaseAttachmentDownloadUrl to identify the case ID for downloading an attachment from.
    /// This member is required.
    public var caseId: Swift.String?

    public init(
        attachmentId: Swift.String? = nil,
        caseId: Swift.String? = nil
    )
    {
        self.attachmentId = attachmentId
        self.caseId = caseId
    }
}

public struct GetCaseAttachmentDownloadUrlOutput: Swift.Sendable {
    /// Response element providing the Amazon S3 presigned URL to download an attachment.
    /// This member is required.
    public var attachmentPresignedUrl: Swift.String?

    public init(
        attachmentPresignedUrl: Swift.String? = nil
    )
    {
        self.attachmentPresignedUrl = attachmentPresignedUrl
    }
}

extension GetCaseAttachmentDownloadUrlOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCaseAttachmentDownloadUrlOutput(attachmentPresignedUrl: \"CONTENT_REDACTED\")"}
}

public struct GetCaseAttachmentUploadUrlInput: Swift.Sendable {
    /// Required element for GetCaseAttachmentUploadUrl to identify the case ID for uploading an attachment to.
    /// This member is required.
    public var caseId: Swift.String?
    /// Optional element for customer provided token.
    public var clientToken: Swift.String?
    /// Required element for GetCaseAttachmentUploadUrl to identify the size od the file attachment.
    /// This member is required.
    public var contentLength: Swift.Int?
    /// Required element for GetCaseAttachmentUploadUrl to identify the file name of the attachment to upload.
    /// This member is required.
    public var fileName: Swift.String?

    public init(
        caseId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        contentLength: Swift.Int? = nil,
        fileName: Swift.String? = nil
    )
    {
        self.caseId = caseId
        self.clientToken = clientToken
        self.contentLength = contentLength
        self.fileName = fileName
    }
}

extension GetCaseAttachmentUploadUrlInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCaseAttachmentUploadUrlInput(caseId: \(Swift.String(describing: caseId)), clientToken: \(Swift.String(describing: clientToken)), contentLength: \(Swift.String(describing: contentLength)), fileName: \"CONTENT_REDACTED\")"}
}

public struct GetCaseAttachmentUploadUrlOutput: Swift.Sendable {
    /// Response element providing the Amazon S3 presigned UTL to upload the attachment.
    /// This member is required.
    public var attachmentPresignedUrl: Swift.String?

    public init(
        attachmentPresignedUrl: Swift.String? = nil
    )
    {
        self.attachmentPresignedUrl = attachmentPresignedUrl
    }
}

extension GetCaseAttachmentUploadUrlOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCaseAttachmentUploadUrlOutput(attachmentPresignedUrl: \"CONTENT_REDACTED\")"}
}

public struct ListCaseEditsInput: Swift.Sendable {
    /// Required element used with ListCaseEdits to identify the case to query.
    /// This member is required.
    public var caseId: Swift.String?
    /// Optional element to identify how many results to obtain. There is a maximum value of 25.
    public var maxResults: Swift.Int?
    /// Optional element for a customer provided token.
    public var nextToken: Swift.String?

    public init(
        caseId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.caseId = caseId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SecurityIRClientTypes {

    ///
    public struct CaseEditItem: Swift.Sendable {
        ///
        public var action: Swift.String?
        ///
        public var eventTimestamp: Foundation.Date?
        ///
        public var message: Swift.String?
        ///
        public var principal: Swift.String?

        public init(
            action: Swift.String? = nil,
            eventTimestamp: Foundation.Date? = nil,
            message: Swift.String? = nil,
            principal: Swift.String? = nil
        )
        {
            self.action = action
            self.eventTimestamp = eventTimestamp
            self.message = message
            self.principal = principal
        }
    }
}

public struct ListCaseEditsOutput: Swift.Sendable {
    /// Response element for ListCaseEdits that includes the action, eventtimestamp, message, and principal for the response.
    public var items: [SecurityIRClientTypes.CaseEditItem]?
    /// Optional element.
    public var nextToken: Swift.String?
    /// Response element for ListCaseEdits that identifies the total number of edits.
    public var total: Swift.Int?

    public init(
        items: [SecurityIRClientTypes.CaseEditItem]? = nil,
        nextToken: Swift.String? = nil,
        total: Swift.Int? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
        self.total = total
    }
}

public struct ListCasesInput: Swift.Sendable {
    /// Optional element for ListCases to limit the number of responses.
    public var maxResults: Swift.Int?
    /// Optional element.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SecurityIRClientTypes {

    ///
    public struct ListCasesItem: Swift.Sendable {
        ///
        public var caseArn: Swift.String?
        ///
        /// This member is required.
        public var caseId: Swift.String?
        ///
        public var caseStatus: SecurityIRClientTypes.CaseStatus?
        ///
        public var closedDate: Foundation.Date?
        ///
        public var createdDate: Foundation.Date?
        ///
        public var engagementType: SecurityIRClientTypes.EngagementType?
        ///
        public var lastUpdatedDate: Foundation.Date?
        ///
        public var pendingAction: SecurityIRClientTypes.PendingAction?
        ///
        public var resolverType: SecurityIRClientTypes.ResolverType?
        ///
        public var title: Swift.String?

        public init(
            caseArn: Swift.String? = nil,
            caseId: Swift.String? = nil,
            caseStatus: SecurityIRClientTypes.CaseStatus? = nil,
            closedDate: Foundation.Date? = nil,
            createdDate: Foundation.Date? = nil,
            engagementType: SecurityIRClientTypes.EngagementType? = nil,
            lastUpdatedDate: Foundation.Date? = nil,
            pendingAction: SecurityIRClientTypes.PendingAction? = nil,
            resolverType: SecurityIRClientTypes.ResolverType? = nil,
            title: Swift.String? = nil
        )
        {
            self.caseArn = caseArn
            self.caseId = caseId
            self.caseStatus = caseStatus
            self.closedDate = closedDate
            self.createdDate = createdDate
            self.engagementType = engagementType
            self.lastUpdatedDate = lastUpdatedDate
            self.pendingAction = pendingAction
            self.resolverType = resolverType
            self.title = title
        }
    }
}

extension SecurityIRClientTypes.ListCasesItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCasesItem(caseArn: \(Swift.String(describing: caseArn)), caseId: \(Swift.String(describing: caseId)), caseStatus: \(Swift.String(describing: caseStatus)), closedDate: \(Swift.String(describing: closedDate)), createdDate: \(Swift.String(describing: createdDate)), engagementType: \(Swift.String(describing: engagementType)), lastUpdatedDate: \(Swift.String(describing: lastUpdatedDate)), pendingAction: \(Swift.String(describing: pendingAction)), resolverType: \(Swift.String(describing: resolverType)), title: \"CONTENT_REDACTED\")"}
}

public struct ListCasesOutput: Swift.Sendable {
    /// Response element for ListCases that includes caseARN, caseID, caseStatus, closedDate, createdDate, engagementType, lastUpdatedDate, pendingAction, resolverType, and title for each response.
    public var items: [SecurityIRClientTypes.ListCasesItem]?
    /// Optional element.
    public var nextToken: Swift.String?
    /// Response element for ListCases providing the total number of responses.
    public var total: Swift.Int?

    public init(
        items: [SecurityIRClientTypes.ListCasesItem]? = nil,
        nextToken: Swift.String? = nil,
        total: Swift.Int? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
        self.total = total
    }
}

public struct ListCommentsInput: Swift.Sendable {
    /// Required element for ListComments to designate the case to query.
    /// This member is required.
    public var caseId: Swift.String?
    /// Optional element for ListComments to limit the number of responses.
    public var maxResults: Swift.Int?
    /// Optional element.
    public var nextToken: Swift.String?

    public init(
        caseId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.caseId = caseId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SecurityIRClientTypes {

    ///
    public struct ListCommentsItem: Swift.Sendable {
        ///
        public var body: Swift.String?
        ///
        /// This member is required.
        public var commentId: Swift.String?
        ///
        public var createdDate: Foundation.Date?
        ///
        public var creator: Swift.String?
        ///
        public var lastUpdatedBy: Swift.String?
        ///
        public var lastUpdatedDate: Foundation.Date?

        public init(
            body: Swift.String? = nil,
            commentId: Swift.String? = nil,
            createdDate: Foundation.Date? = nil,
            creator: Swift.String? = nil,
            lastUpdatedBy: Swift.String? = nil,
            lastUpdatedDate: Foundation.Date? = nil
        )
        {
            self.body = body
            self.commentId = commentId
            self.createdDate = createdDate
            self.creator = creator
            self.lastUpdatedBy = lastUpdatedBy
            self.lastUpdatedDate = lastUpdatedDate
        }
    }
}

extension SecurityIRClientTypes.ListCommentsItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListCommentsItem(commentId: \(Swift.String(describing: commentId)), createdDate: \(Swift.String(describing: createdDate)), creator: \(Swift.String(describing: creator)), lastUpdatedBy: \(Swift.String(describing: lastUpdatedBy)), lastUpdatedDate: \(Swift.String(describing: lastUpdatedDate)), body: \"CONTENT_REDACTED\")"}
}

public struct ListCommentsOutput: Swift.Sendable {
    /// Response element for ListComments providing the body, commentID, createDate, creator, lastUpdatedBy and lastUpdatedDate for each response.
    public var items: [SecurityIRClientTypes.ListCommentsItem]?
    /// Optional request elements.
    public var nextToken: Swift.String?
    /// Response element for ListComments identifying the number of responses.
    public var total: Swift.Int?

    public init(
        items: [SecurityIRClientTypes.ListCommentsItem]? = nil,
        nextToken: Swift.String? = nil,
        total: Swift.Int? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
        self.total = total
    }
}

public struct UpdateCaseInput: Swift.Sendable {
    /// Optional element for UpdateCase to provide content for the incident start date field.
    public var actualIncidentStartDate: Foundation.Date?
    /// Required element for UpdateCase to identify the case ID for updates.
    /// This member is required.
    public var caseId: Swift.String?
    /// Optional element for UpdateCase to provide content for the description field.
    public var description: Swift.String?
    /// Optional element for UpdateCase to provide content for the engagement type field. Available engagement types include Security Incident | Investigation.
    public var engagementType: SecurityIRClientTypes.EngagementType?
    /// Optional element for UpdateCase to provide content to add accounts impacted.
    public var impactedAccountsToAdd: [Swift.String]?
    /// Optional element for UpdateCase to provide content to add accounts impacted.
    public var impactedAccountsToDelete: [Swift.String]?
    /// Optional element for UpdateCase to provide content to add regions impacted.
    public var impactedAwsRegionsToAdd: [SecurityIRClientTypes.ImpactedAwsRegion]?
    /// Optional element for UpdateCase to provide content to remove regions impacted.
    public var impactedAwsRegionsToDelete: [SecurityIRClientTypes.ImpactedAwsRegion]?
    /// Optional element for UpdateCase to provide content to add services impacted.
    public var impactedServicesToAdd: [Swift.String]?
    /// Optional element for UpdateCase to provide content to remove services impacted.
    public var impactedServicesToDelete: [Swift.String]?
    /// Optional element for UpdateCase to provide content for the customer reported incident start date field.
    public var reportedIncidentStartDate: Foundation.Date?
    /// Optional element for UpdateCase to provide content to add additional suspicious IP addresses related to a case.
    public var threatActorIpAddressesToAdd: [SecurityIRClientTypes.ThreatActorIp]?
    /// Optional element for UpdateCase to provide content to remove suspicious IP addresses from a case.
    public var threatActorIpAddressesToDelete: [SecurityIRClientTypes.ThreatActorIp]?
    /// Optional element for UpdateCase to provide content for the title field.
    public var title: Swift.String?
    /// Optional element for UpdateCase to provide content to add additional watchers to a case.
    public var watchersToAdd: [SecurityIRClientTypes.Watcher]?
    /// Optional element for UpdateCase to provide content to remove existing watchers from a case.
    public var watchersToDelete: [SecurityIRClientTypes.Watcher]?

    public init(
        actualIncidentStartDate: Foundation.Date? = nil,
        caseId: Swift.String? = nil,
        description: Swift.String? = nil,
        engagementType: SecurityIRClientTypes.EngagementType? = nil,
        impactedAccountsToAdd: [Swift.String]? = nil,
        impactedAccountsToDelete: [Swift.String]? = nil,
        impactedAwsRegionsToAdd: [SecurityIRClientTypes.ImpactedAwsRegion]? = nil,
        impactedAwsRegionsToDelete: [SecurityIRClientTypes.ImpactedAwsRegion]? = nil,
        impactedServicesToAdd: [Swift.String]? = nil,
        impactedServicesToDelete: [Swift.String]? = nil,
        reportedIncidentStartDate: Foundation.Date? = nil,
        threatActorIpAddressesToAdd: [SecurityIRClientTypes.ThreatActorIp]? = nil,
        threatActorIpAddressesToDelete: [SecurityIRClientTypes.ThreatActorIp]? = nil,
        title: Swift.String? = nil,
        watchersToAdd: [SecurityIRClientTypes.Watcher]? = nil,
        watchersToDelete: [SecurityIRClientTypes.Watcher]? = nil
    )
    {
        self.actualIncidentStartDate = actualIncidentStartDate
        self.caseId = caseId
        self.description = description
        self.engagementType = engagementType
        self.impactedAccountsToAdd = impactedAccountsToAdd
        self.impactedAccountsToDelete = impactedAccountsToDelete
        self.impactedAwsRegionsToAdd = impactedAwsRegionsToAdd
        self.impactedAwsRegionsToDelete = impactedAwsRegionsToDelete
        self.impactedServicesToAdd = impactedServicesToAdd
        self.impactedServicesToDelete = impactedServicesToDelete
        self.reportedIncidentStartDate = reportedIncidentStartDate
        self.threatActorIpAddressesToAdd = threatActorIpAddressesToAdd
        self.threatActorIpAddressesToDelete = threatActorIpAddressesToDelete
        self.title = title
        self.watchersToAdd = watchersToAdd
        self.watchersToDelete = watchersToDelete
    }
}

extension UpdateCaseInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCaseInput(actualIncidentStartDate: \(Swift.String(describing: actualIncidentStartDate)), caseId: \(Swift.String(describing: caseId)), engagementType: \(Swift.String(describing: engagementType)), impactedAccountsToAdd: \(Swift.String(describing: impactedAccountsToAdd)), impactedAccountsToDelete: \(Swift.String(describing: impactedAccountsToDelete)), impactedAwsRegionsToAdd: \(Swift.String(describing: impactedAwsRegionsToAdd)), impactedAwsRegionsToDelete: \(Swift.String(describing: impactedAwsRegionsToDelete)), impactedServicesToAdd: \(Swift.String(describing: impactedServicesToAdd)), impactedServicesToDelete: \(Swift.String(describing: impactedServicesToDelete)), reportedIncidentStartDate: \(Swift.String(describing: reportedIncidentStartDate)), threatActorIpAddressesToAdd: \(Swift.String(describing: threatActorIpAddressesToAdd)), threatActorIpAddressesToDelete: \(Swift.String(describing: threatActorIpAddressesToDelete)), watchersToAdd: \(Swift.String(describing: watchersToAdd)), watchersToDelete: \(Swift.String(describing: watchersToDelete)), description: \"CONTENT_REDACTED\", title: \"CONTENT_REDACTED\")"}
}

public struct UpdateCaseOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateCaseCommentInput: Swift.Sendable {
    /// Required element for UpdateCaseComment to identify the content for the comment to be updated.
    /// This member is required.
    public var body: Swift.String?
    /// Required element for UpdateCaseComment to identify the case ID containing the comment to be updated.
    /// This member is required.
    public var caseId: Swift.String?
    /// Required element for UpdateCaseComment to identify the case ID to be updated.
    /// This member is required.
    public var commentId: Swift.String?

    public init(
        body: Swift.String? = nil,
        caseId: Swift.String? = nil,
        commentId: Swift.String? = nil
    )
    {
        self.body = body
        self.caseId = caseId
        self.commentId = commentId
    }
}

extension UpdateCaseCommentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCaseCommentInput(caseId: \(Swift.String(describing: caseId)), commentId: \(Swift.String(describing: commentId)), body: \"CONTENT_REDACTED\")"}
}

public struct UpdateCaseCommentOutput: Swift.Sendable {
    /// Response element for UpdateCaseComment providing the updated comment content.
    public var body: Swift.String?
    /// Response element for UpdateCaseComment providing the updated comment ID.
    /// This member is required.
    public var commentId: Swift.String?

    public init(
        body: Swift.String? = nil,
        commentId: Swift.String? = nil
    )
    {
        self.body = body
        self.commentId = commentId
    }
}

extension UpdateCaseCommentOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCaseCommentOutput(commentId: \(Swift.String(describing: commentId)), body: \"CONTENT_REDACTED\")"}
}

extension SecurityIRClientTypes {

    public enum SelfManagedCaseStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case containmentEradicationAndRecovery
        case detectionAndAnalysis
        case postIncidentActivities
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [SelfManagedCaseStatus] {
            return [
                .containmentEradicationAndRecovery,
                .detectionAndAnalysis,
                .postIncidentActivities,
                .submitted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .containmentEradicationAndRecovery: return "Containment, Eradication and Recovery"
            case .detectionAndAnalysis: return "Detection and Analysis"
            case .postIncidentActivities: return "Post-incident Activities"
            case .submitted: return "Submitted"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct UpdateCaseStatusInput: Swift.Sendable {
    /// Required element for UpdateCaseStatus to identify the case to update.
    /// This member is required.
    public var caseId: Swift.String?
    /// Required element for UpdateCaseStatus to identify the status for a case. Options include Submitted | Detection and Analysis | Containment, Eradication and Recovery | Post-incident Activities.
    /// This member is required.
    public var caseStatus: SecurityIRClientTypes.SelfManagedCaseStatus?

    public init(
        caseId: Swift.String? = nil,
        caseStatus: SecurityIRClientTypes.SelfManagedCaseStatus? = nil
    )
    {
        self.caseId = caseId
        self.caseStatus = caseStatus
    }
}

public struct UpdateCaseStatusOutput: Swift.Sendable {
    /// Response element for UpdateCaseStatus showing the newly configured status.
    public var caseStatus: SecurityIRClientTypes.SelfManagedCaseStatus?

    public init(
        caseStatus: SecurityIRClientTypes.SelfManagedCaseStatus? = nil
    )
    {
        self.caseStatus = caseStatus
    }
}

public struct UpdateResolverTypeInput: Swift.Sendable {
    /// Required element for UpdateResolverType to identify the case to update.
    /// This member is required.
    public var caseId: Swift.String?
    /// Required element for UpdateResolverType to identify the new resolver.
    /// This member is required.
    public var resolverType: SecurityIRClientTypes.ResolverType?

    public init(
        caseId: Swift.String? = nil,
        resolverType: SecurityIRClientTypes.ResolverType? = nil
    )
    {
        self.caseId = caseId
        self.resolverType = resolverType
    }
}

public struct UpdateResolverTypeOutput: Swift.Sendable {
    /// Response element for UpdateResolver identifying the case ID being updated.
    /// This member is required.
    public var caseId: Swift.String?
    /// Response element for UpdateResolver identifying the current status of the case.
    public var caseStatus: SecurityIRClientTypes.CaseStatus?
    /// Response element for UpdateResolver identifying the current resolver of the case.
    public var resolverType: SecurityIRClientTypes.ResolverType?

    public init(
        caseId: Swift.String? = nil,
        caseStatus: SecurityIRClientTypes.CaseStatus? = nil,
        resolverType: SecurityIRClientTypes.ResolverType? = nil
    )
    {
        self.caseId = caseId
        self.caseStatus = caseStatus
        self.resolverType = resolverType
    }
}

///
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Element providing the ID of the resource affected.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Element providing the type of the resource affected.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

extension SecurityIRClientTypes {

    ///
    public struct IncidentResponder: Swift.Sendable {
        ///
        /// This member is required.
        public var email: Swift.String?
        ///
        /// This member is required.
        public var jobTitle: Swift.String?
        ///
        /// This member is required.
        public var name: Swift.String?

        public init(
            email: Swift.String? = nil,
            jobTitle: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.email = email
            self.jobTitle = jobTitle
            self.name = name
        }
    }
}

extension SecurityIRClientTypes.IncidentResponder: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IncidentResponder(email: \"CONTENT_REDACTED\", jobTitle: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension SecurityIRClientTypes {

    public enum OptInFeatureName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case triage
        case sdkUnknown(Swift.String)

        public static var allCases: [OptInFeatureName] {
            return [
                .triage
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .triage: return "Triage"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SecurityIRClientTypes {

    ///
    public struct OptInFeature: Swift.Sendable {
        ///
        /// This member is required.
        public var featureName: SecurityIRClientTypes.OptInFeatureName?
        ///
        /// This member is required.
        public var isEnabled: Swift.Bool?

        public init(
            featureName: SecurityIRClientTypes.OptInFeatureName? = nil,
            isEnabled: Swift.Bool? = nil
        )
        {
            self.featureName = featureName
            self.isEnabled = isEnabled
        }
    }
}

public struct CreateMembershipInput: Swift.Sendable {
    /// An optional element used in combination with CreateMembership.
    public var clientToken: Swift.String?
    /// Required element use in combination with CreateMembership to add customer incident response team members and trusted partners to the membership.
    /// This member is required.
    public var incidentResponseTeam: [SecurityIRClientTypes.IncidentResponder]?
    /// Required element use in combination with CreateMembership to create a name for the membership.
    /// This member is required.
    public var membershipName: Swift.String?
    /// Optional element to enable the monitoring and investigation opt-in features for the service.
    public var optInFeatures: [SecurityIRClientTypes.OptInFeature]?
    /// Optional element for customer configured tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        incidentResponseTeam: [SecurityIRClientTypes.IncidentResponder]? = nil,
        membershipName: Swift.String? = nil,
        optInFeatures: [SecurityIRClientTypes.OptInFeature]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.incidentResponseTeam = incidentResponseTeam
        self.membershipName = membershipName
        self.optInFeatures = optInFeatures
        self.tags = tags
    }
}

extension CreateMembershipInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMembershipInput(clientToken: \(Swift.String(describing: clientToken)), incidentResponseTeam: \(Swift.String(describing: incidentResponseTeam)), optInFeatures: \(Swift.String(describing: optInFeatures)), tags: \(Swift.String(describing: tags)), membershipName: \"CONTENT_REDACTED\")"}
}

public struct CreateMembershipOutput: Swift.Sendable {
    /// Response element for CreateMembership providing the newly created membership ID.
    /// This member is required.
    public var membershipId: Swift.String?

    public init(
        membershipId: Swift.String? = nil
    )
    {
        self.membershipId = membershipId
    }
}

extension SecurityIRClientTypes {

    public enum CustomerType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case organization
        case standalone
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomerType] {
            return [
                .organization,
                .standalone
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .organization: return "Organization"
            case .standalone: return "Standalone"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetMembershipInput: Swift.Sendable {
    /// Required element for GetMembership to identify the membership ID to query.
    /// This member is required.
    public var membershipId: Swift.String?

    public init(
        membershipId: Swift.String? = nil
    )
    {
        self.membershipId = membershipId
    }
}

extension SecurityIRClientTypes {

    public enum MembershipStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case cancelled
        case terminated
        case sdkUnknown(Swift.String)

        public static var allCases: [MembershipStatus] {
            return [
                .active,
                .cancelled,
                .terminated
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .cancelled: return "Cancelled"
            case .terminated: return "Terminated"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetMembershipOutput: Swift.Sendable {
    /// Response element for GetMembership that provides the configured account for managing the membership.
    public var accountId: Swift.String?
    /// Response element for GetMembership that provides the configured membership type. Options include  Standalone | Organizations.
    public var customerType: SecurityIRClientTypes.CustomerType?
    /// Response element for GetMembership that provides the configured membership incident response team members.
    public var incidentResponseTeam: [SecurityIRClientTypes.IncidentResponder]?
    /// Response element for GetMembership that provides the configured membership activation timestamp.
    public var membershipActivationTimestamp: Foundation.Date?
    /// Response element for GetMembership that provides the membership ARN.
    public var membershipArn: Swift.String?
    /// Response element for GetMembership that provides the configured membership name deactivation timestamp.
    public var membershipDeactivationTimestamp: Foundation.Date?
    /// Response element for GetMembership that provides the queried membership ID.
    /// This member is required.
    public var membershipId: Swift.String?
    /// Response element for GetMembership that provides the configured membership name.
    public var membershipName: Swift.String?
    /// Response element for GetMembership that provides the current membership status.
    public var membershipStatus: SecurityIRClientTypes.MembershipStatus?
    /// Response element for GetMembership that provides the number of accounts in the membership.
    public var numberOfAccountsCovered: Swift.Int?
    /// Response element for GetMembership that provides the if opt-in features have been enabled.
    public var optInFeatures: [SecurityIRClientTypes.OptInFeature]?
    /// Response element for GetMembership that provides the configured region for managing the membership.
    public var region: SecurityIRClientTypes.AwsRegion?

    public init(
        accountId: Swift.String? = nil,
        customerType: SecurityIRClientTypes.CustomerType? = nil,
        incidentResponseTeam: [SecurityIRClientTypes.IncidentResponder]? = nil,
        membershipActivationTimestamp: Foundation.Date? = nil,
        membershipArn: Swift.String? = nil,
        membershipDeactivationTimestamp: Foundation.Date? = nil,
        membershipId: Swift.String? = nil,
        membershipName: Swift.String? = nil,
        membershipStatus: SecurityIRClientTypes.MembershipStatus? = nil,
        numberOfAccountsCovered: Swift.Int? = nil,
        optInFeatures: [SecurityIRClientTypes.OptInFeature]? = nil,
        region: SecurityIRClientTypes.AwsRegion? = nil
    )
    {
        self.accountId = accountId
        self.customerType = customerType
        self.incidentResponseTeam = incidentResponseTeam
        self.membershipActivationTimestamp = membershipActivationTimestamp
        self.membershipArn = membershipArn
        self.membershipDeactivationTimestamp = membershipDeactivationTimestamp
        self.membershipId = membershipId
        self.membershipName = membershipName
        self.membershipStatus = membershipStatus
        self.numberOfAccountsCovered = numberOfAccountsCovered
        self.optInFeatures = optInFeatures
        self.region = region
    }
}

extension GetMembershipOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMembershipOutput(accountId: \(Swift.String(describing: accountId)), customerType: \(Swift.String(describing: customerType)), incidentResponseTeam: \(Swift.String(describing: incidentResponseTeam)), membershipActivationTimestamp: \(Swift.String(describing: membershipActivationTimestamp)), membershipArn: \(Swift.String(describing: membershipArn)), membershipDeactivationTimestamp: \(Swift.String(describing: membershipDeactivationTimestamp)), membershipId: \(Swift.String(describing: membershipId)), membershipStatus: \(Swift.String(describing: membershipStatus)), numberOfAccountsCovered: \(Swift.String(describing: numberOfAccountsCovered)), optInFeatures: \(Swift.String(describing: optInFeatures)), region: \(Swift.String(describing: region)), membershipName: \"CONTENT_REDACTED\")"}
}

///
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Element providing advice to clients on when the call can be safely retried.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

///
public struct InvalidTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTokenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SecurityIRClientTypes {

    ///
    public struct ListMembershipItem: Swift.Sendable {
        ///
        public var accountId: Swift.String?
        ///
        public var membershipArn: Swift.String?
        ///
        /// This member is required.
        public var membershipId: Swift.String?
        ///
        public var membershipStatus: SecurityIRClientTypes.MembershipStatus?
        ///
        public var region: SecurityIRClientTypes.AwsRegion?

        public init(
            accountId: Swift.String? = nil,
            membershipArn: Swift.String? = nil,
            membershipId: Swift.String? = nil,
            membershipStatus: SecurityIRClientTypes.MembershipStatus? = nil,
            region: SecurityIRClientTypes.AwsRegion? = nil
        )
        {
            self.accountId = accountId
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.membershipStatus = membershipStatus
            self.region = region
        }
    }
}

public struct ListMembershipsInput: Swift.Sendable {
    /// Request element for ListMemberships to limit the number of responses.
    public var maxResults: Swift.Int?
    /// Optional element.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListMembershipsOutput: Swift.Sendable {
    /// Request element for ListMemberships including the accountID, membershipARN, membershipID, membershipStatus, and region for each response.
    public var items: [SecurityIRClientTypes.ListMembershipItem]?
    /// Optional element.
    public var nextToken: Swift.String?

    public init(
        items: [SecurityIRClientTypes.ListMembershipItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

///
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SecurityIRClientTypes {

    ///
    public struct ValidationExceptionField: Swift.Sendable {
        ///
        /// This member is required.
        public var message: Swift.String?
        ///
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }
}

extension SecurityIRClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

///
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Element that provides the list of field(s) that caused the error, if applicable.
        public internal(set) var fieldList: [SecurityIRClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Element that provides the reason the request failed validation.
        /// This member is required.
        public internal(set) var reason: SecurityIRClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [SecurityIRClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: SecurityIRClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// Required element for ListTagsForResource to provide the ARN to identify a specific resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// Response element for ListTagsForResource providing content for each configured tag.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct UpdateMembershipInput: Swift.Sendable {
    /// Optional element for UpdateMembership to update the membership name.
    public var incidentResponseTeam: [SecurityIRClientTypes.IncidentResponder]?
    /// Required element for UpdateMembership to identify the membership to update.
    /// This member is required.
    public var membershipId: Swift.String?
    /// Optional element for UpdateMembership to update the membership name.
    public var membershipName: Swift.String?
    /// Optional element for UpdateMembership to enable or disable opt-in features for the service.
    public var optInFeatures: [SecurityIRClientTypes.OptInFeature]?

    public init(
        incidentResponseTeam: [SecurityIRClientTypes.IncidentResponder]? = nil,
        membershipId: Swift.String? = nil,
        membershipName: Swift.String? = nil,
        optInFeatures: [SecurityIRClientTypes.OptInFeature]? = nil
    )
    {
        self.incidentResponseTeam = incidentResponseTeam
        self.membershipId = membershipId
        self.membershipName = membershipName
        self.optInFeatures = optInFeatures
    }
}

extension UpdateMembershipInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateMembershipInput(incidentResponseTeam: \(Swift.String(describing: incidentResponseTeam)), membershipId: \(Swift.String(describing: membershipId)), optInFeatures: \(Swift.String(describing: optInFeatures)), membershipName: \"CONTENT_REDACTED\")"}
}

public struct UpdateMembershipOutput: Swift.Sendable {

    public init() { }
}

///
public struct SecurityIncidentResponseNotActiveException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SecurityIncidentResponseNotActiveException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

///
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Element that provides the quota that was exceeded.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// Element that provides the ID of the resource affected.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Element that provides the type of the resource affected.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
        /// Element that provides the originating service who made the call.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// Required element for TagResource to identify the ARN for the resource to add a tag to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Required element for ListTagsForResource to provide the content for a tag.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

///
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Element providing the quota of the originating service.
        public internal(set) var quotaCode: Swift.String? = nil
        /// Element providing advice to clients on when the call can be safely retried.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
        /// Element providing the service code of the originating service.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

public struct UntagResourceInput: Swift.Sendable {
    /// Required element for UnTagResource to identify the ARN for the resource to remove a tag from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Required element for UnTagResource to identify tag to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension BatchGetMemberAccountDetailsInput {

    static func urlPathProvider(_ value: BatchGetMemberAccountDetailsInput) -> Swift.String? {
        guard let membershipId = value.membershipId else {
            return nil
        }
        return "/v1/membership/\(membershipId.urlPercentEncoding())/batch-member-details"
    }
}

extension CancelMembershipInput {

    static func urlPathProvider(_ value: CancelMembershipInput) -> Swift.String? {
        guard let membershipId = value.membershipId else {
            return nil
        }
        return "/v1/membership/\(membershipId.urlPercentEncoding())"
    }
}

extension CloseCaseInput {

    static func urlPathProvider(_ value: CloseCaseInput) -> Swift.String? {
        guard let caseId = value.caseId else {
            return nil
        }
        return "/v1/cases/\(caseId.urlPercentEncoding())/close-case"
    }
}

extension CreateCaseInput {

    static func urlPathProvider(_ value: CreateCaseInput) -> Swift.String? {
        return "/v1/create-case"
    }
}

extension CreateCaseCommentInput {

    static func urlPathProvider(_ value: CreateCaseCommentInput) -> Swift.String? {
        guard let caseId = value.caseId else {
            return nil
        }
        return "/v1/cases/\(caseId.urlPercentEncoding())/create-comment"
    }
}

extension CreateMembershipInput {

    static func urlPathProvider(_ value: CreateMembershipInput) -> Swift.String? {
        return "/v1/membership"
    }
}

extension GetCaseInput {

    static func urlPathProvider(_ value: GetCaseInput) -> Swift.String? {
        guard let caseId = value.caseId else {
            return nil
        }
        return "/v1/cases/\(caseId.urlPercentEncoding())/get-case"
    }
}

extension GetCaseAttachmentDownloadUrlInput {

    static func urlPathProvider(_ value: GetCaseAttachmentDownloadUrlInput) -> Swift.String? {
        guard let caseId = value.caseId else {
            return nil
        }
        guard let attachmentId = value.attachmentId else {
            return nil
        }
        return "/v1/cases/\(caseId.urlPercentEncoding())/get-presigned-url/\(attachmentId.urlPercentEncoding())"
    }
}

extension GetCaseAttachmentUploadUrlInput {

    static func urlPathProvider(_ value: GetCaseAttachmentUploadUrlInput) -> Swift.String? {
        guard let caseId = value.caseId else {
            return nil
        }
        return "/v1/cases/\(caseId.urlPercentEncoding())/get-presigned-url"
    }
}

extension GetMembershipInput {

    static func urlPathProvider(_ value: GetMembershipInput) -> Swift.String? {
        guard let membershipId = value.membershipId else {
            return nil
        }
        return "/v1/membership/\(membershipId.urlPercentEncoding())"
    }
}

extension ListCaseEditsInput {

    static func urlPathProvider(_ value: ListCaseEditsInput) -> Swift.String? {
        guard let caseId = value.caseId else {
            return nil
        }
        return "/v1/cases/\(caseId.urlPercentEncoding())/list-case-edits"
    }
}

extension ListCasesInput {

    static func urlPathProvider(_ value: ListCasesInput) -> Swift.String? {
        return "/v1/list-cases"
    }
}

extension ListCommentsInput {

    static func urlPathProvider(_ value: ListCommentsInput) -> Swift.String? {
        guard let caseId = value.caseId else {
            return nil
        }
        return "/v1/cases/\(caseId.urlPercentEncoding())/list-comments"
    }
}

extension ListMembershipsInput {

    static func urlPathProvider(_ value: ListMembershipsInput) -> Swift.String? {
        return "/v1/memberships"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/v1/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/v1/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/v1/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateCaseInput {

    static func urlPathProvider(_ value: UpdateCaseInput) -> Swift.String? {
        guard let caseId = value.caseId else {
            return nil
        }
        return "/v1/cases/\(caseId.urlPercentEncoding())/update-case"
    }
}

extension UpdateCaseCommentInput {

    static func urlPathProvider(_ value: UpdateCaseCommentInput) -> Swift.String? {
        guard let caseId = value.caseId else {
            return nil
        }
        guard let commentId = value.commentId else {
            return nil
        }
        return "/v1/cases/\(caseId.urlPercentEncoding())/update-case-comment/\(commentId.urlPercentEncoding())"
    }
}

extension UpdateCaseStatusInput {

    static func urlPathProvider(_ value: UpdateCaseStatusInput) -> Swift.String? {
        guard let caseId = value.caseId else {
            return nil
        }
        return "/v1/cases/\(caseId.urlPercentEncoding())/update-case-status"
    }
}

extension UpdateMembershipInput {

    static func urlPathProvider(_ value: UpdateMembershipInput) -> Swift.String? {
        guard let membershipId = value.membershipId else {
            return nil
        }
        return "/v1/membership/\(membershipId.urlPercentEncoding())/update-membership"
    }
}

extension UpdateResolverTypeInput {

    static func urlPathProvider(_ value: UpdateResolverTypeInput) -> Swift.String? {
        guard let caseId = value.caseId else {
            return nil
        }
        return "/v1/cases/\(caseId.urlPercentEncoding())/update-resolver-type"
    }
}

extension BatchGetMemberAccountDetailsInput {

    static func write(value: BatchGetMemberAccountDetailsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountIds"].writeList(value.accountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateCaseInput {

    static func write(value: CreateCaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["engagementType"].write(value.engagementType)
        try writer["impactedAccounts"].writeList(value.impactedAccounts, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["impactedAwsRegions"].writeList(value.impactedAwsRegions, memberWritingClosure: SecurityIRClientTypes.ImpactedAwsRegion.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["impactedServices"].writeList(value.impactedServices, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["reportedIncidentStartDate"].writeTimestamp(value.reportedIncidentStartDate, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["resolverType"].write(value.resolverType)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["threatActorIpAddresses"].writeList(value.threatActorIpAddresses, memberWritingClosure: SecurityIRClientTypes.ThreatActorIp.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["title"].write(value.title)
        try writer["watchers"].writeList(value.watchers, memberWritingClosure: SecurityIRClientTypes.Watcher.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateCaseCommentInput {

    static func write(value: CreateCaseCommentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["body"].write(value.body)
        try writer["clientToken"].write(value.clientToken)
    }
}

extension CreateMembershipInput {

    static func write(value: CreateMembershipInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["incidentResponseTeam"].writeList(value.incidentResponseTeam, memberWritingClosure: SecurityIRClientTypes.IncidentResponder.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["membershipName"].write(value.membershipName)
        try writer["optInFeatures"].writeList(value.optInFeatures, memberWritingClosure: SecurityIRClientTypes.OptInFeature.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension GetCaseAttachmentUploadUrlInput {

    static func write(value: GetCaseAttachmentUploadUrlInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["contentLength"].write(value.contentLength)
        try writer["fileName"].write(value.fileName)
    }
}

extension ListCaseEditsInput {

    static func write(value: ListCaseEditsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListCasesInput {

    static func write(value: ListCasesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListCommentsInput {

    static func write(value: ListCommentsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListMembershipsInput {

    static func write(value: ListMembershipsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateCaseInput {

    static func write(value: UpdateCaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actualIncidentStartDate"].writeTimestamp(value.actualIncidentStartDate, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["description"].write(value.description)
        try writer["engagementType"].write(value.engagementType)
        try writer["impactedAccountsToAdd"].writeList(value.impactedAccountsToAdd, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["impactedAccountsToDelete"].writeList(value.impactedAccountsToDelete, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["impactedAwsRegionsToAdd"].writeList(value.impactedAwsRegionsToAdd, memberWritingClosure: SecurityIRClientTypes.ImpactedAwsRegion.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["impactedAwsRegionsToDelete"].writeList(value.impactedAwsRegionsToDelete, memberWritingClosure: SecurityIRClientTypes.ImpactedAwsRegion.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["impactedServicesToAdd"].writeList(value.impactedServicesToAdd, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["impactedServicesToDelete"].writeList(value.impactedServicesToDelete, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["reportedIncidentStartDate"].writeTimestamp(value.reportedIncidentStartDate, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["threatActorIpAddressesToAdd"].writeList(value.threatActorIpAddressesToAdd, memberWritingClosure: SecurityIRClientTypes.ThreatActorIp.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["threatActorIpAddressesToDelete"].writeList(value.threatActorIpAddressesToDelete, memberWritingClosure: SecurityIRClientTypes.ThreatActorIp.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["title"].write(value.title)
        try writer["watchersToAdd"].writeList(value.watchersToAdd, memberWritingClosure: SecurityIRClientTypes.Watcher.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["watchersToDelete"].writeList(value.watchersToDelete, memberWritingClosure: SecurityIRClientTypes.Watcher.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateCaseCommentInput {

    static func write(value: UpdateCaseCommentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["body"].write(value.body)
    }
}

extension UpdateCaseStatusInput {

    static func write(value: UpdateCaseStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["caseStatus"].write(value.caseStatus)
    }
}

extension UpdateMembershipInput {

    static func write(value: UpdateMembershipInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["incidentResponseTeam"].writeList(value.incidentResponseTeam, memberWritingClosure: SecurityIRClientTypes.IncidentResponder.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["membershipName"].write(value.membershipName)
        try writer["optInFeatures"].writeList(value.optInFeatures, memberWritingClosure: SecurityIRClientTypes.OptInFeature.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateResolverTypeInput {

    static func write(value: UpdateResolverTypeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resolverType"].write(value.resolverType)
    }
}

extension BatchGetMemberAccountDetailsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetMemberAccountDetailsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetMemberAccountDetailsOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: SecurityIRClientTypes.GetMembershipAccountDetailError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: SecurityIRClientTypes.GetMembershipAccountDetailItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CancelMembershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelMembershipOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelMembershipOutput()
        value.membershipId = try reader["membershipId"].readIfPresent() ?? ""
        return value
    }
}

extension CloseCaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CloseCaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CloseCaseOutput()
        value.caseStatus = try reader["caseStatus"].readIfPresent()
        value.closedDate = try reader["closedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension CreateCaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCaseOutput()
        value.caseId = try reader["caseId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateCaseCommentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCaseCommentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCaseCommentOutput()
        value.commentId = try reader["commentId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateMembershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMembershipOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMembershipOutput()
        value.membershipId = try reader["membershipId"].readIfPresent() ?? ""
        return value
    }
}

extension GetCaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCaseOutput()
        value.actualIncidentStartDate = try reader["actualIncidentStartDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.caseArn = try reader["caseArn"].readIfPresent()
        value.caseAttachments = try reader["caseAttachments"].readListIfPresent(memberReadingClosure: SecurityIRClientTypes.CaseAttachmentAttributes.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.caseStatus = try reader["caseStatus"].readIfPresent()
        value.closedDate = try reader["closedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.closureCode = try reader["closureCode"].readIfPresent()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.engagementType = try reader["engagementType"].readIfPresent()
        value.impactedAccounts = try reader["impactedAccounts"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.impactedAwsRegions = try reader["impactedAwsRegions"].readListIfPresent(memberReadingClosure: SecurityIRClientTypes.ImpactedAwsRegion.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.impactedServices = try reader["impactedServices"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.pendingAction = try reader["pendingAction"].readIfPresent()
        value.reportedIncidentStartDate = try reader["reportedIncidentStartDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.resolverType = try reader["resolverType"].readIfPresent()
        value.threatActorIpAddresses = try reader["threatActorIpAddresses"].readListIfPresent(memberReadingClosure: SecurityIRClientTypes.ThreatActorIp.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.title = try reader["title"].readIfPresent()
        value.watchers = try reader["watchers"].readListIfPresent(memberReadingClosure: SecurityIRClientTypes.Watcher.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetCaseAttachmentDownloadUrlOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCaseAttachmentDownloadUrlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCaseAttachmentDownloadUrlOutput()
        value.attachmentPresignedUrl = try reader["attachmentPresignedUrl"].readIfPresent() ?? ""
        return value
    }
}

extension GetCaseAttachmentUploadUrlOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCaseAttachmentUploadUrlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCaseAttachmentUploadUrlOutput()
        value.attachmentPresignedUrl = try reader["attachmentPresignedUrl"].readIfPresent() ?? ""
        return value
    }
}

extension GetMembershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMembershipOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMembershipOutput()
        value.accountId = try reader["accountId"].readIfPresent()
        value.customerType = try reader["customerType"].readIfPresent()
        value.incidentResponseTeam = try reader["incidentResponseTeam"].readListIfPresent(memberReadingClosure: SecurityIRClientTypes.IncidentResponder.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.membershipActivationTimestamp = try reader["membershipActivationTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.membershipArn = try reader["membershipArn"].readIfPresent()
        value.membershipDeactivationTimestamp = try reader["membershipDeactivationTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.membershipId = try reader["membershipId"].readIfPresent() ?? ""
        value.membershipName = try reader["membershipName"].readIfPresent()
        value.membershipStatus = try reader["membershipStatus"].readIfPresent()
        value.numberOfAccountsCovered = try reader["numberOfAccountsCovered"].readIfPresent()
        value.optInFeatures = try reader["optInFeatures"].readListIfPresent(memberReadingClosure: SecurityIRClientTypes.OptInFeature.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.region = try reader["region"].readIfPresent()
        return value
    }
}

extension ListCaseEditsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCaseEditsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCaseEditsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: SecurityIRClientTypes.CaseEditItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.total = try reader["total"].readIfPresent()
        return value
    }
}

extension ListCasesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCasesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCasesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: SecurityIRClientTypes.ListCasesItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.total = try reader["total"].readIfPresent()
        return value
    }
}

extension ListCommentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCommentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCommentsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: SecurityIRClientTypes.ListCommentsItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.total = try reader["total"].readIfPresent()
        return value
    }
}

extension ListMembershipsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMembershipsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMembershipsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: SecurityIRClientTypes.ListMembershipItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateCaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCaseOutput {
        return UpdateCaseOutput()
    }
}

extension UpdateCaseCommentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCaseCommentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateCaseCommentOutput()
        value.body = try reader["body"].readIfPresent()
        value.commentId = try reader["commentId"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateCaseStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCaseStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateCaseStatusOutput()
        value.caseStatus = try reader["caseStatus"].readIfPresent()
        return value
    }
}

extension UpdateMembershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateMembershipOutput {
        return UpdateMembershipOutput()
    }
}

extension UpdateResolverTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateResolverTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateResolverTypeOutput()
        value.caseId = try reader["caseId"].readIfPresent() ?? ""
        value.caseStatus = try reader["caseStatus"].readIfPresent()
        value.resolverType = try reader["resolverType"].readIfPresent()
        return value
    }
}

func httpServiceError(baseError: AWSClientRuntime.RestJSONError) throws -> Swift.Error? {
    switch baseError.code {
        case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
        case "ConflictException": return try ConflictException.makeError(baseError: baseError)
        case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
        case "InvalidTokenException": return try InvalidTokenException.makeError(baseError: baseError)
        case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
        case "SecurityIncidentResponseNotActiveException": return try SecurityIncidentResponseNotActiveException.makeError(baseError: baseError)
        case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
        case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
        case "ValidationException": return try ValidationException.makeError(baseError: baseError)
        default: return nil
    }
}

enum BatchGetMemberAccountDetailsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelMembershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CloseCaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCaseCommentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMembershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCaseAttachmentDownloadUrlOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCaseAttachmentUploadUrlOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMembershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCaseEditsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCasesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCommentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMembershipsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCaseCommentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCaseStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateMembershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateResolverTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: SecurityIRClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidTokenException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidTokenException {
        let reader = baseError.errorBodyReader
        var value = InvalidTokenException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SecurityIncidentResponseNotActiveException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> SecurityIncidentResponseNotActiveException {
        let reader = baseError.errorBodyReader
        var value = SecurityIncidentResponseNotActiveException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SecurityIRClientTypes.GetMembershipAccountDetailItem {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityIRClientTypes.GetMembershipAccountDetailItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityIRClientTypes.GetMembershipAccountDetailItem()
        value.accountId = try reader["accountId"].readIfPresent()
        value.relationshipStatus = try reader["relationshipStatus"].readIfPresent()
        value.relationshipType = try reader["relationshipType"].readIfPresent()
        return value
    }
}

extension SecurityIRClientTypes.GetMembershipAccountDetailError {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityIRClientTypes.GetMembershipAccountDetailError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityIRClientTypes.GetMembershipAccountDetailError()
        value.accountId = try reader["accountId"].readIfPresent() ?? ""
        value.error = try reader["error"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension SecurityIRClientTypes.ImpactedAwsRegion {

    static func write(value: SecurityIRClientTypes.ImpactedAwsRegion?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["region"].write(value.region)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityIRClientTypes.ImpactedAwsRegion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityIRClientTypes.ImpactedAwsRegion()
        value.region = try reader["region"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension SecurityIRClientTypes.ThreatActorIp {

    static func write(value: SecurityIRClientTypes.ThreatActorIp?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ipAddress"].write(value.ipAddress)
        try writer["userAgent"].write(value.userAgent)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityIRClientTypes.ThreatActorIp {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityIRClientTypes.ThreatActorIp()
        value.ipAddress = try reader["ipAddress"].readIfPresent() ?? ""
        value.userAgent = try reader["userAgent"].readIfPresent()
        return value
    }
}

extension SecurityIRClientTypes.Watcher {

    static func write(value: SecurityIRClientTypes.Watcher?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["email"].write(value.email)
        try writer["jobTitle"].write(value.jobTitle)
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityIRClientTypes.Watcher {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityIRClientTypes.Watcher()
        value.email = try reader["email"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.jobTitle = try reader["jobTitle"].readIfPresent()
        return value
    }
}

extension SecurityIRClientTypes.CaseAttachmentAttributes {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityIRClientTypes.CaseAttachmentAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityIRClientTypes.CaseAttachmentAttributes()
        value.attachmentId = try reader["attachmentId"].readIfPresent() ?? ""
        value.fileName = try reader["fileName"].readIfPresent() ?? ""
        value.attachmentStatus = try reader["attachmentStatus"].readIfPresent() ?? .sdkUnknown("")
        value.creator = try reader["creator"].readIfPresent() ?? ""
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension SecurityIRClientTypes.IncidentResponder {

    static func write(value: SecurityIRClientTypes.IncidentResponder?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["email"].write(value.email)
        try writer["jobTitle"].write(value.jobTitle)
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityIRClientTypes.IncidentResponder {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityIRClientTypes.IncidentResponder()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.jobTitle = try reader["jobTitle"].readIfPresent() ?? ""
        value.email = try reader["email"].readIfPresent() ?? ""
        return value
    }
}

extension SecurityIRClientTypes.OptInFeature {

    static func write(value: SecurityIRClientTypes.OptInFeature?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["featureName"].write(value.featureName)
        try writer["isEnabled"].write(value.isEnabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityIRClientTypes.OptInFeature {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityIRClientTypes.OptInFeature()
        value.featureName = try reader["featureName"].readIfPresent() ?? .sdkUnknown("")
        value.isEnabled = try reader["isEnabled"].readIfPresent() ?? false
        return value
    }
}

extension SecurityIRClientTypes.CaseEditItem {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityIRClientTypes.CaseEditItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityIRClientTypes.CaseEditItem()
        value.eventTimestamp = try reader["eventTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.principal = try reader["principal"].readIfPresent()
        value.action = try reader["action"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension SecurityIRClientTypes.ListCasesItem {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityIRClientTypes.ListCasesItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityIRClientTypes.ListCasesItem()
        value.caseId = try reader["caseId"].readIfPresent() ?? ""
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.title = try reader["title"].readIfPresent()
        value.caseArn = try reader["caseArn"].readIfPresent()
        value.engagementType = try reader["engagementType"].readIfPresent()
        value.caseStatus = try reader["caseStatus"].readIfPresent()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.closedDate = try reader["closedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.resolverType = try reader["resolverType"].readIfPresent()
        value.pendingAction = try reader["pendingAction"].readIfPresent()
        return value
    }
}

extension SecurityIRClientTypes.ListCommentsItem {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityIRClientTypes.ListCommentsItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityIRClientTypes.ListCommentsItem()
        value.commentId = try reader["commentId"].readIfPresent() ?? ""
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.creator = try reader["creator"].readIfPresent()
        value.lastUpdatedBy = try reader["lastUpdatedBy"].readIfPresent()
        value.body = try reader["body"].readIfPresent()
        return value
    }
}

extension SecurityIRClientTypes.ListMembershipItem {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityIRClientTypes.ListMembershipItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityIRClientTypes.ListMembershipItem()
        value.membershipId = try reader["membershipId"].readIfPresent() ?? ""
        value.accountId = try reader["accountId"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.membershipArn = try reader["membershipArn"].readIfPresent()
        value.membershipStatus = try reader["membershipStatus"].readIfPresent()
        return value
    }
}

extension SecurityIRClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> SecurityIRClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SecurityIRClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

public enum SecurityIRClientTypes {}
