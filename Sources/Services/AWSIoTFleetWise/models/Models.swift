// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You don't have sufficient permission to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTFleetWiseClientTypes.Actuator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedValues
        case assignedValue
        case dataType
        case description
        case fullyQualifiedName
        case max
        case min
        case unit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedValues = allowedValues {
            var allowedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedValues)
            for string0 in allowedValues {
                try allowedValuesContainer.encode(string0)
            }
        }
        if let assignedValue = self.assignedValue {
            try encodeContainer.encode(assignedValue, forKey: .assignedValue)
        }
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let fullyQualifiedName = self.fullyQualifiedName {
            try encodeContainer.encode(fullyQualifiedName, forKey: .fullyQualifiedName)
        }
        if let max = self.max {
            try encodeContainer.encode(max, forKey: .max)
        }
        if let min = self.min {
            try encodeContainer.encode(min, forKey: .min)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fullyQualifiedNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fullyQualifiedName)
        fullyQualifiedName = fullyQualifiedNameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.NodeDataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let allowedValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowedValues)
        var allowedValuesDecoded0:[Swift.String]? = nil
        if let allowedValuesContainer = allowedValuesContainer {
            allowedValuesDecoded0 = [Swift.String]()
            for string0 in allowedValuesContainer {
                if let string0 = string0 {
                    allowedValuesDecoded0?.append(string0)
                }
            }
        }
        allowedValues = allowedValuesDecoded0
        let minDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .min)
        min = minDecoded
        let maxDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .max)
        max = maxDecoded
        let assignedValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assignedValue)
        assignedValue = assignedValueDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// A signal that represents a vehicle device such as the engine, heater, and door locks. Data from an actuator reports the state of a certain vehicle device. Updating actuator data can change the state of a device. For example, you can turn on or off the heater by updating its actuator data.
    public struct Actuator: Swift.Equatable {
        /// A list of possible values an actuator can take.
        public var allowedValues: [Swift.String]?
        /// A specified value for the actuator.
        @available(*, deprecated, message: "assignedValue is no longer in use")
        public var assignedValue: Swift.String?
        /// The specified data type of the actuator.
        /// This member is required.
        public var dataType: IoTFleetWiseClientTypes.NodeDataType?
        /// A brief description of the actuator.
        public var description: Swift.String?
        /// The fully qualified name of the actuator. For example, the fully qualified name of an actuator might be Vehicle.Front.Left.Door.Lock.
        /// This member is required.
        public var fullyQualifiedName: Swift.String?
        /// The specified possible maximum value of an actuator.
        public var max: Swift.Double?
        /// The specified possible minimum value of an actuator.
        public var min: Swift.Double?
        /// The scientific unit for the actuator.
        public var unit: Swift.String?

        public init (
            allowedValues: [Swift.String]? = nil,
            assignedValue: Swift.String? = nil,
            dataType: IoTFleetWiseClientTypes.NodeDataType? = nil,
            description: Swift.String? = nil,
            fullyQualifiedName: Swift.String? = nil,
            max: Swift.Double? = nil,
            min: Swift.Double? = nil,
            unit: Swift.String? = nil
        )
        {
            self.allowedValues = allowedValues
            self.assignedValue = assignedValue
            self.dataType = dataType
            self.description = description
            self.fullyQualifiedName = fullyQualifiedName
            self.max = max
            self.min = min
            self.unit = unit
        }
    }

}

extension AssociateVehicleFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetId = self.fleetId {
            try encodeContainer.encode(fleetId, forKey: .fleetId)
        }
    }
}

extension AssociateVehicleFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateVehicleFleetInput: Swift.Equatable {
    /// The ID of a fleet.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The unique ID of the vehicle to associate with the fleet.
    /// This member is required.
    public var vehicleName: Swift.String?

    public init (
        fleetId: Swift.String? = nil,
        vehicleName: Swift.String? = nil
    )
    {
        self.fleetId = fleetId
        self.vehicleName = vehicleName
    }
}

struct AssociateVehicleFleetInputBody: Swift.Equatable {
    let fleetId: Swift.String?
}

extension AssociateVehicleFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetId)
        fleetId = fleetIdDecoded
    }
}

extension AssociateVehicleFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateVehicleFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateVehicleFleetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateVehicleFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateVehicleFleetOutputResponse: Swift.Equatable {

    public init () { }
}

extension IoTFleetWiseClientTypes.Attribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedValues
        case assignedValue
        case dataType
        case defaultValue
        case description
        case fullyQualifiedName
        case max
        case min
        case unit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedValues = allowedValues {
            var allowedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedValues)
            for string0 in allowedValues {
                try allowedValuesContainer.encode(string0)
            }
        }
        if let assignedValue = self.assignedValue {
            try encodeContainer.encode(assignedValue, forKey: .assignedValue)
        }
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let fullyQualifiedName = self.fullyQualifiedName {
            try encodeContainer.encode(fullyQualifiedName, forKey: .fullyQualifiedName)
        }
        if let max = self.max {
            try encodeContainer.encode(max, forKey: .max)
        }
        if let min = self.min {
            try encodeContainer.encode(min, forKey: .min)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fullyQualifiedNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fullyQualifiedName)
        fullyQualifiedName = fullyQualifiedNameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.NodeDataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let allowedValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowedValues)
        var allowedValuesDecoded0:[Swift.String]? = nil
        if let allowedValuesContainer = allowedValuesContainer {
            allowedValuesDecoded0 = [Swift.String]()
            for string0 in allowedValuesContainer {
                if let string0 = string0 {
                    allowedValuesDecoded0?.append(string0)
                }
            }
        }
        allowedValues = allowedValuesDecoded0
        let minDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .min)
        min = minDecoded
        let maxDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .max)
        max = maxDecoded
        let assignedValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assignedValue)
        assignedValue = assignedValueDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// A signal that represents static information about the vehicle, such as engine type or manufacturing date.
    public struct Attribute: Swift.Equatable {
        /// A list of possible values an attribute can be assigned.
        public var allowedValues: [Swift.String]?
        /// A specified value for the attribute.
        @available(*, deprecated, message: "assignedValue is no longer in use")
        public var assignedValue: Swift.String?
        /// The specified data type of the attribute.
        /// This member is required.
        public var dataType: IoTFleetWiseClientTypes.NodeDataType?
        /// The default value of the attribute.
        public var defaultValue: Swift.String?
        /// A brief description of the attribute.
        public var description: Swift.String?
        /// The fully qualified name of the attribute. For example, the fully qualified name of an attribute might be Vehicle.Body.Engine.Type.
        /// This member is required.
        public var fullyQualifiedName: Swift.String?
        /// The specified possible maximum value of the attribute.
        public var max: Swift.Double?
        /// The specified possible minimum value of the attribute.
        public var min: Swift.Double?
        /// The scientific unit for the attribute.
        public var unit: Swift.String?

        public init (
            allowedValues: [Swift.String]? = nil,
            assignedValue: Swift.String? = nil,
            dataType: IoTFleetWiseClientTypes.NodeDataType? = nil,
            defaultValue: Swift.String? = nil,
            description: Swift.String? = nil,
            fullyQualifiedName: Swift.String? = nil,
            max: Swift.Double? = nil,
            min: Swift.Double? = nil,
            unit: Swift.String? = nil
        )
        {
            self.allowedValues = allowedValues
            self.assignedValue = assignedValue
            self.dataType = dataType
            self.defaultValue = defaultValue
            self.description = description
            self.fullyQualifiedName = fullyQualifiedName
            self.max = max
            self.min = min
            self.unit = unit
        }
    }

}

extension BatchCreateVehicleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vehicles
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vehicles = vehicles {
            var vehiclesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vehicles)
            for createvehiclerequestitem0 in vehicles {
                try vehiclesContainer.encode(createvehiclerequestitem0)
            }
        }
    }
}

extension BatchCreateVehicleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchCreateVehicleInput: Swift.Equatable {
    /// A list of information about each vehicle to create. For more information, see the API data type.
    /// This member is required.
    public var vehicles: [IoTFleetWiseClientTypes.CreateVehicleRequestItem]?

    public init (
        vehicles: [IoTFleetWiseClientTypes.CreateVehicleRequestItem]? = nil
    )
    {
        self.vehicles = vehicles
    }
}

struct BatchCreateVehicleInputBody: Swift.Equatable {
    let vehicles: [IoTFleetWiseClientTypes.CreateVehicleRequestItem]?
}

extension BatchCreateVehicleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vehicles
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vehiclesContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.CreateVehicleRequestItem?].self, forKey: .vehicles)
        var vehiclesDecoded0:[IoTFleetWiseClientTypes.CreateVehicleRequestItem]? = nil
        if let vehiclesContainer = vehiclesContainer {
            vehiclesDecoded0 = [IoTFleetWiseClientTypes.CreateVehicleRequestItem]()
            for structure0 in vehiclesContainer {
                if let structure0 = structure0 {
                    vehiclesDecoded0?.append(structure0)
                }
            }
        }
        vehicles = vehiclesDecoded0
    }
}

extension BatchCreateVehicleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchCreateVehicleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchCreateVehicleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case limitExceededException(LimitExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchCreateVehicleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchCreateVehicleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
            self.vehicles = output.vehicles
        } else {
            self.errors = nil
            self.vehicles = nil
        }
    }
}

public struct BatchCreateVehicleOutputResponse: Swift.Equatable {
    /// A list of information about creation errors, or an empty list if there aren't any errors.
    public var errors: [IoTFleetWiseClientTypes.CreateVehicleError]?
    /// A list of information about a batch of created vehicles. For more information, see the API data type.
    public var vehicles: [IoTFleetWiseClientTypes.CreateVehicleResponseItem]?

    public init (
        errors: [IoTFleetWiseClientTypes.CreateVehicleError]? = nil,
        vehicles: [IoTFleetWiseClientTypes.CreateVehicleResponseItem]? = nil
    )
    {
        self.errors = errors
        self.vehicles = vehicles
    }
}

struct BatchCreateVehicleOutputResponseBody: Swift.Equatable {
    let vehicles: [IoTFleetWiseClientTypes.CreateVehicleResponseItem]?
    let errors: [IoTFleetWiseClientTypes.CreateVehicleError]?
}

extension BatchCreateVehicleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
        case vehicles
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vehiclesContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.CreateVehicleResponseItem?].self, forKey: .vehicles)
        var vehiclesDecoded0:[IoTFleetWiseClientTypes.CreateVehicleResponseItem]? = nil
        if let vehiclesContainer = vehiclesContainer {
            vehiclesDecoded0 = [IoTFleetWiseClientTypes.CreateVehicleResponseItem]()
            for structure0 in vehiclesContainer {
                if let structure0 = structure0 {
                    vehiclesDecoded0?.append(structure0)
                }
            }
        }
        vehicles = vehiclesDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.CreateVehicleError?].self, forKey: .errors)
        var errorsDecoded0:[IoTFleetWiseClientTypes.CreateVehicleError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [IoTFleetWiseClientTypes.CreateVehicleError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension BatchUpdateVehicleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vehicles
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vehicles = vehicles {
            var vehiclesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vehicles)
            for updatevehiclerequestitem0 in vehicles {
                try vehiclesContainer.encode(updatevehiclerequestitem0)
            }
        }
    }
}

extension BatchUpdateVehicleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchUpdateVehicleInput: Swift.Equatable {
    /// A list of information about the vehicles to update. For more information, see the API data type.
    /// This member is required.
    public var vehicles: [IoTFleetWiseClientTypes.UpdateVehicleRequestItem]?

    public init (
        vehicles: [IoTFleetWiseClientTypes.UpdateVehicleRequestItem]? = nil
    )
    {
        self.vehicles = vehicles
    }
}

struct BatchUpdateVehicleInputBody: Swift.Equatable {
    let vehicles: [IoTFleetWiseClientTypes.UpdateVehicleRequestItem]?
}

extension BatchUpdateVehicleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vehicles
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vehiclesContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.UpdateVehicleRequestItem?].self, forKey: .vehicles)
        var vehiclesDecoded0:[IoTFleetWiseClientTypes.UpdateVehicleRequestItem]? = nil
        if let vehiclesContainer = vehiclesContainer {
            vehiclesDecoded0 = [IoTFleetWiseClientTypes.UpdateVehicleRequestItem]()
            for structure0 in vehiclesContainer {
                if let structure0 = structure0 {
                    vehiclesDecoded0?.append(structure0)
                }
            }
        }
        vehicles = vehiclesDecoded0
    }
}

extension BatchUpdateVehicleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchUpdateVehicleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchUpdateVehicleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchUpdateVehicleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchUpdateVehicleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
            self.vehicles = output.vehicles
        } else {
            self.errors = nil
            self.vehicles = nil
        }
    }
}

public struct BatchUpdateVehicleOutputResponse: Swift.Equatable {
    /// A list of information about errors returned while updating a batch of vehicles, or, if there aren't any errors, an empty list.
    public var errors: [IoTFleetWiseClientTypes.UpdateVehicleError]?
    /// A list of information about the batch of updated vehicles. This list contains only unique IDs for the vehicles that were updated.
    public var vehicles: [IoTFleetWiseClientTypes.UpdateVehicleResponseItem]?

    public init (
        errors: [IoTFleetWiseClientTypes.UpdateVehicleError]? = nil,
        vehicles: [IoTFleetWiseClientTypes.UpdateVehicleResponseItem]? = nil
    )
    {
        self.errors = errors
        self.vehicles = vehicles
    }
}

struct BatchUpdateVehicleOutputResponseBody: Swift.Equatable {
    let vehicles: [IoTFleetWiseClientTypes.UpdateVehicleResponseItem]?
    let errors: [IoTFleetWiseClientTypes.UpdateVehicleError]?
}

extension BatchUpdateVehicleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
        case vehicles
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vehiclesContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.UpdateVehicleResponseItem?].self, forKey: .vehicles)
        var vehiclesDecoded0:[IoTFleetWiseClientTypes.UpdateVehicleResponseItem]? = nil
        if let vehiclesContainer = vehiclesContainer {
            vehiclesDecoded0 = [IoTFleetWiseClientTypes.UpdateVehicleResponseItem]()
            for structure0 in vehiclesContainer {
                if let structure0 = structure0 {
                    vehiclesDecoded0?.append(structure0)
                }
            }
        }
        vehicles = vehiclesDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.UpdateVehicleError?].self, forKey: .errors)
        var errorsDecoded0:[IoTFleetWiseClientTypes.UpdateVehicleError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [IoTFleetWiseClientTypes.UpdateVehicleError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension IoTFleetWiseClientTypes.Branch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case fullyQualifiedName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let fullyQualifiedName = self.fullyQualifiedName {
            try encodeContainer.encode(fullyQualifiedName, forKey: .fullyQualifiedName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fullyQualifiedNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fullyQualifiedName)
        fullyQualifiedName = fullyQualifiedNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// A group of signals that are defined in a hierarchical structure.
    public struct Branch: Swift.Equatable {
        /// A brief description of the branch.
        public var description: Swift.String?
        /// The fully qualified name of the branch. For example, the fully qualified name of a branch might be Vehicle.Body.Engine.
        /// This member is required.
        public var fullyQualifiedName: Swift.String?

        public init (
            description: Swift.String? = nil,
            fullyQualifiedName: Swift.String? = nil
        )
        {
            self.description = description
            self.fullyQualifiedName = fullyQualifiedName
        }
    }

}

extension IoTFleetWiseClientTypes {
    public enum CampaignStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creating
        case running
        case suspended
        case waitingForApproval
        case sdkUnknown(Swift.String)

        public static var allCases: [CampaignStatus] {
            return [
                .creating,
                .running,
                .suspended,
                .waitingForApproval,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .running: return "RUNNING"
            case .suspended: return "SUSPENDED"
            case .waitingForApproval: return "WAITING_FOR_APPROVAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CampaignStatus(rawValue: rawValue) ?? CampaignStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTFleetWiseClientTypes.CampaignSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case lastModificationTime
        case name
        case signalCatalogArn
        case status
        case targetArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let signalCatalogArn = self.signalCatalogArn {
            try encodeContainer.encode(signalCatalogArn, forKey: .signalCatalogArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targetArn = self.targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let signalCatalogArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signalCatalogArn)
        signalCatalogArn = signalCatalogArnDecoded
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.CampaignStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about a campaign. You can use the API operation to return this information about multiple created campaigns.
    public struct CampaignSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of a campaign.
        public var arn: Swift.String?
        /// The time the campaign was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The description of the campaign.
        public var description: Swift.String?
        /// The last time the campaign was modified.
        /// This member is required.
        public var lastModificationTime: ClientRuntime.Date?
        /// The name of a campaign.
        public var name: Swift.String?
        /// The ARN of the signal catalog associated with the campaign.
        public var signalCatalogArn: Swift.String?
        /// The state of a campaign. The status can be one of the following:
        ///
        /// * CREATING - Amazon Web Services IoT FleetWise is processing your request to create the campaign.
        ///
        /// * WAITING_FOR_APPROVAL - After a campaign is created, it enters the WAITING_FOR_APPROVAL state. To allow Amazon Web Services IoT FleetWise to deploy the campaign to the target vehicle or fleet, use the API operation to approve the campaign.
        ///
        /// * RUNNING - The campaign is active.
        ///
        /// * SUSPENDED - The campaign is suspended. To resume the campaign, use the API operation.
        public var status: IoTFleetWiseClientTypes.CampaignStatus?
        /// The ARN of a vehicle or fleet to which the campaign is deployed.
        public var targetArn: Swift.String?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            signalCatalogArn: Swift.String? = nil,
            status: IoTFleetWiseClientTypes.CampaignStatus? = nil,
            targetArn: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.lastModificationTime = lastModificationTime
            self.name = name
            self.signalCatalogArn = signalCatalogArn
            self.status = status
            self.targetArn = targetArn
        }
    }

}

extension IoTFleetWiseClientTypes.CanDbcDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canDbcFiles
        case networkInterface
        case signalsMap
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let canDbcFiles = canDbcFiles {
            var canDbcFilesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .canDbcFiles)
            for networkfileblob0 in canDbcFiles {
                try canDbcFilesContainer.encode(networkfileblob0.base64EncodedString())
            }
        }
        if let networkInterface = self.networkInterface {
            try encodeContainer.encode(networkInterface, forKey: .networkInterface)
        }
        if let signalsMap = signalsMap {
            var signalsMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .signalsMap)
            for (dictKey0, modelSignalsMap0) in signalsMap {
                try signalsMapContainer.encode(modelSignalsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkInterfaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterface)
        networkInterface = networkInterfaceDecoded
        let canDbcFilesContainer = try containerValues.decodeIfPresent([ClientRuntime.Data?].self, forKey: .canDbcFiles)
        var canDbcFilesDecoded0:[ClientRuntime.Data]? = nil
        if let canDbcFilesContainer = canDbcFilesContainer {
            canDbcFilesDecoded0 = [ClientRuntime.Data]()
            for blob0 in canDbcFilesContainer {
                if let blob0 = blob0 {
                    canDbcFilesDecoded0?.append(blob0)
                }
            }
        }
        canDbcFiles = canDbcFilesDecoded0
        let signalsMapContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .signalsMap)
        var signalsMapDecoded0: [Swift.String:Swift.String]? = nil
        if let signalsMapContainer = signalsMapContainer {
            signalsMapDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in signalsMapContainer {
                if let string0 = string0 {
                    signalsMapDecoded0?[key0] = string0
                }
            }
        }
        signalsMap = signalsMapDecoded0
    }
}

extension IoTFleetWiseClientTypes {
    /// Configurations used to create a decoder manifest.
    public struct CanDbcDefinition: Swift.Equatable {
        /// A list of DBC files. You can upload only one DBC file for each network interface and specify up to five (inclusive) files in the list.
        /// This member is required.
        public var canDbcFiles: [ClientRuntime.Data]?
        /// Contains information about a network interface.
        /// This member is required.
        public var networkInterface: Swift.String?
        /// Pairs every signal specified in your vehicle model with a signal decoder.
        public var signalsMap: [Swift.String:Swift.String]?

        public init (
            canDbcFiles: [ClientRuntime.Data]? = nil,
            networkInterface: Swift.String? = nil,
            signalsMap: [Swift.String:Swift.String]? = nil
        )
        {
            self.canDbcFiles = canDbcFiles
            self.networkInterface = networkInterface
            self.signalsMap = signalsMap
        }
    }

}

extension IoTFleetWiseClientTypes.CanInterface: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case protocolName
        case protocolVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let protocolName = self.protocolName {
            try encodeContainer.encode(protocolName, forKey: .protocolName)
        }
        if let protocolVersion = self.protocolVersion {
            try encodeContainer.encode(protocolVersion, forKey: .protocolVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let protocolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocolName)
        protocolName = protocolNameDecoded
        let protocolVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocolVersion)
        protocolVersion = protocolVersionDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// A single controller area network (CAN) device interface.
    public struct CanInterface: Swift.Equatable {
        /// The unique name of the interface.
        /// This member is required.
        public var name: Swift.String?
        /// The name of the communication protocol for the interface.
        public var protocolName: Swift.String?
        /// The version of the communication protocol for the interface.
        public var protocolVersion: Swift.String?

        public init (
            name: Swift.String? = nil,
            protocolName: Swift.String? = nil,
            protocolVersion: Swift.String? = nil
        )
        {
            self.name = name
            self.protocolName = protocolName
            self.protocolVersion = protocolVersion
        }
    }

}

extension IoTFleetWiseClientTypes.CanSignal: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case factor
        case isBigEndian
        case isSigned
        case length
        case messageId
        case name
        case offset
        case startBit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let factor = self.factor {
            try encodeContainer.encode(factor, forKey: .factor)
        }
        if isBigEndian != false {
            try encodeContainer.encode(isBigEndian, forKey: .isBigEndian)
        }
        if isSigned != false {
            try encodeContainer.encode(isSigned, forKey: .isSigned)
        }
        if length != 0 {
            try encodeContainer.encode(length, forKey: .length)
        }
        if messageId != 0 {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let offset = self.offset {
            try encodeContainer.encode(offset, forKey: .offset)
        }
        if startBit != 0 {
            try encodeContainer.encode(startBit, forKey: .startBit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .messageId) ?? 0
        messageId = messageIdDecoded
        let isBigEndianDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isBigEndian) ?? false
        isBigEndian = isBigEndianDecoded
        let isSignedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isSigned) ?? false
        isSigned = isSignedDecoded
        let startBitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startBit) ?? 0
        startBit = startBitDecoded
        let offsetDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .offset)
        offset = offsetDecoded
        let factorDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .factor)
        factor = factorDecoded
        let lengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .length) ?? 0
        length = lengthDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about a single controller area network (CAN) signal and the messages it receives and transmits.
    public struct CanSignal: Swift.Equatable {
        /// A multiplier used to decode the CAN message.
        /// This member is required.
        public var factor: Swift.Double?
        /// Whether the byte ordering of a CAN message is big-endian.
        /// This member is required.
        public var isBigEndian: Swift.Bool
        /// Whether the message data is specified as a signed value.
        /// This member is required.
        public var isSigned: Swift.Bool
        /// How many bytes of data are in the message.
        /// This member is required.
        public var length: Swift.Int
        /// The ID of the message.
        /// This member is required.
        public var messageId: Swift.Int
        /// The name of the signal.
        public var name: Swift.String?
        /// Indicates where data appears in the CAN message.
        /// This member is required.
        public var offset: Swift.Double?
        /// Indicates the beginning of the CAN message.
        /// This member is required.
        public var startBit: Swift.Int

        public init (
            factor: Swift.Double? = nil,
            isBigEndian: Swift.Bool = false,
            isSigned: Swift.Bool = false,
            length: Swift.Int = 0,
            messageId: Swift.Int = 0,
            name: Swift.String? = nil,
            offset: Swift.Double? = nil,
            startBit: Swift.Int = 0
        )
        {
            self.factor = factor
            self.isBigEndian = isBigEndian
            self.isSigned = isSigned
            self.length = length
            self.messageId = messageId
            self.name = name
            self.offset = offset
            self.startBit = startBit
        }
    }

}

extension IoTFleetWiseClientTypes.CloudWatchLogDeliveryOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logGroupName
        case logType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logGroupName = self.logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
        if let logType = self.logType {
            try encodeContainer.encode(logType.rawValue, forKey: .logType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logTypeDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.LogType.self, forKey: .logType)
        logType = logTypeDecoded
        let logGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// The log delivery option to send data to Amazon CloudWatch Logs.
    public struct CloudWatchLogDeliveryOptions: Swift.Equatable {
        /// The Amazon CloudWatch Logs group the operation sends data to.
        public var logGroupName: Swift.String?
        /// The type of log to send data to Amazon CloudWatch Logs.
        /// This member is required.
        public var logType: IoTFleetWiseClientTypes.LogType?

        public init (
            logGroupName: Swift.String? = nil,
            logType: IoTFleetWiseClientTypes.LogType? = nil
        )
        {
            self.logGroupName = logGroupName
            self.logType = logType
        }
    }

}

extension IoTFleetWiseClientTypes.CollectionScheme: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conditionbasedcollectionscheme = "conditionBasedCollectionScheme"
        case sdkUnknown
        case timebasedcollectionscheme = "timeBasedCollectionScheme"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .conditionbasedcollectionscheme(conditionbasedcollectionscheme):
                try container.encode(conditionbasedcollectionscheme, forKey: .conditionbasedcollectionscheme)
            case let .timebasedcollectionscheme(timebasedcollectionscheme):
                try container.encode(timebasedcollectionscheme, forKey: .timebasedcollectionscheme)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let timebasedcollectionschemeDecoded = try values.decodeIfPresent(IoTFleetWiseClientTypes.TimeBasedCollectionScheme.self, forKey: .timebasedcollectionscheme)
        if let timebasedcollectionscheme = timebasedcollectionschemeDecoded {
            self = .timebasedcollectionscheme(timebasedcollectionscheme)
            return
        }
        let conditionbasedcollectionschemeDecoded = try values.decodeIfPresent(IoTFleetWiseClientTypes.ConditionBasedCollectionScheme.self, forKey: .conditionbasedcollectionscheme)
        if let conditionbasedcollectionscheme = conditionbasedcollectionschemeDecoded {
            self = .conditionbasedcollectionscheme(conditionbasedcollectionscheme)
            return
        }
        self = .sdkUnknown("")
    }
}

extension IoTFleetWiseClientTypes {
    /// Specifies what data to collect and how often or when to collect it.
    public enum CollectionScheme: Swift.Equatable {
        /// Information about a collection scheme that uses a time period to decide how often to collect data.
        case timebasedcollectionscheme(IoTFleetWiseClientTypes.TimeBasedCollectionScheme)
        /// Information about a collection scheme that uses a simple logical expression to recognize what data to collect.
        case conditionbasedcollectionscheme(IoTFleetWiseClientTypes.ConditionBasedCollectionScheme)
        case sdkUnknown(Swift.String)
    }

}

extension IoTFleetWiseClientTypes {
    public enum Compression: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case off
        case snappy
        case sdkUnknown(Swift.String)

        public static var allCases: [Compression] {
            return [
                .off,
                .snappy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .off: return "OFF"
            case .snappy: return "SNAPPY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Compression(rawValue: rawValue) ?? Compression.sdkUnknown(rawValue)
        }
    }
}

extension IoTFleetWiseClientTypes.ConditionBasedCollectionScheme: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conditionLanguageVersion
        case expression
        case minimumTriggerIntervalMs
        case triggerMode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conditionLanguageVersion = self.conditionLanguageVersion {
            try encodeContainer.encode(conditionLanguageVersion, forKey: .conditionLanguageVersion)
        }
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let minimumTriggerIntervalMs = self.minimumTriggerIntervalMs {
            try encodeContainer.encode(minimumTriggerIntervalMs, forKey: .minimumTriggerIntervalMs)
        }
        if let triggerMode = self.triggerMode {
            try encodeContainer.encode(triggerMode.rawValue, forKey: .triggerMode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let minimumTriggerIntervalMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumTriggerIntervalMs)
        minimumTriggerIntervalMs = minimumTriggerIntervalMsDecoded
        let triggerModeDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.TriggerMode.self, forKey: .triggerMode)
        triggerMode = triggerModeDecoded
        let conditionLanguageVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .conditionLanguageVersion)
        conditionLanguageVersion = conditionLanguageVersionDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about a collection scheme that uses a simple logical expression to recognize what data to collect.
    public struct ConditionBasedCollectionScheme: Swift.Equatable {
        /// Specifies the version of the conditional expression language.
        public var conditionLanguageVersion: Swift.Int?
        /// The logical expression used to recognize what data to collect. For example, $variable.Vehicle.OutsideAirTemperature >= 105.0.
        /// This member is required.
        public var expression: Swift.String?
        /// The minimum duration of time between two triggering events to collect data, in milliseconds. If a signal changes often, you might want to collect data at a slower rate.
        public var minimumTriggerIntervalMs: Swift.Int?
        /// Whether to collect data for all triggering events (ALWAYS). Specify (RISING_EDGE), or specify only when the condition first evaluates to false. For example, triggering on "AirbagDeployed"; Users aren't interested on triggering when the airbag is already exploded; they only care about the change from not deployed => deployed.
        public var triggerMode: IoTFleetWiseClientTypes.TriggerMode?

        public init (
            conditionLanguageVersion: Swift.Int? = nil,
            expression: Swift.String? = nil,
            minimumTriggerIntervalMs: Swift.Int? = nil,
            triggerMode: IoTFleetWiseClientTypes.TriggerMode? = nil
        )
        {
            self.conditionLanguageVersion = conditionLanguageVersion
            self.expression = expression
            self.minimumTriggerIntervalMs = minimumTriggerIntervalMs
            self.triggerMode = triggerMode
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resource = output.resource
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resource = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request has conflicting operations. This can occur if you're trying to perform more than one operation on the same resource at the same time.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The resource on which there are conflicting operations.
    /// This member is required.
    public var resource: Swift.String?
    /// The type of resource on which there are conflicting operations..
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resource: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resource = resource
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resource: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resource
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CreateCampaignInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectionScheme
        case compression
        case dataExtraDimensions
        case description
        case diagnosticsMode
        case expiryTime
        case postTriggerCollectionDuration
        case priority
        case signalCatalogArn
        case signalsToCollect
        case spoolingMode
        case startTime
        case tags
        case targetArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collectionScheme = self.collectionScheme {
            try encodeContainer.encode(collectionScheme, forKey: .collectionScheme)
        }
        if let compression = self.compression {
            try encodeContainer.encode(compression.rawValue, forKey: .compression)
        }
        if let dataExtraDimensions = dataExtraDimensions {
            var dataExtraDimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataExtraDimensions)
            for nodepath0 in dataExtraDimensions {
                try dataExtraDimensionsContainer.encode(nodepath0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let diagnosticsMode = self.diagnosticsMode {
            try encodeContainer.encode(diagnosticsMode.rawValue, forKey: .diagnosticsMode)
        }
        if let expiryTime = self.expiryTime {
            try encodeContainer.encodeTimestamp(expiryTime, format: .epochSeconds, forKey: .expiryTime)
        }
        if let postTriggerCollectionDuration = self.postTriggerCollectionDuration {
            try encodeContainer.encode(postTriggerCollectionDuration, forKey: .postTriggerCollectionDuration)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let signalCatalogArn = self.signalCatalogArn {
            try encodeContainer.encode(signalCatalogArn, forKey: .signalCatalogArn)
        }
        if let signalsToCollect = signalsToCollect {
            var signalsToCollectContainer = encodeContainer.nestedUnkeyedContainer(forKey: .signalsToCollect)
            for signalinformation0 in signalsToCollect {
                try signalsToCollectContainer.encode(signalinformation0)
            }
        }
        if let spoolingMode = self.spoolingMode {
            try encodeContainer.encode(spoolingMode.rawValue, forKey: .spoolingMode)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let targetArn = self.targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }
}

extension CreateCampaignInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateCampaignInput: Swift.Equatable {
    /// The data collection scheme associated with the campaign. You can specify a scheme that collects data based on time or an event.
    /// This member is required.
    public var collectionScheme: IoTFleetWiseClientTypes.CollectionScheme?
    /// (Optional) Whether to compress signals before transmitting data to Amazon Web Services IoT FleetWise. If you don't want to compress the signals, use OFF. If it's not specified, SNAPPY is used. Default: SNAPPY
    public var compression: IoTFleetWiseClientTypes.Compression?
    /// (Optional) A list of vehicle attributes to associate with a campaign. Enrich the data with specified vehicle attributes. For example, add make and model to the campaign, and Amazon Web Services IoT FleetWise will associate the data with those attributes as dimensions in Amazon Timestream. You can then query the data against make and model. Default: An empty array
    public var dataExtraDimensions: [Swift.String]?
    /// An optional description of the campaign to help identify its purpose.
    public var description: Swift.String?
    /// (Optional) Option for a vehicle to send diagnostic trouble codes to Amazon Web Services IoT FleetWise. If you want to send diagnostic trouble codes, use SEND_ACTIVE_DTCS. If it's not specified, OFF is used. Default: OFF
    public var diagnosticsMode: IoTFleetWiseClientTypes.DiagnosticsMode?
    /// (Optional) The time the campaign expires, in seconds since epoch (January 1, 1970 at midnight UTC time). Vehicle data won't be collected after the campaign expires. Default: 253402214400 (December 31, 9999, 00:00:00 UTC)
    public var expiryTime: ClientRuntime.Date?
    /// The name of the campaign to create.
    /// This member is required.
    public var name: Swift.String?
    /// (Optional) How long (in milliseconds) to collect raw data after a triggering event initiates the collection. If it's not specified, 0 is used. Default: 0
    public var postTriggerCollectionDuration: Swift.Int?
    /// (Optional) A number indicating the priority of one campaign over another campaign for a certain vehicle or fleet. A campaign with the lowest value is deployed to vehicles before any other campaigns. If it's not specified, 0 is used. Default: 0
    public var priority: Swift.Int?
    /// (Optional) The Amazon Resource Name (ARN) of the signal catalog to associate with the campaign.
    /// This member is required.
    public var signalCatalogArn: Swift.String?
    /// (Optional) A list of information about signals to collect.
    public var signalsToCollect: [IoTFleetWiseClientTypes.SignalInformation]?
    /// (Optional) Whether to store collected data after a vehicle lost a connection with the cloud. After a connection is re-established, the data is automatically forwarded to Amazon Web Services IoT FleetWise. If you want to store collected data when a vehicle loses connection with the cloud, use TO_DISK. If it's not specified, OFF is used. Default: OFF
    public var spoolingMode: IoTFleetWiseClientTypes.SpoolingMode?
    /// (Optional) The time, in milliseconds, to deliver a campaign after it was approved. If it's not specified, 0 is used. Default: 0
    public var startTime: ClientRuntime.Date?
    /// Metadata that can be used to manage the campaign.
    public var tags: [IoTFleetWiseClientTypes.Tag]?
    /// The ARN of the vehicle or fleet to deploy a campaign to.
    /// This member is required.
    public var targetArn: Swift.String?

    public init (
        collectionScheme: IoTFleetWiseClientTypes.CollectionScheme? = nil,
        compression: IoTFleetWiseClientTypes.Compression? = nil,
        dataExtraDimensions: [Swift.String]? = nil,
        description: Swift.String? = nil,
        diagnosticsMode: IoTFleetWiseClientTypes.DiagnosticsMode? = nil,
        expiryTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        postTriggerCollectionDuration: Swift.Int? = nil,
        priority: Swift.Int? = nil,
        signalCatalogArn: Swift.String? = nil,
        signalsToCollect: [IoTFleetWiseClientTypes.SignalInformation]? = nil,
        spoolingMode: IoTFleetWiseClientTypes.SpoolingMode? = nil,
        startTime: ClientRuntime.Date? = nil,
        tags: [IoTFleetWiseClientTypes.Tag]? = nil,
        targetArn: Swift.String? = nil
    )
    {
        self.collectionScheme = collectionScheme
        self.compression = compression
        self.dataExtraDimensions = dataExtraDimensions
        self.description = description
        self.diagnosticsMode = diagnosticsMode
        self.expiryTime = expiryTime
        self.name = name
        self.postTriggerCollectionDuration = postTriggerCollectionDuration
        self.priority = priority
        self.signalCatalogArn = signalCatalogArn
        self.signalsToCollect = signalsToCollect
        self.spoolingMode = spoolingMode
        self.startTime = startTime
        self.tags = tags
        self.targetArn = targetArn
    }
}

struct CreateCampaignInputBody: Swift.Equatable {
    let description: Swift.String?
    let signalCatalogArn: Swift.String?
    let targetArn: Swift.String?
    let startTime: ClientRuntime.Date?
    let expiryTime: ClientRuntime.Date?
    let postTriggerCollectionDuration: Swift.Int?
    let diagnosticsMode: IoTFleetWiseClientTypes.DiagnosticsMode?
    let spoolingMode: IoTFleetWiseClientTypes.SpoolingMode?
    let compression: IoTFleetWiseClientTypes.Compression?
    let priority: Swift.Int?
    let signalsToCollect: [IoTFleetWiseClientTypes.SignalInformation]?
    let collectionScheme: IoTFleetWiseClientTypes.CollectionScheme?
    let dataExtraDimensions: [Swift.String]?
    let tags: [IoTFleetWiseClientTypes.Tag]?
}

extension CreateCampaignInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectionScheme
        case compression
        case dataExtraDimensions
        case description
        case diagnosticsMode
        case expiryTime
        case postTriggerCollectionDuration
        case priority
        case signalCatalogArn
        case signalsToCollect
        case spoolingMode
        case startTime
        case tags
        case targetArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let signalCatalogArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signalCatalogArn)
        signalCatalogArn = signalCatalogArnDecoded
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let expiryTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expiryTime)
        expiryTime = expiryTimeDecoded
        let postTriggerCollectionDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .postTriggerCollectionDuration)
        postTriggerCollectionDuration = postTriggerCollectionDurationDecoded
        let diagnosticsModeDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.DiagnosticsMode.self, forKey: .diagnosticsMode)
        diagnosticsMode = diagnosticsModeDecoded
        let spoolingModeDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.SpoolingMode.self, forKey: .spoolingMode)
        spoolingMode = spoolingModeDecoded
        let compressionDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.Compression.self, forKey: .compression)
        compression = compressionDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let signalsToCollectContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.SignalInformation?].self, forKey: .signalsToCollect)
        var signalsToCollectDecoded0:[IoTFleetWiseClientTypes.SignalInformation]? = nil
        if let signalsToCollectContainer = signalsToCollectContainer {
            signalsToCollectDecoded0 = [IoTFleetWiseClientTypes.SignalInformation]()
            for structure0 in signalsToCollectContainer {
                if let structure0 = structure0 {
                    signalsToCollectDecoded0?.append(structure0)
                }
            }
        }
        signalsToCollect = signalsToCollectDecoded0
        let collectionSchemeDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.CollectionScheme.self, forKey: .collectionScheme)
        collectionScheme = collectionSchemeDecoded
        let dataExtraDimensionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dataExtraDimensions)
        var dataExtraDimensionsDecoded0:[Swift.String]? = nil
        if let dataExtraDimensionsContainer = dataExtraDimensionsContainer {
            dataExtraDimensionsDecoded0 = [Swift.String]()
            for string0 in dataExtraDimensionsContainer {
                if let string0 = string0 {
                    dataExtraDimensionsDecoded0?.append(string0)
                }
            }
        }
        dataExtraDimensions = dataExtraDimensionsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTFleetWiseClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTFleetWiseClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateCampaignOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCampaignOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateCampaignOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCampaignOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateCampaignOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct CreateCampaignOutputResponse: Swift.Equatable {
    /// The ARN of the created campaign.
    public var arn: Swift.String?
    /// The name of the created campaign.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct CreateCampaignOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
}

extension CreateCampaignOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension CreateDecoderManifestInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case modelManifestArn
        case networkInterfaces
        case signalDecoders
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let modelManifestArn = self.modelManifestArn {
            try encodeContainer.encode(modelManifestArn, forKey: .modelManifestArn)
        }
        if let networkInterfaces = networkInterfaces {
            var networkInterfacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInterfaces)
            for networkinterface0 in networkInterfaces {
                try networkInterfacesContainer.encode(networkinterface0)
            }
        }
        if let signalDecoders = signalDecoders {
            var signalDecodersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .signalDecoders)
            for signaldecoder0 in signalDecoders {
                try signalDecodersContainer.encode(signaldecoder0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateDecoderManifestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDecoderManifestInput: Swift.Equatable {
    /// A brief description of the decoder manifest.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the vehicle model (model manifest).
    /// This member is required.
    public var modelManifestArn: Swift.String?
    /// The unique name of the decoder manifest to create.
    /// This member is required.
    public var name: Swift.String?
    /// A list of information about available network interfaces.
    public var networkInterfaces: [IoTFleetWiseClientTypes.NetworkInterface]?
    /// A list of information about signal decoders.
    public var signalDecoders: [IoTFleetWiseClientTypes.SignalDecoder]?
    /// Metadata that can be used to manage the decoder manifest.
    public var tags: [IoTFleetWiseClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        modelManifestArn: Swift.String? = nil,
        name: Swift.String? = nil,
        networkInterfaces: [IoTFleetWiseClientTypes.NetworkInterface]? = nil,
        signalDecoders: [IoTFleetWiseClientTypes.SignalDecoder]? = nil,
        tags: [IoTFleetWiseClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.modelManifestArn = modelManifestArn
        self.name = name
        self.networkInterfaces = networkInterfaces
        self.signalDecoders = signalDecoders
        self.tags = tags
    }
}

struct CreateDecoderManifestInputBody: Swift.Equatable {
    let description: Swift.String?
    let modelManifestArn: Swift.String?
    let signalDecoders: [IoTFleetWiseClientTypes.SignalDecoder]?
    let networkInterfaces: [IoTFleetWiseClientTypes.NetworkInterface]?
    let tags: [IoTFleetWiseClientTypes.Tag]?
}

extension CreateDecoderManifestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case modelManifestArn
        case networkInterfaces
        case signalDecoders
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let modelManifestArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelManifestArn)
        modelManifestArn = modelManifestArnDecoded
        let signalDecodersContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.SignalDecoder?].self, forKey: .signalDecoders)
        var signalDecodersDecoded0:[IoTFleetWiseClientTypes.SignalDecoder]? = nil
        if let signalDecodersContainer = signalDecodersContainer {
            signalDecodersDecoded0 = [IoTFleetWiseClientTypes.SignalDecoder]()
            for structure0 in signalDecodersContainer {
                if let structure0 = structure0 {
                    signalDecodersDecoded0?.append(structure0)
                }
            }
        }
        signalDecoders = signalDecodersDecoded0
        let networkInterfacesContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.NetworkInterface?].self, forKey: .networkInterfaces)
        var networkInterfacesDecoded0:[IoTFleetWiseClientTypes.NetworkInterface]? = nil
        if let networkInterfacesContainer = networkInterfacesContainer {
            networkInterfacesDecoded0 = [IoTFleetWiseClientTypes.NetworkInterface]()
            for structure0 in networkInterfacesContainer {
                if let structure0 = structure0 {
                    networkInterfacesDecoded0?.append(structure0)
                }
            }
        }
        networkInterfaces = networkInterfacesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTFleetWiseClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTFleetWiseClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDecoderManifestOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDecoderManifestOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DecoderManifestValidationException" : self = .decoderManifestValidationException(try DecoderManifestValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDecoderManifestOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case decoderManifestValidationException(DecoderManifestValidationException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDecoderManifestOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDecoderManifestOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct CreateDecoderManifestOutputResponse: Swift.Equatable {
    /// The ARN of the created decoder manifest.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the created decoder manifest.
    /// This member is required.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct CreateDecoderManifestOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
}

extension CreateDecoderManifestOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension CreateFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case signalCatalogArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let signalCatalogArn = self.signalCatalogArn {
            try encodeContainer.encode(signalCatalogArn, forKey: .signalCatalogArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateFleetInput: Swift.Equatable {
    /// A brief description of the fleet to create.
    public var description: Swift.String?
    /// The unique ID of the fleet to create.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The Amazon Resource Name (ARN) of a signal catalog.
    /// This member is required.
    public var signalCatalogArn: Swift.String?
    /// Metadata that can be used to manage the fleet.
    public var tags: [IoTFleetWiseClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        signalCatalogArn: Swift.String? = nil,
        tags: [IoTFleetWiseClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.fleetId = fleetId
        self.signalCatalogArn = signalCatalogArn
        self.tags = tags
    }
}

struct CreateFleetInputBody: Swift.Equatable {
    let description: Swift.String?
    let signalCatalogArn: Swift.String?
    let tags: [IoTFleetWiseClientTypes.Tag]?
}

extension CreateFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case signalCatalogArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let signalCatalogArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signalCatalogArn)
        signalCatalogArn = signalCatalogArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTFleetWiseClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTFleetWiseClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateFleetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateFleetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateFleetOutputResponse: Swift.Equatable {
    /// The ARN of the created fleet.
    /// This member is required.
    public var arn: Swift.String?
    /// The ID of the created fleet.
    /// This member is required.
    public var id: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateFleetOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
}

extension CreateFleetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension CreateModelManifestInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case nodes
        case signalCatalogArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let nodes = nodes {
            var nodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodes)
            for string0 in nodes {
                try nodesContainer.encode(string0)
            }
        }
        if let signalCatalogArn = self.signalCatalogArn {
            try encodeContainer.encode(signalCatalogArn, forKey: .signalCatalogArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateModelManifestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateModelManifestInput: Swift.Equatable {
    /// A brief description of the vehicle model.
    public var description: Swift.String?
    /// The name of the vehicle model to create.
    /// This member is required.
    public var name: Swift.String?
    /// A list of nodes, which are a general abstraction of signals.
    /// This member is required.
    public var nodes: [Swift.String]?
    /// The Amazon Resource Name (ARN) of a signal catalog.
    /// This member is required.
    public var signalCatalogArn: Swift.String?
    /// Metadata that can be used to manage the vehicle model.
    public var tags: [IoTFleetWiseClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        nodes: [Swift.String]? = nil,
        signalCatalogArn: Swift.String? = nil,
        tags: [IoTFleetWiseClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.name = name
        self.nodes = nodes
        self.signalCatalogArn = signalCatalogArn
        self.tags = tags
    }
}

struct CreateModelManifestInputBody: Swift.Equatable {
    let description: Swift.String?
    let nodes: [Swift.String]?
    let signalCatalogArn: Swift.String?
    let tags: [IoTFleetWiseClientTypes.Tag]?
}

extension CreateModelManifestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case nodes
        case signalCatalogArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nodesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .nodes)
        var nodesDecoded0:[Swift.String]? = nil
        if let nodesContainer = nodesContainer {
            nodesDecoded0 = [Swift.String]()
            for string0 in nodesContainer {
                if let string0 = string0 {
                    nodesDecoded0?.append(string0)
                }
            }
        }
        nodes = nodesDecoded0
        let signalCatalogArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signalCatalogArn)
        signalCatalogArn = signalCatalogArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTFleetWiseClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTFleetWiseClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateModelManifestOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateModelManifestOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSignalsException" : self = .invalidSignalsException(try InvalidSignalsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateModelManifestOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case invalidSignalsException(InvalidSignalsException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateModelManifestOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateModelManifestOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct CreateModelManifestOutputResponse: Swift.Equatable {
    /// The ARN of the created vehicle model.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the created vehicle model.
    /// This member is required.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct CreateModelManifestOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
}

extension CreateModelManifestOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension CreateSignalCatalogInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case nodes
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let nodes = nodes {
            var nodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodes)
            for node0 in nodes {
                try nodesContainer.encode(node0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateSignalCatalogInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateSignalCatalogInput: Swift.Equatable {
    /// A brief description of the signal catalog.
    public var description: Swift.String?
    /// The name of the signal catalog to create.
    /// This member is required.
    public var name: Swift.String?
    /// A list of information about nodes, which are a general abstraction of signals. For more information, see the API data type.
    public var nodes: [IoTFleetWiseClientTypes.Node]?
    /// Metadata that can be used to manage the signal catalog.
    public var tags: [IoTFleetWiseClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        nodes: [IoTFleetWiseClientTypes.Node]? = nil,
        tags: [IoTFleetWiseClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.name = name
        self.nodes = nodes
        self.tags = tags
    }
}

struct CreateSignalCatalogInputBody: Swift.Equatable {
    let description: Swift.String?
    let nodes: [IoTFleetWiseClientTypes.Node]?
    let tags: [IoTFleetWiseClientTypes.Tag]?
}

extension CreateSignalCatalogInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case nodes
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nodesContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.Node?].self, forKey: .nodes)
        var nodesDecoded0:[IoTFleetWiseClientTypes.Node]? = nil
        if let nodesContainer = nodesContainer {
            nodesDecoded0 = [IoTFleetWiseClientTypes.Node]()
            for union0 in nodesContainer {
                if let union0 = union0 {
                    nodesDecoded0?.append(union0)
                }
            }
        }
        nodes = nodesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTFleetWiseClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTFleetWiseClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSignalCatalogOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSignalCatalogOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNodeException" : self = .invalidNodeException(try InvalidNodeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSignalsException" : self = .invalidSignalsException(try InvalidSignalsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSignalCatalogOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case invalidNodeException(InvalidNodeException)
    case invalidSignalsException(InvalidSignalsException)
    case limitExceededException(LimitExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSignalCatalogOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSignalCatalogOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct CreateSignalCatalogOutputResponse: Swift.Equatable {
    /// The ARN of the created signal catalog.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the created signal catalog.
    /// This member is required.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct CreateSignalCatalogOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
}

extension CreateSignalCatalogOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension IoTFleetWiseClientTypes.CreateVehicleError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case vehicleName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let vehicleName = self.vehicleName {
            try encodeContainer.encode(vehicleName, forKey: .vehicleName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vehicleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vehicleName)
        vehicleName = vehicleNameDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// An HTTP error resulting from creating a vehicle.
    public struct CreateVehicleError: Swift.Equatable {
        /// An HTTP error code.
        public var code: Swift.String?
        /// A description of the HTTP error.
        public var message: Swift.String?
        /// The ID of the vehicle with the error.
        public var vehicleName: Swift.String?

        public init (
            code: Swift.String? = nil,
            message: Swift.String? = nil,
            vehicleName: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
            self.vehicleName = vehicleName
        }
    }

}

extension CreateVehicleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationBehavior
        case attributes
        case decoderManifestArn
        case modelManifestArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationBehavior = self.associationBehavior {
            try encodeContainer.encode(associationBehavior.rawValue, forKey: .associationBehavior)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributesMap0) in attributes {
                try attributesContainer.encode(attributesMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let decoderManifestArn = self.decoderManifestArn {
            try encodeContainer.encode(decoderManifestArn, forKey: .decoderManifestArn)
        }
        if let modelManifestArn = self.modelManifestArn {
            try encodeContainer.encode(modelManifestArn, forKey: .modelManifestArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateVehicleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateVehicleInput: Swift.Equatable {
    /// An option to create a new Amazon Web Services IoT thing when creating a vehicle, or to validate an existing Amazon Web Services IoT thing as a vehicle. Default:
    public var associationBehavior: IoTFleetWiseClientTypes.VehicleAssociationBehavior?
    /// Static information about a vehicle in a key-value pair. For example: "engineType" : "1.3 L R2"
    public var attributes: [Swift.String:Swift.String]?
    /// The ARN of a decoder manifest.
    /// This member is required.
    public var decoderManifestArn: Swift.String?
    /// The Amazon Resource Name ARN of a vehicle model.
    /// This member is required.
    public var modelManifestArn: Swift.String?
    /// Metadata that can be used to manage the vehicle.
    public var tags: [IoTFleetWiseClientTypes.Tag]?
    /// The unique ID of the vehicle to create.
    /// This member is required.
    public var vehicleName: Swift.String?

    public init (
        associationBehavior: IoTFleetWiseClientTypes.VehicleAssociationBehavior? = nil,
        attributes: [Swift.String:Swift.String]? = nil,
        decoderManifestArn: Swift.String? = nil,
        modelManifestArn: Swift.String? = nil,
        tags: [IoTFleetWiseClientTypes.Tag]? = nil,
        vehicleName: Swift.String? = nil
    )
    {
        self.associationBehavior = associationBehavior
        self.attributes = attributes
        self.decoderManifestArn = decoderManifestArn
        self.modelManifestArn = modelManifestArn
        self.tags = tags
        self.vehicleName = vehicleName
    }
}

struct CreateVehicleInputBody: Swift.Equatable {
    let modelManifestArn: Swift.String?
    let decoderManifestArn: Swift.String?
    let attributes: [Swift.String:Swift.String]?
    let associationBehavior: IoTFleetWiseClientTypes.VehicleAssociationBehavior?
    let tags: [IoTFleetWiseClientTypes.Tag]?
}

extension CreateVehicleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationBehavior
        case attributes
        case decoderManifestArn
        case modelManifestArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelManifestArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelManifestArn)
        modelManifestArn = modelManifestArnDecoded
        let decoderManifestArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .decoderManifestArn)
        decoderManifestArn = decoderManifestArnDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let associationBehaviorDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.VehicleAssociationBehavior.self, forKey: .associationBehavior)
        associationBehavior = associationBehaviorDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTFleetWiseClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTFleetWiseClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateVehicleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVehicleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateVehicleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVehicleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateVehicleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.thingArn = output.thingArn
            self.vehicleName = output.vehicleName
        } else {
            self.arn = nil
            self.thingArn = nil
            self.vehicleName = nil
        }
    }
}

public struct CreateVehicleOutputResponse: Swift.Equatable {
    /// The ARN of the created vehicle.
    public var arn: Swift.String?
    /// The ARN of a created or validated Amazon Web Services IoT thing.
    public var thingArn: Swift.String?
    /// The unique ID of the created vehicle.
    public var vehicleName: Swift.String?

    public init (
        arn: Swift.String? = nil,
        thingArn: Swift.String? = nil,
        vehicleName: Swift.String? = nil
    )
    {
        self.arn = arn
        self.thingArn = thingArn
        self.vehicleName = vehicleName
    }
}

struct CreateVehicleOutputResponseBody: Swift.Equatable {
    let vehicleName: Swift.String?
    let arn: Swift.String?
    let thingArn: Swift.String?
}

extension CreateVehicleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case thingArn
        case vehicleName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vehicleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vehicleName)
        vehicleName = vehicleNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
    }
}

extension IoTFleetWiseClientTypes.CreateVehicleRequestItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationBehavior
        case attributes
        case decoderManifestArn
        case modelManifestArn
        case tags
        case vehicleName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationBehavior = self.associationBehavior {
            try encodeContainer.encode(associationBehavior.rawValue, forKey: .associationBehavior)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributesMap0) in attributes {
                try attributesContainer.encode(attributesMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let decoderManifestArn = self.decoderManifestArn {
            try encodeContainer.encode(decoderManifestArn, forKey: .decoderManifestArn)
        }
        if let modelManifestArn = self.modelManifestArn {
            try encodeContainer.encode(modelManifestArn, forKey: .modelManifestArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let vehicleName = self.vehicleName {
            try encodeContainer.encode(vehicleName, forKey: .vehicleName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vehicleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vehicleName)
        vehicleName = vehicleNameDecoded
        let modelManifestArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelManifestArn)
        modelManifestArn = modelManifestArnDecoded
        let decoderManifestArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .decoderManifestArn)
        decoderManifestArn = decoderManifestArnDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let associationBehaviorDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.VehicleAssociationBehavior.self, forKey: .associationBehavior)
        associationBehavior = associationBehaviorDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTFleetWiseClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTFleetWiseClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about the vehicle to create.
    public struct CreateVehicleRequestItem: Swift.Equatable {
        /// An option to create a new Amazon Web Services IoT thing when creating a vehicle, or to validate an existing thing as a vehicle.
        public var associationBehavior: IoTFleetWiseClientTypes.VehicleAssociationBehavior?
        /// Static information about a vehicle in a key-value pair. For example: "engine Type" : "v6"
        public var attributes: [Swift.String:Swift.String]?
        /// The Amazon Resource Name (ARN) of a decoder manifest associated with the vehicle to create.
        /// This member is required.
        public var decoderManifestArn: Swift.String?
        /// The ARN of the vehicle model (model manifest) to create the vehicle from.
        /// This member is required.
        public var modelManifestArn: Swift.String?
        /// Metadata which can be used to manage the vehicle.
        public var tags: [IoTFleetWiseClientTypes.Tag]?
        /// The unique ID of the vehicle to create.
        /// This member is required.
        public var vehicleName: Swift.String?

        public init (
            associationBehavior: IoTFleetWiseClientTypes.VehicleAssociationBehavior? = nil,
            attributes: [Swift.String:Swift.String]? = nil,
            decoderManifestArn: Swift.String? = nil,
            modelManifestArn: Swift.String? = nil,
            tags: [IoTFleetWiseClientTypes.Tag]? = nil,
            vehicleName: Swift.String? = nil
        )
        {
            self.associationBehavior = associationBehavior
            self.attributes = attributes
            self.decoderManifestArn = decoderManifestArn
            self.modelManifestArn = modelManifestArn
            self.tags = tags
            self.vehicleName = vehicleName
        }
    }

}

extension IoTFleetWiseClientTypes.CreateVehicleResponseItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case thingArn
        case vehicleName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let thingArn = self.thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
        if let vehicleName = self.vehicleName {
            try encodeContainer.encode(vehicleName, forKey: .vehicleName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vehicleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vehicleName)
        vehicleName = vehicleNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about a created vehicle.
    public struct CreateVehicleResponseItem: Swift.Equatable {
        /// The ARN of the created vehicle.
        public var arn: Swift.String?
        /// The ARN of a created or validated Amazon Web Services IoT thing.
        public var thingArn: Swift.String?
        /// The unique ID of the vehicle to create.
        public var vehicleName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            thingArn: Swift.String? = nil,
            vehicleName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.thingArn = thingArn
            self.vehicleName = vehicleName
        }
    }

}

extension IoTFleetWiseClientTypes.DecoderManifestSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case lastModificationTime
        case modelManifestArn
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let modelManifestArn = self.modelManifestArn {
            try encodeContainer.encode(modelManifestArn, forKey: .modelManifestArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let modelManifestArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelManifestArn)
        modelManifestArn = modelManifestArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.ManifestStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about a created decoder manifest. You can use the API operation to return this information about multiple decoder manifests.
    public struct DecoderManifestSummary: Swift.Equatable {
        /// The ARN of a vehicle model (model manifest) associated with the decoder manifest.
        public var arn: Swift.String?
        /// The time the decoder manifest was created in seconds since epoch (January 1, 1970 at midnight UTC time).
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// A brief description of the decoder manifest.
        public var description: Swift.String?
        /// The time the decoder manifest was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).
        /// This member is required.
        public var lastModificationTime: ClientRuntime.Date?
        /// The ARN of a vehicle model (model manifest) associated with the decoder manifest.
        public var modelManifestArn: Swift.String?
        /// The name of the decoder manifest.
        public var name: Swift.String?
        /// The state of the decoder manifest. If the status is ACTIVE, the decoder manifest can't be edited. If the status is marked DRAFT, you can edit the decoder manifest.
        public var status: IoTFleetWiseClientTypes.ManifestStatus?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            modelManifestArn: Swift.String? = nil,
            name: Swift.String? = nil,
            status: IoTFleetWiseClientTypes.ManifestStatus? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.lastModificationTime = lastModificationTime
            self.modelManifestArn = modelManifestArn
            self.name = name
            self.status = status
        }
    }

}

extension DecoderManifestValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DecoderManifestValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.invalidNetworkInterfaces = output.invalidNetworkInterfaces
            self.invalidSignals = output.invalidSignals
            self.message = output.message
        } else {
            self.invalidNetworkInterfaces = nil
            self.invalidSignals = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request couldn't be completed because it contains signal decoders with one or more validation errors.
public struct DecoderManifestValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The request couldn't be completed because of invalid network interfaces in the request.
    public var invalidNetworkInterfaces: [IoTFleetWiseClientTypes.InvalidNetworkInterface]?
    /// The request couldn't be completed because of invalid signals in the request.
    public var invalidSignals: [IoTFleetWiseClientTypes.InvalidSignalDecoder]?
    public var message: Swift.String?

    public init (
        invalidNetworkInterfaces: [IoTFleetWiseClientTypes.InvalidNetworkInterface]? = nil,
        invalidSignals: [IoTFleetWiseClientTypes.InvalidSignalDecoder]? = nil,
        message: Swift.String? = nil
    )
    {
        self.invalidNetworkInterfaces = invalidNetworkInterfaces
        self.invalidSignals = invalidSignals
        self.message = message
    }
}

struct DecoderManifestValidationExceptionBody: Swift.Equatable {
    let invalidSignals: [IoTFleetWiseClientTypes.InvalidSignalDecoder]?
    let invalidNetworkInterfaces: [IoTFleetWiseClientTypes.InvalidNetworkInterface]?
    let message: Swift.String?
}

extension DecoderManifestValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidNetworkInterfaces
        case invalidSignals
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidSignalsContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.InvalidSignalDecoder?].self, forKey: .invalidSignals)
        var invalidSignalsDecoded0:[IoTFleetWiseClientTypes.InvalidSignalDecoder]? = nil
        if let invalidSignalsContainer = invalidSignalsContainer {
            invalidSignalsDecoded0 = [IoTFleetWiseClientTypes.InvalidSignalDecoder]()
            for structure0 in invalidSignalsContainer {
                if let structure0 = structure0 {
                    invalidSignalsDecoded0?.append(structure0)
                }
            }
        }
        invalidSignals = invalidSignalsDecoded0
        let invalidNetworkInterfacesContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.InvalidNetworkInterface?].self, forKey: .invalidNetworkInterfaces)
        var invalidNetworkInterfacesDecoded0:[IoTFleetWiseClientTypes.InvalidNetworkInterface]? = nil
        if let invalidNetworkInterfacesContainer = invalidNetworkInterfacesContainer {
            invalidNetworkInterfacesDecoded0 = [IoTFleetWiseClientTypes.InvalidNetworkInterface]()
            for structure0 in invalidNetworkInterfacesContainer {
                if let structure0 = structure0 {
                    invalidNetworkInterfacesDecoded0?.append(structure0)
                }
            }
        }
        invalidNetworkInterfaces = invalidNetworkInterfacesDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeleteCampaignInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteCampaignInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteCampaignInput: Swift.Equatable {
    /// The name of the campaign to delete.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteCampaignInputBody: Swift.Equatable {
}

extension DeleteCampaignInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCampaignOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCampaignOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteCampaignOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCampaignOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteCampaignOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct DeleteCampaignOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deleted campaign. The ARN isn’t returned if a campaign doesn’t exist.
    public var arn: Swift.String?
    /// The name of the deleted campaign.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct DeleteCampaignOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
}

extension DeleteCampaignOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteDecoderManifestInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteDecoderManifestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDecoderManifestInput: Swift.Equatable {
    /// The name of the decoder manifest to delete.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteDecoderManifestInputBody: Swift.Equatable {
}

extension DeleteDecoderManifestInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDecoderManifestOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDecoderManifestOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDecoderManifestOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDecoderManifestOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteDecoderManifestOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct DeleteDecoderManifestOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deleted decoder manifest.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the deleted decoder manifest.
    /// This member is required.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct DeleteDecoderManifestOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
}

extension DeleteDecoderManifestOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteFleetInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteFleetInput: Swift.Equatable {
    /// The ID of the fleet to delete.
    /// This member is required.
    public var fleetId: Swift.String?

    public init (
        fleetId: Swift.String? = nil
    )
    {
        self.fleetId = fleetId
    }
}

struct DeleteFleetInputBody: Swift.Equatable {
}

extension DeleteFleetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteFleetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteFleetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct DeleteFleetOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deleted fleet.
    public var arn: Swift.String?
    /// The ID of the deleted fleet.
    public var id: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct DeleteFleetOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
}

extension DeleteFleetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteModelManifestInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteModelManifestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteModelManifestInput: Swift.Equatable {
    /// The name of the model manifest to delete.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteModelManifestInputBody: Swift.Equatable {
}

extension DeleteModelManifestInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteModelManifestOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteModelManifestOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteModelManifestOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteModelManifestOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteModelManifestOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct DeleteModelManifestOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deleted model manifest.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the deleted model manifest.
    /// This member is required.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct DeleteModelManifestOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
}

extension DeleteModelManifestOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteSignalCatalogInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteSignalCatalogInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSignalCatalogInput: Swift.Equatable {
    /// The name of the signal catalog to delete.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteSignalCatalogInputBody: Swift.Equatable {
}

extension DeleteSignalCatalogInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSignalCatalogOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSignalCatalogOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSignalCatalogOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSignalCatalogOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteSignalCatalogOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct DeleteSignalCatalogOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deleted signal catalog.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the deleted signal catalog.
    /// This member is required.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct DeleteSignalCatalogOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
}

extension DeleteSignalCatalogOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteVehicleInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteVehicleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteVehicleInput: Swift.Equatable {
    /// The ID of the vehicle to delete.
    /// This member is required.
    public var vehicleName: Swift.String?

    public init (
        vehicleName: Swift.String? = nil
    )
    {
        self.vehicleName = vehicleName
    }
}

struct DeleteVehicleInputBody: Swift.Equatable {
}

extension DeleteVehicleInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVehicleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVehicleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteVehicleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVehicleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteVehicleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.vehicleName = output.vehicleName
        } else {
            self.arn = nil
            self.vehicleName = nil
        }
    }
}

public struct DeleteVehicleOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deleted vehicle.
    /// This member is required.
    public var arn: Swift.String?
    /// The ID of the deleted vehicle.
    /// This member is required.
    public var vehicleName: Swift.String?

    public init (
        arn: Swift.String? = nil,
        vehicleName: Swift.String? = nil
    )
    {
        self.arn = arn
        self.vehicleName = vehicleName
    }
}

struct DeleteVehicleOutputResponseBody: Swift.Equatable {
    let vehicleName: Swift.String?
    let arn: Swift.String?
}

extension DeleteVehicleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case vehicleName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vehicleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vehicleName)
        vehicleName = vehicleNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension IoTFleetWiseClientTypes {
    public enum DiagnosticsMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case off
        case sendActiveDtcs
        case sdkUnknown(Swift.String)

        public static var allCases: [DiagnosticsMode] {
            return [
                .off,
                .sendActiveDtcs,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .off: return "OFF"
            case .sendActiveDtcs: return "SEND_ACTIVE_DTCS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DiagnosticsMode(rawValue: rawValue) ?? DiagnosticsMode.sdkUnknown(rawValue)
        }
    }
}

extension DisassociateVehicleFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetId = self.fleetId {
            try encodeContainer.encode(fleetId, forKey: .fleetId)
        }
    }
}

extension DisassociateVehicleFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateVehicleFleetInput: Swift.Equatable {
    /// The unique ID of a fleet.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The unique ID of the vehicle to disassociate from the fleet.
    /// This member is required.
    public var vehicleName: Swift.String?

    public init (
        fleetId: Swift.String? = nil,
        vehicleName: Swift.String? = nil
    )
    {
        self.fleetId = fleetId
        self.vehicleName = vehicleName
    }
}

struct DisassociateVehicleFleetInputBody: Swift.Equatable {
    let fleetId: Swift.String?
}

extension DisassociateVehicleFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetId)
        fleetId = fleetIdDecoded
    }
}

extension DisassociateVehicleFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateVehicleFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateVehicleFleetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateVehicleFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateVehicleFleetOutputResponse: Swift.Equatable {

    public init () { }
}

extension IoTFleetWiseClientTypes.FleetSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case id
        case lastModificationTime
        case signalCatalogArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let signalCatalogArn = self.signalCatalogArn {
            try encodeContainer.encode(signalCatalogArn, forKey: .signalCatalogArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let signalCatalogArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signalCatalogArn)
        signalCatalogArn = signalCatalogArnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about a fleet. You can use the API operation to return this information about multiple fleets.
    public struct FleetSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the fleet.
        /// This member is required.
        public var arn: Swift.String?
        /// The time the fleet was created, in seconds since epoch (January 1, 1970 at midnight UTC time).
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// A brief description of the fleet.
        public var description: Swift.String?
        /// The unique ID of the fleet.
        /// This member is required.
        public var id: Swift.String?
        /// The time the fleet was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).
        public var lastModificationTime: ClientRuntime.Date?
        /// The ARN of the signal catalog associated with the fleet.
        /// This member is required.
        public var signalCatalogArn: Swift.String?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            signalCatalogArn: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.lastModificationTime = lastModificationTime
            self.signalCatalogArn = signalCatalogArn
        }
    }

}

extension IoTFleetWiseClientTypes.FormattedVss: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sdkUnknown
        case vssjson = "vssJson"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .vssjson(vssjson):
                try container.encode(vssjson, forKey: .vssjson)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let vssjsonDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .vssjson)
        if let vssjson = vssjsonDecoded {
            self = .vssjson(vssjson)
            return
        }
        self = .sdkUnknown("")
    }
}

extension IoTFleetWiseClientTypes {
    /// Vehicle Signal Specification (VSS) is a precise language used to describe and model signals in vehicle networks. The JSON file collects signal specificiations in a VSS format.
    public enum FormattedVss: Swift.Equatable, Swift.Hashable {
        /// Provides the VSS in JSON format.
        case vssjson(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension GetCampaignInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetCampaignInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCampaignInput: Swift.Equatable {
    /// The name of the campaign to retrieve information about.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetCampaignInputBody: Swift.Equatable {
}

extension GetCampaignInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCampaignOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCampaignOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetCampaignOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCampaignOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetCampaignOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.collectionScheme = output.collectionScheme
            self.compression = output.compression
            self.creationTime = output.creationTime
            self.dataExtraDimensions = output.dataExtraDimensions
            self.description = output.description
            self.diagnosticsMode = output.diagnosticsMode
            self.expiryTime = output.expiryTime
            self.lastModificationTime = output.lastModificationTime
            self.name = output.name
            self.postTriggerCollectionDuration = output.postTriggerCollectionDuration
            self.priority = output.priority
            self.signalCatalogArn = output.signalCatalogArn
            self.signalsToCollect = output.signalsToCollect
            self.spoolingMode = output.spoolingMode
            self.startTime = output.startTime
            self.status = output.status
            self.targetArn = output.targetArn
        } else {
            self.arn = nil
            self.collectionScheme = nil
            self.compression = nil
            self.creationTime = nil
            self.dataExtraDimensions = nil
            self.description = nil
            self.diagnosticsMode = nil
            self.expiryTime = nil
            self.lastModificationTime = nil
            self.name = nil
            self.postTriggerCollectionDuration = nil
            self.priority = nil
            self.signalCatalogArn = nil
            self.signalsToCollect = nil
            self.spoolingMode = nil
            self.startTime = nil
            self.status = nil
            self.targetArn = nil
        }
    }
}

public struct GetCampaignOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the campaign.
    public var arn: Swift.String?
    /// Information about the data collection scheme associated with the campaign.
    public var collectionScheme: IoTFleetWiseClientTypes.CollectionScheme?
    /// Whether to compress signals before transmitting data to Amazon Web Services IoT FleetWise. If OFF is specified, the signals aren't compressed. If it's not specified, SNAPPY is used.
    public var compression: IoTFleetWiseClientTypes.Compression?
    /// The time the campaign was created in seconds since epoch (January 1, 1970 at midnight UTC time).
    public var creationTime: ClientRuntime.Date?
    /// A list of vehicle attributes associated with the campaign.
    public var dataExtraDimensions: [Swift.String]?
    /// The description of the campaign.
    public var description: Swift.String?
    /// Option for a vehicle to send diagnostic trouble codes to Amazon Web Services IoT FleetWise.
    public var diagnosticsMode: IoTFleetWiseClientTypes.DiagnosticsMode?
    /// The time the campaign expires, in seconds since epoch (January 1, 1970 at midnight UTC time). Vehicle data won't be collected after the campaign expires.
    public var expiryTime: ClientRuntime.Date?
    /// The last time the campaign was modified.
    public var lastModificationTime: ClientRuntime.Date?
    /// The name of the campaign.
    public var name: Swift.String?
    /// How long (in seconds) to collect raw data after a triggering event initiates the collection.
    public var postTriggerCollectionDuration: Swift.Int?
    /// A number indicating the priority of one campaign over another campaign for a certain vehicle or fleet. A campaign with the lowest value is deployed to vehicles before any other campaigns.
    public var priority: Swift.Int?
    /// The ARN of a signal catalog.
    public var signalCatalogArn: Swift.String?
    /// Information about a list of signals to collect data on.
    public var signalsToCollect: [IoTFleetWiseClientTypes.SignalInformation]?
    /// Whether to store collected data after a vehicle lost a connection with the cloud. After a connection is re-established, the data is automatically forwarded to Amazon Web Services IoT FleetWise.
    public var spoolingMode: IoTFleetWiseClientTypes.SpoolingMode?
    /// The time, in milliseconds, to deliver a campaign after it was approved.
    public var startTime: ClientRuntime.Date?
    /// The state of the campaign. The status can be one of: CREATING, WAITING_FOR_APPROVAL, RUNNING, and SUSPENDED.
    public var status: IoTFleetWiseClientTypes.CampaignStatus?
    /// The ARN of the vehicle or the fleet targeted by the campaign.
    public var targetArn: Swift.String?

    public init (
        arn: Swift.String? = nil,
        collectionScheme: IoTFleetWiseClientTypes.CollectionScheme? = nil,
        compression: IoTFleetWiseClientTypes.Compression? = nil,
        creationTime: ClientRuntime.Date? = nil,
        dataExtraDimensions: [Swift.String]? = nil,
        description: Swift.String? = nil,
        diagnosticsMode: IoTFleetWiseClientTypes.DiagnosticsMode? = nil,
        expiryTime: ClientRuntime.Date? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        postTriggerCollectionDuration: Swift.Int? = nil,
        priority: Swift.Int? = nil,
        signalCatalogArn: Swift.String? = nil,
        signalsToCollect: [IoTFleetWiseClientTypes.SignalInformation]? = nil,
        spoolingMode: IoTFleetWiseClientTypes.SpoolingMode? = nil,
        startTime: ClientRuntime.Date? = nil,
        status: IoTFleetWiseClientTypes.CampaignStatus? = nil,
        targetArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.collectionScheme = collectionScheme
        self.compression = compression
        self.creationTime = creationTime
        self.dataExtraDimensions = dataExtraDimensions
        self.description = description
        self.diagnosticsMode = diagnosticsMode
        self.expiryTime = expiryTime
        self.lastModificationTime = lastModificationTime
        self.name = name
        self.postTriggerCollectionDuration = postTriggerCollectionDuration
        self.priority = priority
        self.signalCatalogArn = signalCatalogArn
        self.signalsToCollect = signalsToCollect
        self.spoolingMode = spoolingMode
        self.startTime = startTime
        self.status = status
        self.targetArn = targetArn
    }
}

struct GetCampaignOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let description: Swift.String?
    let signalCatalogArn: Swift.String?
    let targetArn: Swift.String?
    let status: IoTFleetWiseClientTypes.CampaignStatus?
    let startTime: ClientRuntime.Date?
    let expiryTime: ClientRuntime.Date?
    let postTriggerCollectionDuration: Swift.Int?
    let diagnosticsMode: IoTFleetWiseClientTypes.DiagnosticsMode?
    let spoolingMode: IoTFleetWiseClientTypes.SpoolingMode?
    let compression: IoTFleetWiseClientTypes.Compression?
    let priority: Swift.Int?
    let signalsToCollect: [IoTFleetWiseClientTypes.SignalInformation]?
    let collectionScheme: IoTFleetWiseClientTypes.CollectionScheme?
    let dataExtraDimensions: [Swift.String]?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
}

extension GetCampaignOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case collectionScheme
        case compression
        case creationTime
        case dataExtraDimensions
        case description
        case diagnosticsMode
        case expiryTime
        case lastModificationTime
        case name
        case postTriggerCollectionDuration
        case priority
        case signalCatalogArn
        case signalsToCollect
        case spoolingMode
        case startTime
        case status
        case targetArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let signalCatalogArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signalCatalogArn)
        signalCatalogArn = signalCatalogArnDecoded
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.CampaignStatus.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let expiryTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expiryTime)
        expiryTime = expiryTimeDecoded
        let postTriggerCollectionDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .postTriggerCollectionDuration)
        postTriggerCollectionDuration = postTriggerCollectionDurationDecoded
        let diagnosticsModeDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.DiagnosticsMode.self, forKey: .diagnosticsMode)
        diagnosticsMode = diagnosticsModeDecoded
        let spoolingModeDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.SpoolingMode.self, forKey: .spoolingMode)
        spoolingMode = spoolingModeDecoded
        let compressionDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.Compression.self, forKey: .compression)
        compression = compressionDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let signalsToCollectContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.SignalInformation?].self, forKey: .signalsToCollect)
        var signalsToCollectDecoded0:[IoTFleetWiseClientTypes.SignalInformation]? = nil
        if let signalsToCollectContainer = signalsToCollectContainer {
            signalsToCollectDecoded0 = [IoTFleetWiseClientTypes.SignalInformation]()
            for structure0 in signalsToCollectContainer {
                if let structure0 = structure0 {
                    signalsToCollectDecoded0?.append(structure0)
                }
            }
        }
        signalsToCollect = signalsToCollectDecoded0
        let collectionSchemeDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.CollectionScheme.self, forKey: .collectionScheme)
        collectionScheme = collectionSchemeDecoded
        let dataExtraDimensionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dataExtraDimensions)
        var dataExtraDimensionsDecoded0:[Swift.String]? = nil
        if let dataExtraDimensionsContainer = dataExtraDimensionsContainer {
            dataExtraDimensionsDecoded0 = [Swift.String]()
            for string0 in dataExtraDimensionsContainer {
                if let string0 = string0 {
                    dataExtraDimensionsDecoded0?.append(string0)
                }
            }
        }
        dataExtraDimensions = dataExtraDimensionsDecoded0
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension GetDecoderManifestInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetDecoderManifestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetDecoderManifestInput: Swift.Equatable {
    /// The name of the decoder manifest to retrieve information about.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetDecoderManifestInputBody: Swift.Equatable {
}

extension GetDecoderManifestInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDecoderManifestOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDecoderManifestOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDecoderManifestOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDecoderManifestOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDecoderManifestOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.description = output.description
            self.lastModificationTime = output.lastModificationTime
            self.modelManifestArn = output.modelManifestArn
            self.name = output.name
            self.status = output.status
        } else {
            self.arn = nil
            self.creationTime = nil
            self.description = nil
            self.lastModificationTime = nil
            self.modelManifestArn = nil
            self.name = nil
            self.status = nil
        }
    }
}

public struct GetDecoderManifestOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the decoder manifest.
    /// This member is required.
    public var arn: Swift.String?
    /// The time the decoder manifest was created in seconds since epoch (January 1, 1970 at midnight UTC time).
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// A brief description of the decoder manifest.
    public var description: Swift.String?
    /// The time the decoder manifest was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).
    /// This member is required.
    public var lastModificationTime: ClientRuntime.Date?
    /// The ARN of a vehicle model (model manifest) associated with the decoder manifest.
    public var modelManifestArn: Swift.String?
    /// The name of the decoder manifest.
    /// This member is required.
    public var name: Swift.String?
    /// The state of the decoder manifest. If the status is ACTIVE, the decoder manifest can't be edited. If the status is marked DRAFT, you can edit the decoder manifest.
    public var status: IoTFleetWiseClientTypes.ManifestStatus?

    public init (
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        modelManifestArn: Swift.String? = nil,
        name: Swift.String? = nil,
        status: IoTFleetWiseClientTypes.ManifestStatus? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.lastModificationTime = lastModificationTime
        self.modelManifestArn = modelManifestArn
        self.name = name
        self.status = status
    }
}

struct GetDecoderManifestOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let description: Swift.String?
    let modelManifestArn: Swift.String?
    let status: IoTFleetWiseClientTypes.ManifestStatus?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
}

extension GetDecoderManifestOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case lastModificationTime
        case modelManifestArn
        case name
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let modelManifestArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelManifestArn)
        modelManifestArn = modelManifestArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.ManifestStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension GetFleetInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetFleetInput: Swift.Equatable {
    /// The ID of the fleet to retrieve information about.
    /// This member is required.
    public var fleetId: Swift.String?

    public init (
        fleetId: Swift.String? = nil
    )
    {
        self.fleetId = fleetId
    }
}

struct GetFleetInputBody: Swift.Equatable {
}

extension GetFleetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetFleetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetFleetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.description = output.description
            self.id = output.id
            self.lastModificationTime = output.lastModificationTime
            self.signalCatalogArn = output.signalCatalogArn
        } else {
            self.arn = nil
            self.creationTime = nil
            self.description = nil
            self.id = nil
            self.lastModificationTime = nil
            self.signalCatalogArn = nil
        }
    }
}

public struct GetFleetOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var arn: Swift.String?
    /// The time the fleet was created in seconds since epoch (January 1, 1970 at midnight UTC time).
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// A brief description of the fleet.
    public var description: Swift.String?
    /// The ID of the fleet.
    /// This member is required.
    public var id: Swift.String?
    /// The time the fleet was last updated, in seconds since epoch (January 1, 1970 at midnight UTC time).
    /// This member is required.
    public var lastModificationTime: ClientRuntime.Date?
    /// The ARN of a signal catalog associated with the fleet.
    /// This member is required.
    public var signalCatalogArn: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        signalCatalogArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.lastModificationTime = lastModificationTime
        self.signalCatalogArn = signalCatalogArn
    }
}

struct GetFleetOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let description: Swift.String?
    let signalCatalogArn: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
}

extension GetFleetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case id
        case lastModificationTime
        case signalCatalogArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let signalCatalogArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signalCatalogArn)
        signalCatalogArn = signalCatalogArnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension GetLoggingOptionsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetLoggingOptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetLoggingOptionsInput: Swift.Equatable {

    public init () { }
}

struct GetLoggingOptionsInputBody: Swift.Equatable {
}

extension GetLoggingOptionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetLoggingOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLoggingOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetLoggingOptionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLoggingOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetLoggingOptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cloudWatchLogDelivery = output.cloudWatchLogDelivery
        } else {
            self.cloudWatchLogDelivery = nil
        }
    }
}

public struct GetLoggingOptionsOutputResponse: Swift.Equatable {
    /// Returns information about log delivery to Amazon CloudWatch Logs.
    /// This member is required.
    public var cloudWatchLogDelivery: IoTFleetWiseClientTypes.CloudWatchLogDeliveryOptions?

    public init (
        cloudWatchLogDelivery: IoTFleetWiseClientTypes.CloudWatchLogDeliveryOptions? = nil
    )
    {
        self.cloudWatchLogDelivery = cloudWatchLogDelivery
    }
}

struct GetLoggingOptionsOutputResponseBody: Swift.Equatable {
    let cloudWatchLogDelivery: IoTFleetWiseClientTypes.CloudWatchLogDeliveryOptions?
}

extension GetLoggingOptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogDelivery
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLogDeliveryDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.CloudWatchLogDeliveryOptions.self, forKey: .cloudWatchLogDelivery)
        cloudWatchLogDelivery = cloudWatchLogDeliveryDecoded
    }
}

extension GetModelManifestInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetModelManifestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetModelManifestInput: Swift.Equatable {
    /// The name of the vehicle model to retrieve information about.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetModelManifestInputBody: Swift.Equatable {
}

extension GetModelManifestInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetModelManifestOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetModelManifestOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetModelManifestOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetModelManifestOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetModelManifestOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.description = output.description
            self.lastModificationTime = output.lastModificationTime
            self.name = output.name
            self.signalCatalogArn = output.signalCatalogArn
            self.status = output.status
        } else {
            self.arn = nil
            self.creationTime = nil
            self.description = nil
            self.lastModificationTime = nil
            self.name = nil
            self.signalCatalogArn = nil
            self.status = nil
        }
    }
}

public struct GetModelManifestOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the vehicle model.
    /// This member is required.
    public var arn: Swift.String?
    /// The time the vehicle model was created, in seconds since epoch (January 1, 1970 at midnight UTC time).
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// A brief description of the vehicle model.
    public var description: Swift.String?
    /// The last time the vehicle model was modified.
    /// This member is required.
    public var lastModificationTime: ClientRuntime.Date?
    /// The name of the vehicle model.
    /// This member is required.
    public var name: Swift.String?
    /// The ARN of the signal catalog associated with the vehicle model.
    public var signalCatalogArn: Swift.String?
    /// The state of the vehicle model. If the status is ACTIVE, the vehicle model can't be edited. You can edit the vehicle model if the status is marked DRAFT.
    public var status: IoTFleetWiseClientTypes.ManifestStatus?

    public init (
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        signalCatalogArn: Swift.String? = nil,
        status: IoTFleetWiseClientTypes.ManifestStatus? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.lastModificationTime = lastModificationTime
        self.name = name
        self.signalCatalogArn = signalCatalogArn
        self.status = status
    }
}

struct GetModelManifestOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let description: Swift.String?
    let signalCatalogArn: Swift.String?
    let status: IoTFleetWiseClientTypes.ManifestStatus?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
}

extension GetModelManifestOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case lastModificationTime
        case name
        case signalCatalogArn
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let signalCatalogArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signalCatalogArn)
        signalCatalogArn = signalCatalogArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.ManifestStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension GetRegisterAccountStatusInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetRegisterAccountStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetRegisterAccountStatusInput: Swift.Equatable {

    public init () { }
}

struct GetRegisterAccountStatusInputBody: Swift.Equatable {
}

extension GetRegisterAccountStatusInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRegisterAccountStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRegisterAccountStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetRegisterAccountStatusOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRegisterAccountStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetRegisterAccountStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountStatus = output.accountStatus
            self.creationTime = output.creationTime
            self.customerAccountId = output.customerAccountId
            self.iamRegistrationResponse = output.iamRegistrationResponse
            self.lastModificationTime = output.lastModificationTime
            self.timestreamRegistrationResponse = output.timestreamRegistrationResponse
        } else {
            self.accountStatus = nil
            self.creationTime = nil
            self.customerAccountId = nil
            self.iamRegistrationResponse = nil
            self.lastModificationTime = nil
            self.timestreamRegistrationResponse = nil
        }
    }
}

public struct GetRegisterAccountStatusOutputResponse: Swift.Equatable {
    /// The status of registering your account and resources. The status can be one of:
    ///
    /// * REGISTRATION_SUCCESS - The Amazon Web Services resource is successfully registered.
    ///
    /// * REGISTRATION_PENDING - Amazon Web Services IoT FleetWise is processing the registration request. This process takes approximately five minutes to complete.
    ///
    /// * REGISTRATION_FAILURE - Amazon Web Services IoT FleetWise can't register the AWS resource. Try again later.
    /// This member is required.
    public var accountStatus: IoTFleetWiseClientTypes.RegistrationStatus?
    /// The time the account was registered, in seconds since epoch (January 1, 1970 at midnight UTC time).
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The unique ID of the Amazon Web Services account, provided at account creation.
    /// This member is required.
    public var customerAccountId: Swift.String?
    /// Information about the registered IAM resources or errors, if any.
    /// This member is required.
    public var iamRegistrationResponse: IoTFleetWiseClientTypes.IamRegistrationResponse?
    /// The time this registration was last updated, in seconds since epoch (January 1, 1970 at midnight UTC time).
    /// This member is required.
    public var lastModificationTime: ClientRuntime.Date?
    /// Information about the registered Amazon Timestream resources or errors, if any.
    /// This member is required.
    public var timestreamRegistrationResponse: IoTFleetWiseClientTypes.TimestreamRegistrationResponse?

    public init (
        accountStatus: IoTFleetWiseClientTypes.RegistrationStatus? = nil,
        creationTime: ClientRuntime.Date? = nil,
        customerAccountId: Swift.String? = nil,
        iamRegistrationResponse: IoTFleetWiseClientTypes.IamRegistrationResponse? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        timestreamRegistrationResponse: IoTFleetWiseClientTypes.TimestreamRegistrationResponse? = nil
    )
    {
        self.accountStatus = accountStatus
        self.creationTime = creationTime
        self.customerAccountId = customerAccountId
        self.iamRegistrationResponse = iamRegistrationResponse
        self.lastModificationTime = lastModificationTime
        self.timestreamRegistrationResponse = timestreamRegistrationResponse
    }
}

struct GetRegisterAccountStatusOutputResponseBody: Swift.Equatable {
    let customerAccountId: Swift.String?
    let accountStatus: IoTFleetWiseClientTypes.RegistrationStatus?
    let timestreamRegistrationResponse: IoTFleetWiseClientTypes.TimestreamRegistrationResponse?
    let iamRegistrationResponse: IoTFleetWiseClientTypes.IamRegistrationResponse?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
}

extension GetRegisterAccountStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountStatus
        case creationTime
        case customerAccountId
        case iamRegistrationResponse
        case lastModificationTime
        case timestreamRegistrationResponse
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerAccountId)
        customerAccountId = customerAccountIdDecoded
        let accountStatusDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.RegistrationStatus.self, forKey: .accountStatus)
        accountStatus = accountStatusDecoded
        let timestreamRegistrationResponseDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.TimestreamRegistrationResponse.self, forKey: .timestreamRegistrationResponse)
        timestreamRegistrationResponse = timestreamRegistrationResponseDecoded
        let iamRegistrationResponseDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.IamRegistrationResponse.self, forKey: .iamRegistrationResponse)
        iamRegistrationResponse = iamRegistrationResponseDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension GetSignalCatalogInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetSignalCatalogInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSignalCatalogInput: Swift.Equatable {
    /// The name of the signal catalog to retrieve information about.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetSignalCatalogInputBody: Swift.Equatable {
}

extension GetSignalCatalogInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSignalCatalogOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSignalCatalogOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSignalCatalogOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSignalCatalogOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSignalCatalogOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.description = output.description
            self.lastModificationTime = output.lastModificationTime
            self.name = output.name
            self.nodeCounts = output.nodeCounts
        } else {
            self.arn = nil
            self.creationTime = nil
            self.description = nil
            self.lastModificationTime = nil
            self.name = nil
            self.nodeCounts = nil
        }
    }
}

public struct GetSignalCatalogOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the signal catalog.
    /// This member is required.
    public var arn: Swift.String?
    /// The time the signal catalog was created in seconds since epoch (January 1, 1970 at midnight UTC time).
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// A brief description of the signal catalog.
    public var description: Swift.String?
    /// The last time the signal catalog was modified.
    /// This member is required.
    public var lastModificationTime: ClientRuntime.Date?
    /// The name of the signal catalog.
    /// This member is required.
    public var name: Swift.String?
    /// The total number of network nodes specified in a signal catalog.
    public var nodeCounts: IoTFleetWiseClientTypes.NodeCounts?

    public init (
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        nodeCounts: IoTFleetWiseClientTypes.NodeCounts? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.lastModificationTime = lastModificationTime
        self.name = name
        self.nodeCounts = nodeCounts
    }
}

struct GetSignalCatalogOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let description: Swift.String?
    let nodeCounts: IoTFleetWiseClientTypes.NodeCounts?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
}

extension GetSignalCatalogOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case lastModificationTime
        case name
        case nodeCounts
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nodeCountsDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.NodeCounts.self, forKey: .nodeCounts)
        nodeCounts = nodeCountsDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension GetVehicleInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetVehicleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetVehicleInput: Swift.Equatable {
    /// The ID of the vehicle to retrieve information about.
    /// This member is required.
    public var vehicleName: Swift.String?

    public init (
        vehicleName: Swift.String? = nil
    )
    {
        self.vehicleName = vehicleName
    }
}

struct GetVehicleInputBody: Swift.Equatable {
}

extension GetVehicleInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetVehicleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVehicleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetVehicleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVehicleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetVehicleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.attributes = output.attributes
            self.creationTime = output.creationTime
            self.decoderManifestArn = output.decoderManifestArn
            self.lastModificationTime = output.lastModificationTime
            self.modelManifestArn = output.modelManifestArn
            self.vehicleName = output.vehicleName
        } else {
            self.arn = nil
            self.attributes = nil
            self.creationTime = nil
            self.decoderManifestArn = nil
            self.lastModificationTime = nil
            self.modelManifestArn = nil
            self.vehicleName = nil
        }
    }
}

public struct GetVehicleOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the vehicle to retrieve information about.
    public var arn: Swift.String?
    /// Static information about a vehicle in a key-value pair. For example: "engineType" : "1.3 L R2"
    public var attributes: [Swift.String:Swift.String]?
    /// The time the vehicle was created in seconds since epoch (January 1, 1970 at midnight UTC time).
    public var creationTime: ClientRuntime.Date?
    /// The ARN of a decoder manifest associated with the vehicle.
    public var decoderManifestArn: Swift.String?
    /// The time the vehicle was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).
    public var lastModificationTime: ClientRuntime.Date?
    /// The ARN of a vehicle model (model manifest) associated with the vehicle.
    public var modelManifestArn: Swift.String?
    /// The ID of the vehicle.
    public var vehicleName: Swift.String?

    public init (
        arn: Swift.String? = nil,
        attributes: [Swift.String:Swift.String]? = nil,
        creationTime: ClientRuntime.Date? = nil,
        decoderManifestArn: Swift.String? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        modelManifestArn: Swift.String? = nil,
        vehicleName: Swift.String? = nil
    )
    {
        self.arn = arn
        self.attributes = attributes
        self.creationTime = creationTime
        self.decoderManifestArn = decoderManifestArn
        self.lastModificationTime = lastModificationTime
        self.modelManifestArn = modelManifestArn
        self.vehicleName = vehicleName
    }
}

struct GetVehicleOutputResponseBody: Swift.Equatable {
    let vehicleName: Swift.String?
    let arn: Swift.String?
    let modelManifestArn: Swift.String?
    let decoderManifestArn: Swift.String?
    let attributes: [Swift.String:Swift.String]?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
}

extension GetVehicleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case attributes
        case creationTime
        case decoderManifestArn
        case lastModificationTime
        case modelManifestArn
        case vehicleName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vehicleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vehicleName)
        vehicleName = vehicleNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let modelManifestArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelManifestArn)
        modelManifestArn = modelManifestArnDecoded
        let decoderManifestArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .decoderManifestArn)
        decoderManifestArn = decoderManifestArnDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension GetVehicleStatusInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetVehicleStatusInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension GetVehicleStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetVehicleStatusInput: Swift.Equatable {
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?
    /// The ID of the vehicle to retrieve information about.
    /// This member is required.
    public var vehicleName: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        vehicleName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.vehicleName = vehicleName
    }
}

struct GetVehicleStatusInputBody: Swift.Equatable {
}

extension GetVehicleStatusInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetVehicleStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVehicleStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetVehicleStatusOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVehicleStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetVehicleStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.campaigns = output.campaigns
            self.nextToken = output.nextToken
        } else {
            self.campaigns = nil
            self.nextToken = nil
        }
    }
}

public struct GetVehicleStatusOutputResponse: Swift.Equatable {
    /// Lists information about the state of the vehicle with deployed campaigns.
    public var campaigns: [IoTFleetWiseClientTypes.VehicleStatus]?
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        campaigns: [IoTFleetWiseClientTypes.VehicleStatus]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.campaigns = campaigns
        self.nextToken = nextToken
    }
}

struct GetVehicleStatusOutputResponseBody: Swift.Equatable {
    let campaigns: [IoTFleetWiseClientTypes.VehicleStatus]?
    let nextToken: Swift.String?
}

extension GetVehicleStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaigns
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignsContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.VehicleStatus?].self, forKey: .campaigns)
        var campaignsDecoded0:[IoTFleetWiseClientTypes.VehicleStatus]? = nil
        if let campaignsContainer = campaignsContainer {
            campaignsDecoded0 = [IoTFleetWiseClientTypes.VehicleStatus]()
            for structure0 in campaignsContainer {
                if let structure0 = structure0 {
                    campaignsDecoded0?.append(structure0)
                }
            }
        }
        campaigns = campaignsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension IoTFleetWiseClientTypes.IamRegistrationResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorMessage
        case registrationStatus
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let registrationStatus = self.registrationStatus {
            try encodeContainer.encode(registrationStatus.rawValue, forKey: .registrationStatus)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let registrationStatusDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.RegistrationStatus.self, forKey: .registrationStatus)
        registrationStatus = registrationStatusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about registering an Identity and Access Management (IAM) resource so Amazon Web Services IoT FleetWise edge agent software can transfer your vehicle data to Amazon Timestream.
    public struct IamRegistrationResponse: Swift.Equatable {
        /// A message associated with a registration error.
        public var errorMessage: Swift.String?
        /// The status of registering your IAM resource. The status can be one of REGISTRATION_SUCCESS, REGISTRATION_PENDING, REGISTRATION_FAILURE.
        /// This member is required.
        public var registrationStatus: IoTFleetWiseClientTypes.RegistrationStatus?
        /// The Amazon Resource Name (ARN) of the IAM role to register.
        /// This member is required.
        public var roleArn: Swift.String?

        public init (
            errorMessage: Swift.String? = nil,
            registrationStatus: IoTFleetWiseClientTypes.RegistrationStatus? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.errorMessage = errorMessage
            self.registrationStatus = registrationStatus
            self.roleArn = roleArn
        }
    }

}

extension IoTFleetWiseClientTypes.IamResources: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// The IAM resource that enables Amazon Web Services IoT FleetWise edge agent software to send data to Amazon Timestream. For more information, see [IAM roles](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html) in the Identity and Access Management User Guide.
    public struct IamResources: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the IAM resource that allows Amazon Web Services IoT FleetWise to send data to Amazon Timestream. For example, arn:aws:iam::123456789012:role/SERVICE-ROLE-ARN.
        /// This member is required.
        public var roleArn: Swift.String?

        public init (
            roleArn: Swift.String? = nil
        )
        {
            self.roleArn = roleArn
        }
    }

}

extension ImportDecoderManifestInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkFileDefinitions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let networkFileDefinitions = networkFileDefinitions {
            var networkFileDefinitionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkFileDefinitions)
            for networkfiledefinition0 in networkFileDefinitions {
                try networkFileDefinitionsContainer.encode(networkfiledefinition0)
            }
        }
    }
}

extension ImportDecoderManifestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ImportDecoderManifestInput: Swift.Equatable {
    /// The name of the decoder manifest to import.
    /// This member is required.
    public var name: Swift.String?
    /// The file to load into an Amazon Web Services account.
    /// This member is required.
    public var networkFileDefinitions: [IoTFleetWiseClientTypes.NetworkFileDefinition]?

    public init (
        name: Swift.String? = nil,
        networkFileDefinitions: [IoTFleetWiseClientTypes.NetworkFileDefinition]? = nil
    )
    {
        self.name = name
        self.networkFileDefinitions = networkFileDefinitions
    }
}

struct ImportDecoderManifestInputBody: Swift.Equatable {
    let networkFileDefinitions: [IoTFleetWiseClientTypes.NetworkFileDefinition]?
}

extension ImportDecoderManifestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkFileDefinitions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkFileDefinitionsContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.NetworkFileDefinition?].self, forKey: .networkFileDefinitions)
        var networkFileDefinitionsDecoded0:[IoTFleetWiseClientTypes.NetworkFileDefinition]? = nil
        if let networkFileDefinitionsContainer = networkFileDefinitionsContainer {
            networkFileDefinitionsDecoded0 = [IoTFleetWiseClientTypes.NetworkFileDefinition]()
            for union0 in networkFileDefinitionsContainer {
                if let union0 = union0 {
                    networkFileDefinitionsDecoded0?.append(union0)
                }
            }
        }
        networkFileDefinitions = networkFileDefinitionsDecoded0
    }
}

extension ImportDecoderManifestOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportDecoderManifestOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DecoderManifestValidationException" : self = .decoderManifestValidationException(try DecoderManifestValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSignalsException" : self = .invalidSignalsException(try InvalidSignalsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ImportDecoderManifestOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case decoderManifestValidationException(DecoderManifestValidationException)
    case invalidSignalsException(InvalidSignalsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportDecoderManifestOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ImportDecoderManifestOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct ImportDecoderManifestOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the decoder manifest that was imported.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the imported decoder manifest.
    /// This member is required.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct ImportDecoderManifestOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
}

extension ImportDecoderManifestOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension ImportSignalCatalogInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case tags
        case vss
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let vss = self.vss {
            try encodeContainer.encode(vss, forKey: .vss)
        }
    }
}

extension ImportSignalCatalogInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ImportSignalCatalogInput: Swift.Equatable {
    /// A brief description of the signal catalog.
    public var description: Swift.String?
    /// The name of the signal catalog to import.
    /// This member is required.
    public var name: Swift.String?
    /// Metadata that can be used to manage the signal catalog.
    public var tags: [IoTFleetWiseClientTypes.Tag]?
    /// The contents of the Vehicle Signal Specification (VSS) configuration. VSS is a precise language used to describe and model signals in vehicle networks.
    public var vss: IoTFleetWiseClientTypes.FormattedVss?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [IoTFleetWiseClientTypes.Tag]? = nil,
        vss: IoTFleetWiseClientTypes.FormattedVss? = nil
    )
    {
        self.description = description
        self.name = name
        self.tags = tags
        self.vss = vss
    }
}

struct ImportSignalCatalogInputBody: Swift.Equatable {
    let description: Swift.String?
    let vss: IoTFleetWiseClientTypes.FormattedVss?
    let tags: [IoTFleetWiseClientTypes.Tag]?
}

extension ImportSignalCatalogInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case tags
        case vss
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let vssDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.FormattedVss.self, forKey: .vss)
        vss = vssDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTFleetWiseClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTFleetWiseClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImportSignalCatalogOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportSignalCatalogOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSignalsException" : self = .invalidSignalsException(try InvalidSignalsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ImportSignalCatalogOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case invalidSignalsException(InvalidSignalsException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportSignalCatalogOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ImportSignalCatalogOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct ImportSignalCatalogOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the imported signal catalog.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the imported signal catalog.
    /// This member is required.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct ImportSignalCatalogOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
}

extension ImportSignalCatalogOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request couldn't be completed because the server temporarily failed.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?
    /// The number of seconds to wait before retrying the command.
    public var retryAfterSeconds: Swift.Int

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTFleetWiseClientTypes.InvalidNetworkInterface: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interfaceId
        case reason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let interfaceId = self.interfaceId {
            try encodeContainer.encode(interfaceId, forKey: .interfaceId)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let interfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .interfaceId)
        interfaceId = interfaceIdDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.NetworkInterfaceFailureReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// A reason a vehicle network interface isn't valid.
    public struct InvalidNetworkInterface: Swift.Equatable {
        /// The ID of the interface that isn't valid.
        public var interfaceId: Swift.String?
        /// A message about why the interface isn't valid.
        public var reason: IoTFleetWiseClientTypes.NetworkInterfaceFailureReason?

        public init (
            interfaceId: Swift.String? = nil,
            reason: IoTFleetWiseClientTypes.NetworkInterfaceFailureReason? = nil
        )
        {
            self.interfaceId = interfaceId
            self.reason = reason
        }
    }

}

extension InvalidNodeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidNodeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.invalidNodes = output.invalidNodes
            self.message = output.message
            self.reason = output.reason
        } else {
            self.invalidNodes = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified node type doesn't match the expected node type for a node. You can specify the node type as branch, sensor, actuator, or attribute.
public struct InvalidNodeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The specified node type isn't valid.
    public var invalidNodes: [IoTFleetWiseClientTypes.Node]?
    public var message: Swift.String?
    /// The reason the node validation failed.
    public var reason: Swift.String?

    public init (
        invalidNodes: [IoTFleetWiseClientTypes.Node]? = nil,
        message: Swift.String? = nil,
        reason: Swift.String? = nil
    )
    {
        self.invalidNodes = invalidNodes
        self.message = message
        self.reason = reason
    }
}

struct InvalidNodeExceptionBody: Swift.Equatable {
    let invalidNodes: [IoTFleetWiseClientTypes.Node]?
    let reason: Swift.String?
    let message: Swift.String?
}

extension InvalidNodeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidNodes
        case message
        case reason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidNodesContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.Node?].self, forKey: .invalidNodes)
        var invalidNodesDecoded0:[IoTFleetWiseClientTypes.Node]? = nil
        if let invalidNodesContainer = invalidNodesContainer {
            invalidNodesDecoded0 = [IoTFleetWiseClientTypes.Node]()
            for union0 in invalidNodesContainer {
                if let union0 = union0 {
                    invalidNodesDecoded0?.append(union0)
                }
            }
        }
        invalidNodes = invalidNodesDecoded0
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTFleetWiseClientTypes.InvalidSignal: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case reason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// A reason that a signal isn't valid.
    public struct InvalidSignal: Swift.Equatable {
        /// The name of the signal that isn't valid.
        public var name: Swift.String?
        /// A message about why the signal isn't valid.
        public var reason: Swift.String?

        public init (
            name: Swift.String? = nil,
            reason: Swift.String? = nil
        )
        {
            self.name = name
            self.reason = reason
        }
    }

}

extension IoTFleetWiseClientTypes.InvalidSignalDecoder: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case reason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.SignalDecoderFailureReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// A reason that a signal decoder isn't valid.
    public struct InvalidSignalDecoder: Swift.Equatable {
        /// The name of a signal decoder that isn't valid.
        public var name: Swift.String?
        /// A message about why the signal decoder isn't valid.
        public var reason: IoTFleetWiseClientTypes.SignalDecoderFailureReason?

        public init (
            name: Swift.String? = nil,
            reason: IoTFleetWiseClientTypes.SignalDecoderFailureReason? = nil
        )
        {
            self.name = name
            self.reason = reason
        }
    }

}

extension InvalidSignalsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidSignalsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.invalidSignals = output.invalidSignals
            self.message = output.message
        } else {
            self.invalidSignals = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request couldn't be completed because it contains signals that aren't valid.
public struct InvalidSignalsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The signals which caused the exception.
    public var invalidSignals: [IoTFleetWiseClientTypes.InvalidSignal]?
    public var message: Swift.String?

    public init (
        invalidSignals: [IoTFleetWiseClientTypes.InvalidSignal]? = nil,
        message: Swift.String? = nil
    )
    {
        self.invalidSignals = invalidSignals
        self.message = message
    }
}

struct InvalidSignalsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let invalidSignals: [IoTFleetWiseClientTypes.InvalidSignal]?
}

extension InvalidSignalsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidSignals
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let invalidSignalsContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.InvalidSignal?].self, forKey: .invalidSignals)
        var invalidSignalsDecoded0:[IoTFleetWiseClientTypes.InvalidSignal]? = nil
        if let invalidSignalsContainer = invalidSignalsContainer {
            invalidSignalsDecoded0 = [IoTFleetWiseClientTypes.InvalidSignal]()
            for structure0 in invalidSignalsContainer {
                if let structure0 = structure0 {
                    invalidSignalsDecoded0?.append(structure0)
                }
            }
        }
        invalidSignals = invalidSignalsDecoded0
    }
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A service quota was exceeded.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The identifier of the resource that was exceeded.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The type of resource that was exceeded.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ListCampaignsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListCampaignsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListCampaignsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListCampaignsInput: Swift.Equatable {
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?
    /// Optional parameter to filter the results by the status of each created campaign in your account. The status can be one of: CREATING, WAITING_FOR_APPROVAL, RUNNING, or SUSPENDED.
    public var status: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

struct ListCampaignsInputBody: Swift.Equatable {
}

extension ListCampaignsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListCampaignsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCampaignsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListCampaignsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCampaignsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListCampaignsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.campaignSummaries = output.campaignSummaries
            self.nextToken = output.nextToken
        } else {
            self.campaignSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListCampaignsOutputResponse: Swift.Equatable {
    /// A summary of information about each campaign.
    public var campaignSummaries: [IoTFleetWiseClientTypes.CampaignSummary]?
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        campaignSummaries: [IoTFleetWiseClientTypes.CampaignSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.campaignSummaries = campaignSummaries
        self.nextToken = nextToken
    }
}

struct ListCampaignsOutputResponseBody: Swift.Equatable {
    let campaignSummaries: [IoTFleetWiseClientTypes.CampaignSummary]?
    let nextToken: Swift.String?
}

extension ListCampaignsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignSummariesContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.CampaignSummary?].self, forKey: .campaignSummaries)
        var campaignSummariesDecoded0:[IoTFleetWiseClientTypes.CampaignSummary]? = nil
        if let campaignSummariesContainer = campaignSummariesContainer {
            campaignSummariesDecoded0 = [IoTFleetWiseClientTypes.CampaignSummary]()
            for structure0 in campaignSummariesContainer {
                if let structure0 = structure0 {
                    campaignSummariesDecoded0?.append(structure0)
                }
            }
        }
        campaignSummaries = campaignSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDecoderManifestNetworkInterfacesInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListDecoderManifestNetworkInterfacesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListDecoderManifestNetworkInterfacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDecoderManifestNetworkInterfacesInput: Swift.Equatable {
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// The name of the decoder manifest to list information about.
    /// This member is required.
    public var name: Swift.String?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct ListDecoderManifestNetworkInterfacesInputBody: Swift.Equatable {
}

extension ListDecoderManifestNetworkInterfacesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDecoderManifestNetworkInterfacesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDecoderManifestNetworkInterfacesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDecoderManifestNetworkInterfacesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDecoderManifestNetworkInterfacesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDecoderManifestNetworkInterfacesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkInterfaces = output.networkInterfaces
            self.nextToken = output.nextToken
        } else {
            self.networkInterfaces = nil
            self.nextToken = nil
        }
    }
}

public struct ListDecoderManifestNetworkInterfacesOutputResponse: Swift.Equatable {
    /// A list of information about network interfaces.
    public var networkInterfaces: [IoTFleetWiseClientTypes.NetworkInterface]?
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        networkInterfaces: [IoTFleetWiseClientTypes.NetworkInterface]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkInterfaces = networkInterfaces
        self.nextToken = nextToken
    }
}

struct ListDecoderManifestNetworkInterfacesOutputResponseBody: Swift.Equatable {
    let networkInterfaces: [IoTFleetWiseClientTypes.NetworkInterface]?
    let nextToken: Swift.String?
}

extension ListDecoderManifestNetworkInterfacesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkInterfaces
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkInterfacesContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.NetworkInterface?].self, forKey: .networkInterfaces)
        var networkInterfacesDecoded0:[IoTFleetWiseClientTypes.NetworkInterface]? = nil
        if let networkInterfacesContainer = networkInterfacesContainer {
            networkInterfacesDecoded0 = [IoTFleetWiseClientTypes.NetworkInterface]()
            for structure0 in networkInterfacesContainer {
                if let structure0 = structure0 {
                    networkInterfacesDecoded0?.append(structure0)
                }
            }
        }
        networkInterfaces = networkInterfacesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDecoderManifestSignalsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListDecoderManifestSignalsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListDecoderManifestSignalsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDecoderManifestSignalsInput: Swift.Equatable {
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// The name of the decoder manifest to list information about.
    /// This member is required.
    public var name: Swift.String?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct ListDecoderManifestSignalsInputBody: Swift.Equatable {
}

extension ListDecoderManifestSignalsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDecoderManifestSignalsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDecoderManifestSignalsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDecoderManifestSignalsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDecoderManifestSignalsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDecoderManifestSignalsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.signalDecoders = output.signalDecoders
        } else {
            self.nextToken = nil
            self.signalDecoders = nil
        }
    }
}

public struct ListDecoderManifestSignalsOutputResponse: Swift.Equatable {
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// Information about a list of signals to decode.
    public var signalDecoders: [IoTFleetWiseClientTypes.SignalDecoder]?

    public init (
        nextToken: Swift.String? = nil,
        signalDecoders: [IoTFleetWiseClientTypes.SignalDecoder]? = nil
    )
    {
        self.nextToken = nextToken
        self.signalDecoders = signalDecoders
    }
}

struct ListDecoderManifestSignalsOutputResponseBody: Swift.Equatable {
    let signalDecoders: [IoTFleetWiseClientTypes.SignalDecoder]?
    let nextToken: Swift.String?
}

extension ListDecoderManifestSignalsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case signalDecoders
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signalDecodersContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.SignalDecoder?].self, forKey: .signalDecoders)
        var signalDecodersDecoded0:[IoTFleetWiseClientTypes.SignalDecoder]? = nil
        if let signalDecodersContainer = signalDecodersContainer {
            signalDecodersDecoded0 = [IoTFleetWiseClientTypes.SignalDecoder]()
            for structure0 in signalDecodersContainer {
                if let structure0 = structure0 {
                    signalDecodersDecoded0?.append(structure0)
                }
            }
        }
        signalDecoders = signalDecodersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDecoderManifestsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListDecoderManifestsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListDecoderManifestsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDecoderManifestsInput: Swift.Equatable {
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// The Amazon Resource Name (ARN) of a vehicle model (model manifest) associated with the decoder manifest.
    public var modelManifestArn: Swift.String?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        modelManifestArn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.modelManifestArn = modelManifestArn
        self.nextToken = nextToken
    }
}

struct ListDecoderManifestsInputBody: Swift.Equatable {
}

extension ListDecoderManifestsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDecoderManifestsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDecoderManifestsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDecoderManifestsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDecoderManifestsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDecoderManifestsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct ListDecoderManifestsOutputResponse: Swift.Equatable {
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A list of information about each decoder manifest.
    public var summaries: [IoTFleetWiseClientTypes.DecoderManifestSummary]?

    public init (
        nextToken: Swift.String? = nil,
        summaries: [IoTFleetWiseClientTypes.DecoderManifestSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct ListDecoderManifestsOutputResponseBody: Swift.Equatable {
    let summaries: [IoTFleetWiseClientTypes.DecoderManifestSummary]?
    let nextToken: Swift.String?
}

extension ListDecoderManifestsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case summaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summariesContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.DecoderManifestSummary?].self, forKey: .summaries)
        var summariesDecoded0:[IoTFleetWiseClientTypes.DecoderManifestSummary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [IoTFleetWiseClientTypes.DecoderManifestSummary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFleetsForVehicleInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListFleetsForVehicleInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListFleetsForVehicleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListFleetsForVehicleInput: Swift.Equatable {
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?
    /// The ID of the vehicle to retrieve information about.
    /// This member is required.
    public var vehicleName: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        vehicleName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.vehicleName = vehicleName
    }
}

struct ListFleetsForVehicleInputBody: Swift.Equatable {
}

extension ListFleetsForVehicleInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFleetsForVehicleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFleetsForVehicleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListFleetsForVehicleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFleetsForVehicleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListFleetsForVehicleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fleets = output.fleets
            self.nextToken = output.nextToken
        } else {
            self.fleets = nil
            self.nextToken = nil
        }
    }
}

public struct ListFleetsForVehicleOutputResponse: Swift.Equatable {
    /// A list of fleet IDs that the vehicle is associated with.
    public var fleets: [Swift.String]?
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        fleets: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleets = fleets
        self.nextToken = nextToken
    }
}

struct ListFleetsForVehicleOutputResponseBody: Swift.Equatable {
    let fleets: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListFleetsForVehicleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleets
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .fleets)
        var fleetsDecoded0:[Swift.String]? = nil
        if let fleetsContainer = fleetsContainer {
            fleetsDecoded0 = [Swift.String]()
            for string0 in fleetsContainer {
                if let string0 = string0 {
                    fleetsDecoded0?.append(string0)
                }
            }
        }
        fleets = fleetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFleetsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListFleetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListFleetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListFleetsInput: Swift.Equatable {
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFleetsInputBody: Swift.Equatable {
}

extension ListFleetsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFleetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFleetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListFleetsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFleetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListFleetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fleetSummaries = output.fleetSummaries
            self.nextToken = output.nextToken
        } else {
            self.fleetSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListFleetsOutputResponse: Swift.Equatable {
    /// A list of information for each fleet.
    public var fleetSummaries: [IoTFleetWiseClientTypes.FleetSummary]?
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init (
        fleetSummaries: [IoTFleetWiseClientTypes.FleetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetSummaries = fleetSummaries
        self.nextToken = nextToken
    }
}

struct ListFleetsOutputResponseBody: Swift.Equatable {
    let fleetSummaries: [IoTFleetWiseClientTypes.FleetSummary]?
    let nextToken: Swift.String?
}

extension ListFleetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetSummariesContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.FleetSummary?].self, forKey: .fleetSummaries)
        var fleetSummariesDecoded0:[IoTFleetWiseClientTypes.FleetSummary]? = nil
        if let fleetSummariesContainer = fleetSummariesContainer {
            fleetSummariesDecoded0 = [IoTFleetWiseClientTypes.FleetSummary]()
            for structure0 in fleetSummariesContainer {
                if let structure0 = structure0 {
                    fleetSummariesDecoded0?.append(structure0)
                }
            }
        }
        fleetSummaries = fleetSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListModelManifestNodesInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListModelManifestNodesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListModelManifestNodesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListModelManifestNodesInput: Swift.Equatable {
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// The name of the vehicle model to list information about.
    /// This member is required.
    public var name: Swift.String?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct ListModelManifestNodesInputBody: Swift.Equatable {
}

extension ListModelManifestNodesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListModelManifestNodesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListModelManifestNodesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListModelManifestNodesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListModelManifestNodesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListModelManifestNodesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.nodes = output.nodes
        } else {
            self.nextToken = nil
            self.nodes = nil
        }
    }
}

public struct ListModelManifestNodesOutputResponse: Swift.Equatable {
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A list of information about nodes.
    public var nodes: [IoTFleetWiseClientTypes.Node]?

    public init (
        nextToken: Swift.String? = nil,
        nodes: [IoTFleetWiseClientTypes.Node]? = nil
    )
    {
        self.nextToken = nextToken
        self.nodes = nodes
    }
}

struct ListModelManifestNodesOutputResponseBody: Swift.Equatable {
    let nodes: [IoTFleetWiseClientTypes.Node]?
    let nextToken: Swift.String?
}

extension ListModelManifestNodesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case nodes
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodesContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.Node?].self, forKey: .nodes)
        var nodesDecoded0:[IoTFleetWiseClientTypes.Node]? = nil
        if let nodesContainer = nodesContainer {
            nodesDecoded0 = [IoTFleetWiseClientTypes.Node]()
            for union0 in nodesContainer {
                if let union0 = union0 {
                    nodesDecoded0?.append(union0)
                }
            }
        }
        nodes = nodesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListModelManifestsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListModelManifestsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListModelManifestsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListModelManifestsInput: Swift.Equatable {
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?
    /// The ARN of a signal catalog. If you specify a signal catalog, only the vehicle models associated with it are returned.
    public var signalCatalogArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        signalCatalogArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.signalCatalogArn = signalCatalogArn
    }
}

struct ListModelManifestsInputBody: Swift.Equatable {
}

extension ListModelManifestsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListModelManifestsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListModelManifestsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListModelManifestsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListModelManifestsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListModelManifestsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct ListModelManifestsOutputResponse: Swift.Equatable {
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A list of information about vehicle models.
    public var summaries: [IoTFleetWiseClientTypes.ModelManifestSummary]?

    public init (
        nextToken: Swift.String? = nil,
        summaries: [IoTFleetWiseClientTypes.ModelManifestSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct ListModelManifestsOutputResponseBody: Swift.Equatable {
    let summaries: [IoTFleetWiseClientTypes.ModelManifestSummary]?
    let nextToken: Swift.String?
}

extension ListModelManifestsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case summaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summariesContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.ModelManifestSummary?].self, forKey: .summaries)
        var summariesDecoded0:[IoTFleetWiseClientTypes.ModelManifestSummary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [IoTFleetWiseClientTypes.ModelManifestSummary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSignalCatalogNodesInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListSignalCatalogNodesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListSignalCatalogNodesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSignalCatalogNodesInput: Swift.Equatable {
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// The name of the signal catalog to list information about.
    /// This member is required.
    public var name: Swift.String?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct ListSignalCatalogNodesInputBody: Swift.Equatable {
}

extension ListSignalCatalogNodesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSignalCatalogNodesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSignalCatalogNodesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSignalCatalogNodesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSignalCatalogNodesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSignalCatalogNodesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.nodes = output.nodes
        } else {
            self.nextToken = nil
            self.nodes = nil
        }
    }
}

public struct ListSignalCatalogNodesOutputResponse: Swift.Equatable {
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A list of information about nodes.
    public var nodes: [IoTFleetWiseClientTypes.Node]?

    public init (
        nextToken: Swift.String? = nil,
        nodes: [IoTFleetWiseClientTypes.Node]? = nil
    )
    {
        self.nextToken = nextToken
        self.nodes = nodes
    }
}

struct ListSignalCatalogNodesOutputResponseBody: Swift.Equatable {
    let nodes: [IoTFleetWiseClientTypes.Node]?
    let nextToken: Swift.String?
}

extension ListSignalCatalogNodesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case nodes
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodesContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.Node?].self, forKey: .nodes)
        var nodesDecoded0:[IoTFleetWiseClientTypes.Node]? = nil
        if let nodesContainer = nodesContainer {
            nodesDecoded0 = [IoTFleetWiseClientTypes.Node]()
            for union0 in nodesContainer {
                if let union0 = union0 {
                    nodesDecoded0?.append(union0)
                }
            }
        }
        nodes = nodesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSignalCatalogsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListSignalCatalogsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListSignalCatalogsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSignalCatalogsInput: Swift.Equatable {
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSignalCatalogsInputBody: Swift.Equatable {
}

extension ListSignalCatalogsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSignalCatalogsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSignalCatalogsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSignalCatalogsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSignalCatalogsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSignalCatalogsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct ListSignalCatalogsOutputResponse: Swift.Equatable {
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A list of information about each signal catalog.
    public var summaries: [IoTFleetWiseClientTypes.SignalCatalogSummary]?

    public init (
        nextToken: Swift.String? = nil,
        summaries: [IoTFleetWiseClientTypes.SignalCatalogSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct ListSignalCatalogsOutputResponseBody: Swift.Equatable {
    let summaries: [IoTFleetWiseClientTypes.SignalCatalogSummary]?
    let nextToken: Swift.String?
}

extension ListSignalCatalogsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case summaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summariesContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.SignalCatalogSummary?].self, forKey: .summaries)
        var summariesDecoded0:[IoTFleetWiseClientTypes.SignalCatalogSummary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [IoTFleetWiseClientTypes.SignalCatalogSummary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListTagsForResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init (
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The list of tags assigned to the resource.
    public var tags: [IoTFleetWiseClientTypes.Tag]?

    public init (
        tags: [IoTFleetWiseClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [IoTFleetWiseClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTFleetWiseClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTFleetWiseClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListVehiclesInFleetInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListVehiclesInFleetInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListVehiclesInFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListVehiclesInFleetInput: Swift.Equatable {
    /// The ID of a fleet.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init (
        fleetId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetId = fleetId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListVehiclesInFleetInputBody: Swift.Equatable {
}

extension ListVehiclesInFleetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListVehiclesInFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVehiclesInFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListVehiclesInFleetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVehiclesInFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListVehiclesInFleetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.vehicles = output.vehicles
        } else {
            self.nextToken = nil
            self.vehicles = nil
        }
    }
}

public struct ListVehiclesInFleetOutputResponse: Swift.Equatable {
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A list of vehicles associated with the fleet.
    public var vehicles: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        vehicles: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.vehicles = vehicles
    }
}

struct ListVehiclesInFleetOutputResponseBody: Swift.Equatable {
    let vehicles: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListVehiclesInFleetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case vehicles
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vehiclesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vehicles)
        var vehiclesDecoded0:[Swift.String]? = nil
        if let vehiclesContainer = vehiclesContainer {
            vehiclesDecoded0 = [Swift.String]()
            for string0 in vehiclesContainer {
                if let string0 = string0 {
                    vehiclesDecoded0?.append(string0)
                }
            }
        }
        vehicles = vehiclesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListVehiclesInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListVehiclesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListVehiclesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListVehiclesInput: Swift.Equatable {
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// The Amazon Resource Name (ARN) of a vehicle model (model manifest). You can use this optional parameter to list only the vehicles created from a certain vehicle model.
    public var modelManifestArn: Swift.String?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        modelManifestArn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.modelManifestArn = modelManifestArn
        self.nextToken = nextToken
    }
}

struct ListVehiclesInputBody: Swift.Equatable {
}

extension ListVehiclesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListVehiclesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVehiclesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListVehiclesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVehiclesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListVehiclesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.vehicleSummaries = output.vehicleSummaries
        } else {
            self.nextToken = nil
            self.vehicleSummaries = nil
        }
    }
}

public struct ListVehiclesOutputResponse: Swift.Equatable {
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A list of vehicles and information about them.
    public var vehicleSummaries: [IoTFleetWiseClientTypes.VehicleSummary]?

    public init (
        nextToken: Swift.String? = nil,
        vehicleSummaries: [IoTFleetWiseClientTypes.VehicleSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.vehicleSummaries = vehicleSummaries
    }
}

struct ListVehiclesOutputResponseBody: Swift.Equatable {
    let vehicleSummaries: [IoTFleetWiseClientTypes.VehicleSummary]?
    let nextToken: Swift.String?
}

extension ListVehiclesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case vehicleSummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vehicleSummariesContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.VehicleSummary?].self, forKey: .vehicleSummaries)
        var vehicleSummariesDecoded0:[IoTFleetWiseClientTypes.VehicleSummary]? = nil
        if let vehicleSummariesContainer = vehicleSummariesContainer {
            vehicleSummariesDecoded0 = [IoTFleetWiseClientTypes.VehicleSummary]()
            for structure0 in vehicleSummariesContainer {
                if let structure0 = structure0 {
                    vehicleSummariesDecoded0?.append(structure0)
                }
            }
        }
        vehicleSummaries = vehicleSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension IoTFleetWiseClientTypes {
    public enum LogType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case off
        case sdkUnknown(Swift.String)

        public static var allCases: [LogType] {
            return [
                .error,
                .off,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .off: return "OFF"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LogType(rawValue: rawValue) ?? LogType.sdkUnknown(rawValue)
        }
    }
}

extension IoTFleetWiseClientTypes {
    public enum ManifestStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case draft
        case sdkUnknown(Swift.String)

        public static var allCases: [ManifestStatus] {
            return [
                .active,
                .draft,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .draft: return "DRAFT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ManifestStatus(rawValue: rawValue) ?? ManifestStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTFleetWiseClientTypes.ModelManifestSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case lastModificationTime
        case name
        case signalCatalogArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let signalCatalogArn = self.signalCatalogArn {
            try encodeContainer.encode(signalCatalogArn, forKey: .signalCatalogArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let signalCatalogArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signalCatalogArn)
        signalCatalogArn = signalCatalogArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.ManifestStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about a vehicle model (model manifest). You can use the API operation to return this information about multiple vehicle models.
    public struct ModelManifestSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the vehicle model.
        public var arn: Swift.String?
        /// The time the vehicle model was created, in seconds since epoch (January 1, 1970 at midnight UTC time).
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// A brief description of the vehicle model.
        public var description: Swift.String?
        /// The time the vehicle model was last updated, in seconds since epoch (January 1, 1970 at midnight UTC time).
        /// This member is required.
        public var lastModificationTime: ClientRuntime.Date?
        /// The name of the vehicle model.
        public var name: Swift.String?
        /// The ARN of the signal catalog associated with the vehicle model.
        public var signalCatalogArn: Swift.String?
        /// The state of the vehicle model. If the status is ACTIVE, the vehicle model can't be edited. If the status is DRAFT, you can edit the vehicle model.
        public var status: IoTFleetWiseClientTypes.ManifestStatus?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            signalCatalogArn: Swift.String? = nil,
            status: IoTFleetWiseClientTypes.ManifestStatus? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.lastModificationTime = lastModificationTime
            self.name = name
            self.signalCatalogArn = signalCatalogArn
            self.status = status
        }
    }

}

extension IoTFleetWiseClientTypes.NetworkFileDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case candbc = "canDbc"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .candbc(candbc):
                try container.encode(candbc, forKey: .candbc)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let candbcDecoded = try values.decodeIfPresent(IoTFleetWiseClientTypes.CanDbcDefinition.self, forKey: .candbc)
        if let candbc = candbcDecoded {
            self = .candbc(candbc)
            return
        }
        self = .sdkUnknown("")
    }
}

extension IoTFleetWiseClientTypes {
    /// Specifications for defining a vehicle network.
    public enum NetworkFileDefinition: Swift.Equatable {
        /// Information, including CAN DBC files, about the configurations used to create a decoder manifest.
        case candbc(IoTFleetWiseClientTypes.CanDbcDefinition)
        case sdkUnknown(Swift.String)
    }

}

extension IoTFleetWiseClientTypes.NetworkInterface: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canInterface
        case interfaceId
        case obdInterface
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let canInterface = self.canInterface {
            try encodeContainer.encode(canInterface, forKey: .canInterface)
        }
        if let interfaceId = self.interfaceId {
            try encodeContainer.encode(interfaceId, forKey: .interfaceId)
        }
        if let obdInterface = self.obdInterface {
            try encodeContainer.encode(obdInterface, forKey: .obdInterface)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let interfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .interfaceId)
        interfaceId = interfaceIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.NetworkInterfaceType.self, forKey: .type)
        type = typeDecoded
        let canInterfaceDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.CanInterface.self, forKey: .canInterface)
        canInterface = canInterfaceDecoded
        let obdInterfaceDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.ObdInterface.self, forKey: .obdInterface)
        obdInterface = obdInterfaceDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Represents a node and its specifications in an in-vehicle communication network. All signal decoders must be associated with a network node. To return this information about all the network interfaces specified in a decoder manifest, use the API operation.
    public struct NetworkInterface: Swift.Equatable {
        /// Information about a network interface specified by the Controller Area Network (CAN) protocol.
        public var canInterface: IoTFleetWiseClientTypes.CanInterface?
        /// The ID of the network interface.
        /// This member is required.
        public var interfaceId: Swift.String?
        /// Information about a network interface specified by the On-board diagnostic (OBD) II protocol.
        public var obdInterface: IoTFleetWiseClientTypes.ObdInterface?
        /// The network protocol for the vehicle. For example, CAN_SIGNAL specifies a protocol that defines how data is communicated between electronic control units (ECUs). OBD_SIGNAL specifies a protocol that defines how self-diagnostic data is communicated between ECUs.
        /// This member is required.
        public var type: IoTFleetWiseClientTypes.NetworkInterfaceType?

        public init (
            canInterface: IoTFleetWiseClientTypes.CanInterface? = nil,
            interfaceId: Swift.String? = nil,
            obdInterface: IoTFleetWiseClientTypes.ObdInterface? = nil,
            type: IoTFleetWiseClientTypes.NetworkInterfaceType? = nil
        )
        {
            self.canInterface = canInterface
            self.interfaceId = interfaceId
            self.obdInterface = obdInterface
            self.type = type
        }
    }

}

extension IoTFleetWiseClientTypes {
    public enum NetworkInterfaceFailureReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canNetworkInterfaceInfoIsNull
        case conflictingNetworkInterface
        case duplicateInterface
        case networkInterfaceToAddAlreadyExists
        case networkInterfaceToRemoveAssociatedWithSignals
        case obdNetworkInterfaceInfoIsNull
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkInterfaceFailureReason] {
            return [
                .canNetworkInterfaceInfoIsNull,
                .conflictingNetworkInterface,
                .duplicateInterface,
                .networkInterfaceToAddAlreadyExists,
                .networkInterfaceToRemoveAssociatedWithSignals,
                .obdNetworkInterfaceInfoIsNull,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canNetworkInterfaceInfoIsNull: return "CAN_NETWORK_INTERFACE_INFO_IS_NULL"
            case .conflictingNetworkInterface: return "CONFLICTING_NETWORK_INTERFACE"
            case .duplicateInterface: return "DUPLICATE_NETWORK_INTERFACE"
            case .networkInterfaceToAddAlreadyExists: return "NETWORK_INTERFACE_TO_ADD_ALREADY_EXISTS"
            case .networkInterfaceToRemoveAssociatedWithSignals: return "NETWORK_INTERFACE_TO_REMOVE_ASSOCIATED_WITH_SIGNALS"
            case .obdNetworkInterfaceInfoIsNull: return "OBD_NETWORK_INTERFACE_INFO_IS_NULL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkInterfaceFailureReason(rawValue: rawValue) ?? NetworkInterfaceFailureReason.sdkUnknown(rawValue)
        }
    }
}

extension IoTFleetWiseClientTypes {
    public enum NetworkInterfaceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canInterface
        case obdInterface
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkInterfaceType] {
            return [
                .canInterface,
                .obdInterface,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canInterface: return "CAN_INTERFACE"
            case .obdInterface: return "OBD_INTERFACE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkInterfaceType(rawValue: rawValue) ?? NetworkInterfaceType.sdkUnknown(rawValue)
        }
    }
}

extension IoTFleetWiseClientTypes.Node: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actuator
        case attribute
        case branch
        case sdkUnknown
        case sensor
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .actuator(actuator):
                try container.encode(actuator, forKey: .actuator)
            case let .attribute(attribute):
                try container.encode(attribute, forKey: .attribute)
            case let .branch(branch):
                try container.encode(branch, forKey: .branch)
            case let .sensor(sensor):
                try container.encode(sensor, forKey: .sensor)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let branchDecoded = try values.decodeIfPresent(IoTFleetWiseClientTypes.Branch.self, forKey: .branch)
        if let branch = branchDecoded {
            self = .branch(branch)
            return
        }
        let sensorDecoded = try values.decodeIfPresent(IoTFleetWiseClientTypes.Sensor.self, forKey: .sensor)
        if let sensor = sensorDecoded {
            self = .sensor(sensor)
            return
        }
        let actuatorDecoded = try values.decodeIfPresent(IoTFleetWiseClientTypes.Actuator.self, forKey: .actuator)
        if let actuator = actuatorDecoded {
            self = .actuator(actuator)
            return
        }
        let attributeDecoded = try values.decodeIfPresent(IoTFleetWiseClientTypes.Attribute.self, forKey: .attribute)
        if let attribute = attributeDecoded {
            self = .attribute(attribute)
            return
        }
        self = .sdkUnknown("")
    }
}

extension IoTFleetWiseClientTypes {
    /// A general abstraction of a signal. A node can be specified as an actuator, attribute, branch, or sensor.
    public enum Node: Swift.Equatable {
        /// Information about a node specified as a branch. A group of signals that are defined in a hierarchical structure.
        case branch(IoTFleetWiseClientTypes.Branch)
        /// An input component that reports the environmental condition of a vehicle. You can collect data about fluid levels, temperatures, vibrations, or battery voltage from sensors.
        case sensor(IoTFleetWiseClientTypes.Sensor)
        /// Information about a node specified as an actuator. An actuator is a digital representation of a vehicle device.
        case actuator(IoTFleetWiseClientTypes.Actuator)
        /// Information about a node specified as an attribute. An attribute represents static information about a vehicle.
        case attribute(IoTFleetWiseClientTypes.Attribute)
        case sdkUnknown(Swift.String)
    }

}

extension IoTFleetWiseClientTypes.NodeCounts: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case totalActuators
        case totalAttributes
        case totalBranches
        case totalNodes
        case totalSensors
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if totalActuators != 0 {
            try encodeContainer.encode(totalActuators, forKey: .totalActuators)
        }
        if totalAttributes != 0 {
            try encodeContainer.encode(totalAttributes, forKey: .totalAttributes)
        }
        if totalBranches != 0 {
            try encodeContainer.encode(totalBranches, forKey: .totalBranches)
        }
        if totalNodes != 0 {
            try encodeContainer.encode(totalNodes, forKey: .totalNodes)
        }
        if totalSensors != 0 {
            try encodeContainer.encode(totalSensors, forKey: .totalSensors)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalNodesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalNodes) ?? 0
        totalNodes = totalNodesDecoded
        let totalBranchesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalBranches) ?? 0
        totalBranches = totalBranchesDecoded
        let totalSensorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalSensors) ?? 0
        totalSensors = totalSensorsDecoded
        let totalAttributesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalAttributes) ?? 0
        totalAttributes = totalAttributesDecoded
        let totalActuatorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalActuators) ?? 0
        totalActuators = totalActuatorsDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about the number of nodes and node types in a vehicle network.
    public struct NodeCounts: Swift.Equatable {
        /// The total number of nodes in a vehicle network that represent actuators.
        public var totalActuators: Swift.Int
        /// The total number of nodes in a vehicle network that represent attributes.
        public var totalAttributes: Swift.Int
        /// The total number of nodes in a vehicle network that represent branches.
        public var totalBranches: Swift.Int
        /// The total number of nodes in a vehicle network.
        public var totalNodes: Swift.Int
        /// The total number of nodes in a vehicle network that represent sensors.
        public var totalSensors: Swift.Int

        public init (
            totalActuators: Swift.Int = 0,
            totalAttributes: Swift.Int = 0,
            totalBranches: Swift.Int = 0,
            totalNodes: Swift.Int = 0,
            totalSensors: Swift.Int = 0
        )
        {
            self.totalActuators = totalActuators
            self.totalAttributes = totalAttributes
            self.totalBranches = totalBranches
            self.totalNodes = totalNodes
            self.totalSensors = totalSensors
        }
    }

}

extension IoTFleetWiseClientTypes {
    public enum NodeDataType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case boolean
        case booleanArray
        case double
        case doubleArray
        case float
        case floatArray
        case int16
        case int16Array
        case int32
        case int32Array
        case int64
        case int64Array
        case int8
        case int8Array
        case string
        case stringArray
        case uint16
        case uint16Array
        case uint32
        case uint32Array
        case uint64
        case uint64Array
        case uint8
        case uint8Array
        case unixTimestamp
        case unixTimestampArray
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [NodeDataType] {
            return [
                .boolean,
                .booleanArray,
                .double,
                .doubleArray,
                .float,
                .floatArray,
                .int16,
                .int16Array,
                .int32,
                .int32Array,
                .int64,
                .int64Array,
                .int8,
                .int8Array,
                .string,
                .stringArray,
                .uint16,
                .uint16Array,
                .uint32,
                .uint32Array,
                .uint64,
                .uint64Array,
                .uint8,
                .uint8Array,
                .unixTimestamp,
                .unixTimestampArray,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "BOOLEAN"
            case .booleanArray: return "BOOLEAN_ARRAY"
            case .double: return "DOUBLE"
            case .doubleArray: return "DOUBLE_ARRAY"
            case .float: return "FLOAT"
            case .floatArray: return "FLOAT_ARRAY"
            case .int16: return "INT16"
            case .int16Array: return "INT16_ARRAY"
            case .int32: return "INT32"
            case .int32Array: return "INT32_ARRAY"
            case .int64: return "INT64"
            case .int64Array: return "INT64_ARRAY"
            case .int8: return "INT8"
            case .int8Array: return "INT8_ARRAY"
            case .string: return "STRING"
            case .stringArray: return "STRING_ARRAY"
            case .uint16: return "UINT16"
            case .uint16Array: return "UINT16_ARRAY"
            case .uint32: return "UINT32"
            case .uint32Array: return "UINT32_ARRAY"
            case .uint64: return "UINT64"
            case .uint64Array: return "UINT64_ARRAY"
            case .uint8: return "UINT8"
            case .uint8Array: return "UINT8_ARRAY"
            case .unixTimestamp: return "UNIX_TIMESTAMP"
            case .unixTimestampArray: return "UNIX_TIMESTAMP_ARRAY"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NodeDataType(rawValue: rawValue) ?? NodeDataType.sdkUnknown(rawValue)
        }
    }
}

extension IoTFleetWiseClientTypes.ObdInterface: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dtcRequestIntervalSeconds
        case hasTransmissionEcu
        case name
        case obdStandard
        case pidRequestIntervalSeconds
        case requestMessageId
        case useExtendedIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dtcRequestIntervalSeconds != 0 {
            try encodeContainer.encode(dtcRequestIntervalSeconds, forKey: .dtcRequestIntervalSeconds)
        }
        if hasTransmissionEcu != false {
            try encodeContainer.encode(hasTransmissionEcu, forKey: .hasTransmissionEcu)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let obdStandard = self.obdStandard {
            try encodeContainer.encode(obdStandard, forKey: .obdStandard)
        }
        if pidRequestIntervalSeconds != 0 {
            try encodeContainer.encode(pidRequestIntervalSeconds, forKey: .pidRequestIntervalSeconds)
        }
        if requestMessageId != 0 {
            try encodeContainer.encode(requestMessageId, forKey: .requestMessageId)
        }
        if useExtendedIds != false {
            try encodeContainer.encode(useExtendedIds, forKey: .useExtendedIds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let requestMessageIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .requestMessageId) ?? 0
        requestMessageId = requestMessageIdDecoded
        let obdStandardDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .obdStandard)
        obdStandard = obdStandardDecoded
        let pidRequestIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pidRequestIntervalSeconds) ?? 0
        pidRequestIntervalSeconds = pidRequestIntervalSecondsDecoded
        let dtcRequestIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dtcRequestIntervalSeconds) ?? 0
        dtcRequestIntervalSeconds = dtcRequestIntervalSecondsDecoded
        let useExtendedIdsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useExtendedIds) ?? false
        useExtendedIds = useExtendedIdsDecoded
        let hasTransmissionEcuDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasTransmissionEcu) ?? false
        hasTransmissionEcu = hasTransmissionEcuDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// A network interface that specifies the On-board diagnostic (OBD) II network protocol.
    public struct ObdInterface: Swift.Equatable {
        /// The maximum number message requests per diagnostic trouble code per second.
        public var dtcRequestIntervalSeconds: Swift.Int
        /// Whether the vehicle has a transmission control module (TCM).
        public var hasTransmissionEcu: Swift.Bool
        /// The name of the interface.
        /// This member is required.
        public var name: Swift.String?
        /// The standard OBD II PID.
        public var obdStandard: Swift.String?
        /// The maximum number message requests per second.
        public var pidRequestIntervalSeconds: Swift.Int
        /// The ID of the message requesting vehicle data.
        /// This member is required.
        public var requestMessageId: Swift.Int
        /// Whether to use extended IDs in the message.
        public var useExtendedIds: Swift.Bool

        public init (
            dtcRequestIntervalSeconds: Swift.Int = 0,
            hasTransmissionEcu: Swift.Bool = false,
            name: Swift.String? = nil,
            obdStandard: Swift.String? = nil,
            pidRequestIntervalSeconds: Swift.Int = 0,
            requestMessageId: Swift.Int = 0,
            useExtendedIds: Swift.Bool = false
        )
        {
            self.dtcRequestIntervalSeconds = dtcRequestIntervalSeconds
            self.hasTransmissionEcu = hasTransmissionEcu
            self.name = name
            self.obdStandard = obdStandard
            self.pidRequestIntervalSeconds = pidRequestIntervalSeconds
            self.requestMessageId = requestMessageId
            self.useExtendedIds = useExtendedIds
        }
    }

}

extension IoTFleetWiseClientTypes.ObdSignal: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bitMaskLength
        case bitRightShift
        case byteLength
        case offset
        case pid
        case pidResponseLength
        case scaling
        case serviceMode
        case startByte
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bitMaskLength = self.bitMaskLength {
            try encodeContainer.encode(bitMaskLength, forKey: .bitMaskLength)
        }
        if bitRightShift != 0 {
            try encodeContainer.encode(bitRightShift, forKey: .bitRightShift)
        }
        if let byteLength = self.byteLength {
            try encodeContainer.encode(byteLength, forKey: .byteLength)
        }
        if let offset = self.offset {
            try encodeContainer.encode(offset, forKey: .offset)
        }
        if pid != 0 {
            try encodeContainer.encode(pid, forKey: .pid)
        }
        if pidResponseLength != 0 {
            try encodeContainer.encode(pidResponseLength, forKey: .pidResponseLength)
        }
        if let scaling = self.scaling {
            try encodeContainer.encode(scaling, forKey: .scaling)
        }
        if serviceMode != 0 {
            try encodeContainer.encode(serviceMode, forKey: .serviceMode)
        }
        if startByte != 0 {
            try encodeContainer.encode(startByte, forKey: .startByte)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pidResponseLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pidResponseLength) ?? 0
        pidResponseLength = pidResponseLengthDecoded
        let serviceModeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .serviceMode) ?? 0
        serviceMode = serviceModeDecoded
        let pidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pid) ?? 0
        pid = pidDecoded
        let scalingDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .scaling)
        scaling = scalingDecoded
        let offsetDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .offset)
        offset = offsetDecoded
        let startByteDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startByte) ?? 0
        startByte = startByteDecoded
        let byteLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .byteLength)
        byteLength = byteLengthDecoded
        let bitRightShiftDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bitRightShift) ?? 0
        bitRightShift = bitRightShiftDecoded
        let bitMaskLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bitMaskLength)
        bitMaskLength = bitMaskLengthDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about signal messages using the on-board diagnostics (OBD) II protocol in a vehicle.
    public struct ObdSignal: Swift.Equatable {
        /// The number of bits to mask in a message.
        public var bitMaskLength: Swift.Int?
        /// The number of positions to shift bits in the message.
        public var bitRightShift: Swift.Int
        /// The length of a message.
        /// This member is required.
        public var byteLength: Swift.Int?
        /// Indicates where data appears in the message.
        /// This member is required.
        public var offset: Swift.Double?
        /// The diagnostic code used to request data from a vehicle for this signal.
        /// This member is required.
        public var pid: Swift.Int
        /// The length of the requested data.
        /// This member is required.
        public var pidResponseLength: Swift.Int
        /// A multiplier used to decode the message.
        /// This member is required.
        public var scaling: Swift.Double?
        /// The mode of operation (diagnostic service) in a message.
        /// This member is required.
        public var serviceMode: Swift.Int
        /// Indicates the beginning of the message.
        /// This member is required.
        public var startByte: Swift.Int

        public init (
            bitMaskLength: Swift.Int? = nil,
            bitRightShift: Swift.Int = 0,
            byteLength: Swift.Int? = nil,
            offset: Swift.Double? = nil,
            pid: Swift.Int = 0,
            pidResponseLength: Swift.Int = 0,
            scaling: Swift.Double? = nil,
            serviceMode: Swift.Int = 0,
            startByte: Swift.Int = 0
        )
        {
            self.bitMaskLength = bitMaskLength
            self.bitRightShift = bitRightShift
            self.byteLength = byteLength
            self.offset = offset
            self.pid = pid
            self.pidResponseLength = pidResponseLength
            self.scaling = scaling
            self.serviceMode = serviceMode
            self.startByte = startByte
        }
    }

}

extension PutLoggingOptionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogDelivery
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogDelivery = self.cloudWatchLogDelivery {
            try encodeContainer.encode(cloudWatchLogDelivery, forKey: .cloudWatchLogDelivery)
        }
    }
}

extension PutLoggingOptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutLoggingOptionsInput: Swift.Equatable {
    /// Creates or updates the log delivery option to Amazon CloudWatch Logs.
    /// This member is required.
    public var cloudWatchLogDelivery: IoTFleetWiseClientTypes.CloudWatchLogDeliveryOptions?

    public init (
        cloudWatchLogDelivery: IoTFleetWiseClientTypes.CloudWatchLogDeliveryOptions? = nil
    )
    {
        self.cloudWatchLogDelivery = cloudWatchLogDelivery
    }
}

struct PutLoggingOptionsInputBody: Swift.Equatable {
    let cloudWatchLogDelivery: IoTFleetWiseClientTypes.CloudWatchLogDeliveryOptions?
}

extension PutLoggingOptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogDelivery
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLogDeliveryDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.CloudWatchLogDeliveryOptions.self, forKey: .cloudWatchLogDelivery)
        cloudWatchLogDelivery = cloudWatchLogDeliveryDecoded
    }
}

extension PutLoggingOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutLoggingOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutLoggingOptionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutLoggingOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutLoggingOptionsOutputResponse: Swift.Equatable {

    public init () { }
}

extension RegisterAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamResources
        case timestreamResources
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iamResources = self.iamResources {
            try encodeContainer.encode(iamResources, forKey: .iamResources)
        }
        if let timestreamResources = self.timestreamResources {
            try encodeContainer.encode(timestreamResources, forKey: .timestreamResources)
        }
    }
}

extension RegisterAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RegisterAccountInput: Swift.Equatable {
    /// The IAM resource that allows Amazon Web Services IoT FleetWise to send data to Amazon Timestream.
    @available(*, deprecated, message: "iamResources is no longer used or needed as input")
    public var iamResources: IoTFleetWiseClientTypes.IamResources?
    /// The registered Amazon Timestream resources that Amazon Web Services IoT FleetWise edge agent software can transfer your vehicle data to.
    /// This member is required.
    public var timestreamResources: IoTFleetWiseClientTypes.TimestreamResources?

    public init (
        iamResources: IoTFleetWiseClientTypes.IamResources? = nil,
        timestreamResources: IoTFleetWiseClientTypes.TimestreamResources? = nil
    )
    {
        self.iamResources = iamResources
        self.timestreamResources = timestreamResources
    }
}

struct RegisterAccountInputBody: Swift.Equatable {
    let timestreamResources: IoTFleetWiseClientTypes.TimestreamResources?
    let iamResources: IoTFleetWiseClientTypes.IamResources?
}

extension RegisterAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamResources
        case timestreamResources
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestreamResourcesDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.TimestreamResources.self, forKey: .timestreamResources)
        timestreamResources = timestreamResourcesDecoded
        let iamResourcesDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.IamResources.self, forKey: .iamResources)
        iamResources = iamResourcesDecoded
    }
}

extension RegisterAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RegisterAccountOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RegisterAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.iamResources = output.iamResources
            self.lastModificationTime = output.lastModificationTime
            self.registerAccountStatus = output.registerAccountStatus
            self.timestreamResources = output.timestreamResources
        } else {
            self.creationTime = nil
            self.iamResources = nil
            self.lastModificationTime = nil
            self.registerAccountStatus = nil
            self.timestreamResources = nil
        }
    }
}

public struct RegisterAccountOutputResponse: Swift.Equatable {
    /// The time the account was registered, in seconds since epoch (January 1, 1970 at midnight UTC time).
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The registered IAM resource that allows Amazon Web Services IoT FleetWise to send data to Amazon Timestream.
    /// This member is required.
    public var iamResources: IoTFleetWiseClientTypes.IamResources?
    /// The time this registration was last updated, in seconds since epoch (January 1, 1970 at midnight UTC time).
    /// This member is required.
    public var lastModificationTime: ClientRuntime.Date?
    /// The status of registering your Amazon Web Services account, IAM role, and Timestream resources.
    /// This member is required.
    public var registerAccountStatus: IoTFleetWiseClientTypes.RegistrationStatus?
    /// The registered Amazon Timestream resources that Amazon Web Services IoT FleetWise edge agent software can transfer your vehicle data to.
    /// This member is required.
    public var timestreamResources: IoTFleetWiseClientTypes.TimestreamResources?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        iamResources: IoTFleetWiseClientTypes.IamResources? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        registerAccountStatus: IoTFleetWiseClientTypes.RegistrationStatus? = nil,
        timestreamResources: IoTFleetWiseClientTypes.TimestreamResources? = nil
    )
    {
        self.creationTime = creationTime
        self.iamResources = iamResources
        self.lastModificationTime = lastModificationTime
        self.registerAccountStatus = registerAccountStatus
        self.timestreamResources = timestreamResources
    }
}

struct RegisterAccountOutputResponseBody: Swift.Equatable {
    let registerAccountStatus: IoTFleetWiseClientTypes.RegistrationStatus?
    let timestreamResources: IoTFleetWiseClientTypes.TimestreamResources?
    let iamResources: IoTFleetWiseClientTypes.IamResources?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
}

extension RegisterAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case iamResources
        case lastModificationTime
        case registerAccountStatus
        case timestreamResources
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registerAccountStatusDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.RegistrationStatus.self, forKey: .registerAccountStatus)
        registerAccountStatus = registerAccountStatusDecoded
        let timestreamResourcesDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.TimestreamResources.self, forKey: .timestreamResources)
        timestreamResources = timestreamResourcesDecoded
        let iamResourcesDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.IamResources.self, forKey: .iamResources)
        iamResources = iamResourcesDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension IoTFleetWiseClientTypes {
    public enum RegistrationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case registrationFailure
        case registrationPending
        case registrationSuccess
        case sdkUnknown(Swift.String)

        public static var allCases: [RegistrationStatus] {
            return [
                .registrationFailure,
                .registrationPending,
                .registrationSuccess,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .registrationFailure: return "REGISTRATION_FAILURE"
            case .registrationPending: return "REGISTRATION_PENDING"
            case .registrationSuccess: return "REGISTRATION_SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RegistrationStatus(rawValue: rawValue) ?? RegistrationStatus.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource wasn't found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The identifier of the resource that wasn't found.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The type of resource that wasn't found.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension IoTFleetWiseClientTypes.Sensor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedValues
        case dataType
        case description
        case fullyQualifiedName
        case max
        case min
        case unit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedValues = allowedValues {
            var allowedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedValues)
            for string0 in allowedValues {
                try allowedValuesContainer.encode(string0)
            }
        }
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let fullyQualifiedName = self.fullyQualifiedName {
            try encodeContainer.encode(fullyQualifiedName, forKey: .fullyQualifiedName)
        }
        if let max = self.max {
            try encodeContainer.encode(max, forKey: .max)
        }
        if let min = self.min {
            try encodeContainer.encode(min, forKey: .min)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fullyQualifiedNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fullyQualifiedName)
        fullyQualifiedName = fullyQualifiedNameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.NodeDataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let allowedValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowedValues)
        var allowedValuesDecoded0:[Swift.String]? = nil
        if let allowedValuesContainer = allowedValuesContainer {
            allowedValuesDecoded0 = [Swift.String]()
            for string0 in allowedValuesContainer {
                if let string0 = string0 {
                    allowedValuesDecoded0?.append(string0)
                }
            }
        }
        allowedValues = allowedValuesDecoded0
        let minDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .min)
        min = minDecoded
        let maxDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .max)
        max = maxDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// An input component that reports the environmental condition of a vehicle. You can collect data about fluid levels, temperatures, vibrations, or battery voltage from sensors.
    public struct Sensor: Swift.Equatable {
        /// A list of possible values a sensor can take.
        public var allowedValues: [Swift.String]?
        /// The specified data type of the sensor.
        /// This member is required.
        public var dataType: IoTFleetWiseClientTypes.NodeDataType?
        /// A brief description of a sensor.
        public var description: Swift.String?
        /// The fully qualified name of the sensor. For example, the fully qualified name of a sensor might be Vehicle.Body.Engine.Battery.
        /// This member is required.
        public var fullyQualifiedName: Swift.String?
        /// The specified possible maximum value of the sensor.
        public var max: Swift.Double?
        /// The specified possible minimum value of the sensor.
        public var min: Swift.Double?
        /// The scientific unit of measurement for data collected by the sensor.
        public var unit: Swift.String?

        public init (
            allowedValues: [Swift.String]? = nil,
            dataType: IoTFleetWiseClientTypes.NodeDataType? = nil,
            description: Swift.String? = nil,
            fullyQualifiedName: Swift.String? = nil,
            max: Swift.Double? = nil,
            min: Swift.Double? = nil,
            unit: Swift.String? = nil
        )
        {
            self.allowedValues = allowedValues
            self.dataType = dataType
            self.description = description
            self.fullyQualifiedName = fullyQualifiedName
            self.max = max
            self.min = min
            self.unit = unit
        }
    }

}

extension IoTFleetWiseClientTypes.SignalCatalogSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case lastModificationTime
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about a collection of standardized signals, which can be attributes, branches, sensors, or actuators.
    public struct SignalCatalogSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the signal catalog.
        public var arn: Swift.String?
        /// The time the signal catalog was created in seconds since epoch (January 1, 1970 at midnight UTC time).
        public var creationTime: ClientRuntime.Date?
        /// The time the signal catalog was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).
        public var lastModificationTime: ClientRuntime.Date?
        /// The name of the signal catalog.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.lastModificationTime = lastModificationTime
            self.name = name
        }
    }

}

extension IoTFleetWiseClientTypes.SignalDecoder: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canSignal
        case fullyQualifiedName
        case interfaceId
        case obdSignal
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let canSignal = self.canSignal {
            try encodeContainer.encode(canSignal, forKey: .canSignal)
        }
        if let fullyQualifiedName = self.fullyQualifiedName {
            try encodeContainer.encode(fullyQualifiedName, forKey: .fullyQualifiedName)
        }
        if let interfaceId = self.interfaceId {
            try encodeContainer.encode(interfaceId, forKey: .interfaceId)
        }
        if let obdSignal = self.obdSignal {
            try encodeContainer.encode(obdSignal, forKey: .obdSignal)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fullyQualifiedNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fullyQualifiedName)
        fullyQualifiedName = fullyQualifiedNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.SignalDecoderType.self, forKey: .type)
        type = typeDecoded
        let interfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .interfaceId)
        interfaceId = interfaceIdDecoded
        let canSignalDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.CanSignal.self, forKey: .canSignal)
        canSignal = canSignalDecoded
        let obdSignalDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.ObdSignal.self, forKey: .obdSignal)
        obdSignal = obdSignalDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about a signal decoder.
    public struct SignalDecoder: Swift.Equatable {
        /// Information about signal decoder using the Controller Area Network (CAN) protocol.
        public var canSignal: IoTFleetWiseClientTypes.CanSignal?
        /// The fully qualified name of a signal decoder as defined in a vehicle model.
        /// This member is required.
        public var fullyQualifiedName: Swift.String?
        /// The ID of a network interface that specifies what network protocol a vehicle follows.
        /// This member is required.
        public var interfaceId: Swift.String?
        /// Information about signal decoder using the On-board diagnostic (OBD) II protocol.
        public var obdSignal: IoTFleetWiseClientTypes.ObdSignal?
        /// The network protocol for the vehicle. For example, CAN_SIGNAL specifies a protocol that defines how data is communicated between electronic control units (ECUs). OBD_SIGNAL specifies a protocol that defines how self-diagnostic data is communicated between ECUs.
        /// This member is required.
        public var type: IoTFleetWiseClientTypes.SignalDecoderType?

        public init (
            canSignal: IoTFleetWiseClientTypes.CanSignal? = nil,
            fullyQualifiedName: Swift.String? = nil,
            interfaceId: Swift.String? = nil,
            obdSignal: IoTFleetWiseClientTypes.ObdSignal? = nil,
            type: IoTFleetWiseClientTypes.SignalDecoderType? = nil
        )
        {
            self.canSignal = canSignal
            self.fullyQualifiedName = fullyQualifiedName
            self.interfaceId = interfaceId
            self.obdSignal = obdSignal
            self.type = type
        }
    }

}

extension IoTFleetWiseClientTypes {
    public enum SignalDecoderFailureReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canSignalInfoIsNull
        case conflictingSignal
        case duplicateSignal
        case networkInterfaceTypeIncompatibleWithSignalDecoderType
        case noDecoderInfoForSignalInModel
        case obdSignalInfoIsNull
        case signalNotAssociatedWithNetworkInterface
        case signalNotInModel
        case signalToAddAlreadyExists
        case sdkUnknown(Swift.String)

        public static var allCases: [SignalDecoderFailureReason] {
            return [
                .canSignalInfoIsNull,
                .conflictingSignal,
                .duplicateSignal,
                .networkInterfaceTypeIncompatibleWithSignalDecoderType,
                .noDecoderInfoForSignalInModel,
                .obdSignalInfoIsNull,
                .signalNotAssociatedWithNetworkInterface,
                .signalNotInModel,
                .signalToAddAlreadyExists,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canSignalInfoIsNull: return "CAN_SIGNAL_INFO_IS_NULL"
            case .conflictingSignal: return "CONFLICTING_SIGNAL"
            case .duplicateSignal: return "DUPLICATE_SIGNAL"
            case .networkInterfaceTypeIncompatibleWithSignalDecoderType: return "NETWORK_INTERFACE_TYPE_INCOMPATIBLE_WITH_SIGNAL_DECODER_TYPE"
            case .noDecoderInfoForSignalInModel: return "NO_DECODER_INFO_FOR_SIGNAL_IN_MODEL"
            case .obdSignalInfoIsNull: return "OBD_SIGNAL_INFO_IS_NULL"
            case .signalNotAssociatedWithNetworkInterface: return "SIGNAL_NOT_ASSOCIATED_WITH_NETWORK_INTERFACE"
            case .signalNotInModel: return "SIGNAL_NOT_IN_MODEL"
            case .signalToAddAlreadyExists: return "SIGNAL_TO_ADD_ALREADY_EXISTS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SignalDecoderFailureReason(rawValue: rawValue) ?? SignalDecoderFailureReason.sdkUnknown(rawValue)
        }
    }
}

extension IoTFleetWiseClientTypes {
    public enum SignalDecoderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canSignal
        case obdSignal
        case sdkUnknown(Swift.String)

        public static var allCases: [SignalDecoderType] {
            return [
                .canSignal,
                .obdSignal,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canSignal: return "CAN_SIGNAL"
            case .obdSignal: return "OBD_SIGNAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SignalDecoderType(rawValue: rawValue) ?? SignalDecoderType.sdkUnknown(rawValue)
        }
    }
}

extension IoTFleetWiseClientTypes.SignalInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxSampleCount
        case minimumSamplingIntervalMs
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxSampleCount = self.maxSampleCount {
            try encodeContainer.encode(maxSampleCount, forKey: .maxSampleCount)
        }
        if let minimumSamplingIntervalMs = self.minimumSamplingIntervalMs {
            try encodeContainer.encode(minimumSamplingIntervalMs, forKey: .minimumSamplingIntervalMs)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let maxSampleCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSampleCount)
        maxSampleCount = maxSampleCountDecoded
        let minimumSamplingIntervalMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumSamplingIntervalMs)
        minimumSamplingIntervalMs = minimumSamplingIntervalMsDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about a signal.
    public struct SignalInformation: Swift.Equatable {
        /// The maximum number of samples to collect.
        public var maxSampleCount: Swift.Int?
        /// The minimum duration of time (in milliseconds) between two triggering events to collect data. If a signal changes often, you might want to collect data at a slower rate.
        public var minimumSamplingIntervalMs: Swift.Int?
        /// The name of the signal.
        /// This member is required.
        public var name: Swift.String?

        public init (
            maxSampleCount: Swift.Int? = nil,
            minimumSamplingIntervalMs: Swift.Int? = nil,
            name: Swift.String? = nil
        )
        {
            self.maxSampleCount = maxSampleCount
            self.minimumSamplingIntervalMs = minimumSamplingIntervalMs
            self.name = name
        }
    }

}

extension IoTFleetWiseClientTypes {
    public enum SpoolingMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case off
        case toDisk
        case sdkUnknown(Swift.String)

        public static var allCases: [SpoolingMode] {
            return [
                .off,
                .toDisk,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .off: return "OFF"
            case .toDisk: return "TO_DISK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SpoolingMode(rawValue: rawValue) ?? SpoolingMode.sdkUnknown(rawValue)
        }
    }
}

extension IoTFleetWiseClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// A set of key/value pairs that are used to manage the resource.
    public struct Tag: Swift.Equatable {
        /// The tag's key.
        /// This member is required.
        public var key: Swift.String?
        /// The tag's value.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The new or modified tags for the resource.
    /// This member is required.
    public var tags: [IoTFleetWiseClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [IoTFleetWiseClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [IoTFleetWiseClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTFleetWiseClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTFleetWiseClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request couldn't be completed due to throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The quota identifier of the applied throttling rules for this request.
    public var quotaCode: Swift.String?
    /// The number of seconds to wait before retrying the command.
    public var retryAfterSeconds: Swift.Int
    /// The code for the service that couldn't be completed due to throttling.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.retryAfterSeconds = retryAfterSeconds
        self.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let quotaCode: Swift.String?
    let serviceCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension IoTFleetWiseClientTypes.TimeBasedCollectionScheme: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case periodMs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let periodMs = self.periodMs {
            try encodeContainer.encode(periodMs, forKey: .periodMs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let periodMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .periodMs)
        periodMs = periodMsDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about a collection scheme that uses a time period to decide how often to collect data.
    public struct TimeBasedCollectionScheme: Swift.Equatable {
        /// The time period (in milliseconds) to decide how often to collect data. For example, if the time period is 60000, the Edge Agent software collects data once every minute.
        /// This member is required.
        public var periodMs: Swift.Int?

        public init (
            periodMs: Swift.Int? = nil
        )
        {
            self.periodMs = periodMs
        }
    }

}

extension IoTFleetWiseClientTypes.TimestreamRegistrationResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorMessage
        case registrationStatus
        case timestreamDatabaseArn
        case timestreamDatabaseName
        case timestreamTableArn
        case timestreamTableName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let registrationStatus = self.registrationStatus {
            try encodeContainer.encode(registrationStatus.rawValue, forKey: .registrationStatus)
        }
        if let timestreamDatabaseArn = self.timestreamDatabaseArn {
            try encodeContainer.encode(timestreamDatabaseArn, forKey: .timestreamDatabaseArn)
        }
        if let timestreamDatabaseName = self.timestreamDatabaseName {
            try encodeContainer.encode(timestreamDatabaseName, forKey: .timestreamDatabaseName)
        }
        if let timestreamTableArn = self.timestreamTableArn {
            try encodeContainer.encode(timestreamTableArn, forKey: .timestreamTableArn)
        }
        if let timestreamTableName = self.timestreamTableName {
            try encodeContainer.encode(timestreamTableName, forKey: .timestreamTableName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestreamDatabaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestreamDatabaseName)
        timestreamDatabaseName = timestreamDatabaseNameDecoded
        let timestreamTableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestreamTableName)
        timestreamTableName = timestreamTableNameDecoded
        let timestreamDatabaseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestreamDatabaseArn)
        timestreamDatabaseArn = timestreamDatabaseArnDecoded
        let timestreamTableArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestreamTableArn)
        timestreamTableArn = timestreamTableArnDecoded
        let registrationStatusDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.RegistrationStatus.self, forKey: .registrationStatus)
        registrationStatus = registrationStatusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about the registered Amazon Timestream resources or errors, if any.
    public struct TimestreamRegistrationResponse: Swift.Equatable {
        /// A message associated with a registration error.
        public var errorMessage: Swift.String?
        /// The status of registering your Amazon Timestream resources. The status can be one of REGISTRATION_SUCCESS, REGISTRATION_PENDING, REGISTRATION_FAILURE.
        /// This member is required.
        public var registrationStatus: IoTFleetWiseClientTypes.RegistrationStatus?
        /// The Amazon Resource Name (ARN) of the Timestream database.
        public var timestreamDatabaseArn: Swift.String?
        /// The name of the Timestream database.
        /// This member is required.
        public var timestreamDatabaseName: Swift.String?
        /// The ARN of the Timestream database table.
        public var timestreamTableArn: Swift.String?
        /// The name of the Timestream database table.
        /// This member is required.
        public var timestreamTableName: Swift.String?

        public init (
            errorMessage: Swift.String? = nil,
            registrationStatus: IoTFleetWiseClientTypes.RegistrationStatus? = nil,
            timestreamDatabaseArn: Swift.String? = nil,
            timestreamDatabaseName: Swift.String? = nil,
            timestreamTableArn: Swift.String? = nil,
            timestreamTableName: Swift.String? = nil
        )
        {
            self.errorMessage = errorMessage
            self.registrationStatus = registrationStatus
            self.timestreamDatabaseArn = timestreamDatabaseArn
            self.timestreamDatabaseName = timestreamDatabaseName
            self.timestreamTableArn = timestreamTableArn
            self.timestreamTableName = timestreamTableName
        }
    }

}

extension IoTFleetWiseClientTypes.TimestreamResources: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timestreamDatabaseName
        case timestreamTableName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timestreamDatabaseName = self.timestreamDatabaseName {
            try encodeContainer.encode(timestreamDatabaseName, forKey: .timestreamDatabaseName)
        }
        if let timestreamTableName = self.timestreamTableName {
            try encodeContainer.encode(timestreamTableName, forKey: .timestreamTableName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestreamDatabaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestreamDatabaseName)
        timestreamDatabaseName = timestreamDatabaseNameDecoded
        let timestreamTableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestreamTableName)
        timestreamTableName = timestreamTableNameDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// The registered Amazon Timestream resources that Amazon Web Services IoT FleetWise edge agent software can transfer your vehicle data to.
    public struct TimestreamResources: Swift.Equatable {
        /// The name of the registered Amazon Timestream database.
        /// This member is required.
        public var timestreamDatabaseName: Swift.String?
        /// The name of the registered Amazon Timestream database table.
        /// This member is required.
        public var timestreamTableName: Swift.String?

        public init (
            timestreamDatabaseName: Swift.String? = nil,
            timestreamTableName: Swift.String? = nil
        )
        {
            self.timestreamDatabaseName = timestreamDatabaseName
            self.timestreamTableName = timestreamTableName
        }
    }

}

extension IoTFleetWiseClientTypes {
    public enum TriggerMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case always
        case risingEdge
        case sdkUnknown(Swift.String)

        public static var allCases: [TriggerMode] {
            return [
                .always,
                .risingEdge,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .always: return "ALWAYS"
            case .risingEdge: return "RISING_EDGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TriggerMode(rawValue: rawValue) ?? TriggerMode.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of the keys of the tags to be removed from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension IoTFleetWiseClientTypes {
    public enum UpdateCampaignAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approve
        case resume
        case suspend
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateCampaignAction] {
            return [
                .approve,
                .resume,
                .suspend,
                .update,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approve: return "APPROVE"
            case .resume: return "RESUME"
            case .suspend: return "SUSPEND"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateCampaignAction(rawValue: rawValue) ?? UpdateCampaignAction.sdkUnknown(rawValue)
        }
    }
}

extension UpdateCampaignInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case dataExtraDimensions
        case description
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let dataExtraDimensions = dataExtraDimensions {
            var dataExtraDimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataExtraDimensions)
            for nodepath0 in dataExtraDimensions {
                try dataExtraDimensionsContainer.encode(nodepath0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateCampaignInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateCampaignInput: Swift.Equatable {
    /// Specifies how to update a campaign. The action can be one of the following:
    ///
    /// * APPROVE - To approve delivering a data collection scheme to vehicles.
    ///
    /// * SUSPEND - To suspend collecting signal data.
    ///
    /// * RESUME - To resume collecting signal data.
    ///
    /// * UPDATE - To update a campaign.
    /// This member is required.
    public var action: IoTFleetWiseClientTypes.UpdateCampaignAction?
    /// A list of vehicle attributes to associate with a signal. Default: An empty array
    public var dataExtraDimensions: [Swift.String]?
    /// The description of the campaign.
    public var description: Swift.String?
    /// The name of the campaign to update.
    /// This member is required.
    public var name: Swift.String?

    public init (
        action: IoTFleetWiseClientTypes.UpdateCampaignAction? = nil,
        dataExtraDimensions: [Swift.String]? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.action = action
        self.dataExtraDimensions = dataExtraDimensions
        self.description = description
        self.name = name
    }
}

struct UpdateCampaignInputBody: Swift.Equatable {
    let description: Swift.String?
    let dataExtraDimensions: [Swift.String]?
    let action: IoTFleetWiseClientTypes.UpdateCampaignAction?
}

extension UpdateCampaignInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case dataExtraDimensions
        case description
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataExtraDimensionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dataExtraDimensions)
        var dataExtraDimensionsDecoded0:[Swift.String]? = nil
        if let dataExtraDimensionsContainer = dataExtraDimensionsContainer {
            dataExtraDimensionsDecoded0 = [Swift.String]()
            for string0 in dataExtraDimensionsContainer {
                if let string0 = string0 {
                    dataExtraDimensionsDecoded0?.append(string0)
                }
            }
        }
        dataExtraDimensions = dataExtraDimensionsDecoded0
        let actionDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.UpdateCampaignAction.self, forKey: .action)
        action = actionDecoded
    }
}

extension UpdateCampaignOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCampaignOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateCampaignOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCampaignOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateCampaignOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
            self.status = output.status
        } else {
            self.arn = nil
            self.name = nil
            self.status = nil
        }
    }
}

public struct UpdateCampaignOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the campaign.
    public var arn: Swift.String?
    /// The name of the updated campaign.
    public var name: Swift.String?
    /// The state of a campaign. The status can be one of:
    ///
    /// * CREATING - Amazon Web Services IoT FleetWise is processing your request to create the campaign.
    ///
    /// * WAITING_FOR_APPROVAL - After a campaign is created, it enters the WAITING_FOR_APPROVAL state. To allow Amazon Web Services IoT FleetWise to deploy the campaign to the target vehicle or fleet, use the API operation to approve the campaign.
    ///
    /// * RUNNING - The campaign is active.
    ///
    /// * SUSPENDED - The campaign is suspended. To resume the campaign, use the API operation.
    public var status: IoTFleetWiseClientTypes.CampaignStatus?

    public init (
        arn: Swift.String? = nil,
        name: Swift.String? = nil,
        status: IoTFleetWiseClientTypes.CampaignStatus? = nil
    )
    {
        self.arn = arn
        self.name = name
        self.status = status
    }
}

struct UpdateCampaignOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let status: IoTFleetWiseClientTypes.CampaignStatus?
}

extension UpdateCampaignOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.CampaignStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateDecoderManifestInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case networkInterfacesToAdd
        case networkInterfacesToRemove
        case networkInterfacesToUpdate
        case signalDecodersToAdd
        case signalDecodersToRemove
        case signalDecodersToUpdate
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let networkInterfacesToAdd = networkInterfacesToAdd {
            var networkInterfacesToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInterfacesToAdd)
            for networkinterface0 in networkInterfacesToAdd {
                try networkInterfacesToAddContainer.encode(networkinterface0)
            }
        }
        if let networkInterfacesToRemove = networkInterfacesToRemove {
            var networkInterfacesToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInterfacesToRemove)
            for interfaceid0 in networkInterfacesToRemove {
                try networkInterfacesToRemoveContainer.encode(interfaceid0)
            }
        }
        if let networkInterfacesToUpdate = networkInterfacesToUpdate {
            var networkInterfacesToUpdateContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInterfacesToUpdate)
            for networkinterface0 in networkInterfacesToUpdate {
                try networkInterfacesToUpdateContainer.encode(networkinterface0)
            }
        }
        if let signalDecodersToAdd = signalDecodersToAdd {
            var signalDecodersToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .signalDecodersToAdd)
            for signaldecoder0 in signalDecodersToAdd {
                try signalDecodersToAddContainer.encode(signaldecoder0)
            }
        }
        if let signalDecodersToRemove = signalDecodersToRemove {
            var signalDecodersToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .signalDecodersToRemove)
            for fullyqualifiedname0 in signalDecodersToRemove {
                try signalDecodersToRemoveContainer.encode(fullyqualifiedname0)
            }
        }
        if let signalDecodersToUpdate = signalDecodersToUpdate {
            var signalDecodersToUpdateContainer = encodeContainer.nestedUnkeyedContainer(forKey: .signalDecodersToUpdate)
            for signaldecoder0 in signalDecodersToUpdate {
                try signalDecodersToUpdateContainer.encode(signaldecoder0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateDecoderManifestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateDecoderManifestInput: Swift.Equatable {
    /// A brief description of the decoder manifest to update.
    public var description: Swift.String?
    /// The name of the decoder manifest to update.
    /// This member is required.
    public var name: Swift.String?
    /// A list of information about the network interfaces to add to the decoder manifest.
    public var networkInterfacesToAdd: [IoTFleetWiseClientTypes.NetworkInterface]?
    /// A list of network interfaces to remove from the decoder manifest.
    public var networkInterfacesToRemove: [Swift.String]?
    /// A list of information about the network interfaces to update in the decoder manifest.
    public var networkInterfacesToUpdate: [IoTFleetWiseClientTypes.NetworkInterface]?
    /// A list of information about decoding additional signals to add to the decoder manifest.
    public var signalDecodersToAdd: [IoTFleetWiseClientTypes.SignalDecoder]?
    /// A list of signal decoders to remove from the decoder manifest.
    public var signalDecodersToRemove: [Swift.String]?
    /// A list of updated information about decoding signals to update in the decoder manifest.
    public var signalDecodersToUpdate: [IoTFleetWiseClientTypes.SignalDecoder]?
    /// The state of the decoder manifest. If the status is ACTIVE, the decoder manifest can't be edited. If the status is DRAFT, you can edit the decoder manifest.
    public var status: IoTFleetWiseClientTypes.ManifestStatus?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        networkInterfacesToAdd: [IoTFleetWiseClientTypes.NetworkInterface]? = nil,
        networkInterfacesToRemove: [Swift.String]? = nil,
        networkInterfacesToUpdate: [IoTFleetWiseClientTypes.NetworkInterface]? = nil,
        signalDecodersToAdd: [IoTFleetWiseClientTypes.SignalDecoder]? = nil,
        signalDecodersToRemove: [Swift.String]? = nil,
        signalDecodersToUpdate: [IoTFleetWiseClientTypes.SignalDecoder]? = nil,
        status: IoTFleetWiseClientTypes.ManifestStatus? = nil
    )
    {
        self.description = description
        self.name = name
        self.networkInterfacesToAdd = networkInterfacesToAdd
        self.networkInterfacesToRemove = networkInterfacesToRemove
        self.networkInterfacesToUpdate = networkInterfacesToUpdate
        self.signalDecodersToAdd = signalDecodersToAdd
        self.signalDecodersToRemove = signalDecodersToRemove
        self.signalDecodersToUpdate = signalDecodersToUpdate
        self.status = status
    }
}

struct UpdateDecoderManifestInputBody: Swift.Equatable {
    let description: Swift.String?
    let signalDecodersToAdd: [IoTFleetWiseClientTypes.SignalDecoder]?
    let signalDecodersToUpdate: [IoTFleetWiseClientTypes.SignalDecoder]?
    let signalDecodersToRemove: [Swift.String]?
    let networkInterfacesToAdd: [IoTFleetWiseClientTypes.NetworkInterface]?
    let networkInterfacesToUpdate: [IoTFleetWiseClientTypes.NetworkInterface]?
    let networkInterfacesToRemove: [Swift.String]?
    let status: IoTFleetWiseClientTypes.ManifestStatus?
}

extension UpdateDecoderManifestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case networkInterfacesToAdd
        case networkInterfacesToRemove
        case networkInterfacesToUpdate
        case signalDecodersToAdd
        case signalDecodersToRemove
        case signalDecodersToUpdate
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let signalDecodersToAddContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.SignalDecoder?].self, forKey: .signalDecodersToAdd)
        var signalDecodersToAddDecoded0:[IoTFleetWiseClientTypes.SignalDecoder]? = nil
        if let signalDecodersToAddContainer = signalDecodersToAddContainer {
            signalDecodersToAddDecoded0 = [IoTFleetWiseClientTypes.SignalDecoder]()
            for structure0 in signalDecodersToAddContainer {
                if let structure0 = structure0 {
                    signalDecodersToAddDecoded0?.append(structure0)
                }
            }
        }
        signalDecodersToAdd = signalDecodersToAddDecoded0
        let signalDecodersToUpdateContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.SignalDecoder?].self, forKey: .signalDecodersToUpdate)
        var signalDecodersToUpdateDecoded0:[IoTFleetWiseClientTypes.SignalDecoder]? = nil
        if let signalDecodersToUpdateContainer = signalDecodersToUpdateContainer {
            signalDecodersToUpdateDecoded0 = [IoTFleetWiseClientTypes.SignalDecoder]()
            for structure0 in signalDecodersToUpdateContainer {
                if let structure0 = structure0 {
                    signalDecodersToUpdateDecoded0?.append(structure0)
                }
            }
        }
        signalDecodersToUpdate = signalDecodersToUpdateDecoded0
        let signalDecodersToRemoveContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .signalDecodersToRemove)
        var signalDecodersToRemoveDecoded0:[Swift.String]? = nil
        if let signalDecodersToRemoveContainer = signalDecodersToRemoveContainer {
            signalDecodersToRemoveDecoded0 = [Swift.String]()
            for string0 in signalDecodersToRemoveContainer {
                if let string0 = string0 {
                    signalDecodersToRemoveDecoded0?.append(string0)
                }
            }
        }
        signalDecodersToRemove = signalDecodersToRemoveDecoded0
        let networkInterfacesToAddContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.NetworkInterface?].self, forKey: .networkInterfacesToAdd)
        var networkInterfacesToAddDecoded0:[IoTFleetWiseClientTypes.NetworkInterface]? = nil
        if let networkInterfacesToAddContainer = networkInterfacesToAddContainer {
            networkInterfacesToAddDecoded0 = [IoTFleetWiseClientTypes.NetworkInterface]()
            for structure0 in networkInterfacesToAddContainer {
                if let structure0 = structure0 {
                    networkInterfacesToAddDecoded0?.append(structure0)
                }
            }
        }
        networkInterfacesToAdd = networkInterfacesToAddDecoded0
        let networkInterfacesToUpdateContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.NetworkInterface?].self, forKey: .networkInterfacesToUpdate)
        var networkInterfacesToUpdateDecoded0:[IoTFleetWiseClientTypes.NetworkInterface]? = nil
        if let networkInterfacesToUpdateContainer = networkInterfacesToUpdateContainer {
            networkInterfacesToUpdateDecoded0 = [IoTFleetWiseClientTypes.NetworkInterface]()
            for structure0 in networkInterfacesToUpdateContainer {
                if let structure0 = structure0 {
                    networkInterfacesToUpdateDecoded0?.append(structure0)
                }
            }
        }
        networkInterfacesToUpdate = networkInterfacesToUpdateDecoded0
        let networkInterfacesToRemoveContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .networkInterfacesToRemove)
        var networkInterfacesToRemoveDecoded0:[Swift.String]? = nil
        if let networkInterfacesToRemoveContainer = networkInterfacesToRemoveContainer {
            networkInterfacesToRemoveDecoded0 = [Swift.String]()
            for string0 in networkInterfacesToRemoveContainer {
                if let string0 = string0 {
                    networkInterfacesToRemoveDecoded0?.append(string0)
                }
            }
        }
        networkInterfacesToRemove = networkInterfacesToRemoveDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.ManifestStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateDecoderManifestOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDecoderManifestOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DecoderManifestValidationException" : self = .decoderManifestValidationException(try DecoderManifestValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDecoderManifestOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case decoderManifestValidationException(DecoderManifestValidationException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDecoderManifestOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateDecoderManifestOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct UpdateDecoderManifestOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the updated decoder manifest.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the updated decoder manifest.
    /// This member is required.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct UpdateDecoderManifestOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
}

extension UpdateDecoderManifestOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension UpdateFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateFleetInput: Swift.Equatable {
    /// An updated description of the fleet.
    public var description: Swift.String?
    /// The ID of the fleet to update.
    /// This member is required.
    public var fleetId: Swift.String?

    public init (
        description: Swift.String? = nil,
        fleetId: Swift.String? = nil
    )
    {
        self.description = description
        self.fleetId = fleetId
    }
}

struct UpdateFleetInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension UpdateFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateFleetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateFleetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct UpdateFleetOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the updated fleet.
    public var arn: Swift.String?
    /// The ID of the updated fleet.
    public var id: Swift.String?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct UpdateFleetOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
}

extension UpdateFleetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension IoTFleetWiseClientTypes {
    public enum UpdateMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case merge
        case overwrite
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateMode] {
            return [
                .merge,
                .overwrite,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .merge: return "Merge"
            case .overwrite: return "Overwrite"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateMode(rawValue: rawValue) ?? UpdateMode.sdkUnknown(rawValue)
        }
    }
}

extension UpdateModelManifestInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case nodesToAdd
        case nodesToRemove
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let nodesToAdd = nodesToAdd {
            var nodesToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodesToAdd)
            for nodepath0 in nodesToAdd {
                try nodesToAddContainer.encode(nodepath0)
            }
        }
        if let nodesToRemove = nodesToRemove {
            var nodesToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodesToRemove)
            for nodepath0 in nodesToRemove {
                try nodesToRemoveContainer.encode(nodepath0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateModelManifestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateModelManifestInput: Swift.Equatable {
    /// A brief description of the vehicle model.
    public var description: Swift.String?
    /// The name of the vehicle model to update.
    /// This member is required.
    public var name: Swift.String?
    /// A list of fullyQualifiedName of nodes, which are a general abstraction of signals, to add to the vehicle model.
    public var nodesToAdd: [Swift.String]?
    /// A list of fullyQualifiedName of nodes, which are a general abstraction of signals, to remove from the vehicle model.
    public var nodesToRemove: [Swift.String]?
    /// The state of the vehicle model. If the status is ACTIVE, the vehicle model can't be edited. If the status is DRAFT, you can edit the vehicle model.
    public var status: IoTFleetWiseClientTypes.ManifestStatus?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        nodesToAdd: [Swift.String]? = nil,
        nodesToRemove: [Swift.String]? = nil,
        status: IoTFleetWiseClientTypes.ManifestStatus? = nil
    )
    {
        self.description = description
        self.name = name
        self.nodesToAdd = nodesToAdd
        self.nodesToRemove = nodesToRemove
        self.status = status
    }
}

struct UpdateModelManifestInputBody: Swift.Equatable {
    let description: Swift.String?
    let nodesToAdd: [Swift.String]?
    let nodesToRemove: [Swift.String]?
    let status: IoTFleetWiseClientTypes.ManifestStatus?
}

extension UpdateModelManifestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case nodesToAdd
        case nodesToRemove
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nodesToAddContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .nodesToAdd)
        var nodesToAddDecoded0:[Swift.String]? = nil
        if let nodesToAddContainer = nodesToAddContainer {
            nodesToAddDecoded0 = [Swift.String]()
            for string0 in nodesToAddContainer {
                if let string0 = string0 {
                    nodesToAddDecoded0?.append(string0)
                }
            }
        }
        nodesToAdd = nodesToAddDecoded0
        let nodesToRemoveContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .nodesToRemove)
        var nodesToRemoveDecoded0:[Swift.String]? = nil
        if let nodesToRemoveContainer = nodesToRemoveContainer {
            nodesToRemoveDecoded0 = [Swift.String]()
            for string0 in nodesToRemoveContainer {
                if let string0 = string0 {
                    nodesToRemoveDecoded0?.append(string0)
                }
            }
        }
        nodesToRemove = nodesToRemoveDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.ManifestStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateModelManifestOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateModelManifestOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSignalsException" : self = .invalidSignalsException(try InvalidSignalsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateModelManifestOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case invalidSignalsException(InvalidSignalsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateModelManifestOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateModelManifestOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct UpdateModelManifestOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the updated vehicle model.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the updated vehicle model.
    /// This member is required.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct UpdateModelManifestOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
}

extension UpdateModelManifestOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension UpdateSignalCatalogInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case nodesToAdd
        case nodesToRemove
        case nodesToUpdate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let nodesToAdd = nodesToAdd {
            var nodesToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodesToAdd)
            for node0 in nodesToAdd {
                try nodesToAddContainer.encode(node0)
            }
        }
        if let nodesToRemove = nodesToRemove {
            var nodesToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodesToRemove)
            for nodepath0 in nodesToRemove {
                try nodesToRemoveContainer.encode(nodepath0)
            }
        }
        if let nodesToUpdate = nodesToUpdate {
            var nodesToUpdateContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodesToUpdate)
            for node0 in nodesToUpdate {
                try nodesToUpdateContainer.encode(node0)
            }
        }
    }
}

extension UpdateSignalCatalogInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateSignalCatalogInput: Swift.Equatable {
    /// A brief description of the signal catalog to update.
    public var description: Swift.String?
    /// The name of the signal catalog to update.
    /// This member is required.
    public var name: Swift.String?
    /// A list of information about nodes to add to the signal catalog.
    public var nodesToAdd: [IoTFleetWiseClientTypes.Node]?
    /// A list of fullyQualifiedName of nodes to remove from the signal catalog.
    public var nodesToRemove: [Swift.String]?
    /// A list of information about nodes to update in the signal catalog.
    public var nodesToUpdate: [IoTFleetWiseClientTypes.Node]?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        nodesToAdd: [IoTFleetWiseClientTypes.Node]? = nil,
        nodesToRemove: [Swift.String]? = nil,
        nodesToUpdate: [IoTFleetWiseClientTypes.Node]? = nil
    )
    {
        self.description = description
        self.name = name
        self.nodesToAdd = nodesToAdd
        self.nodesToRemove = nodesToRemove
        self.nodesToUpdate = nodesToUpdate
    }
}

struct UpdateSignalCatalogInputBody: Swift.Equatable {
    let description: Swift.String?
    let nodesToAdd: [IoTFleetWiseClientTypes.Node]?
    let nodesToUpdate: [IoTFleetWiseClientTypes.Node]?
    let nodesToRemove: [Swift.String]?
}

extension UpdateSignalCatalogInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case nodesToAdd
        case nodesToRemove
        case nodesToUpdate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nodesToAddContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.Node?].self, forKey: .nodesToAdd)
        var nodesToAddDecoded0:[IoTFleetWiseClientTypes.Node]? = nil
        if let nodesToAddContainer = nodesToAddContainer {
            nodesToAddDecoded0 = [IoTFleetWiseClientTypes.Node]()
            for union0 in nodesToAddContainer {
                if let union0 = union0 {
                    nodesToAddDecoded0?.append(union0)
                }
            }
        }
        nodesToAdd = nodesToAddDecoded0
        let nodesToUpdateContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.Node?].self, forKey: .nodesToUpdate)
        var nodesToUpdateDecoded0:[IoTFleetWiseClientTypes.Node]? = nil
        if let nodesToUpdateContainer = nodesToUpdateContainer {
            nodesToUpdateDecoded0 = [IoTFleetWiseClientTypes.Node]()
            for union0 in nodesToUpdateContainer {
                if let union0 = union0 {
                    nodesToUpdateDecoded0?.append(union0)
                }
            }
        }
        nodesToUpdate = nodesToUpdateDecoded0
        let nodesToRemoveContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .nodesToRemove)
        var nodesToRemoveDecoded0:[Swift.String]? = nil
        if let nodesToRemoveContainer = nodesToRemoveContainer {
            nodesToRemoveDecoded0 = [Swift.String]()
            for string0 in nodesToRemoveContainer {
                if let string0 = string0 {
                    nodesToRemoveDecoded0?.append(string0)
                }
            }
        }
        nodesToRemove = nodesToRemoveDecoded0
    }
}

extension UpdateSignalCatalogOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSignalCatalogOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNodeException" : self = .invalidNodeException(try InvalidNodeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSignalsException" : self = .invalidSignalsException(try InvalidSignalsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSignalCatalogOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case invalidNodeException(InvalidNodeException)
    case invalidSignalsException(InvalidSignalsException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSignalCatalogOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateSignalCatalogOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct UpdateSignalCatalogOutputResponse: Swift.Equatable {
    /// The ARN of the updated signal catalog.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the updated signal catalog.
    /// This member is required.
    public var name: Swift.String?

    public init (
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct UpdateSignalCatalogOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
}

extension UpdateSignalCatalogOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension IoTFleetWiseClientTypes.UpdateVehicleError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case vehicleName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if code != 0 {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let vehicleName = self.vehicleName {
            try encodeContainer.encode(vehicleName, forKey: .vehicleName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vehicleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vehicleName)
        vehicleName = vehicleNameDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .code) ?? 0
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// An HTTP error resulting from updating the description for a vehicle.
    public struct UpdateVehicleError: Swift.Equatable {
        /// The relevant HTTP error code (400+).
        public var code: Swift.Int
        /// A message associated with the error.
        public var message: Swift.String?
        /// The ID of the vehicle with the error.
        public var vehicleName: Swift.String?

        public init (
            code: Swift.Int = 0,
            message: Swift.String? = nil,
            vehicleName: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
            self.vehicleName = vehicleName
        }
    }

}

extension UpdateVehicleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeUpdateMode
        case attributes
        case decoderManifestArn
        case modelManifestArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeUpdateMode = self.attributeUpdateMode {
            try encodeContainer.encode(attributeUpdateMode.rawValue, forKey: .attributeUpdateMode)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributesMap0) in attributes {
                try attributesContainer.encode(attributesMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let decoderManifestArn = self.decoderManifestArn {
            try encodeContainer.encode(decoderManifestArn, forKey: .decoderManifestArn)
        }
        if let modelManifestArn = self.modelManifestArn {
            try encodeContainer.encode(modelManifestArn, forKey: .modelManifestArn)
        }
    }
}

extension UpdateVehicleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateVehicleInput: Swift.Equatable {
    /// The method the specified attributes will update the existing attributes on the vehicle. UseOverwite to replace the vehicle attributes with the specified attributes. Or use Merge to combine all attributes. This is required if attributes are present in the input.
    public var attributeUpdateMode: IoTFleetWiseClientTypes.UpdateMode?
    /// Static information about a vehicle in a key-value pair. For example: "engineType" : "1.3 L R2"
    public var attributes: [Swift.String:Swift.String]?
    /// The ARN of the decoder manifest associated with this vehicle.
    public var decoderManifestArn: Swift.String?
    /// The ARN of a vehicle model (model manifest) associated with the vehicle.
    public var modelManifestArn: Swift.String?
    /// The unique ID of the vehicle to update.
    /// This member is required.
    public var vehicleName: Swift.String?

    public init (
        attributeUpdateMode: IoTFleetWiseClientTypes.UpdateMode? = nil,
        attributes: [Swift.String:Swift.String]? = nil,
        decoderManifestArn: Swift.String? = nil,
        modelManifestArn: Swift.String? = nil,
        vehicleName: Swift.String? = nil
    )
    {
        self.attributeUpdateMode = attributeUpdateMode
        self.attributes = attributes
        self.decoderManifestArn = decoderManifestArn
        self.modelManifestArn = modelManifestArn
        self.vehicleName = vehicleName
    }
}

struct UpdateVehicleInputBody: Swift.Equatable {
    let modelManifestArn: Swift.String?
    let decoderManifestArn: Swift.String?
    let attributes: [Swift.String:Swift.String]?
    let attributeUpdateMode: IoTFleetWiseClientTypes.UpdateMode?
}

extension UpdateVehicleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeUpdateMode
        case attributes
        case decoderManifestArn
        case modelManifestArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelManifestArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelManifestArn)
        modelManifestArn = modelManifestArnDecoded
        let decoderManifestArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .decoderManifestArn)
        decoderManifestArn = decoderManifestArnDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let attributeUpdateModeDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.UpdateMode.self, forKey: .attributeUpdateMode)
        attributeUpdateMode = attributeUpdateModeDecoded
    }
}

extension UpdateVehicleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVehicleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateVehicleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVehicleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateVehicleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.vehicleName = output.vehicleName
        } else {
            self.arn = nil
            self.vehicleName = nil
        }
    }
}

public struct UpdateVehicleOutputResponse: Swift.Equatable {
    /// The ARN of the updated vehicle.
    public var arn: Swift.String?
    /// The ID of the updated vehicle.
    public var vehicleName: Swift.String?

    public init (
        arn: Swift.String? = nil,
        vehicleName: Swift.String? = nil
    )
    {
        self.arn = arn
        self.vehicleName = vehicleName
    }
}

struct UpdateVehicleOutputResponseBody: Swift.Equatable {
    let vehicleName: Swift.String?
    let arn: Swift.String?
}

extension UpdateVehicleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case vehicleName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vehicleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vehicleName)
        vehicleName = vehicleNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension IoTFleetWiseClientTypes.UpdateVehicleRequestItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeUpdateMode
        case attributes
        case decoderManifestArn
        case modelManifestArn
        case vehicleName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeUpdateMode = self.attributeUpdateMode {
            try encodeContainer.encode(attributeUpdateMode.rawValue, forKey: .attributeUpdateMode)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributesMap0) in attributes {
                try attributesContainer.encode(attributesMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let decoderManifestArn = self.decoderManifestArn {
            try encodeContainer.encode(decoderManifestArn, forKey: .decoderManifestArn)
        }
        if let modelManifestArn = self.modelManifestArn {
            try encodeContainer.encode(modelManifestArn, forKey: .modelManifestArn)
        }
        if let vehicleName = self.vehicleName {
            try encodeContainer.encode(vehicleName, forKey: .vehicleName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vehicleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vehicleName)
        vehicleName = vehicleNameDecoded
        let modelManifestArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelManifestArn)
        modelManifestArn = modelManifestArnDecoded
        let decoderManifestArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .decoderManifestArn)
        decoderManifestArn = decoderManifestArnDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let attributeUpdateModeDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.UpdateMode.self, forKey: .attributeUpdateMode)
        attributeUpdateMode = attributeUpdateModeDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about the vehicle to update.
    public struct UpdateVehicleRequestItem: Swift.Equatable {
        /// The method the specified attributes will update the existing attributes on the vehicle. UseOverwite to replace the vehicle attributes with the specified attributes. Or use Merge to combine all attributes. This is required if attributes are present in the input.
        public var attributeUpdateMode: IoTFleetWiseClientTypes.UpdateMode?
        /// Static information about a vehicle in a key-value pair. For example: "engineType" : "1.3 L R2"
        public var attributes: [Swift.String:Swift.String]?
        /// The ARN of the signal decoder manifest associated with the vehicle to update.
        public var decoderManifestArn: Swift.String?
        /// The ARN of the vehicle model (model manifest) associated with the vehicle to update.
        public var modelManifestArn: Swift.String?
        /// The unique ID of the vehicle to update.
        /// This member is required.
        public var vehicleName: Swift.String?

        public init (
            attributeUpdateMode: IoTFleetWiseClientTypes.UpdateMode? = nil,
            attributes: [Swift.String:Swift.String]? = nil,
            decoderManifestArn: Swift.String? = nil,
            modelManifestArn: Swift.String? = nil,
            vehicleName: Swift.String? = nil
        )
        {
            self.attributeUpdateMode = attributeUpdateMode
            self.attributes = attributes
            self.decoderManifestArn = decoderManifestArn
            self.modelManifestArn = modelManifestArn
            self.vehicleName = vehicleName
        }
    }

}

extension IoTFleetWiseClientTypes.UpdateVehicleResponseItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case vehicleName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let vehicleName = self.vehicleName {
            try encodeContainer.encode(vehicleName, forKey: .vehicleName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vehicleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vehicleName)
        vehicleName = vehicleNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about the updated vehicle.
    public struct UpdateVehicleResponseItem: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the updated vehicle.
        public var arn: Swift.String?
        /// The unique ID of the updated vehicle.
        public var vehicleName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            vehicleName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.vehicleName = vehicleName
        }
    }

}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.fieldList = output.fieldList
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fieldList = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input fails to satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The list of fields that fail to satisfy the constraints specified by an Amazon Web Services service.
    public var fieldList: [IoTFleetWiseClientTypes.ValidationExceptionField]?
    /// This member is required.
    public var message: Swift.String?
    /// The reason the input failed to satisfy the constraints specified by an Amazon Web Services service.
    public var reason: IoTFleetWiseClientTypes.ValidationExceptionReason?

    public init (
        fieldList: [IoTFleetWiseClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: IoTFleetWiseClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.fieldList = fieldList
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: IoTFleetWiseClientTypes.ValidationExceptionReason?
    let fieldList: [IoTFleetWiseClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList
        case message
        case reason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[IoTFleetWiseClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [IoTFleetWiseClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension IoTFleetWiseClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// A validation error due to mismatch between the expected data type, length, or pattern of the parameter and the input.
    public struct ValidationExceptionField: Swift.Equatable {
        /// A message about the validation error.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the parameter field with the validation error.
        /// This member is required.
        public var name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension IoTFleetWiseClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension IoTFleetWiseClientTypes {
    public enum VehicleAssociationBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createIotThing
        case validateIotThingExists
        case sdkUnknown(Swift.String)

        public static var allCases: [VehicleAssociationBehavior] {
            return [
                .createIotThing,
                .validateIotThingExists,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createIotThing: return "CreateIotThing"
            case .validateIotThingExists: return "ValidateIotThingExists"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VehicleAssociationBehavior(rawValue: rawValue) ?? VehicleAssociationBehavior.sdkUnknown(rawValue)
        }
    }
}

extension IoTFleetWiseClientTypes {
    public enum VehicleState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case deleting
        case healthy
        case ready
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [VehicleState] {
            return [
                .created,
                .deleting,
                .healthy,
                .ready,
                .suspended,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .deleting: return "DELETING"
            case .healthy: return "HEALTHY"
            case .ready: return "READY"
            case .suspended: return "SUSPENDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VehicleState(rawValue: rawValue) ?? VehicleState.sdkUnknown(rawValue)
        }
    }
}

extension IoTFleetWiseClientTypes.VehicleStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignName
        case status
        case vehicleName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignName = self.campaignName {
            try encodeContainer.encode(campaignName, forKey: .campaignName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let vehicleName = self.vehicleName {
            try encodeContainer.encode(vehicleName, forKey: .vehicleName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .campaignName)
        campaignName = campaignNameDecoded
        let vehicleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vehicleName)
        vehicleName = vehicleNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.VehicleState.self, forKey: .status)
        status = statusDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about the state of a vehicle and how it relates to the status of a campaign.
    public struct VehicleStatus: Swift.Equatable {
        /// The name of a campaign.
        public var campaignName: Swift.String?
        /// The state of a vehicle, which can be one of the following:
        ///
        /// * CREATED - Amazon Web Services IoT FleetWise sucessfully created the vehicle.
        ///
        /// * READY - The vehicle is ready to receive a campaign deployment.
        ///
        /// * HEALTHY - A campaign deployment was delivered to the vehicle.
        ///
        /// * SUSPENDED - A campaign associated with the vehicle was suspended and data collection was paused.
        ///
        /// * DELETING - Amazon Web Services IoT FleetWise is removing a campaign from the vehicle.
        public var status: IoTFleetWiseClientTypes.VehicleState?
        /// The unique ID of the vehicle.
        public var vehicleName: Swift.String?

        public init (
            campaignName: Swift.String? = nil,
            status: IoTFleetWiseClientTypes.VehicleState? = nil,
            vehicleName: Swift.String? = nil
        )
        {
            self.campaignName = campaignName
            self.status = status
            self.vehicleName = vehicleName
        }
    }

}

extension IoTFleetWiseClientTypes.VehicleSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case decoderManifestArn
        case lastModificationTime
        case modelManifestArn
        case vehicleName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let decoderManifestArn = self.decoderManifestArn {
            try encodeContainer.encode(decoderManifestArn, forKey: .decoderManifestArn)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let modelManifestArn = self.modelManifestArn {
            try encodeContainer.encode(modelManifestArn, forKey: .modelManifestArn)
        }
        if let vehicleName = self.vehicleName {
            try encodeContainer.encode(vehicleName, forKey: .vehicleName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vehicleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vehicleName)
        vehicleName = vehicleNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let modelManifestArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelManifestArn)
        modelManifestArn = modelManifestArnDecoded
        let decoderManifestArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .decoderManifestArn)
        decoderManifestArn = decoderManifestArnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about a vehicle. To return this information about vehicles in your account, you can use the API operation.
    public struct VehicleSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the vehicle.
        /// This member is required.
        public var arn: Swift.String?
        /// The time the vehicle was created in seconds since epoch (January 1, 1970 at midnight UTC time).
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The ARN of a decoder manifest associated with the vehicle.
        /// This member is required.
        public var decoderManifestArn: Swift.String?
        /// The time the vehicle was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).
        /// This member is required.
        public var lastModificationTime: ClientRuntime.Date?
        /// The ARN of a vehicle model (model manifest) associated with the vehicle.
        /// This member is required.
        public var modelManifestArn: Swift.String?
        /// The unique ID of the vehicle.
        /// This member is required.
        public var vehicleName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            decoderManifestArn: Swift.String? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            modelManifestArn: Swift.String? = nil,
            vehicleName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.decoderManifestArn = decoderManifestArn
            self.lastModificationTime = lastModificationTime
            self.modelManifestArn = modelManifestArn
            self.vehicleName = vehicleName
        }
    }

}
