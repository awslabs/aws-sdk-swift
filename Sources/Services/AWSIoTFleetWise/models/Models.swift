// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You don't have sufficient permission to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTFleetWiseClientTypes.Actuator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedValues
        case assignedValue
        case comment
        case dataType
        case deprecationMessage
        case description
        case fullyQualifiedName
        case max
        case min
        case unit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedValues = allowedValues {
            var allowedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedValues)
            for string0 in allowedValues {
                try allowedValuesContainer.encode(string0)
            }
        }
        if let assignedValue = self.assignedValue {
            try encodeContainer.encode(assignedValue, forKey: .assignedValue)
        }
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let deprecationMessage = self.deprecationMessage {
            try encodeContainer.encode(deprecationMessage, forKey: .deprecationMessage)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let fullyQualifiedName = self.fullyQualifiedName {
            try encodeContainer.encode(fullyQualifiedName, forKey: .fullyQualifiedName)
        }
        if let max = self.max {
            try encodeContainer.encode(max, forKey: .max)
        }
        if let min = self.min {
            try encodeContainer.encode(min, forKey: .min)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fullyQualifiedNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fullyQualifiedName)
        fullyQualifiedName = fullyQualifiedNameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.NodeDataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let allowedValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowedValues)
        var allowedValuesDecoded0:[Swift.String]? = nil
        if let allowedValuesContainer = allowedValuesContainer {
            allowedValuesDecoded0 = [Swift.String]()
            for string0 in allowedValuesContainer {
                if let string0 = string0 {
                    allowedValuesDecoded0?.append(string0)
                }
            }
        }
        allowedValues = allowedValuesDecoded0
        let minDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .min)
        min = minDecoded
        let maxDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .max)
        max = maxDecoded
        let assignedValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assignedValue)
        assignedValue = assignedValueDecoded
        let deprecationMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deprecationMessage)
        deprecationMessage = deprecationMessageDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// A signal that represents a vehicle device such as the engine, heater, and door locks. Data from an actuator reports the state of a certain vehicle device. Updating actuator data can change the state of a device. For example, you can turn on or off the heater by updating its actuator data.
    public struct Actuator: Swift.Equatable {
        /// A list of possible values an actuator can take.
        public var allowedValues: [Swift.String]?
        /// A specified value for the actuator.
        @available(*, deprecated, message: "assignedValue is no longer in use")
        public var assignedValue: Swift.String?
        /// A comment in addition to the description.
        public var comment: Swift.String?
        /// The specified data type of the actuator.
        /// This member is required.
        public var dataType: IoTFleetWiseClientTypes.NodeDataType?
        /// The deprecation message for the node or the branch that was moved or deleted.
        public var deprecationMessage: Swift.String?
        /// A brief description of the actuator.
        public var description: Swift.String?
        /// The fully qualified name of the actuator. For example, the fully qualified name of an actuator might be Vehicle.Front.Left.Door.Lock.
        /// This member is required.
        public var fullyQualifiedName: Swift.String?
        /// The specified possible maximum value of an actuator.
        public var max: Swift.Double?
        /// The specified possible minimum value of an actuator.
        public var min: Swift.Double?
        /// The scientific unit for the actuator.
        public var unit: Swift.String?

        public init(
            allowedValues: [Swift.String]? = nil,
            assignedValue: Swift.String? = nil,
            comment: Swift.String? = nil,
            dataType: IoTFleetWiseClientTypes.NodeDataType? = nil,
            deprecationMessage: Swift.String? = nil,
            description: Swift.String? = nil,
            fullyQualifiedName: Swift.String? = nil,
            max: Swift.Double? = nil,
            min: Swift.Double? = nil,
            unit: Swift.String? = nil
        )
        {
            self.allowedValues = allowedValues
            self.assignedValue = assignedValue
            self.comment = comment
            self.dataType = dataType
            self.deprecationMessage = deprecationMessage
            self.description = description
            self.fullyQualifiedName = fullyQualifiedName
            self.max = max
            self.min = min
            self.unit = unit
        }
    }

}

extension AssociateVehicleFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetId = self.fleetId {
            try encodeContainer.encode(fleetId, forKey: .fleetId)
        }
    }
}

extension AssociateVehicleFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateVehicleFleetInput: Swift.Equatable {
    /// The ID of a fleet.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The unique ID of the vehicle to associate with the fleet.
    /// This member is required.
    public var vehicleName: Swift.String?

    public init(
        fleetId: Swift.String? = nil,
        vehicleName: Swift.String? = nil
    )
    {
        self.fleetId = fleetId
        self.vehicleName = vehicleName
    }
}

struct AssociateVehicleFleetInputBody: Swift.Equatable {
    let fleetId: Swift.String?
}

extension AssociateVehicleFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetId)
        fleetId = fleetIdDecoded
    }
}

extension AssociateVehicleFleetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateVehicleFleetOutput: Swift.Equatable {

    public init() { }
}

enum AssociateVehicleFleetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTFleetWiseClientTypes.Attribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedValues
        case assignedValue
        case comment
        case dataType
        case defaultValue
        case deprecationMessage
        case description
        case fullyQualifiedName
        case max
        case min
        case unit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedValues = allowedValues {
            var allowedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedValues)
            for string0 in allowedValues {
                try allowedValuesContainer.encode(string0)
            }
        }
        if let assignedValue = self.assignedValue {
            try encodeContainer.encode(assignedValue, forKey: .assignedValue)
        }
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let deprecationMessage = self.deprecationMessage {
            try encodeContainer.encode(deprecationMessage, forKey: .deprecationMessage)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let fullyQualifiedName = self.fullyQualifiedName {
            try encodeContainer.encode(fullyQualifiedName, forKey: .fullyQualifiedName)
        }
        if let max = self.max {
            try encodeContainer.encode(max, forKey: .max)
        }
        if let min = self.min {
            try encodeContainer.encode(min, forKey: .min)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fullyQualifiedNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fullyQualifiedName)
        fullyQualifiedName = fullyQualifiedNameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.NodeDataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let allowedValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowedValues)
        var allowedValuesDecoded0:[Swift.String]? = nil
        if let allowedValuesContainer = allowedValuesContainer {
            allowedValuesDecoded0 = [Swift.String]()
            for string0 in allowedValuesContainer {
                if let string0 = string0 {
                    allowedValuesDecoded0?.append(string0)
                }
            }
        }
        allowedValues = allowedValuesDecoded0
        let minDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .min)
        min = minDecoded
        let maxDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .max)
        max = maxDecoded
        let assignedValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assignedValue)
        assignedValue = assignedValueDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let deprecationMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deprecationMessage)
        deprecationMessage = deprecationMessageDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// A signal that represents static information about the vehicle, such as engine type or manufacturing date.
    public struct Attribute: Swift.Equatable {
        /// A list of possible values an attribute can be assigned.
        public var allowedValues: [Swift.String]?
        /// A specified value for the attribute.
        @available(*, deprecated, message: "assignedValue is no longer in use")
        public var assignedValue: Swift.String?
        /// A comment in addition to the description.
        public var comment: Swift.String?
        /// The specified data type of the attribute.
        /// This member is required.
        public var dataType: IoTFleetWiseClientTypes.NodeDataType?
        /// The default value of the attribute.
        public var defaultValue: Swift.String?
        /// The deprecation message for the node or the branch that was moved or deleted.
        public var deprecationMessage: Swift.String?
        /// A brief description of the attribute.
        public var description: Swift.String?
        /// The fully qualified name of the attribute. For example, the fully qualified name of an attribute might be Vehicle.Body.Engine.Type.
        /// This member is required.
        public var fullyQualifiedName: Swift.String?
        /// The specified possible maximum value of the attribute.
        public var max: Swift.Double?
        /// The specified possible minimum value of the attribute.
        public var min: Swift.Double?
        /// The scientific unit for the attribute.
        public var unit: Swift.String?

        public init(
            allowedValues: [Swift.String]? = nil,
            assignedValue: Swift.String? = nil,
            comment: Swift.String? = nil,
            dataType: IoTFleetWiseClientTypes.NodeDataType? = nil,
            defaultValue: Swift.String? = nil,
            deprecationMessage: Swift.String? = nil,
            description: Swift.String? = nil,
            fullyQualifiedName: Swift.String? = nil,
            max: Swift.Double? = nil,
            min: Swift.Double? = nil,
            unit: Swift.String? = nil
        )
        {
            self.allowedValues = allowedValues
            self.assignedValue = assignedValue
            self.comment = comment
            self.dataType = dataType
            self.defaultValue = defaultValue
            self.deprecationMessage = deprecationMessage
            self.description = description
            self.fullyQualifiedName = fullyQualifiedName
            self.max = max
            self.min = min
            self.unit = unit
        }
    }

}

extension BatchCreateVehicleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vehicles
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vehicles = vehicles {
            var vehiclesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vehicles)
            for createvehiclerequestitem0 in vehicles {
                try vehiclesContainer.encode(createvehiclerequestitem0)
            }
        }
    }
}

extension BatchCreateVehicleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchCreateVehicleInput: Swift.Equatable {
    /// A list of information about each vehicle to create. For more information, see the API data type.
    /// This member is required.
    public var vehicles: [IoTFleetWiseClientTypes.CreateVehicleRequestItem]?

    public init(
        vehicles: [IoTFleetWiseClientTypes.CreateVehicleRequestItem]? = nil
    )
    {
        self.vehicles = vehicles
    }
}

struct BatchCreateVehicleInputBody: Swift.Equatable {
    let vehicles: [IoTFleetWiseClientTypes.CreateVehicleRequestItem]?
}

extension BatchCreateVehicleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vehicles
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vehiclesContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.CreateVehicleRequestItem?].self, forKey: .vehicles)
        var vehiclesDecoded0:[IoTFleetWiseClientTypes.CreateVehicleRequestItem]? = nil
        if let vehiclesContainer = vehiclesContainer {
            vehiclesDecoded0 = [IoTFleetWiseClientTypes.CreateVehicleRequestItem]()
            for structure0 in vehiclesContainer {
                if let structure0 = structure0 {
                    vehiclesDecoded0?.append(structure0)
                }
            }
        }
        vehicles = vehiclesDecoded0
    }
}

extension BatchCreateVehicleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchCreateVehicleOutputBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
            self.vehicles = output.vehicles
        } else {
            self.errors = nil
            self.vehicles = nil
        }
    }
}

public struct BatchCreateVehicleOutput: Swift.Equatable {
    /// A list of information about creation errors, or an empty list if there aren't any errors.
    public var errors: [IoTFleetWiseClientTypes.CreateVehicleError]?
    /// A list of information about a batch of created vehicles. For more information, see the API data type.
    public var vehicles: [IoTFleetWiseClientTypes.CreateVehicleResponseItem]?

    public init(
        errors: [IoTFleetWiseClientTypes.CreateVehicleError]? = nil,
        vehicles: [IoTFleetWiseClientTypes.CreateVehicleResponseItem]? = nil
    )
    {
        self.errors = errors
        self.vehicles = vehicles
    }
}

struct BatchCreateVehicleOutputBody: Swift.Equatable {
    let vehicles: [IoTFleetWiseClientTypes.CreateVehicleResponseItem]?
    let errors: [IoTFleetWiseClientTypes.CreateVehicleError]?
}

extension BatchCreateVehicleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
        case vehicles
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vehiclesContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.CreateVehicleResponseItem?].self, forKey: .vehicles)
        var vehiclesDecoded0:[IoTFleetWiseClientTypes.CreateVehicleResponseItem]? = nil
        if let vehiclesContainer = vehiclesContainer {
            vehiclesDecoded0 = [IoTFleetWiseClientTypes.CreateVehicleResponseItem]()
            for structure0 in vehiclesContainer {
                if let structure0 = structure0 {
                    vehiclesDecoded0?.append(structure0)
                }
            }
        }
        vehicles = vehiclesDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.CreateVehicleError?].self, forKey: .errors)
        var errorsDecoded0:[IoTFleetWiseClientTypes.CreateVehicleError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [IoTFleetWiseClientTypes.CreateVehicleError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchCreateVehicleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchUpdateVehicleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vehicles
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vehicles = vehicles {
            var vehiclesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vehicles)
            for updatevehiclerequestitem0 in vehicles {
                try vehiclesContainer.encode(updatevehiclerequestitem0)
            }
        }
    }
}

extension BatchUpdateVehicleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchUpdateVehicleInput: Swift.Equatable {
    /// A list of information about the vehicles to update. For more information, see the API data type.
    /// This member is required.
    public var vehicles: [IoTFleetWiseClientTypes.UpdateVehicleRequestItem]?

    public init(
        vehicles: [IoTFleetWiseClientTypes.UpdateVehicleRequestItem]? = nil
    )
    {
        self.vehicles = vehicles
    }
}

struct BatchUpdateVehicleInputBody: Swift.Equatable {
    let vehicles: [IoTFleetWiseClientTypes.UpdateVehicleRequestItem]?
}

extension BatchUpdateVehicleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vehicles
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vehiclesContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.UpdateVehicleRequestItem?].self, forKey: .vehicles)
        var vehiclesDecoded0:[IoTFleetWiseClientTypes.UpdateVehicleRequestItem]? = nil
        if let vehiclesContainer = vehiclesContainer {
            vehiclesDecoded0 = [IoTFleetWiseClientTypes.UpdateVehicleRequestItem]()
            for structure0 in vehiclesContainer {
                if let structure0 = structure0 {
                    vehiclesDecoded0?.append(structure0)
                }
            }
        }
        vehicles = vehiclesDecoded0
    }
}

extension BatchUpdateVehicleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchUpdateVehicleOutputBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
            self.vehicles = output.vehicles
        } else {
            self.errors = nil
            self.vehicles = nil
        }
    }
}

public struct BatchUpdateVehicleOutput: Swift.Equatable {
    /// A list of information about errors returned while updating a batch of vehicles, or, if there aren't any errors, an empty list.
    public var errors: [IoTFleetWiseClientTypes.UpdateVehicleError]?
    /// A list of information about the batch of updated vehicles. This list contains only unique IDs for the vehicles that were updated.
    public var vehicles: [IoTFleetWiseClientTypes.UpdateVehicleResponseItem]?

    public init(
        errors: [IoTFleetWiseClientTypes.UpdateVehicleError]? = nil,
        vehicles: [IoTFleetWiseClientTypes.UpdateVehicleResponseItem]? = nil
    )
    {
        self.errors = errors
        self.vehicles = vehicles
    }
}

struct BatchUpdateVehicleOutputBody: Swift.Equatable {
    let vehicles: [IoTFleetWiseClientTypes.UpdateVehicleResponseItem]?
    let errors: [IoTFleetWiseClientTypes.UpdateVehicleError]?
}

extension BatchUpdateVehicleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
        case vehicles
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vehiclesContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.UpdateVehicleResponseItem?].self, forKey: .vehicles)
        var vehiclesDecoded0:[IoTFleetWiseClientTypes.UpdateVehicleResponseItem]? = nil
        if let vehiclesContainer = vehiclesContainer {
            vehiclesDecoded0 = [IoTFleetWiseClientTypes.UpdateVehicleResponseItem]()
            for structure0 in vehiclesContainer {
                if let structure0 = structure0 {
                    vehiclesDecoded0?.append(structure0)
                }
            }
        }
        vehicles = vehiclesDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.UpdateVehicleError?].self, forKey: .errors)
        var errorsDecoded0:[IoTFleetWiseClientTypes.UpdateVehicleError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [IoTFleetWiseClientTypes.UpdateVehicleError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchUpdateVehicleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTFleetWiseClientTypes.Branch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
        case deprecationMessage
        case description
        case fullyQualifiedName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let deprecationMessage = self.deprecationMessage {
            try encodeContainer.encode(deprecationMessage, forKey: .deprecationMessage)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let fullyQualifiedName = self.fullyQualifiedName {
            try encodeContainer.encode(fullyQualifiedName, forKey: .fullyQualifiedName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fullyQualifiedNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fullyQualifiedName)
        fullyQualifiedName = fullyQualifiedNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let deprecationMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deprecationMessage)
        deprecationMessage = deprecationMessageDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// A group of signals that are defined in a hierarchical structure.
    public struct Branch: Swift.Equatable {
        /// A comment in addition to the description.
        public var comment: Swift.String?
        /// The deprecation message for the node or the branch that was moved or deleted.
        public var deprecationMessage: Swift.String?
        /// A brief description of the branch.
        public var description: Swift.String?
        /// The fully qualified name of the branch. For example, the fully qualified name of a branch might be Vehicle.Body.Engine.
        /// This member is required.
        public var fullyQualifiedName: Swift.String?

        public init(
            comment: Swift.String? = nil,
            deprecationMessage: Swift.String? = nil,
            description: Swift.String? = nil,
            fullyQualifiedName: Swift.String? = nil
        )
        {
            self.comment = comment
            self.deprecationMessage = deprecationMessage
            self.description = description
            self.fullyQualifiedName = fullyQualifiedName
        }
    }

}

extension IoTFleetWiseClientTypes {
    public enum CampaignStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creating
        case running
        case suspended
        case waitingForApproval
        case sdkUnknown(Swift.String)

        public static var allCases: [CampaignStatus] {
            return [
                .creating,
                .running,
                .suspended,
                .waitingForApproval,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .running: return "RUNNING"
            case .suspended: return "SUSPENDED"
            case .waitingForApproval: return "WAITING_FOR_APPROVAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CampaignStatus(rawValue: rawValue) ?? CampaignStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTFleetWiseClientTypes.CampaignSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case lastModificationTime
        case name
        case signalCatalogArn
        case status
        case targetArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let signalCatalogArn = self.signalCatalogArn {
            try encodeContainer.encode(signalCatalogArn, forKey: .signalCatalogArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targetArn = self.targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let signalCatalogArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signalCatalogArn)
        signalCatalogArn = signalCatalogArnDecoded
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.CampaignStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about a campaign. You can use the API operation to return this information about multiple created campaigns.
    public struct CampaignSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of a campaign.
        public var arn: Swift.String?
        /// The time the campaign was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The description of the campaign.
        public var description: Swift.String?
        /// The last time the campaign was modified.
        /// This member is required.
        public var lastModificationTime: ClientRuntime.Date?
        /// The name of a campaign.
        public var name: Swift.String?
        /// The ARN of the signal catalog associated with the campaign.
        public var signalCatalogArn: Swift.String?
        /// The state of a campaign. The status can be one of the following:
        ///
        /// * CREATING - Amazon Web Services IoT FleetWise is processing your request to create the campaign.
        ///
        /// * WAITING_FOR_APPROVAL - After a campaign is created, it enters the WAITING_FOR_APPROVAL state. To allow Amazon Web Services IoT FleetWise to deploy the campaign to the target vehicle or fleet, use the API operation to approve the campaign.
        ///
        /// * RUNNING - The campaign is active.
        ///
        /// * SUSPENDED - The campaign is suspended. To resume the campaign, use the API operation.
        public var status: IoTFleetWiseClientTypes.CampaignStatus?
        /// The ARN of a vehicle or fleet to which the campaign is deployed.
        public var targetArn: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            signalCatalogArn: Swift.String? = nil,
            status: IoTFleetWiseClientTypes.CampaignStatus? = nil,
            targetArn: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.lastModificationTime = lastModificationTime
            self.name = name
            self.signalCatalogArn = signalCatalogArn
            self.status = status
            self.targetArn = targetArn
        }
    }

}

extension IoTFleetWiseClientTypes.CanDbcDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canDbcFiles
        case networkInterface
        case signalsMap
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let canDbcFiles = canDbcFiles {
            var canDbcFilesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .canDbcFiles)
            for networkfileblob0 in canDbcFiles {
                try canDbcFilesContainer.encode(networkfileblob0.base64EncodedString())
            }
        }
        if let networkInterface = self.networkInterface {
            try encodeContainer.encode(networkInterface, forKey: .networkInterface)
        }
        if let signalsMap = signalsMap {
            var signalsMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .signalsMap)
            for (dictKey0, modelSignalsMap0) in signalsMap {
                try signalsMapContainer.encode(modelSignalsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkInterfaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterface)
        networkInterface = networkInterfaceDecoded
        let canDbcFilesContainer = try containerValues.decodeIfPresent([ClientRuntime.Data?].self, forKey: .canDbcFiles)
        var canDbcFilesDecoded0:[ClientRuntime.Data]? = nil
        if let canDbcFilesContainer = canDbcFilesContainer {
            canDbcFilesDecoded0 = [ClientRuntime.Data]()
            for blob0 in canDbcFilesContainer {
                if let blob0 = blob0 {
                    canDbcFilesDecoded0?.append(blob0)
                }
            }
        }
        canDbcFiles = canDbcFilesDecoded0
        let signalsMapContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .signalsMap)
        var signalsMapDecoded0: [Swift.String:Swift.String]? = nil
        if let signalsMapContainer = signalsMapContainer {
            signalsMapDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in signalsMapContainer {
                if let string0 = string0 {
                    signalsMapDecoded0?[key0] = string0
                }
            }
        }
        signalsMap = signalsMapDecoded0
    }
}

extension IoTFleetWiseClientTypes {
    /// Configurations used to create a decoder manifest.
    public struct CanDbcDefinition: Swift.Equatable {
        /// A list of DBC files. You can upload only one DBC file for each network interface and specify up to five (inclusive) files in the list.
        /// This member is required.
        public var canDbcFiles: [ClientRuntime.Data]?
        /// Contains information about a network interface.
        /// This member is required.
        public var networkInterface: Swift.String?
        /// Pairs every signal specified in your vehicle model with a signal decoder.
        public var signalsMap: [Swift.String:Swift.String]?

        public init(
            canDbcFiles: [ClientRuntime.Data]? = nil,
            networkInterface: Swift.String? = nil,
            signalsMap: [Swift.String:Swift.String]? = nil
        )
        {
            self.canDbcFiles = canDbcFiles
            self.networkInterface = networkInterface
            self.signalsMap = signalsMap
        }
    }

}

extension IoTFleetWiseClientTypes.CanInterface: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case protocolName
        case protocolVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let protocolName = self.protocolName {
            try encodeContainer.encode(protocolName, forKey: .protocolName)
        }
        if let protocolVersion = self.protocolVersion {
            try encodeContainer.encode(protocolVersion, forKey: .protocolVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let protocolNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocolName)
        protocolName = protocolNameDecoded
        let protocolVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocolVersion)
        protocolVersion = protocolVersionDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// A single controller area network (CAN) device interface.
    public struct CanInterface: Swift.Equatable {
        /// The unique name of the interface.
        /// This member is required.
        public var name: Swift.String?
        /// The name of the communication protocol for the interface.
        public var protocolName: Swift.String?
        /// The version of the communication protocol for the interface.
        public var protocolVersion: Swift.String?

        public init(
            name: Swift.String? = nil,
            protocolName: Swift.String? = nil,
            protocolVersion: Swift.String? = nil
        )
        {
            self.name = name
            self.protocolName = protocolName
            self.protocolVersion = protocolVersion
        }
    }

}

extension IoTFleetWiseClientTypes.CanSignal: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case factor
        case isBigEndian
        case isSigned
        case length
        case messageId
        case name
        case offset
        case startBit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let factor = self.factor {
            try encodeContainer.encode(factor, forKey: .factor)
        }
        if isBigEndian != false {
            try encodeContainer.encode(isBigEndian, forKey: .isBigEndian)
        }
        if isSigned != false {
            try encodeContainer.encode(isSigned, forKey: .isSigned)
        }
        if length != 0 {
            try encodeContainer.encode(length, forKey: .length)
        }
        if messageId != 0 {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let offset = self.offset {
            try encodeContainer.encode(offset, forKey: .offset)
        }
        if startBit != 0 {
            try encodeContainer.encode(startBit, forKey: .startBit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .messageId) ?? 0
        messageId = messageIdDecoded
        let isBigEndianDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isBigEndian) ?? false
        isBigEndian = isBigEndianDecoded
        let isSignedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isSigned) ?? false
        isSigned = isSignedDecoded
        let startBitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startBit) ?? 0
        startBit = startBitDecoded
        let offsetDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .offset)
        offset = offsetDecoded
        let factorDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .factor)
        factor = factorDecoded
        let lengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .length) ?? 0
        length = lengthDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about a single controller area network (CAN) signal and the messages it receives and transmits.
    public struct CanSignal: Swift.Equatable {
        /// A multiplier used to decode the CAN message.
        /// This member is required.
        public var factor: Swift.Double?
        /// Whether the byte ordering of a CAN message is big-endian.
        /// This member is required.
        public var isBigEndian: Swift.Bool
        /// Whether the message data is specified as a signed value.
        /// This member is required.
        public var isSigned: Swift.Bool
        /// How many bytes of data are in the message.
        /// This member is required.
        public var length: Swift.Int
        /// The ID of the message.
        /// This member is required.
        public var messageId: Swift.Int
        /// The name of the signal.
        public var name: Swift.String?
        /// The offset used to calculate the signal value. Combined with factor, the calculation is value = raw_value * factor + offset.
        /// This member is required.
        public var offset: Swift.Double?
        /// Indicates the beginning of the CAN signal. This should always be the least significant bit (LSB). This value might be different from the value in a DBC file. For little endian signals, startBit is the same value as in the DBC file. For big endian signals in a DBC file, the start bit is the most significant bit (MSB). You will have to calculate the LSB instead and pass it as the startBit.
        /// This member is required.
        public var startBit: Swift.Int

        public init(
            factor: Swift.Double? = nil,
            isBigEndian: Swift.Bool = false,
            isSigned: Swift.Bool = false,
            length: Swift.Int = 0,
            messageId: Swift.Int = 0,
            name: Swift.String? = nil,
            offset: Swift.Double? = nil,
            startBit: Swift.Int = 0
        )
        {
            self.factor = factor
            self.isBigEndian = isBigEndian
            self.isSigned = isSigned
            self.length = length
            self.messageId = messageId
            self.name = name
            self.offset = offset
            self.startBit = startBit
        }
    }

}

extension IoTFleetWiseClientTypes.CloudWatchLogDeliveryOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logGroupName
        case logType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logGroupName = self.logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
        if let logType = self.logType {
            try encodeContainer.encode(logType.rawValue, forKey: .logType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logTypeDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.LogType.self, forKey: .logType)
        logType = logTypeDecoded
        let logGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// The log delivery option to send data to Amazon CloudWatch Logs.
    public struct CloudWatchLogDeliveryOptions: Swift.Equatable {
        /// The Amazon CloudWatch Logs group the operation sends data to.
        public var logGroupName: Swift.String?
        /// The type of log to send data to Amazon CloudWatch Logs.
        /// This member is required.
        public var logType: IoTFleetWiseClientTypes.LogType?

        public init(
            logGroupName: Swift.String? = nil,
            logType: IoTFleetWiseClientTypes.LogType? = nil
        )
        {
            self.logGroupName = logGroupName
            self.logType = logType
        }
    }

}

extension IoTFleetWiseClientTypes.CollectionScheme: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conditionbasedcollectionscheme = "conditionBasedCollectionScheme"
        case sdkUnknown
        case timebasedcollectionscheme = "timeBasedCollectionScheme"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .conditionbasedcollectionscheme(conditionbasedcollectionscheme):
                try container.encode(conditionbasedcollectionscheme, forKey: .conditionbasedcollectionscheme)
            case let .timebasedcollectionscheme(timebasedcollectionscheme):
                try container.encode(timebasedcollectionscheme, forKey: .timebasedcollectionscheme)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let timebasedcollectionschemeDecoded = try values.decodeIfPresent(IoTFleetWiseClientTypes.TimeBasedCollectionScheme.self, forKey: .timebasedcollectionscheme)
        if let timebasedcollectionscheme = timebasedcollectionschemeDecoded {
            self = .timebasedcollectionscheme(timebasedcollectionscheme)
            return
        }
        let conditionbasedcollectionschemeDecoded = try values.decodeIfPresent(IoTFleetWiseClientTypes.ConditionBasedCollectionScheme.self, forKey: .conditionbasedcollectionscheme)
        if let conditionbasedcollectionscheme = conditionbasedcollectionschemeDecoded {
            self = .conditionbasedcollectionscheme(conditionbasedcollectionscheme)
            return
        }
        self = .sdkUnknown("")
    }
}

extension IoTFleetWiseClientTypes {
    /// Specifies what data to collect and how often or when to collect it.
    public enum CollectionScheme: Swift.Equatable {
        /// Information about a collection scheme that uses a time period to decide how often to collect data.
        case timebasedcollectionscheme(IoTFleetWiseClientTypes.TimeBasedCollectionScheme)
        /// Information about a collection scheme that uses a simple logical expression to recognize what data to collect.
        case conditionbasedcollectionscheme(IoTFleetWiseClientTypes.ConditionBasedCollectionScheme)
        case sdkUnknown(Swift.String)
    }

}

extension IoTFleetWiseClientTypes {
    public enum Compression: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case off
        case snappy
        case sdkUnknown(Swift.String)

        public static var allCases: [Compression] {
            return [
                .off,
                .snappy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .off: return "OFF"
            case .snappy: return "SNAPPY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Compression(rawValue: rawValue) ?? Compression.sdkUnknown(rawValue)
        }
    }
}

extension IoTFleetWiseClientTypes.ConditionBasedCollectionScheme: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conditionLanguageVersion
        case expression
        case minimumTriggerIntervalMs
        case triggerMode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conditionLanguageVersion = self.conditionLanguageVersion {
            try encodeContainer.encode(conditionLanguageVersion, forKey: .conditionLanguageVersion)
        }
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let minimumTriggerIntervalMs = self.minimumTriggerIntervalMs {
            try encodeContainer.encode(minimumTriggerIntervalMs, forKey: .minimumTriggerIntervalMs)
        }
        if let triggerMode = self.triggerMode {
            try encodeContainer.encode(triggerMode.rawValue, forKey: .triggerMode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let minimumTriggerIntervalMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumTriggerIntervalMs)
        minimumTriggerIntervalMs = minimumTriggerIntervalMsDecoded
        let triggerModeDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.TriggerMode.self, forKey: .triggerMode)
        triggerMode = triggerModeDecoded
        let conditionLanguageVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .conditionLanguageVersion)
        conditionLanguageVersion = conditionLanguageVersionDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about a collection scheme that uses a simple logical expression to recognize what data to collect.
    public struct ConditionBasedCollectionScheme: Swift.Equatable {
        /// Specifies the version of the conditional expression language.
        public var conditionLanguageVersion: Swift.Int?
        /// The logical expression used to recognize what data to collect. For example, $variable.Vehicle.OutsideAirTemperature >= 105.0.
        /// This member is required.
        public var expression: Swift.String?
        /// The minimum duration of time between two triggering events to collect data, in milliseconds. If a signal changes often, you might want to collect data at a slower rate.
        public var minimumTriggerIntervalMs: Swift.Int?
        /// Whether to collect data for all triggering events (ALWAYS). Specify (RISING_EDGE), or specify only when the condition first evaluates to false. For example, triggering on "AirbagDeployed"; Users aren't interested on triggering when the airbag is already exploded; they only care about the change from not deployed => deployed.
        public var triggerMode: IoTFleetWiseClientTypes.TriggerMode?

        public init(
            conditionLanguageVersion: Swift.Int? = nil,
            expression: Swift.String? = nil,
            minimumTriggerIntervalMs: Swift.Int? = nil,
            triggerMode: IoTFleetWiseClientTypes.TriggerMode? = nil
        )
        {
            self.conditionLanguageVersion = conditionLanguageVersion
            self.expression = expression
            self.minimumTriggerIntervalMs = minimumTriggerIntervalMs
            self.triggerMode = triggerMode
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resource = output.resource
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resource = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request has conflicting operations. This can occur if you're trying to perform more than one operation on the same resource at the same time.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The resource on which there are conflicting operations.
        /// This member is required.
        public internal(set) var resource: Swift.String? = nil
        /// The type of resource on which there are conflicting operations..
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resource: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resource = resource
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resource: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resource
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CreateCampaignInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectionScheme
        case compression
        case dataDestinationConfigs
        case dataExtraDimensions
        case description
        case diagnosticsMode
        case expiryTime
        case postTriggerCollectionDuration
        case priority
        case signalCatalogArn
        case signalsToCollect
        case spoolingMode
        case startTime
        case tags
        case targetArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collectionScheme = self.collectionScheme {
            try encodeContainer.encode(collectionScheme, forKey: .collectionScheme)
        }
        if let compression = self.compression {
            try encodeContainer.encode(compression.rawValue, forKey: .compression)
        }
        if let dataDestinationConfigs = dataDestinationConfigs {
            var dataDestinationConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataDestinationConfigs)
            for datadestinationconfig0 in dataDestinationConfigs {
                try dataDestinationConfigsContainer.encode(datadestinationconfig0)
            }
        }
        if let dataExtraDimensions = dataExtraDimensions {
            var dataExtraDimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataExtraDimensions)
            for nodepath0 in dataExtraDimensions {
                try dataExtraDimensionsContainer.encode(nodepath0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let diagnosticsMode = self.diagnosticsMode {
            try encodeContainer.encode(diagnosticsMode.rawValue, forKey: .diagnosticsMode)
        }
        if let expiryTime = self.expiryTime {
            try encodeContainer.encodeTimestamp(expiryTime, format: .epochSeconds, forKey: .expiryTime)
        }
        if let postTriggerCollectionDuration = self.postTriggerCollectionDuration {
            try encodeContainer.encode(postTriggerCollectionDuration, forKey: .postTriggerCollectionDuration)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let signalCatalogArn = self.signalCatalogArn {
            try encodeContainer.encode(signalCatalogArn, forKey: .signalCatalogArn)
        }
        if let signalsToCollect = signalsToCollect {
            var signalsToCollectContainer = encodeContainer.nestedUnkeyedContainer(forKey: .signalsToCollect)
            for signalinformation0 in signalsToCollect {
                try signalsToCollectContainer.encode(signalinformation0)
            }
        }
        if let spoolingMode = self.spoolingMode {
            try encodeContainer.encode(spoolingMode.rawValue, forKey: .spoolingMode)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let targetArn = self.targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }
}

extension CreateCampaignInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateCampaignInput: Swift.Equatable {
    /// The data collection scheme associated with the campaign. You can specify a scheme that collects data based on time or an event.
    /// This member is required.
    public var collectionScheme: IoTFleetWiseClientTypes.CollectionScheme?
    /// (Optional) Whether to compress signals before transmitting data to Amazon Web Services IoT FleetWise. If you don't want to compress the signals, use OFF. If it's not specified, SNAPPY is used. Default: SNAPPY
    public var compression: IoTFleetWiseClientTypes.Compression?
    /// The destination where the campaign sends data. You can choose to send data to be stored in Amazon S3 or Amazon Timestream. Amazon S3 optimizes the cost of data storage and provides additional mechanisms to use vehicle data, such as data lakes, centralized data storage, data processing pipelines, and analytics. Amazon Web Services IoT FleetWise supports at-least-once file delivery to S3. Your vehicle data is stored on multiple Amazon Web Services IoT FleetWise servers for redundancy and high availability. You can use Amazon Timestream to access and analyze time series data, and Timestream to query vehicle data so that you can identify trends and patterns.
    public var dataDestinationConfigs: [IoTFleetWiseClientTypes.DataDestinationConfig]?
    /// (Optional) A list of vehicle attributes to associate with a campaign. Enrich the data with specified vehicle attributes. For example, add make and model to the campaign, and Amazon Web Services IoT FleetWise will associate the data with those attributes as dimensions in Amazon Timestream. You can then query the data against make and model. Default: An empty array
    public var dataExtraDimensions: [Swift.String]?
    /// An optional description of the campaign to help identify its purpose.
    public var description: Swift.String?
    /// (Optional) Option for a vehicle to send diagnostic trouble codes to Amazon Web Services IoT FleetWise. If you want to send diagnostic trouble codes, use SEND_ACTIVE_DTCS. If it's not specified, OFF is used. Default: OFF
    public var diagnosticsMode: IoTFleetWiseClientTypes.DiagnosticsMode?
    /// (Optional) The time the campaign expires, in seconds since epoch (January 1, 1970 at midnight UTC time). Vehicle data isn't collected after the campaign expires. Default: 253402214400 (December 31, 9999, 00:00:00 UTC)
    public var expiryTime: ClientRuntime.Date?
    /// The name of the campaign to create.
    /// This member is required.
    public var name: Swift.String?
    /// (Optional) How long (in milliseconds) to collect raw data after a triggering event initiates the collection. If it's not specified, 0 is used. Default: 0
    public var postTriggerCollectionDuration: Swift.Int?
    /// (Optional) A number indicating the priority of one campaign over another campaign for a certain vehicle or fleet. A campaign with the lowest value is deployed to vehicles before any other campaigns. If it's not specified, 0 is used. Default: 0
    public var priority: Swift.Int?
    /// (Optional) The Amazon Resource Name (ARN) of the signal catalog to associate with the campaign.
    /// This member is required.
    public var signalCatalogArn: Swift.String?
    /// (Optional) A list of information about signals to collect.
    public var signalsToCollect: [IoTFleetWiseClientTypes.SignalInformation]?
    /// (Optional) Whether to store collected data after a vehicle lost a connection with the cloud. After a connection is re-established, the data is automatically forwarded to Amazon Web Services IoT FleetWise. If you want to store collected data when a vehicle loses connection with the cloud, use TO_DISK. If it's not specified, OFF is used. Default: OFF
    public var spoolingMode: IoTFleetWiseClientTypes.SpoolingMode?
    /// (Optional) The time, in milliseconds, to deliver a campaign after it was approved. If it's not specified, 0 is used. Default: 0
    public var startTime: ClientRuntime.Date?
    /// Metadata that can be used to manage the campaign.
    public var tags: [IoTFleetWiseClientTypes.Tag]?
    /// The ARN of the vehicle or fleet to deploy a campaign to.
    /// This member is required.
    public var targetArn: Swift.String?

    public init(
        collectionScheme: IoTFleetWiseClientTypes.CollectionScheme? = nil,
        compression: IoTFleetWiseClientTypes.Compression? = nil,
        dataDestinationConfigs: [IoTFleetWiseClientTypes.DataDestinationConfig]? = nil,
        dataExtraDimensions: [Swift.String]? = nil,
        description: Swift.String? = nil,
        diagnosticsMode: IoTFleetWiseClientTypes.DiagnosticsMode? = nil,
        expiryTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        postTriggerCollectionDuration: Swift.Int? = nil,
        priority: Swift.Int? = nil,
        signalCatalogArn: Swift.String? = nil,
        signalsToCollect: [IoTFleetWiseClientTypes.SignalInformation]? = nil,
        spoolingMode: IoTFleetWiseClientTypes.SpoolingMode? = nil,
        startTime: ClientRuntime.Date? = nil,
        tags: [IoTFleetWiseClientTypes.Tag]? = nil,
        targetArn: Swift.String? = nil
    )
    {
        self.collectionScheme = collectionScheme
        self.compression = compression
        self.dataDestinationConfigs = dataDestinationConfigs
        self.dataExtraDimensions = dataExtraDimensions
        self.description = description
        self.diagnosticsMode = diagnosticsMode
        self.expiryTime = expiryTime
        self.name = name
        self.postTriggerCollectionDuration = postTriggerCollectionDuration
        self.priority = priority
        self.signalCatalogArn = signalCatalogArn
        self.signalsToCollect = signalsToCollect
        self.spoolingMode = spoolingMode
        self.startTime = startTime
        self.tags = tags
        self.targetArn = targetArn
    }
}

struct CreateCampaignInputBody: Swift.Equatable {
    let description: Swift.String?
    let signalCatalogArn: Swift.String?
    let targetArn: Swift.String?
    let startTime: ClientRuntime.Date?
    let expiryTime: ClientRuntime.Date?
    let postTriggerCollectionDuration: Swift.Int?
    let diagnosticsMode: IoTFleetWiseClientTypes.DiagnosticsMode?
    let spoolingMode: IoTFleetWiseClientTypes.SpoolingMode?
    let compression: IoTFleetWiseClientTypes.Compression?
    let priority: Swift.Int?
    let signalsToCollect: [IoTFleetWiseClientTypes.SignalInformation]?
    let collectionScheme: IoTFleetWiseClientTypes.CollectionScheme?
    let dataExtraDimensions: [Swift.String]?
    let tags: [IoTFleetWiseClientTypes.Tag]?
    let dataDestinationConfigs: [IoTFleetWiseClientTypes.DataDestinationConfig]?
}

extension CreateCampaignInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectionScheme
        case compression
        case dataDestinationConfigs
        case dataExtraDimensions
        case description
        case diagnosticsMode
        case expiryTime
        case postTriggerCollectionDuration
        case priority
        case signalCatalogArn
        case signalsToCollect
        case spoolingMode
        case startTime
        case tags
        case targetArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let signalCatalogArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signalCatalogArn)
        signalCatalogArn = signalCatalogArnDecoded
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let expiryTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expiryTime)
        expiryTime = expiryTimeDecoded
        let postTriggerCollectionDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .postTriggerCollectionDuration)
        postTriggerCollectionDuration = postTriggerCollectionDurationDecoded
        let diagnosticsModeDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.DiagnosticsMode.self, forKey: .diagnosticsMode)
        diagnosticsMode = diagnosticsModeDecoded
        let spoolingModeDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.SpoolingMode.self, forKey: .spoolingMode)
        spoolingMode = spoolingModeDecoded
        let compressionDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.Compression.self, forKey: .compression)
        compression = compressionDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let signalsToCollectContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.SignalInformation?].self, forKey: .signalsToCollect)
        var signalsToCollectDecoded0:[IoTFleetWiseClientTypes.SignalInformation]? = nil
        if let signalsToCollectContainer = signalsToCollectContainer {
            signalsToCollectDecoded0 = [IoTFleetWiseClientTypes.SignalInformation]()
            for structure0 in signalsToCollectContainer {
                if let structure0 = structure0 {
                    signalsToCollectDecoded0?.append(structure0)
                }
            }
        }
        signalsToCollect = signalsToCollectDecoded0
        let collectionSchemeDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.CollectionScheme.self, forKey: .collectionScheme)
        collectionScheme = collectionSchemeDecoded
        let dataExtraDimensionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dataExtraDimensions)
        var dataExtraDimensionsDecoded0:[Swift.String]? = nil
        if let dataExtraDimensionsContainer = dataExtraDimensionsContainer {
            dataExtraDimensionsDecoded0 = [Swift.String]()
            for string0 in dataExtraDimensionsContainer {
                if let string0 = string0 {
                    dataExtraDimensionsDecoded0?.append(string0)
                }
            }
        }
        dataExtraDimensions = dataExtraDimensionsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTFleetWiseClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTFleetWiseClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let dataDestinationConfigsContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.DataDestinationConfig?].self, forKey: .dataDestinationConfigs)
        var dataDestinationConfigsDecoded0:[IoTFleetWiseClientTypes.DataDestinationConfig]? = nil
        if let dataDestinationConfigsContainer = dataDestinationConfigsContainer {
            dataDestinationConfigsDecoded0 = [IoTFleetWiseClientTypes.DataDestinationConfig]()
            for union0 in dataDestinationConfigsContainer {
                if let union0 = union0 {
                    dataDestinationConfigsDecoded0?.append(union0)
                }
            }
        }
        dataDestinationConfigs = dataDestinationConfigsDecoded0
    }
}

extension CreateCampaignOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateCampaignOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct CreateCampaignOutput: Swift.Equatable {
    /// The ARN of the created campaign.
    public var arn: Swift.String?
    /// The name of the created campaign.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct CreateCampaignOutputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
}

extension CreateCampaignOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum CreateCampaignOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDecoderManifestInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case modelManifestArn
        case networkInterfaces
        case signalDecoders
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let modelManifestArn = self.modelManifestArn {
            try encodeContainer.encode(modelManifestArn, forKey: .modelManifestArn)
        }
        if let networkInterfaces = networkInterfaces {
            var networkInterfacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInterfaces)
            for networkinterface0 in networkInterfaces {
                try networkInterfacesContainer.encode(networkinterface0)
            }
        }
        if let signalDecoders = signalDecoders {
            var signalDecodersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .signalDecoders)
            for signaldecoder0 in signalDecoders {
                try signalDecodersContainer.encode(signaldecoder0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateDecoderManifestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDecoderManifestInput: Swift.Equatable {
    /// A brief description of the decoder manifest.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the vehicle model (model manifest).
    /// This member is required.
    public var modelManifestArn: Swift.String?
    /// The unique name of the decoder manifest to create.
    /// This member is required.
    public var name: Swift.String?
    /// A list of information about available network interfaces.
    public var networkInterfaces: [IoTFleetWiseClientTypes.NetworkInterface]?
    /// A list of information about signal decoders.
    public var signalDecoders: [IoTFleetWiseClientTypes.SignalDecoder]?
    /// Metadata that can be used to manage the decoder manifest.
    public var tags: [IoTFleetWiseClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        modelManifestArn: Swift.String? = nil,
        name: Swift.String? = nil,
        networkInterfaces: [IoTFleetWiseClientTypes.NetworkInterface]? = nil,
        signalDecoders: [IoTFleetWiseClientTypes.SignalDecoder]? = nil,
        tags: [IoTFleetWiseClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.modelManifestArn = modelManifestArn
        self.name = name
        self.networkInterfaces = networkInterfaces
        self.signalDecoders = signalDecoders
        self.tags = tags
    }
}

struct CreateDecoderManifestInputBody: Swift.Equatable {
    let description: Swift.String?
    let modelManifestArn: Swift.String?
    let signalDecoders: [IoTFleetWiseClientTypes.SignalDecoder]?
    let networkInterfaces: [IoTFleetWiseClientTypes.NetworkInterface]?
    let tags: [IoTFleetWiseClientTypes.Tag]?
}

extension CreateDecoderManifestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case modelManifestArn
        case networkInterfaces
        case signalDecoders
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let modelManifestArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelManifestArn)
        modelManifestArn = modelManifestArnDecoded
        let signalDecodersContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.SignalDecoder?].self, forKey: .signalDecoders)
        var signalDecodersDecoded0:[IoTFleetWiseClientTypes.SignalDecoder]? = nil
        if let signalDecodersContainer = signalDecodersContainer {
            signalDecodersDecoded0 = [IoTFleetWiseClientTypes.SignalDecoder]()
            for structure0 in signalDecodersContainer {
                if let structure0 = structure0 {
                    signalDecodersDecoded0?.append(structure0)
                }
            }
        }
        signalDecoders = signalDecodersDecoded0
        let networkInterfacesContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.NetworkInterface?].self, forKey: .networkInterfaces)
        var networkInterfacesDecoded0:[IoTFleetWiseClientTypes.NetworkInterface]? = nil
        if let networkInterfacesContainer = networkInterfacesContainer {
            networkInterfacesDecoded0 = [IoTFleetWiseClientTypes.NetworkInterface]()
            for structure0 in networkInterfacesContainer {
                if let structure0 = structure0 {
                    networkInterfacesDecoded0?.append(structure0)
                }
            }
        }
        networkInterfaces = networkInterfacesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTFleetWiseClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTFleetWiseClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDecoderManifestOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDecoderManifestOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct CreateDecoderManifestOutput: Swift.Equatable {
    /// The ARN of the created decoder manifest.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the created decoder manifest.
    /// This member is required.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct CreateDecoderManifestOutputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
}

extension CreateDecoderManifestOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum CreateDecoderManifestOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DecoderManifestValidationException": return try await DecoderManifestValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case signalCatalogArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let signalCatalogArn = self.signalCatalogArn {
            try encodeContainer.encode(signalCatalogArn, forKey: .signalCatalogArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateFleetInput: Swift.Equatable {
    /// A brief description of the fleet to create.
    public var description: Swift.String?
    /// The unique ID of the fleet to create.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The Amazon Resource Name (ARN) of a signal catalog.
    /// This member is required.
    public var signalCatalogArn: Swift.String?
    /// Metadata that can be used to manage the fleet.
    public var tags: [IoTFleetWiseClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        signalCatalogArn: Swift.String? = nil,
        tags: [IoTFleetWiseClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.fleetId = fleetId
        self.signalCatalogArn = signalCatalogArn
        self.tags = tags
    }
}

struct CreateFleetInputBody: Swift.Equatable {
    let description: Swift.String?
    let signalCatalogArn: Swift.String?
    let tags: [IoTFleetWiseClientTypes.Tag]?
}

extension CreateFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case signalCatalogArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let signalCatalogArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signalCatalogArn)
        signalCatalogArn = signalCatalogArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTFleetWiseClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTFleetWiseClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFleetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateFleetOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateFleetOutput: Swift.Equatable {
    /// The ARN of the created fleet.
    /// This member is required.
    public var arn: Swift.String?
    /// The ID of the created fleet.
    /// This member is required.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateFleetOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
}

extension CreateFleetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum CreateFleetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateModelManifestInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case nodes
        case signalCatalogArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let nodes = nodes {
            var nodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodes)
            for string0 in nodes {
                try nodesContainer.encode(string0)
            }
        }
        if let signalCatalogArn = self.signalCatalogArn {
            try encodeContainer.encode(signalCatalogArn, forKey: .signalCatalogArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateModelManifestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateModelManifestInput: Swift.Equatable {
    /// A brief description of the vehicle model.
    public var description: Swift.String?
    /// The name of the vehicle model to create.
    /// This member is required.
    public var name: Swift.String?
    /// A list of nodes, which are a general abstraction of signals.
    /// This member is required.
    public var nodes: [Swift.String]?
    /// The Amazon Resource Name (ARN) of a signal catalog.
    /// This member is required.
    public var signalCatalogArn: Swift.String?
    /// Metadata that can be used to manage the vehicle model.
    public var tags: [IoTFleetWiseClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        nodes: [Swift.String]? = nil,
        signalCatalogArn: Swift.String? = nil,
        tags: [IoTFleetWiseClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.name = name
        self.nodes = nodes
        self.signalCatalogArn = signalCatalogArn
        self.tags = tags
    }
}

struct CreateModelManifestInputBody: Swift.Equatable {
    let description: Swift.String?
    let nodes: [Swift.String]?
    let signalCatalogArn: Swift.String?
    let tags: [IoTFleetWiseClientTypes.Tag]?
}

extension CreateModelManifestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case nodes
        case signalCatalogArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nodesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .nodes)
        var nodesDecoded0:[Swift.String]? = nil
        if let nodesContainer = nodesContainer {
            nodesDecoded0 = [Swift.String]()
            for string0 in nodesContainer {
                if let string0 = string0 {
                    nodesDecoded0?.append(string0)
                }
            }
        }
        nodes = nodesDecoded0
        let signalCatalogArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signalCatalogArn)
        signalCatalogArn = signalCatalogArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTFleetWiseClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTFleetWiseClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateModelManifestOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateModelManifestOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct CreateModelManifestOutput: Swift.Equatable {
    /// The ARN of the created vehicle model.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the created vehicle model.
    /// This member is required.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct CreateModelManifestOutputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
}

extension CreateModelManifestOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum CreateModelManifestOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidSignalsException": return try await InvalidSignalsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSignalCatalogInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case nodes
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let nodes = nodes {
            var nodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodes)
            for node0 in nodes {
                try nodesContainer.encode(node0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateSignalCatalogInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateSignalCatalogInput: Swift.Equatable {
    /// A brief description of the signal catalog.
    public var description: Swift.String?
    /// The name of the signal catalog to create.
    /// This member is required.
    public var name: Swift.String?
    /// A list of information about nodes, which are a general abstraction of signals. For more information, see the API data type.
    public var nodes: [IoTFleetWiseClientTypes.Node]?
    /// Metadata that can be used to manage the signal catalog.
    public var tags: [IoTFleetWiseClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        nodes: [IoTFleetWiseClientTypes.Node]? = nil,
        tags: [IoTFleetWiseClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.name = name
        self.nodes = nodes
        self.tags = tags
    }
}

struct CreateSignalCatalogInputBody: Swift.Equatable {
    let description: Swift.String?
    let nodes: [IoTFleetWiseClientTypes.Node]?
    let tags: [IoTFleetWiseClientTypes.Tag]?
}

extension CreateSignalCatalogInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case nodes
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nodesContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.Node?].self, forKey: .nodes)
        var nodesDecoded0:[IoTFleetWiseClientTypes.Node]? = nil
        if let nodesContainer = nodesContainer {
            nodesDecoded0 = [IoTFleetWiseClientTypes.Node]()
            for union0 in nodesContainer {
                if let union0 = union0 {
                    nodesDecoded0?.append(union0)
                }
            }
        }
        nodes = nodesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTFleetWiseClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTFleetWiseClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSignalCatalogOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSignalCatalogOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct CreateSignalCatalogOutput: Swift.Equatable {
    /// The ARN of the created signal catalog.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the created signal catalog.
    /// This member is required.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct CreateSignalCatalogOutputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
}

extension CreateSignalCatalogOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum CreateSignalCatalogOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNodeException": return try await InvalidNodeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidSignalsException": return try await InvalidSignalsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTFleetWiseClientTypes.CreateVehicleError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case vehicleName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let vehicleName = self.vehicleName {
            try encodeContainer.encode(vehicleName, forKey: .vehicleName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vehicleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vehicleName)
        vehicleName = vehicleNameDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// An HTTP error resulting from creating a vehicle.
    public struct CreateVehicleError: Swift.Equatable {
        /// An HTTP error code.
        public var code: Swift.String?
        /// A description of the HTTP error.
        public var message: Swift.String?
        /// The ID of the vehicle with the error.
        public var vehicleName: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil,
            vehicleName: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
            self.vehicleName = vehicleName
        }
    }

}

extension CreateVehicleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationBehavior
        case attributes
        case decoderManifestArn
        case modelManifestArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationBehavior = self.associationBehavior {
            try encodeContainer.encode(associationBehavior.rawValue, forKey: .associationBehavior)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributesMap0) in attributes {
                try attributesContainer.encode(attributesMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let decoderManifestArn = self.decoderManifestArn {
            try encodeContainer.encode(decoderManifestArn, forKey: .decoderManifestArn)
        }
        if let modelManifestArn = self.modelManifestArn {
            try encodeContainer.encode(modelManifestArn, forKey: .modelManifestArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateVehicleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateVehicleInput: Swift.Equatable {
    /// An option to create a new Amazon Web Services IoT thing when creating a vehicle, or to validate an existing Amazon Web Services IoT thing as a vehicle. Default:
    public var associationBehavior: IoTFleetWiseClientTypes.VehicleAssociationBehavior?
    /// Static information about a vehicle in a key-value pair. For example: "engineType" : "1.3 L R2" A campaign must include the keys (attribute names) in dataExtraDimensions for them to display in Amazon Timestream.
    public var attributes: [Swift.String:Swift.String]?
    /// The ARN of a decoder manifest.
    /// This member is required.
    public var decoderManifestArn: Swift.String?
    /// The Amazon Resource Name ARN of a vehicle model.
    /// This member is required.
    public var modelManifestArn: Swift.String?
    /// Metadata that can be used to manage the vehicle.
    public var tags: [IoTFleetWiseClientTypes.Tag]?
    /// The unique ID of the vehicle to create.
    /// This member is required.
    public var vehicleName: Swift.String?

    public init(
        associationBehavior: IoTFleetWiseClientTypes.VehicleAssociationBehavior? = nil,
        attributes: [Swift.String:Swift.String]? = nil,
        decoderManifestArn: Swift.String? = nil,
        modelManifestArn: Swift.String? = nil,
        tags: [IoTFleetWiseClientTypes.Tag]? = nil,
        vehicleName: Swift.String? = nil
    )
    {
        self.associationBehavior = associationBehavior
        self.attributes = attributes
        self.decoderManifestArn = decoderManifestArn
        self.modelManifestArn = modelManifestArn
        self.tags = tags
        self.vehicleName = vehicleName
    }
}

struct CreateVehicleInputBody: Swift.Equatable {
    let modelManifestArn: Swift.String?
    let decoderManifestArn: Swift.String?
    let attributes: [Swift.String:Swift.String]?
    let associationBehavior: IoTFleetWiseClientTypes.VehicleAssociationBehavior?
    let tags: [IoTFleetWiseClientTypes.Tag]?
}

extension CreateVehicleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationBehavior
        case attributes
        case decoderManifestArn
        case modelManifestArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelManifestArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelManifestArn)
        modelManifestArn = modelManifestArnDecoded
        let decoderManifestArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .decoderManifestArn)
        decoderManifestArn = decoderManifestArnDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let associationBehaviorDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.VehicleAssociationBehavior.self, forKey: .associationBehavior)
        associationBehavior = associationBehaviorDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTFleetWiseClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTFleetWiseClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateVehicleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateVehicleOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.thingArn = output.thingArn
            self.vehicleName = output.vehicleName
        } else {
            self.arn = nil
            self.thingArn = nil
            self.vehicleName = nil
        }
    }
}

public struct CreateVehicleOutput: Swift.Equatable {
    /// The ARN of the created vehicle.
    public var arn: Swift.String?
    /// The ARN of a created or validated Amazon Web Services IoT thing.
    public var thingArn: Swift.String?
    /// The unique ID of the created vehicle.
    public var vehicleName: Swift.String?

    public init(
        arn: Swift.String? = nil,
        thingArn: Swift.String? = nil,
        vehicleName: Swift.String? = nil
    )
    {
        self.arn = arn
        self.thingArn = thingArn
        self.vehicleName = vehicleName
    }
}

struct CreateVehicleOutputBody: Swift.Equatable {
    let vehicleName: Swift.String?
    let arn: Swift.String?
    let thingArn: Swift.String?
}

extension CreateVehicleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case thingArn
        case vehicleName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vehicleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vehicleName)
        vehicleName = vehicleNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
    }
}

enum CreateVehicleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTFleetWiseClientTypes.CreateVehicleRequestItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associationBehavior
        case attributes
        case decoderManifestArn
        case modelManifestArn
        case tags
        case vehicleName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associationBehavior = self.associationBehavior {
            try encodeContainer.encode(associationBehavior.rawValue, forKey: .associationBehavior)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributesMap0) in attributes {
                try attributesContainer.encode(attributesMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let decoderManifestArn = self.decoderManifestArn {
            try encodeContainer.encode(decoderManifestArn, forKey: .decoderManifestArn)
        }
        if let modelManifestArn = self.modelManifestArn {
            try encodeContainer.encode(modelManifestArn, forKey: .modelManifestArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let vehicleName = self.vehicleName {
            try encodeContainer.encode(vehicleName, forKey: .vehicleName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vehicleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vehicleName)
        vehicleName = vehicleNameDecoded
        let modelManifestArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelManifestArn)
        modelManifestArn = modelManifestArnDecoded
        let decoderManifestArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .decoderManifestArn)
        decoderManifestArn = decoderManifestArnDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let associationBehaviorDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.VehicleAssociationBehavior.self, forKey: .associationBehavior)
        associationBehavior = associationBehaviorDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTFleetWiseClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTFleetWiseClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about the vehicle to create.
    public struct CreateVehicleRequestItem: Swift.Equatable {
        /// An option to create a new Amazon Web Services IoT thing when creating a vehicle, or to validate an existing thing as a vehicle.
        public var associationBehavior: IoTFleetWiseClientTypes.VehicleAssociationBehavior?
        /// Static information about a vehicle in a key-value pair. For example: "engine Type" : "v6"
        public var attributes: [Swift.String:Swift.String]?
        /// The Amazon Resource Name (ARN) of a decoder manifest associated with the vehicle to create.
        /// This member is required.
        public var decoderManifestArn: Swift.String?
        /// The ARN of the vehicle model (model manifest) to create the vehicle from.
        /// This member is required.
        public var modelManifestArn: Swift.String?
        /// Metadata which can be used to manage the vehicle.
        public var tags: [IoTFleetWiseClientTypes.Tag]?
        /// The unique ID of the vehicle to create.
        /// This member is required.
        public var vehicleName: Swift.String?

        public init(
            associationBehavior: IoTFleetWiseClientTypes.VehicleAssociationBehavior? = nil,
            attributes: [Swift.String:Swift.String]? = nil,
            decoderManifestArn: Swift.String? = nil,
            modelManifestArn: Swift.String? = nil,
            tags: [IoTFleetWiseClientTypes.Tag]? = nil,
            vehicleName: Swift.String? = nil
        )
        {
            self.associationBehavior = associationBehavior
            self.attributes = attributes
            self.decoderManifestArn = decoderManifestArn
            self.modelManifestArn = modelManifestArn
            self.tags = tags
            self.vehicleName = vehicleName
        }
    }

}

extension IoTFleetWiseClientTypes.CreateVehicleResponseItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case thingArn
        case vehicleName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let thingArn = self.thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
        if let vehicleName = self.vehicleName {
            try encodeContainer.encode(vehicleName, forKey: .vehicleName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vehicleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vehicleName)
        vehicleName = vehicleNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about a created vehicle.
    public struct CreateVehicleResponseItem: Swift.Equatable {
        /// The ARN of the created vehicle.
        public var arn: Swift.String?
        /// The ARN of a created or validated Amazon Web Services IoT thing.
        public var thingArn: Swift.String?
        /// The unique ID of the vehicle to create.
        public var vehicleName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            thingArn: Swift.String? = nil,
            vehicleName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.thingArn = thingArn
            self.vehicleName = vehicleName
        }
    }

}

extension IoTFleetWiseClientTypes.DataDestinationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3config = "s3Config"
        case sdkUnknown
        case timestreamconfig = "timestreamConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .s3config(s3config):
                try container.encode(s3config, forKey: .s3config)
            case let .timestreamconfig(timestreamconfig):
                try container.encode(timestreamconfig, forKey: .timestreamconfig)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let s3configDecoded = try values.decodeIfPresent(IoTFleetWiseClientTypes.S3Config.self, forKey: .s3config)
        if let s3config = s3configDecoded {
            self = .s3config(s3config)
            return
        }
        let timestreamconfigDecoded = try values.decodeIfPresent(IoTFleetWiseClientTypes.TimestreamConfig.self, forKey: .timestreamconfig)
        if let timestreamconfig = timestreamconfigDecoded {
            self = .timestreamconfig(timestreamconfig)
            return
        }
        self = .sdkUnknown("")
    }
}

extension IoTFleetWiseClientTypes {
    /// The destination where the Amazon Web Services IoT FleetWise campaign sends data. You can send data to be stored in Amazon S3 or Amazon Timestream.
    public enum DataDestinationConfig: Swift.Equatable {
        /// The Amazon S3 bucket where the Amazon Web Services IoT FleetWise campaign sends data.
        case s3config(IoTFleetWiseClientTypes.S3Config)
        /// The Amazon Timestream table where the campaign sends data.
        case timestreamconfig(IoTFleetWiseClientTypes.TimestreamConfig)
        case sdkUnknown(Swift.String)
    }

}

extension IoTFleetWiseClientTypes {
    public enum DataFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case json
        case parquet
        case sdkUnknown(Swift.String)

        public static var allCases: [DataFormat] {
            return [
                .json,
                .parquet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .parquet: return "PARQUET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataFormat(rawValue: rawValue) ?? DataFormat.sdkUnknown(rawValue)
        }
    }
}

extension IoTFleetWiseClientTypes.DecoderManifestSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case lastModificationTime
        case modelManifestArn
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let modelManifestArn = self.modelManifestArn {
            try encodeContainer.encode(modelManifestArn, forKey: .modelManifestArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let modelManifestArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelManifestArn)
        modelManifestArn = modelManifestArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.ManifestStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about a created decoder manifest. You can use the API operation to return this information about multiple decoder manifests.
    public struct DecoderManifestSummary: Swift.Equatable {
        /// The ARN of a vehicle model (model manifest) associated with the decoder manifest.
        public var arn: Swift.String?
        /// The time the decoder manifest was created in seconds since epoch (January 1, 1970 at midnight UTC time).
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// A brief description of the decoder manifest.
        public var description: Swift.String?
        /// The time the decoder manifest was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).
        /// This member is required.
        public var lastModificationTime: ClientRuntime.Date?
        /// The ARN of a vehicle model (model manifest) associated with the decoder manifest.
        public var modelManifestArn: Swift.String?
        /// The name of the decoder manifest.
        public var name: Swift.String?
        /// The state of the decoder manifest. If the status is ACTIVE, the decoder manifest can't be edited. If the status is marked DRAFT, you can edit the decoder manifest.
        public var status: IoTFleetWiseClientTypes.ManifestStatus?

        public init(
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            modelManifestArn: Swift.String? = nil,
            name: Swift.String? = nil,
            status: IoTFleetWiseClientTypes.ManifestStatus? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.lastModificationTime = lastModificationTime
            self.modelManifestArn = modelManifestArn
            self.name = name
            self.status = status
        }
    }

}

extension DecoderManifestValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DecoderManifestValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.invalidNetworkInterfaces = output.invalidNetworkInterfaces
            self.properties.invalidSignals = output.invalidSignals
            self.properties.message = output.message
        } else {
            self.properties.invalidNetworkInterfaces = nil
            self.properties.invalidSignals = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request couldn't be completed because it contains signal decoders with one or more validation errors.
public struct DecoderManifestValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The request couldn't be completed because of invalid network interfaces in the request.
        public internal(set) var invalidNetworkInterfaces: [IoTFleetWiseClientTypes.InvalidNetworkInterface]? = nil
        /// The request couldn't be completed because of invalid signals in the request.
        public internal(set) var invalidSignals: [IoTFleetWiseClientTypes.InvalidSignalDecoder]? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DecoderManifestValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        invalidNetworkInterfaces: [IoTFleetWiseClientTypes.InvalidNetworkInterface]? = nil,
        invalidSignals: [IoTFleetWiseClientTypes.InvalidSignalDecoder]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.invalidNetworkInterfaces = invalidNetworkInterfaces
        self.properties.invalidSignals = invalidSignals
        self.properties.message = message
    }
}

struct DecoderManifestValidationExceptionBody: Swift.Equatable {
    let invalidSignals: [IoTFleetWiseClientTypes.InvalidSignalDecoder]?
    let invalidNetworkInterfaces: [IoTFleetWiseClientTypes.InvalidNetworkInterface]?
    let message: Swift.String?
}

extension DecoderManifestValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidNetworkInterfaces
        case invalidSignals
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidSignalsContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.InvalidSignalDecoder?].self, forKey: .invalidSignals)
        var invalidSignalsDecoded0:[IoTFleetWiseClientTypes.InvalidSignalDecoder]? = nil
        if let invalidSignalsContainer = invalidSignalsContainer {
            invalidSignalsDecoded0 = [IoTFleetWiseClientTypes.InvalidSignalDecoder]()
            for structure0 in invalidSignalsContainer {
                if let structure0 = structure0 {
                    invalidSignalsDecoded0?.append(structure0)
                }
            }
        }
        invalidSignals = invalidSignalsDecoded0
        let invalidNetworkInterfacesContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.InvalidNetworkInterface?].self, forKey: .invalidNetworkInterfaces)
        var invalidNetworkInterfacesDecoded0:[IoTFleetWiseClientTypes.InvalidNetworkInterface]? = nil
        if let invalidNetworkInterfacesContainer = invalidNetworkInterfacesContainer {
            invalidNetworkInterfacesDecoded0 = [IoTFleetWiseClientTypes.InvalidNetworkInterface]()
            for structure0 in invalidNetworkInterfacesContainer {
                if let structure0 = structure0 {
                    invalidNetworkInterfacesDecoded0?.append(structure0)
                }
            }
        }
        invalidNetworkInterfaces = invalidNetworkInterfacesDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeleteCampaignInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteCampaignInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteCampaignInput: Swift.Equatable {
    /// The name of the campaign to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteCampaignInputBody: Swift.Equatable {
}

extension DeleteCampaignInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCampaignOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteCampaignOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct DeleteCampaignOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deleted campaign. The ARN isnt returned if a campaign doesnt exist.
    public var arn: Swift.String?
    /// The name of the deleted campaign.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct DeleteCampaignOutputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
}

extension DeleteCampaignOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum DeleteCampaignOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDecoderManifestInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteDecoderManifestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDecoderManifestInput: Swift.Equatable {
    /// The name of the decoder manifest to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteDecoderManifestInputBody: Swift.Equatable {
}

extension DeleteDecoderManifestInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDecoderManifestOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteDecoderManifestOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct DeleteDecoderManifestOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deleted decoder manifest.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the deleted decoder manifest.
    /// This member is required.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct DeleteDecoderManifestOutputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
}

extension DeleteDecoderManifestOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum DeleteDecoderManifestOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteFleetInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteFleetInput: Swift.Equatable {
    /// The ID of the fleet to delete.
    /// This member is required.
    public var fleetId: Swift.String?

    public init(
        fleetId: Swift.String? = nil
    )
    {
        self.fleetId = fleetId
    }
}

struct DeleteFleetInputBody: Swift.Equatable {
}

extension DeleteFleetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFleetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteFleetOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct DeleteFleetOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deleted fleet.
    public var arn: Swift.String?
    /// The ID of the deleted fleet.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct DeleteFleetOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
}

extension DeleteFleetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum DeleteFleetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteModelManifestInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteModelManifestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteModelManifestInput: Swift.Equatable {
    /// The name of the model manifest to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteModelManifestInputBody: Swift.Equatable {
}

extension DeleteModelManifestInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteModelManifestOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteModelManifestOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct DeleteModelManifestOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deleted model manifest.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the deleted model manifest.
    /// This member is required.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct DeleteModelManifestOutputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
}

extension DeleteModelManifestOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum DeleteModelManifestOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSignalCatalogInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteSignalCatalogInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSignalCatalogInput: Swift.Equatable {
    /// The name of the signal catalog to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteSignalCatalogInputBody: Swift.Equatable {
}

extension DeleteSignalCatalogInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSignalCatalogOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteSignalCatalogOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct DeleteSignalCatalogOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deleted signal catalog.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the deleted signal catalog.
    /// This member is required.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct DeleteSignalCatalogOutputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
}

extension DeleteSignalCatalogOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum DeleteSignalCatalogOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVehicleInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteVehicleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteVehicleInput: Swift.Equatable {
    /// The ID of the vehicle to delete.
    /// This member is required.
    public var vehicleName: Swift.String?

    public init(
        vehicleName: Swift.String? = nil
    )
    {
        self.vehicleName = vehicleName
    }
}

struct DeleteVehicleInputBody: Swift.Equatable {
}

extension DeleteVehicleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVehicleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteVehicleOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.vehicleName = output.vehicleName
        } else {
            self.arn = nil
            self.vehicleName = nil
        }
    }
}

public struct DeleteVehicleOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the deleted vehicle.
    /// This member is required.
    public var arn: Swift.String?
    /// The ID of the deleted vehicle.
    /// This member is required.
    public var vehicleName: Swift.String?

    public init(
        arn: Swift.String? = nil,
        vehicleName: Swift.String? = nil
    )
    {
        self.arn = arn
        self.vehicleName = vehicleName
    }
}

struct DeleteVehicleOutputBody: Swift.Equatable {
    let vehicleName: Swift.String?
    let arn: Swift.String?
}

extension DeleteVehicleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case vehicleName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vehicleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vehicleName)
        vehicleName = vehicleNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum DeleteVehicleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTFleetWiseClientTypes {
    public enum DiagnosticsMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case off
        case sendActiveDtcs
        case sdkUnknown(Swift.String)

        public static var allCases: [DiagnosticsMode] {
            return [
                .off,
                .sendActiveDtcs,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .off: return "OFF"
            case .sendActiveDtcs: return "SEND_ACTIVE_DTCS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DiagnosticsMode(rawValue: rawValue) ?? DiagnosticsMode.sdkUnknown(rawValue)
        }
    }
}

extension DisassociateVehicleFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetId = self.fleetId {
            try encodeContainer.encode(fleetId, forKey: .fleetId)
        }
    }
}

extension DisassociateVehicleFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateVehicleFleetInput: Swift.Equatable {
    /// The unique ID of a fleet.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The unique ID of the vehicle to disassociate from the fleet.
    /// This member is required.
    public var vehicleName: Swift.String?

    public init(
        fleetId: Swift.String? = nil,
        vehicleName: Swift.String? = nil
    )
    {
        self.fleetId = fleetId
        self.vehicleName = vehicleName
    }
}

struct DisassociateVehicleFleetInputBody: Swift.Equatable {
    let fleetId: Swift.String?
}

extension DisassociateVehicleFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetId)
        fleetId = fleetIdDecoded
    }
}

extension DisassociateVehicleFleetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateVehicleFleetOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateVehicleFleetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTFleetWiseClientTypes {
    public enum EncryptionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failure
        case pending
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionStatus] {
            return [
                .failure,
                .pending,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failure: return "FAILURE"
            case .pending: return "PENDING"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionStatus(rawValue: rawValue) ?? EncryptionStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTFleetWiseClientTypes {
    public enum EncryptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fleetwiseDefaultEncryption
        case kmsBasedEncryption
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionType] {
            return [
                .fleetwiseDefaultEncryption,
                .kmsBasedEncryption,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fleetwiseDefaultEncryption: return "FLEETWISE_DEFAULT_ENCRYPTION"
            case .kmsBasedEncryption: return "KMS_BASED_ENCRYPTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionType(rawValue: rawValue) ?? EncryptionType.sdkUnknown(rawValue)
        }
    }
}

extension IoTFleetWiseClientTypes.FleetSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case id
        case lastModificationTime
        case signalCatalogArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let signalCatalogArn = self.signalCatalogArn {
            try encodeContainer.encode(signalCatalogArn, forKey: .signalCatalogArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let signalCatalogArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signalCatalogArn)
        signalCatalogArn = signalCatalogArnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about a fleet. You can use the API operation to return this information about multiple fleets.
    public struct FleetSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the fleet.
        /// This member is required.
        public var arn: Swift.String?
        /// The time the fleet was created, in seconds since epoch (January 1, 1970 at midnight UTC time).
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// A brief description of the fleet.
        public var description: Swift.String?
        /// The unique ID of the fleet.
        /// This member is required.
        public var id: Swift.String?
        /// The time the fleet was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).
        public var lastModificationTime: ClientRuntime.Date?
        /// The ARN of the signal catalog associated with the fleet.
        /// This member is required.
        public var signalCatalogArn: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            signalCatalogArn: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.lastModificationTime = lastModificationTime
            self.signalCatalogArn = signalCatalogArn
        }
    }

}

extension IoTFleetWiseClientTypes.FormattedVss: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sdkUnknown
        case vssjson = "vssJson"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .vssjson(vssjson):
                try container.encode(vssjson, forKey: .vssjson)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let vssjsonDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .vssjson)
        if let vssjson = vssjsonDecoded {
            self = .vssjson(vssjson)
            return
        }
        self = .sdkUnknown("")
    }
}

extension IoTFleetWiseClientTypes {
    /// [Vehicle Signal Specification (VSS)](https://www.w3.org/auto/wg/wiki/Vehicle_Signal_Specification_(VSS)/Vehicle_Data_Spec) is a precise language used to describe and model signals in vehicle networks. The JSON file collects signal specificiations in a VSS format.
    public enum FormattedVss: Swift.Equatable {
        /// Provides the VSS in JSON format.
        case vssjson(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension GetCampaignInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetCampaignInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCampaignInput: Swift.Equatable {
    /// The name of the campaign to retrieve information about.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetCampaignInputBody: Swift.Equatable {
}

extension GetCampaignInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetCampaignOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCampaignOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.collectionScheme = output.collectionScheme
            self.compression = output.compression
            self.creationTime = output.creationTime
            self.dataDestinationConfigs = output.dataDestinationConfigs
            self.dataExtraDimensions = output.dataExtraDimensions
            self.description = output.description
            self.diagnosticsMode = output.diagnosticsMode
            self.expiryTime = output.expiryTime
            self.lastModificationTime = output.lastModificationTime
            self.name = output.name
            self.postTriggerCollectionDuration = output.postTriggerCollectionDuration
            self.priority = output.priority
            self.signalCatalogArn = output.signalCatalogArn
            self.signalsToCollect = output.signalsToCollect
            self.spoolingMode = output.spoolingMode
            self.startTime = output.startTime
            self.status = output.status
            self.targetArn = output.targetArn
        } else {
            self.arn = nil
            self.collectionScheme = nil
            self.compression = nil
            self.creationTime = nil
            self.dataDestinationConfigs = nil
            self.dataExtraDimensions = nil
            self.description = nil
            self.diagnosticsMode = nil
            self.expiryTime = nil
            self.lastModificationTime = nil
            self.name = nil
            self.postTriggerCollectionDuration = nil
            self.priority = nil
            self.signalCatalogArn = nil
            self.signalsToCollect = nil
            self.spoolingMode = nil
            self.startTime = nil
            self.status = nil
            self.targetArn = nil
        }
    }
}

public struct GetCampaignOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the campaign.
    public var arn: Swift.String?
    /// Information about the data collection scheme associated with the campaign.
    public var collectionScheme: IoTFleetWiseClientTypes.CollectionScheme?
    /// Whether to compress signals before transmitting data to Amazon Web Services IoT FleetWise. If OFF is specified, the signals aren't compressed. If it's not specified, SNAPPY is used.
    public var compression: IoTFleetWiseClientTypes.Compression?
    /// The time the campaign was created in seconds since epoch (January 1, 1970 at midnight UTC time).
    public var creationTime: ClientRuntime.Date?
    /// The destination where the campaign sends data. You can choose to send data to be stored in Amazon S3 or Amazon Timestream. Amazon S3 optimizes the cost of data storage and provides additional mechanisms to use vehicle data, such as data lakes, centralized data storage, data processing pipelines, and analytics. You can use Amazon Timestream to access and analyze time series data, and Timestream to query vehicle data so that you can identify trends and patterns.
    public var dataDestinationConfigs: [IoTFleetWiseClientTypes.DataDestinationConfig]?
    /// A list of vehicle attributes associated with the campaign.
    public var dataExtraDimensions: [Swift.String]?
    /// The description of the campaign.
    public var description: Swift.String?
    /// Option for a vehicle to send diagnostic trouble codes to Amazon Web Services IoT FleetWise.
    public var diagnosticsMode: IoTFleetWiseClientTypes.DiagnosticsMode?
    /// The time the campaign expires, in seconds since epoch (January 1, 1970 at midnight UTC time). Vehicle data won't be collected after the campaign expires.
    public var expiryTime: ClientRuntime.Date?
    /// The last time the campaign was modified.
    public var lastModificationTime: ClientRuntime.Date?
    /// The name of the campaign.
    public var name: Swift.String?
    /// How long (in seconds) to collect raw data after a triggering event initiates the collection.
    public var postTriggerCollectionDuration: Swift.Int?
    /// A number indicating the priority of one campaign over another campaign for a certain vehicle or fleet. A campaign with the lowest value is deployed to vehicles before any other campaigns.
    public var priority: Swift.Int?
    /// The ARN of a signal catalog.
    public var signalCatalogArn: Swift.String?
    /// Information about a list of signals to collect data on.
    public var signalsToCollect: [IoTFleetWiseClientTypes.SignalInformation]?
    /// Whether to store collected data after a vehicle lost a connection with the cloud. After a connection is re-established, the data is automatically forwarded to Amazon Web Services IoT FleetWise.
    public var spoolingMode: IoTFleetWiseClientTypes.SpoolingMode?
    /// The time, in milliseconds, to deliver a campaign after it was approved.
    public var startTime: ClientRuntime.Date?
    /// The state of the campaign. The status can be one of: CREATING, WAITING_FOR_APPROVAL, RUNNING, and SUSPENDED.
    public var status: IoTFleetWiseClientTypes.CampaignStatus?
    /// The ARN of the vehicle or the fleet targeted by the campaign.
    public var targetArn: Swift.String?

    public init(
        arn: Swift.String? = nil,
        collectionScheme: IoTFleetWiseClientTypes.CollectionScheme? = nil,
        compression: IoTFleetWiseClientTypes.Compression? = nil,
        creationTime: ClientRuntime.Date? = nil,
        dataDestinationConfigs: [IoTFleetWiseClientTypes.DataDestinationConfig]? = nil,
        dataExtraDimensions: [Swift.String]? = nil,
        description: Swift.String? = nil,
        diagnosticsMode: IoTFleetWiseClientTypes.DiagnosticsMode? = nil,
        expiryTime: ClientRuntime.Date? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        postTriggerCollectionDuration: Swift.Int? = nil,
        priority: Swift.Int? = nil,
        signalCatalogArn: Swift.String? = nil,
        signalsToCollect: [IoTFleetWiseClientTypes.SignalInformation]? = nil,
        spoolingMode: IoTFleetWiseClientTypes.SpoolingMode? = nil,
        startTime: ClientRuntime.Date? = nil,
        status: IoTFleetWiseClientTypes.CampaignStatus? = nil,
        targetArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.collectionScheme = collectionScheme
        self.compression = compression
        self.creationTime = creationTime
        self.dataDestinationConfigs = dataDestinationConfigs
        self.dataExtraDimensions = dataExtraDimensions
        self.description = description
        self.diagnosticsMode = diagnosticsMode
        self.expiryTime = expiryTime
        self.lastModificationTime = lastModificationTime
        self.name = name
        self.postTriggerCollectionDuration = postTriggerCollectionDuration
        self.priority = priority
        self.signalCatalogArn = signalCatalogArn
        self.signalsToCollect = signalsToCollect
        self.spoolingMode = spoolingMode
        self.startTime = startTime
        self.status = status
        self.targetArn = targetArn
    }
}

struct GetCampaignOutputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let description: Swift.String?
    let signalCatalogArn: Swift.String?
    let targetArn: Swift.String?
    let status: IoTFleetWiseClientTypes.CampaignStatus?
    let startTime: ClientRuntime.Date?
    let expiryTime: ClientRuntime.Date?
    let postTriggerCollectionDuration: Swift.Int?
    let diagnosticsMode: IoTFleetWiseClientTypes.DiagnosticsMode?
    let spoolingMode: IoTFleetWiseClientTypes.SpoolingMode?
    let compression: IoTFleetWiseClientTypes.Compression?
    let priority: Swift.Int?
    let signalsToCollect: [IoTFleetWiseClientTypes.SignalInformation]?
    let collectionScheme: IoTFleetWiseClientTypes.CollectionScheme?
    let dataExtraDimensions: [Swift.String]?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
    let dataDestinationConfigs: [IoTFleetWiseClientTypes.DataDestinationConfig]?
}

extension GetCampaignOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case collectionScheme
        case compression
        case creationTime
        case dataDestinationConfigs
        case dataExtraDimensions
        case description
        case diagnosticsMode
        case expiryTime
        case lastModificationTime
        case name
        case postTriggerCollectionDuration
        case priority
        case signalCatalogArn
        case signalsToCollect
        case spoolingMode
        case startTime
        case status
        case targetArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let signalCatalogArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signalCatalogArn)
        signalCatalogArn = signalCatalogArnDecoded
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.CampaignStatus.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let expiryTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expiryTime)
        expiryTime = expiryTimeDecoded
        let postTriggerCollectionDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .postTriggerCollectionDuration)
        postTriggerCollectionDuration = postTriggerCollectionDurationDecoded
        let diagnosticsModeDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.DiagnosticsMode.self, forKey: .diagnosticsMode)
        diagnosticsMode = diagnosticsModeDecoded
        let spoolingModeDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.SpoolingMode.self, forKey: .spoolingMode)
        spoolingMode = spoolingModeDecoded
        let compressionDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.Compression.self, forKey: .compression)
        compression = compressionDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let signalsToCollectContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.SignalInformation?].self, forKey: .signalsToCollect)
        var signalsToCollectDecoded0:[IoTFleetWiseClientTypes.SignalInformation]? = nil
        if let signalsToCollectContainer = signalsToCollectContainer {
            signalsToCollectDecoded0 = [IoTFleetWiseClientTypes.SignalInformation]()
            for structure0 in signalsToCollectContainer {
                if let structure0 = structure0 {
                    signalsToCollectDecoded0?.append(structure0)
                }
            }
        }
        signalsToCollect = signalsToCollectDecoded0
        let collectionSchemeDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.CollectionScheme.self, forKey: .collectionScheme)
        collectionScheme = collectionSchemeDecoded
        let dataExtraDimensionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dataExtraDimensions)
        var dataExtraDimensionsDecoded0:[Swift.String]? = nil
        if let dataExtraDimensionsContainer = dataExtraDimensionsContainer {
            dataExtraDimensionsDecoded0 = [Swift.String]()
            for string0 in dataExtraDimensionsContainer {
                if let string0 = string0 {
                    dataExtraDimensionsDecoded0?.append(string0)
                }
            }
        }
        dataExtraDimensions = dataExtraDimensionsDecoded0
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
        let dataDestinationConfigsContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.DataDestinationConfig?].self, forKey: .dataDestinationConfigs)
        var dataDestinationConfigsDecoded0:[IoTFleetWiseClientTypes.DataDestinationConfig]? = nil
        if let dataDestinationConfigsContainer = dataDestinationConfigsContainer {
            dataDestinationConfigsDecoded0 = [IoTFleetWiseClientTypes.DataDestinationConfig]()
            for union0 in dataDestinationConfigsContainer {
                if let union0 = union0 {
                    dataDestinationConfigsDecoded0?.append(union0)
                }
            }
        }
        dataDestinationConfigs = dataDestinationConfigsDecoded0
    }
}

enum GetCampaignOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDecoderManifestInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetDecoderManifestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetDecoderManifestInput: Swift.Equatable {
    /// The name of the decoder manifest to retrieve information about.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetDecoderManifestInputBody: Swift.Equatable {
}

extension GetDecoderManifestInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDecoderManifestOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDecoderManifestOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.description = output.description
            self.lastModificationTime = output.lastModificationTime
            self.modelManifestArn = output.modelManifestArn
            self.name = output.name
            self.status = output.status
        } else {
            self.arn = nil
            self.creationTime = nil
            self.description = nil
            self.lastModificationTime = nil
            self.modelManifestArn = nil
            self.name = nil
            self.status = nil
        }
    }
}

public struct GetDecoderManifestOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the decoder manifest.
    /// This member is required.
    public var arn: Swift.String?
    /// The time the decoder manifest was created in seconds since epoch (January 1, 1970 at midnight UTC time).
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// A brief description of the decoder manifest.
    public var description: Swift.String?
    /// The time the decoder manifest was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).
    /// This member is required.
    public var lastModificationTime: ClientRuntime.Date?
    /// The ARN of a vehicle model (model manifest) associated with the decoder manifest.
    public var modelManifestArn: Swift.String?
    /// The name of the decoder manifest.
    /// This member is required.
    public var name: Swift.String?
    /// The state of the decoder manifest. If the status is ACTIVE, the decoder manifest can't be edited. If the status is marked DRAFT, you can edit the decoder manifest.
    public var status: IoTFleetWiseClientTypes.ManifestStatus?

    public init(
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        modelManifestArn: Swift.String? = nil,
        name: Swift.String? = nil,
        status: IoTFleetWiseClientTypes.ManifestStatus? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.lastModificationTime = lastModificationTime
        self.modelManifestArn = modelManifestArn
        self.name = name
        self.status = status
    }
}

struct GetDecoderManifestOutputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let description: Swift.String?
    let modelManifestArn: Swift.String?
    let status: IoTFleetWiseClientTypes.ManifestStatus?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
}

extension GetDecoderManifestOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case lastModificationTime
        case modelManifestArn
        case name
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let modelManifestArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelManifestArn)
        modelManifestArn = modelManifestArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.ManifestStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

enum GetDecoderManifestOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEncryptionConfigurationInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetEncryptionConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetEncryptionConfigurationInput: Swift.Equatable {

    public init() { }
}

struct GetEncryptionConfigurationInputBody: Swift.Equatable {
}

extension GetEncryptionConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetEncryptionConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEncryptionConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.encryptionStatus = output.encryptionStatus
            self.encryptionType = output.encryptionType
            self.errorMessage = output.errorMessage
            self.kmsKeyId = output.kmsKeyId
            self.lastModificationTime = output.lastModificationTime
        } else {
            self.creationTime = nil
            self.encryptionStatus = nil
            self.encryptionType = nil
            self.errorMessage = nil
            self.kmsKeyId = nil
            self.lastModificationTime = nil
        }
    }
}

public struct GetEncryptionConfigurationOutput: Swift.Equatable {
    /// The time when encryption was configured in seconds since epoch (January 1, 1970 at midnight UTC time).
    public var creationTime: ClientRuntime.Date?
    /// The encryption status.
    /// This member is required.
    public var encryptionStatus: IoTFleetWiseClientTypes.EncryptionStatus?
    /// The type of encryption. Set to KMS_BASED_ENCRYPTION to use an KMS key that you own and manage. Set to FLEETWISE_DEFAULT_ENCRYPTION to use an Amazon Web Services managed key that is owned by the Amazon Web Services IoT FleetWise service account.
    /// This member is required.
    public var encryptionType: IoTFleetWiseClientTypes.EncryptionType?
    /// The error message that describes why encryption settings couldn't be configured, if applicable.
    public var errorMessage: Swift.String?
    /// The ID of the KMS key that is used for encryption.
    public var kmsKeyId: Swift.String?
    /// The time when encryption was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).
    public var lastModificationTime: ClientRuntime.Date?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        encryptionStatus: IoTFleetWiseClientTypes.EncryptionStatus? = nil,
        encryptionType: IoTFleetWiseClientTypes.EncryptionType? = nil,
        errorMessage: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        lastModificationTime: ClientRuntime.Date? = nil
    )
    {
        self.creationTime = creationTime
        self.encryptionStatus = encryptionStatus
        self.encryptionType = encryptionType
        self.errorMessage = errorMessage
        self.kmsKeyId = kmsKeyId
        self.lastModificationTime = lastModificationTime
    }
}

struct GetEncryptionConfigurationOutputBody: Swift.Equatable {
    let kmsKeyId: Swift.String?
    let encryptionStatus: IoTFleetWiseClientTypes.EncryptionStatus?
    let encryptionType: IoTFleetWiseClientTypes.EncryptionType?
    let errorMessage: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
}

extension GetEncryptionConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case encryptionStatus
        case encryptionType
        case errorMessage
        case kmsKeyId
        case lastModificationTime
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let encryptionStatusDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.EncryptionStatus.self, forKey: .encryptionStatus)
        encryptionStatus = encryptionStatusDecoded
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

enum GetEncryptionConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFleetInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetFleetInput: Swift.Equatable {
    /// The ID of the fleet to retrieve information about.
    /// This member is required.
    public var fleetId: Swift.String?

    public init(
        fleetId: Swift.String? = nil
    )
    {
        self.fleetId = fleetId
    }
}

struct GetFleetInputBody: Swift.Equatable {
}

extension GetFleetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetFleetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFleetOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.description = output.description
            self.id = output.id
            self.lastModificationTime = output.lastModificationTime
            self.signalCatalogArn = output.signalCatalogArn
        } else {
            self.arn = nil
            self.creationTime = nil
            self.description = nil
            self.id = nil
            self.lastModificationTime = nil
            self.signalCatalogArn = nil
        }
    }
}

public struct GetFleetOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var arn: Swift.String?
    /// The time the fleet was created in seconds since epoch (January 1, 1970 at midnight UTC time).
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// A brief description of the fleet.
    public var description: Swift.String?
    /// The ID of the fleet.
    /// This member is required.
    public var id: Swift.String?
    /// The time the fleet was last updated, in seconds since epoch (January 1, 1970 at midnight UTC time).
    /// This member is required.
    public var lastModificationTime: ClientRuntime.Date?
    /// The ARN of a signal catalog associated with the fleet.
    /// This member is required.
    public var signalCatalogArn: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        signalCatalogArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.lastModificationTime = lastModificationTime
        self.signalCatalogArn = signalCatalogArn
    }
}

struct GetFleetOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let description: Swift.String?
    let signalCatalogArn: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
}

extension GetFleetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case id
        case lastModificationTime
        case signalCatalogArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let signalCatalogArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signalCatalogArn)
        signalCatalogArn = signalCatalogArnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

enum GetFleetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLoggingOptionsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetLoggingOptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetLoggingOptionsInput: Swift.Equatable {

    public init() { }
}

struct GetLoggingOptionsInputBody: Swift.Equatable {
}

extension GetLoggingOptionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetLoggingOptionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLoggingOptionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.cloudWatchLogDelivery = output.cloudWatchLogDelivery
        } else {
            self.cloudWatchLogDelivery = nil
        }
    }
}

public struct GetLoggingOptionsOutput: Swift.Equatable {
    /// Returns information about log delivery to Amazon CloudWatch Logs.
    /// This member is required.
    public var cloudWatchLogDelivery: IoTFleetWiseClientTypes.CloudWatchLogDeliveryOptions?

    public init(
        cloudWatchLogDelivery: IoTFleetWiseClientTypes.CloudWatchLogDeliveryOptions? = nil
    )
    {
        self.cloudWatchLogDelivery = cloudWatchLogDelivery
    }
}

struct GetLoggingOptionsOutputBody: Swift.Equatable {
    let cloudWatchLogDelivery: IoTFleetWiseClientTypes.CloudWatchLogDeliveryOptions?
}

extension GetLoggingOptionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogDelivery
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLogDeliveryDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.CloudWatchLogDeliveryOptions.self, forKey: .cloudWatchLogDelivery)
        cloudWatchLogDelivery = cloudWatchLogDeliveryDecoded
    }
}

enum GetLoggingOptionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetModelManifestInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetModelManifestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetModelManifestInput: Swift.Equatable {
    /// The name of the vehicle model to retrieve information about.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetModelManifestInputBody: Swift.Equatable {
}

extension GetModelManifestInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetModelManifestOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetModelManifestOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.description = output.description
            self.lastModificationTime = output.lastModificationTime
            self.name = output.name
            self.signalCatalogArn = output.signalCatalogArn
            self.status = output.status
        } else {
            self.arn = nil
            self.creationTime = nil
            self.description = nil
            self.lastModificationTime = nil
            self.name = nil
            self.signalCatalogArn = nil
            self.status = nil
        }
    }
}

public struct GetModelManifestOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the vehicle model.
    /// This member is required.
    public var arn: Swift.String?
    /// The time the vehicle model was created, in seconds since epoch (January 1, 1970 at midnight UTC time).
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// A brief description of the vehicle model.
    public var description: Swift.String?
    /// The last time the vehicle model was modified.
    /// This member is required.
    public var lastModificationTime: ClientRuntime.Date?
    /// The name of the vehicle model.
    /// This member is required.
    public var name: Swift.String?
    /// The ARN of the signal catalog associated with the vehicle model.
    public var signalCatalogArn: Swift.String?
    /// The state of the vehicle model. If the status is ACTIVE, the vehicle model can't be edited. You can edit the vehicle model if the status is marked DRAFT.
    public var status: IoTFleetWiseClientTypes.ManifestStatus?

    public init(
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        signalCatalogArn: Swift.String? = nil,
        status: IoTFleetWiseClientTypes.ManifestStatus? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.lastModificationTime = lastModificationTime
        self.name = name
        self.signalCatalogArn = signalCatalogArn
        self.status = status
    }
}

struct GetModelManifestOutputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let description: Swift.String?
    let signalCatalogArn: Swift.String?
    let status: IoTFleetWiseClientTypes.ManifestStatus?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
}

extension GetModelManifestOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case lastModificationTime
        case name
        case signalCatalogArn
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let signalCatalogArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signalCatalogArn)
        signalCatalogArn = signalCatalogArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.ManifestStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

enum GetModelManifestOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRegisterAccountStatusInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetRegisterAccountStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetRegisterAccountStatusInput: Swift.Equatable {

    public init() { }
}

struct GetRegisterAccountStatusInputBody: Swift.Equatable {
}

extension GetRegisterAccountStatusInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRegisterAccountStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRegisterAccountStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountStatus = output.accountStatus
            self.creationTime = output.creationTime
            self.customerAccountId = output.customerAccountId
            self.iamRegistrationResponse = output.iamRegistrationResponse
            self.lastModificationTime = output.lastModificationTime
            self.timestreamRegistrationResponse = output.timestreamRegistrationResponse
        } else {
            self.accountStatus = nil
            self.creationTime = nil
            self.customerAccountId = nil
            self.iamRegistrationResponse = nil
            self.lastModificationTime = nil
            self.timestreamRegistrationResponse = nil
        }
    }
}

public struct GetRegisterAccountStatusOutput: Swift.Equatable {
    /// The status of registering your account and resources. The status can be one of:
    ///
    /// * REGISTRATION_SUCCESS - The Amazon Web Services resource is successfully registered.
    ///
    /// * REGISTRATION_PENDING - Amazon Web Services IoT FleetWise is processing the registration request. This process takes approximately five minutes to complete.
    ///
    /// * REGISTRATION_FAILURE - Amazon Web Services IoT FleetWise can't register the AWS resource. Try again later.
    /// This member is required.
    public var accountStatus: IoTFleetWiseClientTypes.RegistrationStatus?
    /// The time the account was registered, in seconds since epoch (January 1, 1970 at midnight UTC time).
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The unique ID of the Amazon Web Services account, provided at account creation.
    /// This member is required.
    public var customerAccountId: Swift.String?
    /// Information about the registered IAM resources or errors, if any.
    /// This member is required.
    public var iamRegistrationResponse: IoTFleetWiseClientTypes.IamRegistrationResponse?
    /// The time this registration was last updated, in seconds since epoch (January 1, 1970 at midnight UTC time).
    /// This member is required.
    public var lastModificationTime: ClientRuntime.Date?
    /// Information about the registered Amazon Timestream resources or errors, if any.
    public var timestreamRegistrationResponse: IoTFleetWiseClientTypes.TimestreamRegistrationResponse?

    public init(
        accountStatus: IoTFleetWiseClientTypes.RegistrationStatus? = nil,
        creationTime: ClientRuntime.Date? = nil,
        customerAccountId: Swift.String? = nil,
        iamRegistrationResponse: IoTFleetWiseClientTypes.IamRegistrationResponse? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        timestreamRegistrationResponse: IoTFleetWiseClientTypes.TimestreamRegistrationResponse? = nil
    )
    {
        self.accountStatus = accountStatus
        self.creationTime = creationTime
        self.customerAccountId = customerAccountId
        self.iamRegistrationResponse = iamRegistrationResponse
        self.lastModificationTime = lastModificationTime
        self.timestreamRegistrationResponse = timestreamRegistrationResponse
    }
}

struct GetRegisterAccountStatusOutputBody: Swift.Equatable {
    let customerAccountId: Swift.String?
    let accountStatus: IoTFleetWiseClientTypes.RegistrationStatus?
    let timestreamRegistrationResponse: IoTFleetWiseClientTypes.TimestreamRegistrationResponse?
    let iamRegistrationResponse: IoTFleetWiseClientTypes.IamRegistrationResponse?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
}

extension GetRegisterAccountStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountStatus
        case creationTime
        case customerAccountId
        case iamRegistrationResponse
        case lastModificationTime
        case timestreamRegistrationResponse
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerAccountId)
        customerAccountId = customerAccountIdDecoded
        let accountStatusDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.RegistrationStatus.self, forKey: .accountStatus)
        accountStatus = accountStatusDecoded
        let timestreamRegistrationResponseDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.TimestreamRegistrationResponse.self, forKey: .timestreamRegistrationResponse)
        timestreamRegistrationResponse = timestreamRegistrationResponseDecoded
        let iamRegistrationResponseDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.IamRegistrationResponse.self, forKey: .iamRegistrationResponse)
        iamRegistrationResponse = iamRegistrationResponseDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

enum GetRegisterAccountStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSignalCatalogInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetSignalCatalogInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSignalCatalogInput: Swift.Equatable {
    /// The name of the signal catalog to retrieve information about.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetSignalCatalogInputBody: Swift.Equatable {
}

extension GetSignalCatalogInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSignalCatalogOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSignalCatalogOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.description = output.description
            self.lastModificationTime = output.lastModificationTime
            self.name = output.name
            self.nodeCounts = output.nodeCounts
        } else {
            self.arn = nil
            self.creationTime = nil
            self.description = nil
            self.lastModificationTime = nil
            self.name = nil
            self.nodeCounts = nil
        }
    }
}

public struct GetSignalCatalogOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the signal catalog.
    /// This member is required.
    public var arn: Swift.String?
    /// The time the signal catalog was created in seconds since epoch (January 1, 1970 at midnight UTC time).
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// A brief description of the signal catalog.
    public var description: Swift.String?
    /// The last time the signal catalog was modified.
    /// This member is required.
    public var lastModificationTime: ClientRuntime.Date?
    /// The name of the signal catalog.
    /// This member is required.
    public var name: Swift.String?
    /// The total number of network nodes specified in a signal catalog.
    public var nodeCounts: IoTFleetWiseClientTypes.NodeCounts?

    public init(
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        nodeCounts: IoTFleetWiseClientTypes.NodeCounts? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.lastModificationTime = lastModificationTime
        self.name = name
        self.nodeCounts = nodeCounts
    }
}

struct GetSignalCatalogOutputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let description: Swift.String?
    let nodeCounts: IoTFleetWiseClientTypes.NodeCounts?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
}

extension GetSignalCatalogOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case lastModificationTime
        case name
        case nodeCounts
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nodeCountsDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.NodeCounts.self, forKey: .nodeCounts)
        nodeCounts = nodeCountsDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

enum GetSignalCatalogOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVehicleInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetVehicleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetVehicleInput: Swift.Equatable {
    /// The ID of the vehicle to retrieve information about.
    /// This member is required.
    public var vehicleName: Swift.String?

    public init(
        vehicleName: Swift.String? = nil
    )
    {
        self.vehicleName = vehicleName
    }
}

struct GetVehicleInputBody: Swift.Equatable {
}

extension GetVehicleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetVehicleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVehicleOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.attributes = output.attributes
            self.creationTime = output.creationTime
            self.decoderManifestArn = output.decoderManifestArn
            self.lastModificationTime = output.lastModificationTime
            self.modelManifestArn = output.modelManifestArn
            self.vehicleName = output.vehicleName
        } else {
            self.arn = nil
            self.attributes = nil
            self.creationTime = nil
            self.decoderManifestArn = nil
            self.lastModificationTime = nil
            self.modelManifestArn = nil
            self.vehicleName = nil
        }
    }
}

public struct GetVehicleOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the vehicle to retrieve information about.
    public var arn: Swift.String?
    /// Static information about a vehicle in a key-value pair. For example: "engineType" : "1.3 L R2"
    public var attributes: [Swift.String:Swift.String]?
    /// The time the vehicle was created in seconds since epoch (January 1, 1970 at midnight UTC time).
    public var creationTime: ClientRuntime.Date?
    /// The ARN of a decoder manifest associated with the vehicle.
    public var decoderManifestArn: Swift.String?
    /// The time the vehicle was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).
    public var lastModificationTime: ClientRuntime.Date?
    /// The ARN of a vehicle model (model manifest) associated with the vehicle.
    public var modelManifestArn: Swift.String?
    /// The ID of the vehicle.
    public var vehicleName: Swift.String?

    public init(
        arn: Swift.String? = nil,
        attributes: [Swift.String:Swift.String]? = nil,
        creationTime: ClientRuntime.Date? = nil,
        decoderManifestArn: Swift.String? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        modelManifestArn: Swift.String? = nil,
        vehicleName: Swift.String? = nil
    )
    {
        self.arn = arn
        self.attributes = attributes
        self.creationTime = creationTime
        self.decoderManifestArn = decoderManifestArn
        self.lastModificationTime = lastModificationTime
        self.modelManifestArn = modelManifestArn
        self.vehicleName = vehicleName
    }
}

struct GetVehicleOutputBody: Swift.Equatable {
    let vehicleName: Swift.String?
    let arn: Swift.String?
    let modelManifestArn: Swift.String?
    let decoderManifestArn: Swift.String?
    let attributes: [Swift.String:Swift.String]?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
}

extension GetVehicleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case attributes
        case creationTime
        case decoderManifestArn
        case lastModificationTime
        case modelManifestArn
        case vehicleName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vehicleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vehicleName)
        vehicleName = vehicleNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let modelManifestArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelManifestArn)
        modelManifestArn = modelManifestArnDecoded
        let decoderManifestArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .decoderManifestArn)
        decoderManifestArn = decoderManifestArnDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

enum GetVehicleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVehicleStatusInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetVehicleStatusInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension GetVehicleStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetVehicleStatusInput: Swift.Equatable {
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?
    /// The ID of the vehicle to retrieve information about.
    /// This member is required.
    public var vehicleName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        vehicleName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.vehicleName = vehicleName
    }
}

struct GetVehicleStatusInputBody: Swift.Equatable {
}

extension GetVehicleStatusInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetVehicleStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVehicleStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.campaigns = output.campaigns
            self.nextToken = output.nextToken
        } else {
            self.campaigns = nil
            self.nextToken = nil
        }
    }
}

public struct GetVehicleStatusOutput: Swift.Equatable {
    /// Lists information about the state of the vehicle with deployed campaigns.
    public var campaigns: [IoTFleetWiseClientTypes.VehicleStatus]?
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        campaigns: [IoTFleetWiseClientTypes.VehicleStatus]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.campaigns = campaigns
        self.nextToken = nextToken
    }
}

struct GetVehicleStatusOutputBody: Swift.Equatable {
    let campaigns: [IoTFleetWiseClientTypes.VehicleStatus]?
    let nextToken: Swift.String?
}

extension GetVehicleStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaigns
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignsContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.VehicleStatus?].self, forKey: .campaigns)
        var campaignsDecoded0:[IoTFleetWiseClientTypes.VehicleStatus]? = nil
        if let campaignsContainer = campaignsContainer {
            campaignsDecoded0 = [IoTFleetWiseClientTypes.VehicleStatus]()
            for structure0 in campaignsContainer {
                if let structure0 = structure0 {
                    campaignsDecoded0?.append(structure0)
                }
            }
        }
        campaigns = campaignsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetVehicleStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTFleetWiseClientTypes.IamRegistrationResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorMessage
        case registrationStatus
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let registrationStatus = self.registrationStatus {
            try encodeContainer.encode(registrationStatus.rawValue, forKey: .registrationStatus)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let registrationStatusDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.RegistrationStatus.self, forKey: .registrationStatus)
        registrationStatus = registrationStatusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about registering an Identity and Access Management (IAM) resource so Amazon Web Services IoT FleetWise edge agent software can transfer your vehicle data to Amazon Timestream.
    public struct IamRegistrationResponse: Swift.Equatable {
        /// A message associated with a registration error.
        public var errorMessage: Swift.String?
        /// The status of registering your IAM resource. The status can be one of REGISTRATION_SUCCESS, REGISTRATION_PENDING, REGISTRATION_FAILURE.
        /// This member is required.
        public var registrationStatus: IoTFleetWiseClientTypes.RegistrationStatus?
        /// The Amazon Resource Name (ARN) of the IAM role to register.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            errorMessage: Swift.String? = nil,
            registrationStatus: IoTFleetWiseClientTypes.RegistrationStatus? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.errorMessage = errorMessage
            self.registrationStatus = registrationStatus
            self.roleArn = roleArn
        }
    }

}

extension IoTFleetWiseClientTypes.IamResources: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// The IAM resource that enables Amazon Web Services IoT FleetWise edge agent software to send data to Amazon Timestream. For more information, see [IAM roles](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html) in the Identity and Access Management User Guide.
    public struct IamResources: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the IAM resource that allows Amazon Web Services IoT FleetWise to send data to Amazon Timestream. For example, arn:aws:iam::123456789012:role/SERVICE-ROLE-ARN.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            roleArn: Swift.String? = nil
        )
        {
            self.roleArn = roleArn
        }
    }

}

extension ImportDecoderManifestInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkFileDefinitions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let networkFileDefinitions = networkFileDefinitions {
            var networkFileDefinitionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkFileDefinitions)
            for networkfiledefinition0 in networkFileDefinitions {
                try networkFileDefinitionsContainer.encode(networkfiledefinition0)
            }
        }
    }
}

extension ImportDecoderManifestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ImportDecoderManifestInput: Swift.Equatable {
    /// The name of the decoder manifest to import.
    /// This member is required.
    public var name: Swift.String?
    /// The file to load into an Amazon Web Services account.
    /// This member is required.
    public var networkFileDefinitions: [IoTFleetWiseClientTypes.NetworkFileDefinition]?

    public init(
        name: Swift.String? = nil,
        networkFileDefinitions: [IoTFleetWiseClientTypes.NetworkFileDefinition]? = nil
    )
    {
        self.name = name
        self.networkFileDefinitions = networkFileDefinitions
    }
}

struct ImportDecoderManifestInputBody: Swift.Equatable {
    let networkFileDefinitions: [IoTFleetWiseClientTypes.NetworkFileDefinition]?
}

extension ImportDecoderManifestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkFileDefinitions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkFileDefinitionsContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.NetworkFileDefinition?].self, forKey: .networkFileDefinitions)
        var networkFileDefinitionsDecoded0:[IoTFleetWiseClientTypes.NetworkFileDefinition]? = nil
        if let networkFileDefinitionsContainer = networkFileDefinitionsContainer {
            networkFileDefinitionsDecoded0 = [IoTFleetWiseClientTypes.NetworkFileDefinition]()
            for union0 in networkFileDefinitionsContainer {
                if let union0 = union0 {
                    networkFileDefinitionsDecoded0?.append(union0)
                }
            }
        }
        networkFileDefinitions = networkFileDefinitionsDecoded0
    }
}

extension ImportDecoderManifestOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ImportDecoderManifestOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct ImportDecoderManifestOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the decoder manifest that was imported.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the imported decoder manifest.
    /// This member is required.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct ImportDecoderManifestOutputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
}

extension ImportDecoderManifestOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum ImportDecoderManifestOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DecoderManifestValidationException": return try await DecoderManifestValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidSignalsException": return try await InvalidSignalsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ImportSignalCatalogInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case tags
        case vss
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let vss = self.vss {
            try encodeContainer.encode(vss, forKey: .vss)
        }
    }
}

extension ImportSignalCatalogInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ImportSignalCatalogInput: Swift.Equatable {
    /// A brief description of the signal catalog.
    public var description: Swift.String?
    /// The name of the signal catalog to import.
    /// This member is required.
    public var name: Swift.String?
    /// Metadata that can be used to manage the signal catalog.
    public var tags: [IoTFleetWiseClientTypes.Tag]?
    /// The contents of the Vehicle Signal Specification (VSS) configuration. VSS is a precise language used to describe and model signals in vehicle networks.
    public var vss: IoTFleetWiseClientTypes.FormattedVss?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [IoTFleetWiseClientTypes.Tag]? = nil,
        vss: IoTFleetWiseClientTypes.FormattedVss? = nil
    )
    {
        self.description = description
        self.name = name
        self.tags = tags
        self.vss = vss
    }
}

struct ImportSignalCatalogInputBody: Swift.Equatable {
    let description: Swift.String?
    let vss: IoTFleetWiseClientTypes.FormattedVss?
    let tags: [IoTFleetWiseClientTypes.Tag]?
}

extension ImportSignalCatalogInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case tags
        case vss
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let vssDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.FormattedVss.self, forKey: .vss)
        vss = vssDecoded
        let tagsContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTFleetWiseClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTFleetWiseClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImportSignalCatalogOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ImportSignalCatalogOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct ImportSignalCatalogOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the imported signal catalog.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the imported signal catalog.
    /// This member is required.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct ImportSignalCatalogOutputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
}

extension ImportSignalCatalogOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum ImportSignalCatalogOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidSignalsException": return try await InvalidSignalsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = 0
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request couldn't be completed because the server temporarily failed.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The number of seconds to wait before retrying the command.
        public internal(set) var retryAfterSeconds: Swift.Int = 0
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTFleetWiseClientTypes.InvalidNetworkInterface: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interfaceId
        case reason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let interfaceId = self.interfaceId {
            try encodeContainer.encode(interfaceId, forKey: .interfaceId)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let interfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .interfaceId)
        interfaceId = interfaceIdDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.NetworkInterfaceFailureReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// A reason a vehicle network interface isn't valid.
    public struct InvalidNetworkInterface: Swift.Equatable {
        /// The ID of the interface that isn't valid.
        public var interfaceId: Swift.String?
        /// A message about why the interface isn't valid.
        public var reason: IoTFleetWiseClientTypes.NetworkInterfaceFailureReason?

        public init(
            interfaceId: Swift.String? = nil,
            reason: IoTFleetWiseClientTypes.NetworkInterfaceFailureReason? = nil
        )
        {
            self.interfaceId = interfaceId
            self.reason = reason
        }
    }

}

extension InvalidNodeException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidNodeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.invalidNodes = output.invalidNodes
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.invalidNodes = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified node type doesn't match the expected node type for a node. You can specify the node type as branch, sensor, actuator, or attribute.
public struct InvalidNodeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The specified node type isn't valid.
        public internal(set) var invalidNodes: [IoTFleetWiseClientTypes.Node]? = nil
        public internal(set) var message: Swift.String? = nil
        /// The reason the node validation failed.
        public internal(set) var reason: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNodeException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        invalidNodes: [IoTFleetWiseClientTypes.Node]? = nil,
        message: Swift.String? = nil,
        reason: Swift.String? = nil
    )
    {
        self.properties.invalidNodes = invalidNodes
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct InvalidNodeExceptionBody: Swift.Equatable {
    let invalidNodes: [IoTFleetWiseClientTypes.Node]?
    let reason: Swift.String?
    let message: Swift.String?
}

extension InvalidNodeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidNodes
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidNodesContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.Node?].self, forKey: .invalidNodes)
        var invalidNodesDecoded0:[IoTFleetWiseClientTypes.Node]? = nil
        if let invalidNodesContainer = invalidNodesContainer {
            invalidNodesDecoded0 = [IoTFleetWiseClientTypes.Node]()
            for union0 in invalidNodesContainer {
                if let union0 = union0 {
                    invalidNodesDecoded0?.append(union0)
                }
            }
        }
        invalidNodes = invalidNodesDecoded0
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTFleetWiseClientTypes.InvalidSignal: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case reason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// A reason that a signal isn't valid.
    public struct InvalidSignal: Swift.Equatable {
        /// The name of the signal that isn't valid.
        public var name: Swift.String?
        /// A message about why the signal isn't valid.
        public var reason: Swift.String?

        public init(
            name: Swift.String? = nil,
            reason: Swift.String? = nil
        )
        {
            self.name = name
            self.reason = reason
        }
    }

}

extension IoTFleetWiseClientTypes.InvalidSignalDecoder: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case reason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.SignalDecoderFailureReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// A reason that a signal decoder isn't valid.
    public struct InvalidSignalDecoder: Swift.Equatable {
        /// The name of a signal decoder that isn't valid.
        public var name: Swift.String?
        /// A message about why the signal decoder isn't valid.
        public var reason: IoTFleetWiseClientTypes.SignalDecoderFailureReason?

        public init(
            name: Swift.String? = nil,
            reason: IoTFleetWiseClientTypes.SignalDecoderFailureReason? = nil
        )
        {
            self.name = name
            self.reason = reason
        }
    }

}

extension InvalidSignalsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidSignalsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.invalidSignals = output.invalidSignals
            self.properties.message = output.message
        } else {
            self.properties.invalidSignals = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request couldn't be completed because it contains signals that aren't valid.
public struct InvalidSignalsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The signals which caused the exception.
        public internal(set) var invalidSignals: [IoTFleetWiseClientTypes.InvalidSignal]? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSignalsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        invalidSignals: [IoTFleetWiseClientTypes.InvalidSignal]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.invalidSignals = invalidSignals
        self.properties.message = message
    }
}

struct InvalidSignalsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let invalidSignals: [IoTFleetWiseClientTypes.InvalidSignal]?
}

extension InvalidSignalsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidSignals
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let invalidSignalsContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.InvalidSignal?].self, forKey: .invalidSignals)
        var invalidSignalsDecoded0:[IoTFleetWiseClientTypes.InvalidSignal]? = nil
        if let invalidSignalsContainer = invalidSignalsContainer {
            invalidSignalsDecoded0 = [IoTFleetWiseClientTypes.InvalidSignal]()
            for structure0 in invalidSignalsContainer {
                if let structure0 = structure0 {
                    invalidSignalsDecoded0?.append(structure0)
                }
            }
        }
        invalidSignals = invalidSignalsDecoded0
    }
}

extension IoTFleetWiseClientTypes {
    static func makeServiceError(_ httpResponse: ClientRuntime.HttpResponse, _ decoder: ClientRuntime.ResponseDecoder? = nil, _ error: AWSClientRuntime.RestJSONError, _ id: String?) async throws -> Swift.Error? {
        switch error.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: error.errorMessage, requestID: id)
            default: return nil
        }
    }
}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A service quota was exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the resource that was exceeded.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource that was exceeded.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ListCampaignsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListCampaignsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListCampaignsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListCampaignsInput: Swift.Equatable {
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?
    /// Optional parameter to filter the results by the status of each created campaign in your account. The status can be one of: CREATING, WAITING_FOR_APPROVAL, RUNNING, or SUSPENDED.
    public var status: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

struct ListCampaignsInputBody: Swift.Equatable {
}

extension ListCampaignsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListCampaignsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCampaignsOutputBody = try responseDecoder.decode(responseBody: data)
            self.campaignSummaries = output.campaignSummaries
            self.nextToken = output.nextToken
        } else {
            self.campaignSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListCampaignsOutput: Swift.Equatable {
    /// A summary of information about each campaign.
    public var campaignSummaries: [IoTFleetWiseClientTypes.CampaignSummary]?
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        campaignSummaries: [IoTFleetWiseClientTypes.CampaignSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.campaignSummaries = campaignSummaries
        self.nextToken = nextToken
    }
}

struct ListCampaignsOutputBody: Swift.Equatable {
    let campaignSummaries: [IoTFleetWiseClientTypes.CampaignSummary]?
    let nextToken: Swift.String?
}

extension ListCampaignsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignSummariesContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.CampaignSummary?].self, forKey: .campaignSummaries)
        var campaignSummariesDecoded0:[IoTFleetWiseClientTypes.CampaignSummary]? = nil
        if let campaignSummariesContainer = campaignSummariesContainer {
            campaignSummariesDecoded0 = [IoTFleetWiseClientTypes.CampaignSummary]()
            for structure0 in campaignSummariesContainer {
                if let structure0 = structure0 {
                    campaignSummariesDecoded0?.append(structure0)
                }
            }
        }
        campaignSummaries = campaignSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCampaignsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDecoderManifestNetworkInterfacesInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListDecoderManifestNetworkInterfacesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListDecoderManifestNetworkInterfacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDecoderManifestNetworkInterfacesInput: Swift.Equatable {
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// The name of the decoder manifest to list information about.
    /// This member is required.
    public var name: Swift.String?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct ListDecoderManifestNetworkInterfacesInputBody: Swift.Equatable {
}

extension ListDecoderManifestNetworkInterfacesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDecoderManifestNetworkInterfacesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDecoderManifestNetworkInterfacesOutputBody = try responseDecoder.decode(responseBody: data)
            self.networkInterfaces = output.networkInterfaces
            self.nextToken = output.nextToken
        } else {
            self.networkInterfaces = nil
            self.nextToken = nil
        }
    }
}

public struct ListDecoderManifestNetworkInterfacesOutput: Swift.Equatable {
    /// A list of information about network interfaces.
    public var networkInterfaces: [IoTFleetWiseClientTypes.NetworkInterface]?
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        networkInterfaces: [IoTFleetWiseClientTypes.NetworkInterface]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkInterfaces = networkInterfaces
        self.nextToken = nextToken
    }
}

struct ListDecoderManifestNetworkInterfacesOutputBody: Swift.Equatable {
    let networkInterfaces: [IoTFleetWiseClientTypes.NetworkInterface]?
    let nextToken: Swift.String?
}

extension ListDecoderManifestNetworkInterfacesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkInterfaces
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkInterfacesContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.NetworkInterface?].self, forKey: .networkInterfaces)
        var networkInterfacesDecoded0:[IoTFleetWiseClientTypes.NetworkInterface]? = nil
        if let networkInterfacesContainer = networkInterfacesContainer {
            networkInterfacesDecoded0 = [IoTFleetWiseClientTypes.NetworkInterface]()
            for structure0 in networkInterfacesContainer {
                if let structure0 = structure0 {
                    networkInterfacesDecoded0?.append(structure0)
                }
            }
        }
        networkInterfaces = networkInterfacesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDecoderManifestNetworkInterfacesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDecoderManifestSignalsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListDecoderManifestSignalsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListDecoderManifestSignalsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDecoderManifestSignalsInput: Swift.Equatable {
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// The name of the decoder manifest to list information about.
    /// This member is required.
    public var name: Swift.String?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct ListDecoderManifestSignalsInputBody: Swift.Equatable {
}

extension ListDecoderManifestSignalsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDecoderManifestSignalsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDecoderManifestSignalsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.signalDecoders = output.signalDecoders
        } else {
            self.nextToken = nil
            self.signalDecoders = nil
        }
    }
}

public struct ListDecoderManifestSignalsOutput: Swift.Equatable {
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// Information about a list of signals to decode.
    public var signalDecoders: [IoTFleetWiseClientTypes.SignalDecoder]?

    public init(
        nextToken: Swift.String? = nil,
        signalDecoders: [IoTFleetWiseClientTypes.SignalDecoder]? = nil
    )
    {
        self.nextToken = nextToken
        self.signalDecoders = signalDecoders
    }
}

struct ListDecoderManifestSignalsOutputBody: Swift.Equatable {
    let signalDecoders: [IoTFleetWiseClientTypes.SignalDecoder]?
    let nextToken: Swift.String?
}

extension ListDecoderManifestSignalsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case signalDecoders
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signalDecodersContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.SignalDecoder?].self, forKey: .signalDecoders)
        var signalDecodersDecoded0:[IoTFleetWiseClientTypes.SignalDecoder]? = nil
        if let signalDecodersContainer = signalDecodersContainer {
            signalDecodersDecoded0 = [IoTFleetWiseClientTypes.SignalDecoder]()
            for structure0 in signalDecodersContainer {
                if let structure0 = structure0 {
                    signalDecodersDecoded0?.append(structure0)
                }
            }
        }
        signalDecoders = signalDecodersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDecoderManifestSignalsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDecoderManifestsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListDecoderManifestsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListDecoderManifestsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDecoderManifestsInput: Swift.Equatable {
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// The Amazon Resource Name (ARN) of a vehicle model (model manifest) associated with the decoder manifest.
    public var modelManifestArn: Swift.String?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        modelManifestArn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.modelManifestArn = modelManifestArn
        self.nextToken = nextToken
    }
}

struct ListDecoderManifestsInputBody: Swift.Equatable {
}

extension ListDecoderManifestsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDecoderManifestsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDecoderManifestsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct ListDecoderManifestsOutput: Swift.Equatable {
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A list of information about each decoder manifest.
    public var summaries: [IoTFleetWiseClientTypes.DecoderManifestSummary]?

    public init(
        nextToken: Swift.String? = nil,
        summaries: [IoTFleetWiseClientTypes.DecoderManifestSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct ListDecoderManifestsOutputBody: Swift.Equatable {
    let summaries: [IoTFleetWiseClientTypes.DecoderManifestSummary]?
    let nextToken: Swift.String?
}

extension ListDecoderManifestsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case summaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summariesContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.DecoderManifestSummary?].self, forKey: .summaries)
        var summariesDecoded0:[IoTFleetWiseClientTypes.DecoderManifestSummary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [IoTFleetWiseClientTypes.DecoderManifestSummary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDecoderManifestsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFleetsForVehicleInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListFleetsForVehicleInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListFleetsForVehicleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListFleetsForVehicleInput: Swift.Equatable {
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?
    /// The ID of the vehicle to retrieve information about.
    /// This member is required.
    public var vehicleName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        vehicleName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.vehicleName = vehicleName
    }
}

struct ListFleetsForVehicleInputBody: Swift.Equatable {
}

extension ListFleetsForVehicleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListFleetsForVehicleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFleetsForVehicleOutputBody = try responseDecoder.decode(responseBody: data)
            self.fleets = output.fleets
            self.nextToken = output.nextToken
        } else {
            self.fleets = nil
            self.nextToken = nil
        }
    }
}

public struct ListFleetsForVehicleOutput: Swift.Equatable {
    /// A list of fleet IDs that the vehicle is associated with.
    public var fleets: [Swift.String]?
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        fleets: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleets = fleets
        self.nextToken = nextToken
    }
}

struct ListFleetsForVehicleOutputBody: Swift.Equatable {
    let fleets: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListFleetsForVehicleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleets
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .fleets)
        var fleetsDecoded0:[Swift.String]? = nil
        if let fleetsContainer = fleetsContainer {
            fleetsDecoded0 = [Swift.String]()
            for string0 in fleetsContainer {
                if let string0 = string0 {
                    fleetsDecoded0?.append(string0)
                }
            }
        }
        fleets = fleetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListFleetsForVehicleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFleetsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListFleetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListFleetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListFleetsInput: Swift.Equatable {
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFleetsInputBody: Swift.Equatable {
}

extension ListFleetsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListFleetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFleetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.fleetSummaries = output.fleetSummaries
            self.nextToken = output.nextToken
        } else {
            self.fleetSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListFleetsOutput: Swift.Equatable {
    /// A list of information for each fleet.
    public var fleetSummaries: [IoTFleetWiseClientTypes.FleetSummary]?
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        fleetSummaries: [IoTFleetWiseClientTypes.FleetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetSummaries = fleetSummaries
        self.nextToken = nextToken
    }
}

struct ListFleetsOutputBody: Swift.Equatable {
    let fleetSummaries: [IoTFleetWiseClientTypes.FleetSummary]?
    let nextToken: Swift.String?
}

extension ListFleetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetSummariesContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.FleetSummary?].self, forKey: .fleetSummaries)
        var fleetSummariesDecoded0:[IoTFleetWiseClientTypes.FleetSummary]? = nil
        if let fleetSummariesContainer = fleetSummariesContainer {
            fleetSummariesDecoded0 = [IoTFleetWiseClientTypes.FleetSummary]()
            for structure0 in fleetSummariesContainer {
                if let structure0 = structure0 {
                    fleetSummariesDecoded0?.append(structure0)
                }
            }
        }
        fleetSummaries = fleetSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListFleetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListModelManifestNodesInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListModelManifestNodesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListModelManifestNodesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListModelManifestNodesInput: Swift.Equatable {
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// The name of the vehicle model to list information about.
    /// This member is required.
    public var name: Swift.String?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct ListModelManifestNodesInputBody: Swift.Equatable {
}

extension ListModelManifestNodesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListModelManifestNodesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListModelManifestNodesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.nodes = output.nodes
        } else {
            self.nextToken = nil
            self.nodes = nil
        }
    }
}

public struct ListModelManifestNodesOutput: Swift.Equatable {
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A list of information about nodes.
    public var nodes: [IoTFleetWiseClientTypes.Node]?

    public init(
        nextToken: Swift.String? = nil,
        nodes: [IoTFleetWiseClientTypes.Node]? = nil
    )
    {
        self.nextToken = nextToken
        self.nodes = nodes
    }
}

struct ListModelManifestNodesOutputBody: Swift.Equatable {
    let nodes: [IoTFleetWiseClientTypes.Node]?
    let nextToken: Swift.String?
}

extension ListModelManifestNodesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case nodes
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodesContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.Node?].self, forKey: .nodes)
        var nodesDecoded0:[IoTFleetWiseClientTypes.Node]? = nil
        if let nodesContainer = nodesContainer {
            nodesDecoded0 = [IoTFleetWiseClientTypes.Node]()
            for union0 in nodesContainer {
                if let union0 = union0 {
                    nodesDecoded0?.append(union0)
                }
            }
        }
        nodes = nodesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListModelManifestNodesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListModelManifestsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListModelManifestsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListModelManifestsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListModelManifestsInput: Swift.Equatable {
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?
    /// The ARN of a signal catalog. If you specify a signal catalog, only the vehicle models associated with it are returned.
    public var signalCatalogArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        signalCatalogArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.signalCatalogArn = signalCatalogArn
    }
}

struct ListModelManifestsInputBody: Swift.Equatable {
}

extension ListModelManifestsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListModelManifestsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListModelManifestsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct ListModelManifestsOutput: Swift.Equatable {
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A list of information about vehicle models.
    public var summaries: [IoTFleetWiseClientTypes.ModelManifestSummary]?

    public init(
        nextToken: Swift.String? = nil,
        summaries: [IoTFleetWiseClientTypes.ModelManifestSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct ListModelManifestsOutputBody: Swift.Equatable {
    let summaries: [IoTFleetWiseClientTypes.ModelManifestSummary]?
    let nextToken: Swift.String?
}

extension ListModelManifestsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case summaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summariesContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.ModelManifestSummary?].self, forKey: .summaries)
        var summariesDecoded0:[IoTFleetWiseClientTypes.ModelManifestSummary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [IoTFleetWiseClientTypes.ModelManifestSummary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListModelManifestsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSignalCatalogNodesInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListSignalCatalogNodesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListSignalCatalogNodesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSignalCatalogNodesInput: Swift.Equatable {
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// The name of the signal catalog to list information about.
    /// This member is required.
    public var name: Swift.String?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct ListSignalCatalogNodesInputBody: Swift.Equatable {
}

extension ListSignalCatalogNodesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSignalCatalogNodesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSignalCatalogNodesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.nodes = output.nodes
        } else {
            self.nextToken = nil
            self.nodes = nil
        }
    }
}

public struct ListSignalCatalogNodesOutput: Swift.Equatable {
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A list of information about nodes.
    public var nodes: [IoTFleetWiseClientTypes.Node]?

    public init(
        nextToken: Swift.String? = nil,
        nodes: [IoTFleetWiseClientTypes.Node]? = nil
    )
    {
        self.nextToken = nextToken
        self.nodes = nodes
    }
}

struct ListSignalCatalogNodesOutputBody: Swift.Equatable {
    let nodes: [IoTFleetWiseClientTypes.Node]?
    let nextToken: Swift.String?
}

extension ListSignalCatalogNodesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case nodes
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodesContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.Node?].self, forKey: .nodes)
        var nodesDecoded0:[IoTFleetWiseClientTypes.Node]? = nil
        if let nodesContainer = nodesContainer {
            nodesDecoded0 = [IoTFleetWiseClientTypes.Node]()
            for union0 in nodesContainer {
                if let union0 = union0 {
                    nodesDecoded0?.append(union0)
                }
            }
        }
        nodes = nodesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSignalCatalogNodesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSignalCatalogsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListSignalCatalogsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListSignalCatalogsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSignalCatalogsInput: Swift.Equatable {
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSignalCatalogsInputBody: Swift.Equatable {
}

extension ListSignalCatalogsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSignalCatalogsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSignalCatalogsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct ListSignalCatalogsOutput: Swift.Equatable {
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A list of information about each signal catalog.
    public var summaries: [IoTFleetWiseClientTypes.SignalCatalogSummary]?

    public init(
        nextToken: Swift.String? = nil,
        summaries: [IoTFleetWiseClientTypes.SignalCatalogSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct ListSignalCatalogsOutputBody: Swift.Equatable {
    let summaries: [IoTFleetWiseClientTypes.SignalCatalogSummary]?
    let nextToken: Swift.String?
}

extension ListSignalCatalogsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case summaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summariesContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.SignalCatalogSummary?].self, forKey: .summaries)
        var summariesDecoded0:[IoTFleetWiseClientTypes.SignalCatalogSummary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [IoTFleetWiseClientTypes.SignalCatalogSummary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSignalCatalogsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListTagsForResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The list of tags assigned to the resource.
    public var tags: [IoTFleetWiseClientTypes.Tag]?

    public init(
        tags: [IoTFleetWiseClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [IoTFleetWiseClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTFleetWiseClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTFleetWiseClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListVehiclesInFleetInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListVehiclesInFleetInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListVehiclesInFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListVehiclesInFleetInput: Swift.Equatable {
    /// The ID of a fleet.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        fleetId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetId = fleetId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListVehiclesInFleetInputBody: Swift.Equatable {
}

extension ListVehiclesInFleetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListVehiclesInFleetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListVehiclesInFleetOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.vehicles = output.vehicles
        } else {
            self.nextToken = nil
            self.vehicles = nil
        }
    }
}

public struct ListVehiclesInFleetOutput: Swift.Equatable {
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A list of vehicles associated with the fleet.
    public var vehicles: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        vehicles: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.vehicles = vehicles
    }
}

struct ListVehiclesInFleetOutputBody: Swift.Equatable {
    let vehicles: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListVehiclesInFleetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case vehicles
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vehiclesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vehicles)
        var vehiclesDecoded0:[Swift.String]? = nil
        if let vehiclesContainer = vehiclesContainer {
            vehiclesDecoded0 = [Swift.String]()
            for string0 in vehiclesContainer {
                if let string0 = string0 {
                    vehiclesDecoded0?.append(string0)
                }
            }
        }
        vehicles = vehiclesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListVehiclesInFleetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListVehiclesInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListVehiclesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListVehiclesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListVehiclesInput: Swift.Equatable {
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// The Amazon Resource Name (ARN) of a vehicle model (model manifest). You can use this optional parameter to list only the vehicles created from a certain vehicle model.
    public var modelManifestArn: Swift.String?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        modelManifestArn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.modelManifestArn = modelManifestArn
        self.nextToken = nextToken
    }
}

struct ListVehiclesInputBody: Swift.Equatable {
}

extension ListVehiclesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListVehiclesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListVehiclesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.vehicleSummaries = output.vehicleSummaries
        } else {
            self.nextToken = nil
            self.vehicleSummaries = nil
        }
    }
}

public struct ListVehiclesOutput: Swift.Equatable {
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A list of vehicles and information about them.
    public var vehicleSummaries: [IoTFleetWiseClientTypes.VehicleSummary]?

    public init(
        nextToken: Swift.String? = nil,
        vehicleSummaries: [IoTFleetWiseClientTypes.VehicleSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.vehicleSummaries = vehicleSummaries
    }
}

struct ListVehiclesOutputBody: Swift.Equatable {
    let vehicleSummaries: [IoTFleetWiseClientTypes.VehicleSummary]?
    let nextToken: Swift.String?
}

extension ListVehiclesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case vehicleSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vehicleSummariesContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.VehicleSummary?].self, forKey: .vehicleSummaries)
        var vehicleSummariesDecoded0:[IoTFleetWiseClientTypes.VehicleSummary]? = nil
        if let vehicleSummariesContainer = vehicleSummariesContainer {
            vehicleSummariesDecoded0 = [IoTFleetWiseClientTypes.VehicleSummary]()
            for structure0 in vehicleSummariesContainer {
                if let structure0 = structure0 {
                    vehicleSummariesDecoded0?.append(structure0)
                }
            }
        }
        vehicleSummaries = vehicleSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListVehiclesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTFleetWiseClientTypes {
    public enum LogType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case off
        case sdkUnknown(Swift.String)

        public static var allCases: [LogType] {
            return [
                .error,
                .off,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .off: return "OFF"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LogType(rawValue: rawValue) ?? LogType.sdkUnknown(rawValue)
        }
    }
}

extension IoTFleetWiseClientTypes {
    public enum ManifestStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case draft
        case sdkUnknown(Swift.String)

        public static var allCases: [ManifestStatus] {
            return [
                .active,
                .draft,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .draft: return "DRAFT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ManifestStatus(rawValue: rawValue) ?? ManifestStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTFleetWiseClientTypes.ModelManifestSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case lastModificationTime
        case name
        case signalCatalogArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let signalCatalogArn = self.signalCatalogArn {
            try encodeContainer.encode(signalCatalogArn, forKey: .signalCatalogArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let signalCatalogArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signalCatalogArn)
        signalCatalogArn = signalCatalogArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.ManifestStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about a vehicle model (model manifest). You can use the API operation to return this information about multiple vehicle models.
    public struct ModelManifestSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the vehicle model.
        public var arn: Swift.String?
        /// The time the vehicle model was created, in seconds since epoch (January 1, 1970 at midnight UTC time).
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// A brief description of the vehicle model.
        public var description: Swift.String?
        /// The time the vehicle model was last updated, in seconds since epoch (January 1, 1970 at midnight UTC time).
        /// This member is required.
        public var lastModificationTime: ClientRuntime.Date?
        /// The name of the vehicle model.
        public var name: Swift.String?
        /// The ARN of the signal catalog associated with the vehicle model.
        public var signalCatalogArn: Swift.String?
        /// The state of the vehicle model. If the status is ACTIVE, the vehicle model can't be edited. If the status is DRAFT, you can edit the vehicle model.
        public var status: IoTFleetWiseClientTypes.ManifestStatus?

        public init(
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            signalCatalogArn: Swift.String? = nil,
            status: IoTFleetWiseClientTypes.ManifestStatus? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.lastModificationTime = lastModificationTime
            self.name = name
            self.signalCatalogArn = signalCatalogArn
            self.status = status
        }
    }

}

extension IoTFleetWiseClientTypes.NetworkFileDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case candbc = "canDbc"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .candbc(candbc):
                try container.encode(candbc, forKey: .candbc)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let candbcDecoded = try values.decodeIfPresent(IoTFleetWiseClientTypes.CanDbcDefinition.self, forKey: .candbc)
        if let candbc = candbcDecoded {
            self = .candbc(candbc)
            return
        }
        self = .sdkUnknown("")
    }
}

extension IoTFleetWiseClientTypes {
    /// Specifications for defining a vehicle network.
    public enum NetworkFileDefinition: Swift.Equatable {
        /// Information, including CAN DBC files, about the configurations used to create a decoder manifest.
        case candbc(IoTFleetWiseClientTypes.CanDbcDefinition)
        case sdkUnknown(Swift.String)
    }

}

extension IoTFleetWiseClientTypes.NetworkInterface: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canInterface
        case interfaceId
        case obdInterface
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let canInterface = self.canInterface {
            try encodeContainer.encode(canInterface, forKey: .canInterface)
        }
        if let interfaceId = self.interfaceId {
            try encodeContainer.encode(interfaceId, forKey: .interfaceId)
        }
        if let obdInterface = self.obdInterface {
            try encodeContainer.encode(obdInterface, forKey: .obdInterface)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let interfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .interfaceId)
        interfaceId = interfaceIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.NetworkInterfaceType.self, forKey: .type)
        type = typeDecoded
        let canInterfaceDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.CanInterface.self, forKey: .canInterface)
        canInterface = canInterfaceDecoded
        let obdInterfaceDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.ObdInterface.self, forKey: .obdInterface)
        obdInterface = obdInterfaceDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Represents a node and its specifications in an in-vehicle communication network. All signal decoders must be associated with a network node. To return this information about all the network interfaces specified in a decoder manifest, use the API operation.
    public struct NetworkInterface: Swift.Equatable {
        /// Information about a network interface specified by the Controller Area Network (CAN) protocol.
        public var canInterface: IoTFleetWiseClientTypes.CanInterface?
        /// The ID of the network interface.
        /// This member is required.
        public var interfaceId: Swift.String?
        /// Information about a network interface specified by the On-board diagnostic (OBD) II protocol.
        public var obdInterface: IoTFleetWiseClientTypes.ObdInterface?
        /// The network protocol for the vehicle. For example, CAN_SIGNAL specifies a protocol that defines how data is communicated between electronic control units (ECUs). OBD_SIGNAL specifies a protocol that defines how self-diagnostic data is communicated between ECUs.
        /// This member is required.
        public var type: IoTFleetWiseClientTypes.NetworkInterfaceType?

        public init(
            canInterface: IoTFleetWiseClientTypes.CanInterface? = nil,
            interfaceId: Swift.String? = nil,
            obdInterface: IoTFleetWiseClientTypes.ObdInterface? = nil,
            type: IoTFleetWiseClientTypes.NetworkInterfaceType? = nil
        )
        {
            self.canInterface = canInterface
            self.interfaceId = interfaceId
            self.obdInterface = obdInterface
            self.type = type
        }
    }

}

extension IoTFleetWiseClientTypes {
    public enum NetworkInterfaceFailureReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canNetworkInterfaceInfoIsNull
        case conflictingNetworkInterface
        case duplicateInterface
        case networkInterfaceToAddAlreadyExists
        case networkInterfaceToRemoveAssociatedWithSignals
        case obdNetworkInterfaceInfoIsNull
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkInterfaceFailureReason] {
            return [
                .canNetworkInterfaceInfoIsNull,
                .conflictingNetworkInterface,
                .duplicateInterface,
                .networkInterfaceToAddAlreadyExists,
                .networkInterfaceToRemoveAssociatedWithSignals,
                .obdNetworkInterfaceInfoIsNull,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canNetworkInterfaceInfoIsNull: return "CAN_NETWORK_INTERFACE_INFO_IS_NULL"
            case .conflictingNetworkInterface: return "CONFLICTING_NETWORK_INTERFACE"
            case .duplicateInterface: return "DUPLICATE_NETWORK_INTERFACE"
            case .networkInterfaceToAddAlreadyExists: return "NETWORK_INTERFACE_TO_ADD_ALREADY_EXISTS"
            case .networkInterfaceToRemoveAssociatedWithSignals: return "NETWORK_INTERFACE_TO_REMOVE_ASSOCIATED_WITH_SIGNALS"
            case .obdNetworkInterfaceInfoIsNull: return "OBD_NETWORK_INTERFACE_INFO_IS_NULL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkInterfaceFailureReason(rawValue: rawValue) ?? NetworkInterfaceFailureReason.sdkUnknown(rawValue)
        }
    }
}

extension IoTFleetWiseClientTypes {
    public enum NetworkInterfaceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canInterface
        case obdInterface
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkInterfaceType] {
            return [
                .canInterface,
                .obdInterface,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canInterface: return "CAN_INTERFACE"
            case .obdInterface: return "OBD_INTERFACE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkInterfaceType(rawValue: rawValue) ?? NetworkInterfaceType.sdkUnknown(rawValue)
        }
    }
}

extension IoTFleetWiseClientTypes.Node: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actuator
        case attribute
        case branch
        case sdkUnknown
        case sensor
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .actuator(actuator):
                try container.encode(actuator, forKey: .actuator)
            case let .attribute(attribute):
                try container.encode(attribute, forKey: .attribute)
            case let .branch(branch):
                try container.encode(branch, forKey: .branch)
            case let .sensor(sensor):
                try container.encode(sensor, forKey: .sensor)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let branchDecoded = try values.decodeIfPresent(IoTFleetWiseClientTypes.Branch.self, forKey: .branch)
        if let branch = branchDecoded {
            self = .branch(branch)
            return
        }
        let sensorDecoded = try values.decodeIfPresent(IoTFleetWiseClientTypes.Sensor.self, forKey: .sensor)
        if let sensor = sensorDecoded {
            self = .sensor(sensor)
            return
        }
        let actuatorDecoded = try values.decodeIfPresent(IoTFleetWiseClientTypes.Actuator.self, forKey: .actuator)
        if let actuator = actuatorDecoded {
            self = .actuator(actuator)
            return
        }
        let attributeDecoded = try values.decodeIfPresent(IoTFleetWiseClientTypes.Attribute.self, forKey: .attribute)
        if let attribute = attributeDecoded {
            self = .attribute(attribute)
            return
        }
        self = .sdkUnknown("")
    }
}

extension IoTFleetWiseClientTypes {
    /// A general abstraction of a signal. A node can be specified as an actuator, attribute, branch, or sensor.
    public enum Node: Swift.Equatable {
        /// Information about a node specified as a branch. A group of signals that are defined in a hierarchical structure.
        case branch(IoTFleetWiseClientTypes.Branch)
        /// An input component that reports the environmental condition of a vehicle. You can collect data about fluid levels, temperatures, vibrations, or battery voltage from sensors.
        case sensor(IoTFleetWiseClientTypes.Sensor)
        /// Information about a node specified as an actuator. An actuator is a digital representation of a vehicle device.
        case actuator(IoTFleetWiseClientTypes.Actuator)
        /// Information about a node specified as an attribute. An attribute represents static information about a vehicle.
        case attribute(IoTFleetWiseClientTypes.Attribute)
        case sdkUnknown(Swift.String)
    }

}

extension IoTFleetWiseClientTypes.NodeCounts: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case totalActuators
        case totalAttributes
        case totalBranches
        case totalNodes
        case totalSensors
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if totalActuators != 0 {
            try encodeContainer.encode(totalActuators, forKey: .totalActuators)
        }
        if totalAttributes != 0 {
            try encodeContainer.encode(totalAttributes, forKey: .totalAttributes)
        }
        if totalBranches != 0 {
            try encodeContainer.encode(totalBranches, forKey: .totalBranches)
        }
        if totalNodes != 0 {
            try encodeContainer.encode(totalNodes, forKey: .totalNodes)
        }
        if totalSensors != 0 {
            try encodeContainer.encode(totalSensors, forKey: .totalSensors)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalNodesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalNodes) ?? 0
        totalNodes = totalNodesDecoded
        let totalBranchesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalBranches) ?? 0
        totalBranches = totalBranchesDecoded
        let totalSensorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalSensors) ?? 0
        totalSensors = totalSensorsDecoded
        let totalAttributesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalAttributes) ?? 0
        totalAttributes = totalAttributesDecoded
        let totalActuatorsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalActuators) ?? 0
        totalActuators = totalActuatorsDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about the number of nodes and node types in a vehicle network.
    public struct NodeCounts: Swift.Equatable {
        /// The total number of nodes in a vehicle network that represent actuators.
        public var totalActuators: Swift.Int
        /// The total number of nodes in a vehicle network that represent attributes.
        public var totalAttributes: Swift.Int
        /// The total number of nodes in a vehicle network that represent branches.
        public var totalBranches: Swift.Int
        /// The total number of nodes in a vehicle network.
        public var totalNodes: Swift.Int
        /// The total number of nodes in a vehicle network that represent sensors.
        public var totalSensors: Swift.Int

        public init(
            totalActuators: Swift.Int = 0,
            totalAttributes: Swift.Int = 0,
            totalBranches: Swift.Int = 0,
            totalNodes: Swift.Int = 0,
            totalSensors: Swift.Int = 0
        )
        {
            self.totalActuators = totalActuators
            self.totalAttributes = totalAttributes
            self.totalBranches = totalBranches
            self.totalNodes = totalNodes
            self.totalSensors = totalSensors
        }
    }

}

extension IoTFleetWiseClientTypes {
    public enum NodeDataType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case boolean
        case booleanArray
        case double
        case doubleArray
        case float
        case floatArray
        case int16
        case int16Array
        case int32
        case int32Array
        case int64
        case int64Array
        case int8
        case int8Array
        case string
        case stringArray
        case uint16
        case uint16Array
        case uint32
        case uint32Array
        case uint64
        case uint64Array
        case uint8
        case uint8Array
        case unixTimestamp
        case unixTimestampArray
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [NodeDataType] {
            return [
                .boolean,
                .booleanArray,
                .double,
                .doubleArray,
                .float,
                .floatArray,
                .int16,
                .int16Array,
                .int32,
                .int32Array,
                .int64,
                .int64Array,
                .int8,
                .int8Array,
                .string,
                .stringArray,
                .uint16,
                .uint16Array,
                .uint32,
                .uint32Array,
                .uint64,
                .uint64Array,
                .uint8,
                .uint8Array,
                .unixTimestamp,
                .unixTimestampArray,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "BOOLEAN"
            case .booleanArray: return "BOOLEAN_ARRAY"
            case .double: return "DOUBLE"
            case .doubleArray: return "DOUBLE_ARRAY"
            case .float: return "FLOAT"
            case .floatArray: return "FLOAT_ARRAY"
            case .int16: return "INT16"
            case .int16Array: return "INT16_ARRAY"
            case .int32: return "INT32"
            case .int32Array: return "INT32_ARRAY"
            case .int64: return "INT64"
            case .int64Array: return "INT64_ARRAY"
            case .int8: return "INT8"
            case .int8Array: return "INT8_ARRAY"
            case .string: return "STRING"
            case .stringArray: return "STRING_ARRAY"
            case .uint16: return "UINT16"
            case .uint16Array: return "UINT16_ARRAY"
            case .uint32: return "UINT32"
            case .uint32Array: return "UINT32_ARRAY"
            case .uint64: return "UINT64"
            case .uint64Array: return "UINT64_ARRAY"
            case .uint8: return "UINT8"
            case .uint8Array: return "UINT8_ARRAY"
            case .unixTimestamp: return "UNIX_TIMESTAMP"
            case .unixTimestampArray: return "UNIX_TIMESTAMP_ARRAY"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NodeDataType(rawValue: rawValue) ?? NodeDataType.sdkUnknown(rawValue)
        }
    }
}

extension IoTFleetWiseClientTypes.ObdInterface: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dtcRequestIntervalSeconds
        case hasTransmissionEcu
        case name
        case obdStandard
        case pidRequestIntervalSeconds
        case requestMessageId
        case useExtendedIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dtcRequestIntervalSeconds != 0 {
            try encodeContainer.encode(dtcRequestIntervalSeconds, forKey: .dtcRequestIntervalSeconds)
        }
        if hasTransmissionEcu != false {
            try encodeContainer.encode(hasTransmissionEcu, forKey: .hasTransmissionEcu)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let obdStandard = self.obdStandard {
            try encodeContainer.encode(obdStandard, forKey: .obdStandard)
        }
        if pidRequestIntervalSeconds != 0 {
            try encodeContainer.encode(pidRequestIntervalSeconds, forKey: .pidRequestIntervalSeconds)
        }
        if requestMessageId != 0 {
            try encodeContainer.encode(requestMessageId, forKey: .requestMessageId)
        }
        if useExtendedIds != false {
            try encodeContainer.encode(useExtendedIds, forKey: .useExtendedIds)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let requestMessageIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .requestMessageId) ?? 0
        requestMessageId = requestMessageIdDecoded
        let obdStandardDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .obdStandard)
        obdStandard = obdStandardDecoded
        let pidRequestIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pidRequestIntervalSeconds) ?? 0
        pidRequestIntervalSeconds = pidRequestIntervalSecondsDecoded
        let dtcRequestIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dtcRequestIntervalSeconds) ?? 0
        dtcRequestIntervalSeconds = dtcRequestIntervalSecondsDecoded
        let useExtendedIdsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useExtendedIds) ?? false
        useExtendedIds = useExtendedIdsDecoded
        let hasTransmissionEcuDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasTransmissionEcu) ?? false
        hasTransmissionEcu = hasTransmissionEcuDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// A network interface that specifies the On-board diagnostic (OBD) II network protocol.
    public struct ObdInterface: Swift.Equatable {
        /// The maximum number message requests per diagnostic trouble code per second.
        public var dtcRequestIntervalSeconds: Swift.Int
        /// Whether the vehicle has a transmission control module (TCM).
        public var hasTransmissionEcu: Swift.Bool
        /// The name of the interface.
        /// This member is required.
        public var name: Swift.String?
        /// The standard OBD II PID.
        public var obdStandard: Swift.String?
        /// The maximum number message requests per second.
        public var pidRequestIntervalSeconds: Swift.Int
        /// The ID of the message requesting vehicle data.
        /// This member is required.
        public var requestMessageId: Swift.Int
        /// Whether to use extended IDs in the message.
        public var useExtendedIds: Swift.Bool

        public init(
            dtcRequestIntervalSeconds: Swift.Int = 0,
            hasTransmissionEcu: Swift.Bool = false,
            name: Swift.String? = nil,
            obdStandard: Swift.String? = nil,
            pidRequestIntervalSeconds: Swift.Int = 0,
            requestMessageId: Swift.Int = 0,
            useExtendedIds: Swift.Bool = false
        )
        {
            self.dtcRequestIntervalSeconds = dtcRequestIntervalSeconds
            self.hasTransmissionEcu = hasTransmissionEcu
            self.name = name
            self.obdStandard = obdStandard
            self.pidRequestIntervalSeconds = pidRequestIntervalSeconds
            self.requestMessageId = requestMessageId
            self.useExtendedIds = useExtendedIds
        }
    }

}

extension IoTFleetWiseClientTypes.ObdSignal: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bitMaskLength
        case bitRightShift
        case byteLength
        case offset
        case pid
        case pidResponseLength
        case scaling
        case serviceMode
        case startByte
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bitMaskLength = self.bitMaskLength {
            try encodeContainer.encode(bitMaskLength, forKey: .bitMaskLength)
        }
        if bitRightShift != 0 {
            try encodeContainer.encode(bitRightShift, forKey: .bitRightShift)
        }
        if let byteLength = self.byteLength {
            try encodeContainer.encode(byteLength, forKey: .byteLength)
        }
        if let offset = self.offset {
            try encodeContainer.encode(offset, forKey: .offset)
        }
        if pid != 0 {
            try encodeContainer.encode(pid, forKey: .pid)
        }
        if pidResponseLength != 0 {
            try encodeContainer.encode(pidResponseLength, forKey: .pidResponseLength)
        }
        if let scaling = self.scaling {
            try encodeContainer.encode(scaling, forKey: .scaling)
        }
        if serviceMode != 0 {
            try encodeContainer.encode(serviceMode, forKey: .serviceMode)
        }
        if startByte != 0 {
            try encodeContainer.encode(startByte, forKey: .startByte)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pidResponseLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pidResponseLength) ?? 0
        pidResponseLength = pidResponseLengthDecoded
        let serviceModeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .serviceMode) ?? 0
        serviceMode = serviceModeDecoded
        let pidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pid) ?? 0
        pid = pidDecoded
        let scalingDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .scaling)
        scaling = scalingDecoded
        let offsetDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .offset)
        offset = offsetDecoded
        let startByteDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startByte) ?? 0
        startByte = startByteDecoded
        let byteLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .byteLength)
        byteLength = byteLengthDecoded
        let bitRightShiftDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bitRightShift) ?? 0
        bitRightShift = bitRightShiftDecoded
        let bitMaskLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bitMaskLength)
        bitMaskLength = bitMaskLengthDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about signal messages using the on-board diagnostics (OBD) II protocol in a vehicle.
    public struct ObdSignal: Swift.Equatable {
        /// The number of bits to mask in a message.
        public var bitMaskLength: Swift.Int?
        /// The number of positions to shift bits in the message.
        public var bitRightShift: Swift.Int
        /// The length of a message.
        /// This member is required.
        public var byteLength: Swift.Int?
        /// The offset used to calculate the signal value. Combined with scaling, the calculation is value = raw_value * scaling + offset.
        /// This member is required.
        public var offset: Swift.Double?
        /// The diagnostic code used to request data from a vehicle for this signal.
        /// This member is required.
        public var pid: Swift.Int
        /// The length of the requested data.
        /// This member is required.
        public var pidResponseLength: Swift.Int
        /// A multiplier used to decode the message.
        /// This member is required.
        public var scaling: Swift.Double?
        /// The mode of operation (diagnostic service) in a message.
        /// This member is required.
        public var serviceMode: Swift.Int
        /// Indicates the beginning of the message.
        /// This member is required.
        public var startByte: Swift.Int

        public init(
            bitMaskLength: Swift.Int? = nil,
            bitRightShift: Swift.Int = 0,
            byteLength: Swift.Int? = nil,
            offset: Swift.Double? = nil,
            pid: Swift.Int = 0,
            pidResponseLength: Swift.Int = 0,
            scaling: Swift.Double? = nil,
            serviceMode: Swift.Int = 0,
            startByte: Swift.Int = 0
        )
        {
            self.bitMaskLength = bitMaskLength
            self.bitRightShift = bitRightShift
            self.byteLength = byteLength
            self.offset = offset
            self.pid = pid
            self.pidResponseLength = pidResponseLength
            self.scaling = scaling
            self.serviceMode = serviceMode
            self.startByte = startByte
        }
    }

}

extension PutEncryptionConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionType
        case kmsKeyId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionType = self.encryptionType {
            try encodeContainer.encode(encryptionType.rawValue, forKey: .encryptionType)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
    }
}

extension PutEncryptionConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutEncryptionConfigurationInput: Swift.Equatable {
    /// The type of encryption. Choose KMS_BASED_ENCRYPTION to use a KMS key or FLEETWISE_DEFAULT_ENCRYPTION to use an Amazon Web Services managed key.
    /// This member is required.
    public var encryptionType: IoTFleetWiseClientTypes.EncryptionType?
    /// The ID of the KMS key that is used for encryption.
    public var kmsKeyId: Swift.String?

    public init(
        encryptionType: IoTFleetWiseClientTypes.EncryptionType? = nil,
        kmsKeyId: Swift.String? = nil
    )
    {
        self.encryptionType = encryptionType
        self.kmsKeyId = kmsKeyId
    }
}

struct PutEncryptionConfigurationInputBody: Swift.Equatable {
    let kmsKeyId: Swift.String?
    let encryptionType: IoTFleetWiseClientTypes.EncryptionType?
}

extension PutEncryptionConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionType
        case kmsKeyId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
    }
}

extension PutEncryptionConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutEncryptionConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.encryptionStatus = output.encryptionStatus
            self.encryptionType = output.encryptionType
            self.kmsKeyId = output.kmsKeyId
        } else {
            self.encryptionStatus = nil
            self.encryptionType = nil
            self.kmsKeyId = nil
        }
    }
}

public struct PutEncryptionConfigurationOutput: Swift.Equatable {
    /// The encryption status.
    /// This member is required.
    public var encryptionStatus: IoTFleetWiseClientTypes.EncryptionStatus?
    /// The type of encryption. Set to KMS_BASED_ENCRYPTION to use an KMS key that you own and manage. Set to FLEETWISE_DEFAULT_ENCRYPTION to use an Amazon Web Services managed key that is owned by the Amazon Web Services IoT FleetWise service account.
    /// This member is required.
    public var encryptionType: IoTFleetWiseClientTypes.EncryptionType?
    /// The ID of the KMS key that is used for encryption.
    public var kmsKeyId: Swift.String?

    public init(
        encryptionStatus: IoTFleetWiseClientTypes.EncryptionStatus? = nil,
        encryptionType: IoTFleetWiseClientTypes.EncryptionType? = nil,
        kmsKeyId: Swift.String? = nil
    )
    {
        self.encryptionStatus = encryptionStatus
        self.encryptionType = encryptionType
        self.kmsKeyId = kmsKeyId
    }
}

struct PutEncryptionConfigurationOutputBody: Swift.Equatable {
    let kmsKeyId: Swift.String?
    let encryptionStatus: IoTFleetWiseClientTypes.EncryptionStatus?
    let encryptionType: IoTFleetWiseClientTypes.EncryptionType?
}

extension PutEncryptionConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionStatus
        case encryptionType
        case kmsKeyId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let encryptionStatusDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.EncryptionStatus.self, forKey: .encryptionStatus)
        encryptionStatus = encryptionStatusDecoded
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
    }
}

enum PutEncryptionConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutLoggingOptionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogDelivery
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogDelivery = self.cloudWatchLogDelivery {
            try encodeContainer.encode(cloudWatchLogDelivery, forKey: .cloudWatchLogDelivery)
        }
    }
}

extension PutLoggingOptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutLoggingOptionsInput: Swift.Equatable {
    /// Creates or updates the log delivery option to Amazon CloudWatch Logs.
    /// This member is required.
    public var cloudWatchLogDelivery: IoTFleetWiseClientTypes.CloudWatchLogDeliveryOptions?

    public init(
        cloudWatchLogDelivery: IoTFleetWiseClientTypes.CloudWatchLogDeliveryOptions? = nil
    )
    {
        self.cloudWatchLogDelivery = cloudWatchLogDelivery
    }
}

struct PutLoggingOptionsInputBody: Swift.Equatable {
    let cloudWatchLogDelivery: IoTFleetWiseClientTypes.CloudWatchLogDeliveryOptions?
}

extension PutLoggingOptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogDelivery
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLogDeliveryDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.CloudWatchLogDeliveryOptions.self, forKey: .cloudWatchLogDelivery)
        cloudWatchLogDelivery = cloudWatchLogDeliveryDecoded
    }
}

extension PutLoggingOptionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutLoggingOptionsOutput: Swift.Equatable {

    public init() { }
}

enum PutLoggingOptionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RegisterAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamResources
        case timestreamResources
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iamResources = self.iamResources {
            try encodeContainer.encode(iamResources, forKey: .iamResources)
        }
        if let timestreamResources = self.timestreamResources {
            try encodeContainer.encode(timestreamResources, forKey: .timestreamResources)
        }
    }
}

extension RegisterAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RegisterAccountInput: Swift.Equatable {
    /// The IAM resource that allows Amazon Web Services IoT FleetWise to send data to Amazon Timestream.
    @available(*, deprecated, message: "iamResources is no longer used or needed as input")
    public var iamResources: IoTFleetWiseClientTypes.IamResources?
    /// The registered Amazon Timestream resources that Amazon Web Services IoT FleetWise edge agent software can transfer your vehicle data to.
    @available(*, deprecated, message: "Amazon Timestream metadata is now passed in the CreateCampaign API.")
    public var timestreamResources: IoTFleetWiseClientTypes.TimestreamResources?

    public init(
        iamResources: IoTFleetWiseClientTypes.IamResources? = nil,
        timestreamResources: IoTFleetWiseClientTypes.TimestreamResources? = nil
    )
    {
        self.iamResources = iamResources
        self.timestreamResources = timestreamResources
    }
}

struct RegisterAccountInputBody: Swift.Equatable {
    let timestreamResources: IoTFleetWiseClientTypes.TimestreamResources?
    let iamResources: IoTFleetWiseClientTypes.IamResources?
}

extension RegisterAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamResources
        case timestreamResources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestreamResourcesDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.TimestreamResources.self, forKey: .timestreamResources)
        timestreamResources = timestreamResourcesDecoded
        let iamResourcesDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.IamResources.self, forKey: .iamResources)
        iamResources = iamResourcesDecoded
    }
}

extension RegisterAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RegisterAccountOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.iamResources = output.iamResources
            self.lastModificationTime = output.lastModificationTime
            self.registerAccountStatus = output.registerAccountStatus
            self.timestreamResources = output.timestreamResources
        } else {
            self.creationTime = nil
            self.iamResources = nil
            self.lastModificationTime = nil
            self.registerAccountStatus = nil
            self.timestreamResources = nil
        }
    }
}

public struct RegisterAccountOutput: Swift.Equatable {
    /// The time the account was registered, in seconds since epoch (January 1, 1970 at midnight UTC time).
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The registered IAM resource that allows Amazon Web Services IoT FleetWise to send data to Amazon Timestream.
    /// This member is required.
    public var iamResources: IoTFleetWiseClientTypes.IamResources?
    /// The time this registration was last updated, in seconds since epoch (January 1, 1970 at midnight UTC time).
    /// This member is required.
    public var lastModificationTime: ClientRuntime.Date?
    /// The status of registering your Amazon Web Services account, IAM role, and Timestream resources.
    /// This member is required.
    public var registerAccountStatus: IoTFleetWiseClientTypes.RegistrationStatus?
    /// The registered Amazon Timestream resources that Amazon Web Services IoT FleetWise edge agent software can transfer your vehicle data to.
    public var timestreamResources: IoTFleetWiseClientTypes.TimestreamResources?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        iamResources: IoTFleetWiseClientTypes.IamResources? = nil,
        lastModificationTime: ClientRuntime.Date? = nil,
        registerAccountStatus: IoTFleetWiseClientTypes.RegistrationStatus? = nil,
        timestreamResources: IoTFleetWiseClientTypes.TimestreamResources? = nil
    )
    {
        self.creationTime = creationTime
        self.iamResources = iamResources
        self.lastModificationTime = lastModificationTime
        self.registerAccountStatus = registerAccountStatus
        self.timestreamResources = timestreamResources
    }
}

struct RegisterAccountOutputBody: Swift.Equatable {
    let registerAccountStatus: IoTFleetWiseClientTypes.RegistrationStatus?
    let timestreamResources: IoTFleetWiseClientTypes.TimestreamResources?
    let iamResources: IoTFleetWiseClientTypes.IamResources?
    let creationTime: ClientRuntime.Date?
    let lastModificationTime: ClientRuntime.Date?
}

extension RegisterAccountOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case iamResources
        case lastModificationTime
        case registerAccountStatus
        case timestreamResources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registerAccountStatusDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.RegistrationStatus.self, forKey: .registerAccountStatus)
        registerAccountStatus = registerAccountStatusDecoded
        let timestreamResourcesDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.TimestreamResources.self, forKey: .timestreamResources)
        timestreamResources = timestreamResourcesDecoded
        let iamResourcesDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.IamResources.self, forKey: .iamResources)
        iamResources = iamResourcesDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

enum RegisterAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTFleetWiseClientTypes {
    public enum RegistrationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case registrationFailure
        case registrationPending
        case registrationSuccess
        case sdkUnknown(Swift.String)

        public static var allCases: [RegistrationStatus] {
            return [
                .registrationFailure,
                .registrationPending,
                .registrationSuccess,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .registrationFailure: return "REGISTRATION_FAILURE"
            case .registrationPending: return "REGISTRATION_PENDING"
            case .registrationSuccess: return "REGISTRATION_SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RegistrationStatus(rawValue: rawValue) ?? RegistrationStatus.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource wasn't found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the resource that wasn't found.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource that wasn't found.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension IoTFleetWiseClientTypes.S3Config: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketArn
        case dataFormat
        case `prefix` = "prefix"
        case storageCompressionFormat
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketArn = self.bucketArn {
            try encodeContainer.encode(bucketArn, forKey: .bucketArn)
        }
        if let dataFormat = self.dataFormat {
            try encodeContainer.encode(dataFormat.rawValue, forKey: .dataFormat)
        }
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
        if let storageCompressionFormat = self.storageCompressionFormat {
            try encodeContainer.encode(storageCompressionFormat.rawValue, forKey: .storageCompressionFormat)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketArn)
        bucketArn = bucketArnDecoded
        let dataFormatDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.DataFormat.self, forKey: .dataFormat)
        dataFormat = dataFormatDecoded
        let storageCompressionFormatDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.StorageCompressionFormat.self, forKey: .storageCompressionFormat)
        storageCompressionFormat = storageCompressionFormatDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// The Amazon S3 bucket where the Amazon Web Services IoT FleetWise campaign sends data. Amazon S3 is an object storage service that stores data as objects within buckets. For more information, see [Creating, configuring, and working with Amazon S3 buckets](https://docs.aws.amazon.com/AmazonS3/latest/userguide/creating-buckets-s3.html) in the Amazon Simple Storage Service User Guide.
    public struct S3Config: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Amazon S3 bucket.
        /// This member is required.
        public var bucketArn: Swift.String?
        /// Specify the format that files are saved in the Amazon S3 bucket. You can save files in an Apache Parquet or JSON format.
        ///
        /// * Parquet - Store data in a columnar storage file format. Parquet is optimal for fast data retrieval and can reduce costs. This option is selected by default.
        ///
        /// * JSON - Store data in a standard text-based JSON file format.
        public var dataFormat: IoTFleetWiseClientTypes.DataFormat?
        /// (Optional) Enter an S3 bucket prefix. The prefix is the string of characters after the bucket name and before the object name. You can use the prefix to organize data stored in Amazon S3 buckets. For more information, see [Organizing objects using prefixes](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-prefixes.html) in the Amazon Simple Storage Service User Guide. By default, Amazon Web Services IoT FleetWise sets the prefix processed-data/year=YY/month=MM/date=DD/hour=HH/ (in UTC) to data it delivers to Amazon S3. You can enter a prefix to append it to this default prefix. For example, if you enter the prefix vehicles, the prefix will be vehicles/processed-data/year=YY/month=MM/date=DD/hour=HH/.
        public var `prefix`: Swift.String?
        /// By default, stored data is compressed as a .gzip file. Compressed files have a reduced file size, which can optimize the cost of data storage.
        public var storageCompressionFormat: IoTFleetWiseClientTypes.StorageCompressionFormat?

        public init(
            bucketArn: Swift.String? = nil,
            dataFormat: IoTFleetWiseClientTypes.DataFormat? = nil,
            `prefix`: Swift.String? = nil,
            storageCompressionFormat: IoTFleetWiseClientTypes.StorageCompressionFormat? = nil
        )
        {
            self.bucketArn = bucketArn
            self.dataFormat = dataFormat
            self.`prefix` = `prefix`
            self.storageCompressionFormat = storageCompressionFormat
        }
    }

}

extension IoTFleetWiseClientTypes.Sensor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedValues
        case comment
        case dataType
        case deprecationMessage
        case description
        case fullyQualifiedName
        case max
        case min
        case unit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedValues = allowedValues {
            var allowedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedValues)
            for string0 in allowedValues {
                try allowedValuesContainer.encode(string0)
            }
        }
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let deprecationMessage = self.deprecationMessage {
            try encodeContainer.encode(deprecationMessage, forKey: .deprecationMessage)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let fullyQualifiedName = self.fullyQualifiedName {
            try encodeContainer.encode(fullyQualifiedName, forKey: .fullyQualifiedName)
        }
        if let max = self.max {
            try encodeContainer.encode(max, forKey: .max)
        }
        if let min = self.min {
            try encodeContainer.encode(min, forKey: .min)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fullyQualifiedNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fullyQualifiedName)
        fullyQualifiedName = fullyQualifiedNameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.NodeDataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let allowedValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowedValues)
        var allowedValuesDecoded0:[Swift.String]? = nil
        if let allowedValuesContainer = allowedValuesContainer {
            allowedValuesDecoded0 = [Swift.String]()
            for string0 in allowedValuesContainer {
                if let string0 = string0 {
                    allowedValuesDecoded0?.append(string0)
                }
            }
        }
        allowedValues = allowedValuesDecoded0
        let minDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .min)
        min = minDecoded
        let maxDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .max)
        max = maxDecoded
        let deprecationMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deprecationMessage)
        deprecationMessage = deprecationMessageDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// An input component that reports the environmental condition of a vehicle. You can collect data about fluid levels, temperatures, vibrations, or battery voltage from sensors.
    public struct Sensor: Swift.Equatable {
        /// A list of possible values a sensor can take.
        public var allowedValues: [Swift.String]?
        /// A comment in addition to the description.
        public var comment: Swift.String?
        /// The specified data type of the sensor.
        /// This member is required.
        public var dataType: IoTFleetWiseClientTypes.NodeDataType?
        /// The deprecation message for the node or the branch that was moved or deleted.
        public var deprecationMessage: Swift.String?
        /// A brief description of a sensor.
        public var description: Swift.String?
        /// The fully qualified name of the sensor. For example, the fully qualified name of a sensor might be Vehicle.Body.Engine.Battery.
        /// This member is required.
        public var fullyQualifiedName: Swift.String?
        /// The specified possible maximum value of the sensor.
        public var max: Swift.Double?
        /// The specified possible minimum value of the sensor.
        public var min: Swift.Double?
        /// The scientific unit of measurement for data collected by the sensor.
        public var unit: Swift.String?

        public init(
            allowedValues: [Swift.String]? = nil,
            comment: Swift.String? = nil,
            dataType: IoTFleetWiseClientTypes.NodeDataType? = nil,
            deprecationMessage: Swift.String? = nil,
            description: Swift.String? = nil,
            fullyQualifiedName: Swift.String? = nil,
            max: Swift.Double? = nil,
            min: Swift.Double? = nil,
            unit: Swift.String? = nil
        )
        {
            self.allowedValues = allowedValues
            self.comment = comment
            self.dataType = dataType
            self.deprecationMessage = deprecationMessage
            self.description = description
            self.fullyQualifiedName = fullyQualifiedName
            self.max = max
            self.min = min
            self.unit = unit
        }
    }

}

extension IoTFleetWiseClientTypes.SignalCatalogSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case lastModificationTime
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about a collection of standardized signals, which can be attributes, branches, sensors, or actuators.
    public struct SignalCatalogSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the signal catalog.
        public var arn: Swift.String?
        /// The time the signal catalog was created in seconds since epoch (January 1, 1970 at midnight UTC time).
        public var creationTime: ClientRuntime.Date?
        /// The time the signal catalog was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).
        public var lastModificationTime: ClientRuntime.Date?
        /// The name of the signal catalog.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.lastModificationTime = lastModificationTime
            self.name = name
        }
    }

}

extension IoTFleetWiseClientTypes.SignalDecoder: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canSignal
        case fullyQualifiedName
        case interfaceId
        case obdSignal
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let canSignal = self.canSignal {
            try encodeContainer.encode(canSignal, forKey: .canSignal)
        }
        if let fullyQualifiedName = self.fullyQualifiedName {
            try encodeContainer.encode(fullyQualifiedName, forKey: .fullyQualifiedName)
        }
        if let interfaceId = self.interfaceId {
            try encodeContainer.encode(interfaceId, forKey: .interfaceId)
        }
        if let obdSignal = self.obdSignal {
            try encodeContainer.encode(obdSignal, forKey: .obdSignal)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fullyQualifiedNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fullyQualifiedName)
        fullyQualifiedName = fullyQualifiedNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.SignalDecoderType.self, forKey: .type)
        type = typeDecoded
        let interfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .interfaceId)
        interfaceId = interfaceIdDecoded
        let canSignalDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.CanSignal.self, forKey: .canSignal)
        canSignal = canSignalDecoded
        let obdSignalDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.ObdSignal.self, forKey: .obdSignal)
        obdSignal = obdSignalDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about a signal decoder.
    public struct SignalDecoder: Swift.Equatable {
        /// Information about signal decoder using the Controller Area Network (CAN) protocol.
        public var canSignal: IoTFleetWiseClientTypes.CanSignal?
        /// The fully qualified name of a signal decoder as defined in a vehicle model.
        /// This member is required.
        public var fullyQualifiedName: Swift.String?
        /// The ID of a network interface that specifies what network protocol a vehicle follows.
        /// This member is required.
        public var interfaceId: Swift.String?
        /// Information about signal decoder using the On-board diagnostic (OBD) II protocol.
        public var obdSignal: IoTFleetWiseClientTypes.ObdSignal?
        /// The network protocol for the vehicle. For example, CAN_SIGNAL specifies a protocol that defines how data is communicated between electronic control units (ECUs). OBD_SIGNAL specifies a protocol that defines how self-diagnostic data is communicated between ECUs.
        /// This member is required.
        public var type: IoTFleetWiseClientTypes.SignalDecoderType?

        public init(
            canSignal: IoTFleetWiseClientTypes.CanSignal? = nil,
            fullyQualifiedName: Swift.String? = nil,
            interfaceId: Swift.String? = nil,
            obdSignal: IoTFleetWiseClientTypes.ObdSignal? = nil,
            type: IoTFleetWiseClientTypes.SignalDecoderType? = nil
        )
        {
            self.canSignal = canSignal
            self.fullyQualifiedName = fullyQualifiedName
            self.interfaceId = interfaceId
            self.obdSignal = obdSignal
            self.type = type
        }
    }

}

extension IoTFleetWiseClientTypes {
    public enum SignalDecoderFailureReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canSignalInfoIsNull
        case conflictingSignal
        case duplicateSignal
        case networkInterfaceTypeIncompatibleWithSignalDecoderType
        case noDecoderInfoForSignalInModel
        case obdSignalInfoIsNull
        case signalNotAssociatedWithNetworkInterface
        case signalNotInModel
        case signalToAddAlreadyExists
        case sdkUnknown(Swift.String)

        public static var allCases: [SignalDecoderFailureReason] {
            return [
                .canSignalInfoIsNull,
                .conflictingSignal,
                .duplicateSignal,
                .networkInterfaceTypeIncompatibleWithSignalDecoderType,
                .noDecoderInfoForSignalInModel,
                .obdSignalInfoIsNull,
                .signalNotAssociatedWithNetworkInterface,
                .signalNotInModel,
                .signalToAddAlreadyExists,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canSignalInfoIsNull: return "CAN_SIGNAL_INFO_IS_NULL"
            case .conflictingSignal: return "CONFLICTING_SIGNAL"
            case .duplicateSignal: return "DUPLICATE_SIGNAL"
            case .networkInterfaceTypeIncompatibleWithSignalDecoderType: return "NETWORK_INTERFACE_TYPE_INCOMPATIBLE_WITH_SIGNAL_DECODER_TYPE"
            case .noDecoderInfoForSignalInModel: return "NO_DECODER_INFO_FOR_SIGNAL_IN_MODEL"
            case .obdSignalInfoIsNull: return "OBD_SIGNAL_INFO_IS_NULL"
            case .signalNotAssociatedWithNetworkInterface: return "SIGNAL_NOT_ASSOCIATED_WITH_NETWORK_INTERFACE"
            case .signalNotInModel: return "SIGNAL_NOT_IN_MODEL"
            case .signalToAddAlreadyExists: return "SIGNAL_TO_ADD_ALREADY_EXISTS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SignalDecoderFailureReason(rawValue: rawValue) ?? SignalDecoderFailureReason.sdkUnknown(rawValue)
        }
    }
}

extension IoTFleetWiseClientTypes {
    public enum SignalDecoderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canSignal
        case obdSignal
        case sdkUnknown(Swift.String)

        public static var allCases: [SignalDecoderType] {
            return [
                .canSignal,
                .obdSignal,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canSignal: return "CAN_SIGNAL"
            case .obdSignal: return "OBD_SIGNAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SignalDecoderType(rawValue: rawValue) ?? SignalDecoderType.sdkUnknown(rawValue)
        }
    }
}

extension IoTFleetWiseClientTypes.SignalInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxSampleCount
        case minimumSamplingIntervalMs
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxSampleCount = self.maxSampleCount {
            try encodeContainer.encode(maxSampleCount, forKey: .maxSampleCount)
        }
        if let minimumSamplingIntervalMs = self.minimumSamplingIntervalMs {
            try encodeContainer.encode(minimumSamplingIntervalMs, forKey: .minimumSamplingIntervalMs)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let maxSampleCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSampleCount)
        maxSampleCount = maxSampleCountDecoded
        let minimumSamplingIntervalMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumSamplingIntervalMs)
        minimumSamplingIntervalMs = minimumSamplingIntervalMsDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about a signal.
    public struct SignalInformation: Swift.Equatable {
        /// The maximum number of samples to collect.
        public var maxSampleCount: Swift.Int?
        /// The minimum duration of time (in milliseconds) between two triggering events to collect data. If a signal changes often, you might want to collect data at a slower rate.
        public var minimumSamplingIntervalMs: Swift.Int?
        /// The name of the signal.
        /// This member is required.
        public var name: Swift.String?

        public init(
            maxSampleCount: Swift.Int? = nil,
            minimumSamplingIntervalMs: Swift.Int? = nil,
            name: Swift.String? = nil
        )
        {
            self.maxSampleCount = maxSampleCount
            self.minimumSamplingIntervalMs = minimumSamplingIntervalMs
            self.name = name
        }
    }

}

extension IoTFleetWiseClientTypes {
    public enum SpoolingMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case off
        case toDisk
        case sdkUnknown(Swift.String)

        public static var allCases: [SpoolingMode] {
            return [
                .off,
                .toDisk,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .off: return "OFF"
            case .toDisk: return "TO_DISK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SpoolingMode(rawValue: rawValue) ?? SpoolingMode.sdkUnknown(rawValue)
        }
    }
}

extension IoTFleetWiseClientTypes {
    public enum StorageCompressionFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gzip
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageCompressionFormat] {
            return [
                .gzip,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gzip: return "GZIP"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StorageCompressionFormat(rawValue: rawValue) ?? StorageCompressionFormat.sdkUnknown(rawValue)
        }
    }
}

extension IoTFleetWiseClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// A set of key/value pairs that are used to manage the resource.
    public struct Tag: Swift.Equatable {
        /// The tag's key.
        /// This member is required.
        public var key: Swift.String?
        /// The tag's value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The new or modified tags for the resource.
    /// This member is required.
    public var tags: [IoTFleetWiseClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [IoTFleetWiseClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [IoTFleetWiseClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[IoTFleetWiseClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [IoTFleetWiseClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = 0
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request couldn't be completed due to throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The quota identifier of the applied throttling rules for this request.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The number of seconds to wait before retrying the command.
        public internal(set) var retryAfterSeconds: Swift.Int = 0
        /// The code for the service that couldn't be completed due to throttling.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let quotaCode: Swift.String?
    let serviceCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension IoTFleetWiseClientTypes.TimeBasedCollectionScheme: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case periodMs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let periodMs = self.periodMs {
            try encodeContainer.encode(periodMs, forKey: .periodMs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let periodMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .periodMs)
        periodMs = periodMsDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about a collection scheme that uses a time period to decide how often to collect data.
    public struct TimeBasedCollectionScheme: Swift.Equatable {
        /// The time period (in milliseconds) to decide how often to collect data. For example, if the time period is 60000, the Edge Agent software collects data once every minute.
        /// This member is required.
        public var periodMs: Swift.Int?

        public init(
            periodMs: Swift.Int? = nil
        )
        {
            self.periodMs = periodMs
        }
    }

}

extension IoTFleetWiseClientTypes.TimestreamConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionRoleArn
        case timestreamTableArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let timestreamTableArn = self.timestreamTableArn {
            try encodeContainer.encode(timestreamTableArn, forKey: .timestreamTableArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestreamTableArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestreamTableArn)
        timestreamTableArn = timestreamTableArnDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// The Amazon Timestream table where the Amazon Web Services IoT FleetWise campaign sends data. Timestream stores and organizes data to optimize query processing time and to reduce storage costs. For more information, see [Data modeling](https://docs.aws.amazon.com/timestream/latest/developerguide/data-modeling.html) in the Amazon Timestream Developer Guide.
    public struct TimestreamConfig: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the task execution role that grants Amazon Web Services IoT FleetWise permission to deliver data to the Amazon Timestream table.
        /// This member is required.
        public var executionRoleArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the Amazon Timestream table.
        /// This member is required.
        public var timestreamTableArn: Swift.String?

        public init(
            executionRoleArn: Swift.String? = nil,
            timestreamTableArn: Swift.String? = nil
        )
        {
            self.executionRoleArn = executionRoleArn
            self.timestreamTableArn = timestreamTableArn
        }
    }

}

extension IoTFleetWiseClientTypes.TimestreamRegistrationResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorMessage
        case registrationStatus
        case timestreamDatabaseArn
        case timestreamDatabaseName
        case timestreamTableArn
        case timestreamTableName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let registrationStatus = self.registrationStatus {
            try encodeContainer.encode(registrationStatus.rawValue, forKey: .registrationStatus)
        }
        if let timestreamDatabaseArn = self.timestreamDatabaseArn {
            try encodeContainer.encode(timestreamDatabaseArn, forKey: .timestreamDatabaseArn)
        }
        if let timestreamDatabaseName = self.timestreamDatabaseName {
            try encodeContainer.encode(timestreamDatabaseName, forKey: .timestreamDatabaseName)
        }
        if let timestreamTableArn = self.timestreamTableArn {
            try encodeContainer.encode(timestreamTableArn, forKey: .timestreamTableArn)
        }
        if let timestreamTableName = self.timestreamTableName {
            try encodeContainer.encode(timestreamTableName, forKey: .timestreamTableName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestreamDatabaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestreamDatabaseName)
        timestreamDatabaseName = timestreamDatabaseNameDecoded
        let timestreamTableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestreamTableName)
        timestreamTableName = timestreamTableNameDecoded
        let timestreamDatabaseArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestreamDatabaseArn)
        timestreamDatabaseArn = timestreamDatabaseArnDecoded
        let timestreamTableArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestreamTableArn)
        timestreamTableArn = timestreamTableArnDecoded
        let registrationStatusDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.RegistrationStatus.self, forKey: .registrationStatus)
        registrationStatus = registrationStatusDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about the registered Amazon Timestream resources or errors, if any.
    public struct TimestreamRegistrationResponse: Swift.Equatable {
        /// A message associated with a registration error.
        public var errorMessage: Swift.String?
        /// The status of registering your Amazon Timestream resources. The status can be one of REGISTRATION_SUCCESS, REGISTRATION_PENDING, REGISTRATION_FAILURE.
        /// This member is required.
        public var registrationStatus: IoTFleetWiseClientTypes.RegistrationStatus?
        /// The Amazon Resource Name (ARN) of the Timestream database.
        public var timestreamDatabaseArn: Swift.String?
        /// The name of the Timestream database.
        /// This member is required.
        public var timestreamDatabaseName: Swift.String?
        /// The ARN of the Timestream database table.
        public var timestreamTableArn: Swift.String?
        /// The name of the Timestream database table.
        /// This member is required.
        public var timestreamTableName: Swift.String?

        public init(
            errorMessage: Swift.String? = nil,
            registrationStatus: IoTFleetWiseClientTypes.RegistrationStatus? = nil,
            timestreamDatabaseArn: Swift.String? = nil,
            timestreamDatabaseName: Swift.String? = nil,
            timestreamTableArn: Swift.String? = nil,
            timestreamTableName: Swift.String? = nil
        )
        {
            self.errorMessage = errorMessage
            self.registrationStatus = registrationStatus
            self.timestreamDatabaseArn = timestreamDatabaseArn
            self.timestreamDatabaseName = timestreamDatabaseName
            self.timestreamTableArn = timestreamTableArn
            self.timestreamTableName = timestreamTableName
        }
    }

}

extension IoTFleetWiseClientTypes.TimestreamResources: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timestreamDatabaseName
        case timestreamTableName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timestreamDatabaseName = self.timestreamDatabaseName {
            try encodeContainer.encode(timestreamDatabaseName, forKey: .timestreamDatabaseName)
        }
        if let timestreamTableName = self.timestreamTableName {
            try encodeContainer.encode(timestreamTableName, forKey: .timestreamTableName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestreamDatabaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestreamDatabaseName)
        timestreamDatabaseName = timestreamDatabaseNameDecoded
        let timestreamTableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestreamTableName)
        timestreamTableName = timestreamTableNameDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// The registered Amazon Timestream resources that Amazon Web Services IoT FleetWise edge agent software can transfer your vehicle data to.
    public struct TimestreamResources: Swift.Equatable {
        /// The name of the registered Amazon Timestream database.
        /// This member is required.
        public var timestreamDatabaseName: Swift.String?
        /// The name of the registered Amazon Timestream database table.
        /// This member is required.
        public var timestreamTableName: Swift.String?

        public init(
            timestreamDatabaseName: Swift.String? = nil,
            timestreamTableName: Swift.String? = nil
        )
        {
            self.timestreamDatabaseName = timestreamDatabaseName
            self.timestreamTableName = timestreamTableName
        }
    }

}

extension IoTFleetWiseClientTypes {
    public enum TriggerMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case always
        case risingEdge
        case sdkUnknown(Swift.String)

        public static var allCases: [TriggerMode] {
            return [
                .always,
                .risingEdge,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .always: return "ALWAYS"
            case .risingEdge: return "RISING_EDGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TriggerMode(rawValue: rawValue) ?? TriggerMode.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of the keys of the tags to be removed from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTFleetWiseClientTypes {
    public enum UpdateCampaignAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approve
        case resume
        case suspend
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateCampaignAction] {
            return [
                .approve,
                .resume,
                .suspend,
                .update,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approve: return "APPROVE"
            case .resume: return "RESUME"
            case .suspend: return "SUSPEND"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateCampaignAction(rawValue: rawValue) ?? UpdateCampaignAction.sdkUnknown(rawValue)
        }
    }
}

extension UpdateCampaignInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case dataExtraDimensions
        case description
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let dataExtraDimensions = dataExtraDimensions {
            var dataExtraDimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataExtraDimensions)
            for nodepath0 in dataExtraDimensions {
                try dataExtraDimensionsContainer.encode(nodepath0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateCampaignInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateCampaignInput: Swift.Equatable {
    /// Specifies how to update a campaign. The action can be one of the following:
    ///
    /// * APPROVE - To approve delivering a data collection scheme to vehicles.
    ///
    /// * SUSPEND - To suspend collecting signal data. The campaign is deleted from vehicles and all vehicles in the suspended campaign will stop sending data.
    ///
    /// * RESUME - To reactivate the SUSPEND campaign. The campaign is redeployed to all vehicles and the vehicles will resume sending data.
    ///
    /// * UPDATE - To update a campaign.
    /// This member is required.
    public var action: IoTFleetWiseClientTypes.UpdateCampaignAction?
    /// A list of vehicle attributes to associate with a signal. Default: An empty array
    public var dataExtraDimensions: [Swift.String]?
    /// The description of the campaign.
    public var description: Swift.String?
    /// The name of the campaign to update.
    /// This member is required.
    public var name: Swift.String?

    public init(
        action: IoTFleetWiseClientTypes.UpdateCampaignAction? = nil,
        dataExtraDimensions: [Swift.String]? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.action = action
        self.dataExtraDimensions = dataExtraDimensions
        self.description = description
        self.name = name
    }
}

struct UpdateCampaignInputBody: Swift.Equatable {
    let description: Swift.String?
    let dataExtraDimensions: [Swift.String]?
    let action: IoTFleetWiseClientTypes.UpdateCampaignAction?
}

extension UpdateCampaignInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case dataExtraDimensions
        case description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dataExtraDimensionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dataExtraDimensions)
        var dataExtraDimensionsDecoded0:[Swift.String]? = nil
        if let dataExtraDimensionsContainer = dataExtraDimensionsContainer {
            dataExtraDimensionsDecoded0 = [Swift.String]()
            for string0 in dataExtraDimensionsContainer {
                if let string0 = string0 {
                    dataExtraDimensionsDecoded0?.append(string0)
                }
            }
        }
        dataExtraDimensions = dataExtraDimensionsDecoded0
        let actionDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.UpdateCampaignAction.self, forKey: .action)
        action = actionDecoded
    }
}

extension UpdateCampaignOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateCampaignOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
            self.status = output.status
        } else {
            self.arn = nil
            self.name = nil
            self.status = nil
        }
    }
}

public struct UpdateCampaignOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the campaign.
    public var arn: Swift.String?
    /// The name of the updated campaign.
    public var name: Swift.String?
    /// The state of a campaign. The status can be one of:
    ///
    /// * CREATING - Amazon Web Services IoT FleetWise is processing your request to create the campaign.
    ///
    /// * WAITING_FOR_APPROVAL - After a campaign is created, it enters the WAITING_FOR_APPROVAL state. To allow Amazon Web Services IoT FleetWise to deploy the campaign to the target vehicle or fleet, use the API operation to approve the campaign.
    ///
    /// * RUNNING - The campaign is active.
    ///
    /// * SUSPENDED - The campaign is suspended. To resume the campaign, use the API operation.
    public var status: IoTFleetWiseClientTypes.CampaignStatus?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil,
        status: IoTFleetWiseClientTypes.CampaignStatus? = nil
    )
    {
        self.arn = arn
        self.name = name
        self.status = status
    }
}

struct UpdateCampaignOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let status: IoTFleetWiseClientTypes.CampaignStatus?
}

extension UpdateCampaignOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.CampaignStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum UpdateCampaignOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDecoderManifestInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case networkInterfacesToAdd
        case networkInterfacesToRemove
        case networkInterfacesToUpdate
        case signalDecodersToAdd
        case signalDecodersToRemove
        case signalDecodersToUpdate
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let networkInterfacesToAdd = networkInterfacesToAdd {
            var networkInterfacesToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInterfacesToAdd)
            for networkinterface0 in networkInterfacesToAdd {
                try networkInterfacesToAddContainer.encode(networkinterface0)
            }
        }
        if let networkInterfacesToRemove = networkInterfacesToRemove {
            var networkInterfacesToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInterfacesToRemove)
            for interfaceid0 in networkInterfacesToRemove {
                try networkInterfacesToRemoveContainer.encode(interfaceid0)
            }
        }
        if let networkInterfacesToUpdate = networkInterfacesToUpdate {
            var networkInterfacesToUpdateContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInterfacesToUpdate)
            for networkinterface0 in networkInterfacesToUpdate {
                try networkInterfacesToUpdateContainer.encode(networkinterface0)
            }
        }
        if let signalDecodersToAdd = signalDecodersToAdd {
            var signalDecodersToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .signalDecodersToAdd)
            for signaldecoder0 in signalDecodersToAdd {
                try signalDecodersToAddContainer.encode(signaldecoder0)
            }
        }
        if let signalDecodersToRemove = signalDecodersToRemove {
            var signalDecodersToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .signalDecodersToRemove)
            for fullyqualifiedname0 in signalDecodersToRemove {
                try signalDecodersToRemoveContainer.encode(fullyqualifiedname0)
            }
        }
        if let signalDecodersToUpdate = signalDecodersToUpdate {
            var signalDecodersToUpdateContainer = encodeContainer.nestedUnkeyedContainer(forKey: .signalDecodersToUpdate)
            for signaldecoder0 in signalDecodersToUpdate {
                try signalDecodersToUpdateContainer.encode(signaldecoder0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateDecoderManifestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateDecoderManifestInput: Swift.Equatable {
    /// A brief description of the decoder manifest to update.
    public var description: Swift.String?
    /// The name of the decoder manifest to update.
    /// This member is required.
    public var name: Swift.String?
    /// A list of information about the network interfaces to add to the decoder manifest.
    public var networkInterfacesToAdd: [IoTFleetWiseClientTypes.NetworkInterface]?
    /// A list of network interfaces to remove from the decoder manifest.
    public var networkInterfacesToRemove: [Swift.String]?
    /// A list of information about the network interfaces to update in the decoder manifest.
    public var networkInterfacesToUpdate: [IoTFleetWiseClientTypes.NetworkInterface]?
    /// A list of information about decoding additional signals to add to the decoder manifest.
    public var signalDecodersToAdd: [IoTFleetWiseClientTypes.SignalDecoder]?
    /// A list of signal decoders to remove from the decoder manifest.
    public var signalDecodersToRemove: [Swift.String]?
    /// A list of updated information about decoding signals to update in the decoder manifest.
    public var signalDecodersToUpdate: [IoTFleetWiseClientTypes.SignalDecoder]?
    /// The state of the decoder manifest. If the status is ACTIVE, the decoder manifest can't be edited. If the status is DRAFT, you can edit the decoder manifest.
    public var status: IoTFleetWiseClientTypes.ManifestStatus?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        networkInterfacesToAdd: [IoTFleetWiseClientTypes.NetworkInterface]? = nil,
        networkInterfacesToRemove: [Swift.String]? = nil,
        networkInterfacesToUpdate: [IoTFleetWiseClientTypes.NetworkInterface]? = nil,
        signalDecodersToAdd: [IoTFleetWiseClientTypes.SignalDecoder]? = nil,
        signalDecodersToRemove: [Swift.String]? = nil,
        signalDecodersToUpdate: [IoTFleetWiseClientTypes.SignalDecoder]? = nil,
        status: IoTFleetWiseClientTypes.ManifestStatus? = nil
    )
    {
        self.description = description
        self.name = name
        self.networkInterfacesToAdd = networkInterfacesToAdd
        self.networkInterfacesToRemove = networkInterfacesToRemove
        self.networkInterfacesToUpdate = networkInterfacesToUpdate
        self.signalDecodersToAdd = signalDecodersToAdd
        self.signalDecodersToRemove = signalDecodersToRemove
        self.signalDecodersToUpdate = signalDecodersToUpdate
        self.status = status
    }
}

struct UpdateDecoderManifestInputBody: Swift.Equatable {
    let description: Swift.String?
    let signalDecodersToAdd: [IoTFleetWiseClientTypes.SignalDecoder]?
    let signalDecodersToUpdate: [IoTFleetWiseClientTypes.SignalDecoder]?
    let signalDecodersToRemove: [Swift.String]?
    let networkInterfacesToAdd: [IoTFleetWiseClientTypes.NetworkInterface]?
    let networkInterfacesToUpdate: [IoTFleetWiseClientTypes.NetworkInterface]?
    let networkInterfacesToRemove: [Swift.String]?
    let status: IoTFleetWiseClientTypes.ManifestStatus?
}

extension UpdateDecoderManifestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case networkInterfacesToAdd
        case networkInterfacesToRemove
        case networkInterfacesToUpdate
        case signalDecodersToAdd
        case signalDecodersToRemove
        case signalDecodersToUpdate
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let signalDecodersToAddContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.SignalDecoder?].self, forKey: .signalDecodersToAdd)
        var signalDecodersToAddDecoded0:[IoTFleetWiseClientTypes.SignalDecoder]? = nil
        if let signalDecodersToAddContainer = signalDecodersToAddContainer {
            signalDecodersToAddDecoded0 = [IoTFleetWiseClientTypes.SignalDecoder]()
            for structure0 in signalDecodersToAddContainer {
                if let structure0 = structure0 {
                    signalDecodersToAddDecoded0?.append(structure0)
                }
            }
        }
        signalDecodersToAdd = signalDecodersToAddDecoded0
        let signalDecodersToUpdateContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.SignalDecoder?].self, forKey: .signalDecodersToUpdate)
        var signalDecodersToUpdateDecoded0:[IoTFleetWiseClientTypes.SignalDecoder]? = nil
        if let signalDecodersToUpdateContainer = signalDecodersToUpdateContainer {
            signalDecodersToUpdateDecoded0 = [IoTFleetWiseClientTypes.SignalDecoder]()
            for structure0 in signalDecodersToUpdateContainer {
                if let structure0 = structure0 {
                    signalDecodersToUpdateDecoded0?.append(structure0)
                }
            }
        }
        signalDecodersToUpdate = signalDecodersToUpdateDecoded0
        let signalDecodersToRemoveContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .signalDecodersToRemove)
        var signalDecodersToRemoveDecoded0:[Swift.String]? = nil
        if let signalDecodersToRemoveContainer = signalDecodersToRemoveContainer {
            signalDecodersToRemoveDecoded0 = [Swift.String]()
            for string0 in signalDecodersToRemoveContainer {
                if let string0 = string0 {
                    signalDecodersToRemoveDecoded0?.append(string0)
                }
            }
        }
        signalDecodersToRemove = signalDecodersToRemoveDecoded0
        let networkInterfacesToAddContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.NetworkInterface?].self, forKey: .networkInterfacesToAdd)
        var networkInterfacesToAddDecoded0:[IoTFleetWiseClientTypes.NetworkInterface]? = nil
        if let networkInterfacesToAddContainer = networkInterfacesToAddContainer {
            networkInterfacesToAddDecoded0 = [IoTFleetWiseClientTypes.NetworkInterface]()
            for structure0 in networkInterfacesToAddContainer {
                if let structure0 = structure0 {
                    networkInterfacesToAddDecoded0?.append(structure0)
                }
            }
        }
        networkInterfacesToAdd = networkInterfacesToAddDecoded0
        let networkInterfacesToUpdateContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.NetworkInterface?].self, forKey: .networkInterfacesToUpdate)
        var networkInterfacesToUpdateDecoded0:[IoTFleetWiseClientTypes.NetworkInterface]? = nil
        if let networkInterfacesToUpdateContainer = networkInterfacesToUpdateContainer {
            networkInterfacesToUpdateDecoded0 = [IoTFleetWiseClientTypes.NetworkInterface]()
            for structure0 in networkInterfacesToUpdateContainer {
                if let structure0 = structure0 {
                    networkInterfacesToUpdateDecoded0?.append(structure0)
                }
            }
        }
        networkInterfacesToUpdate = networkInterfacesToUpdateDecoded0
        let networkInterfacesToRemoveContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .networkInterfacesToRemove)
        var networkInterfacesToRemoveDecoded0:[Swift.String]? = nil
        if let networkInterfacesToRemoveContainer = networkInterfacesToRemoveContainer {
            networkInterfacesToRemoveDecoded0 = [Swift.String]()
            for string0 in networkInterfacesToRemoveContainer {
                if let string0 = string0 {
                    networkInterfacesToRemoveDecoded0?.append(string0)
                }
            }
        }
        networkInterfacesToRemove = networkInterfacesToRemoveDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.ManifestStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateDecoderManifestOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateDecoderManifestOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct UpdateDecoderManifestOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the updated decoder manifest.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the updated decoder manifest.
    /// This member is required.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct UpdateDecoderManifestOutputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
}

extension UpdateDecoderManifestOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum UpdateDecoderManifestOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DecoderManifestValidationException": return try await DecoderManifestValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateFleetInput: Swift.Equatable {
    /// An updated description of the fleet.
    public var description: Swift.String?
    /// The ID of the fleet to update.
    /// This member is required.
    public var fleetId: Swift.String?

    public init(
        description: Swift.String? = nil,
        fleetId: Swift.String? = nil
    )
    {
        self.description = description
        self.fleetId = fleetId
    }
}

struct UpdateFleetInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension UpdateFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateFleetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateFleetOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct UpdateFleetOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the updated fleet.
    public var arn: Swift.String?
    /// The ID of the updated fleet.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct UpdateFleetOutputBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
}

extension UpdateFleetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum UpdateFleetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTFleetWiseClientTypes {
    public enum UpdateMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case merge
        case overwrite
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateMode] {
            return [
                .merge,
                .overwrite,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .merge: return "Merge"
            case .overwrite: return "Overwrite"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateMode(rawValue: rawValue) ?? UpdateMode.sdkUnknown(rawValue)
        }
    }
}

extension UpdateModelManifestInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case nodesToAdd
        case nodesToRemove
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let nodesToAdd = nodesToAdd {
            var nodesToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodesToAdd)
            for nodepath0 in nodesToAdd {
                try nodesToAddContainer.encode(nodepath0)
            }
        }
        if let nodesToRemove = nodesToRemove {
            var nodesToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodesToRemove)
            for nodepath0 in nodesToRemove {
                try nodesToRemoveContainer.encode(nodepath0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateModelManifestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateModelManifestInput: Swift.Equatable {
    /// A brief description of the vehicle model.
    public var description: Swift.String?
    /// The name of the vehicle model to update.
    /// This member is required.
    public var name: Swift.String?
    /// A list of fullyQualifiedName of nodes, which are a general abstraction of signals, to add to the vehicle model.
    public var nodesToAdd: [Swift.String]?
    /// A list of fullyQualifiedName of nodes, which are a general abstraction of signals, to remove from the vehicle model.
    public var nodesToRemove: [Swift.String]?
    /// The state of the vehicle model. If the status is ACTIVE, the vehicle model can't be edited. If the status is DRAFT, you can edit the vehicle model.
    public var status: IoTFleetWiseClientTypes.ManifestStatus?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        nodesToAdd: [Swift.String]? = nil,
        nodesToRemove: [Swift.String]? = nil,
        status: IoTFleetWiseClientTypes.ManifestStatus? = nil
    )
    {
        self.description = description
        self.name = name
        self.nodesToAdd = nodesToAdd
        self.nodesToRemove = nodesToRemove
        self.status = status
    }
}

struct UpdateModelManifestInputBody: Swift.Equatable {
    let description: Swift.String?
    let nodesToAdd: [Swift.String]?
    let nodesToRemove: [Swift.String]?
    let status: IoTFleetWiseClientTypes.ManifestStatus?
}

extension UpdateModelManifestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case nodesToAdd
        case nodesToRemove
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nodesToAddContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .nodesToAdd)
        var nodesToAddDecoded0:[Swift.String]? = nil
        if let nodesToAddContainer = nodesToAddContainer {
            nodesToAddDecoded0 = [Swift.String]()
            for string0 in nodesToAddContainer {
                if let string0 = string0 {
                    nodesToAddDecoded0?.append(string0)
                }
            }
        }
        nodesToAdd = nodesToAddDecoded0
        let nodesToRemoveContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .nodesToRemove)
        var nodesToRemoveDecoded0:[Swift.String]? = nil
        if let nodesToRemoveContainer = nodesToRemoveContainer {
            nodesToRemoveDecoded0 = [Swift.String]()
            for string0 in nodesToRemoveContainer {
                if let string0 = string0 {
                    nodesToRemoveDecoded0?.append(string0)
                }
            }
        }
        nodesToRemove = nodesToRemoveDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.ManifestStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateModelManifestOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateModelManifestOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct UpdateModelManifestOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the updated vehicle model.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the updated vehicle model.
    /// This member is required.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct UpdateModelManifestOutputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
}

extension UpdateModelManifestOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum UpdateModelManifestOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidSignalsException": return try await InvalidSignalsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSignalCatalogInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case nodesToAdd
        case nodesToRemove
        case nodesToUpdate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let nodesToAdd = nodesToAdd {
            var nodesToAddContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodesToAdd)
            for node0 in nodesToAdd {
                try nodesToAddContainer.encode(node0)
            }
        }
        if let nodesToRemove = nodesToRemove {
            var nodesToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodesToRemove)
            for nodepath0 in nodesToRemove {
                try nodesToRemoveContainer.encode(nodepath0)
            }
        }
        if let nodesToUpdate = nodesToUpdate {
            var nodesToUpdateContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodesToUpdate)
            for node0 in nodesToUpdate {
                try nodesToUpdateContainer.encode(node0)
            }
        }
    }
}

extension UpdateSignalCatalogInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateSignalCatalogInput: Swift.Equatable {
    /// A brief description of the signal catalog to update.
    public var description: Swift.String?
    /// The name of the signal catalog to update.
    /// This member is required.
    public var name: Swift.String?
    /// A list of information about nodes to add to the signal catalog.
    public var nodesToAdd: [IoTFleetWiseClientTypes.Node]?
    /// A list of fullyQualifiedName of nodes to remove from the signal catalog.
    public var nodesToRemove: [Swift.String]?
    /// A list of information about nodes to update in the signal catalog.
    public var nodesToUpdate: [IoTFleetWiseClientTypes.Node]?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        nodesToAdd: [IoTFleetWiseClientTypes.Node]? = nil,
        nodesToRemove: [Swift.String]? = nil,
        nodesToUpdate: [IoTFleetWiseClientTypes.Node]? = nil
    )
    {
        self.description = description
        self.name = name
        self.nodesToAdd = nodesToAdd
        self.nodesToRemove = nodesToRemove
        self.nodesToUpdate = nodesToUpdate
    }
}

struct UpdateSignalCatalogInputBody: Swift.Equatable {
    let description: Swift.String?
    let nodesToAdd: [IoTFleetWiseClientTypes.Node]?
    let nodesToUpdate: [IoTFleetWiseClientTypes.Node]?
    let nodesToRemove: [Swift.String]?
}

extension UpdateSignalCatalogInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case nodesToAdd
        case nodesToRemove
        case nodesToUpdate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nodesToAddContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.Node?].self, forKey: .nodesToAdd)
        var nodesToAddDecoded0:[IoTFleetWiseClientTypes.Node]? = nil
        if let nodesToAddContainer = nodesToAddContainer {
            nodesToAddDecoded0 = [IoTFleetWiseClientTypes.Node]()
            for union0 in nodesToAddContainer {
                if let union0 = union0 {
                    nodesToAddDecoded0?.append(union0)
                }
            }
        }
        nodesToAdd = nodesToAddDecoded0
        let nodesToUpdateContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.Node?].self, forKey: .nodesToUpdate)
        var nodesToUpdateDecoded0:[IoTFleetWiseClientTypes.Node]? = nil
        if let nodesToUpdateContainer = nodesToUpdateContainer {
            nodesToUpdateDecoded0 = [IoTFleetWiseClientTypes.Node]()
            for union0 in nodesToUpdateContainer {
                if let union0 = union0 {
                    nodesToUpdateDecoded0?.append(union0)
                }
            }
        }
        nodesToUpdate = nodesToUpdateDecoded0
        let nodesToRemoveContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .nodesToRemove)
        var nodesToRemoveDecoded0:[Swift.String]? = nil
        if let nodesToRemoveContainer = nodesToRemoveContainer {
            nodesToRemoveDecoded0 = [Swift.String]()
            for string0 in nodesToRemoveContainer {
                if let string0 = string0 {
                    nodesToRemoveDecoded0?.append(string0)
                }
            }
        }
        nodesToRemove = nodesToRemoveDecoded0
    }
}

extension UpdateSignalCatalogOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSignalCatalogOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct UpdateSignalCatalogOutput: Swift.Equatable {
    /// The ARN of the updated signal catalog.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the updated signal catalog.
    /// This member is required.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct UpdateSignalCatalogOutputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
}

extension UpdateSignalCatalogOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum UpdateSignalCatalogOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNodeException": return try await InvalidNodeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidSignalsException": return try await InvalidSignalsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTFleetWiseClientTypes.UpdateVehicleError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case vehicleName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if code != 0 {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let vehicleName = self.vehicleName {
            try encodeContainer.encode(vehicleName, forKey: .vehicleName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vehicleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vehicleName)
        vehicleName = vehicleNameDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .code) ?? 0
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// An HTTP error resulting from updating the description for a vehicle.
    public struct UpdateVehicleError: Swift.Equatable {
        /// The relevant HTTP error code (400+).
        public var code: Swift.Int
        /// A message associated with the error.
        public var message: Swift.String?
        /// The ID of the vehicle with the error.
        public var vehicleName: Swift.String?

        public init(
            code: Swift.Int = 0,
            message: Swift.String? = nil,
            vehicleName: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
            self.vehicleName = vehicleName
        }
    }

}

extension UpdateVehicleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeUpdateMode
        case attributes
        case decoderManifestArn
        case modelManifestArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeUpdateMode = self.attributeUpdateMode {
            try encodeContainer.encode(attributeUpdateMode.rawValue, forKey: .attributeUpdateMode)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributesMap0) in attributes {
                try attributesContainer.encode(attributesMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let decoderManifestArn = self.decoderManifestArn {
            try encodeContainer.encode(decoderManifestArn, forKey: .decoderManifestArn)
        }
        if let modelManifestArn = self.modelManifestArn {
            try encodeContainer.encode(modelManifestArn, forKey: .modelManifestArn)
        }
    }
}

extension UpdateVehicleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateVehicleInput: Swift.Equatable {
    /// The method the specified attributes will update the existing attributes on the vehicle. UseOverwite to replace the vehicle attributes with the specified attributes. Or use Merge to combine all attributes. This is required if attributes are present in the input.
    public var attributeUpdateMode: IoTFleetWiseClientTypes.UpdateMode?
    /// Static information about a vehicle in a key-value pair. For example: "engineType" : "1.3 L R2"
    public var attributes: [Swift.String:Swift.String]?
    /// The ARN of the decoder manifest associated with this vehicle.
    public var decoderManifestArn: Swift.String?
    /// The ARN of a vehicle model (model manifest) associated with the vehicle.
    public var modelManifestArn: Swift.String?
    /// The unique ID of the vehicle to update.
    /// This member is required.
    public var vehicleName: Swift.String?

    public init(
        attributeUpdateMode: IoTFleetWiseClientTypes.UpdateMode? = nil,
        attributes: [Swift.String:Swift.String]? = nil,
        decoderManifestArn: Swift.String? = nil,
        modelManifestArn: Swift.String? = nil,
        vehicleName: Swift.String? = nil
    )
    {
        self.attributeUpdateMode = attributeUpdateMode
        self.attributes = attributes
        self.decoderManifestArn = decoderManifestArn
        self.modelManifestArn = modelManifestArn
        self.vehicleName = vehicleName
    }
}

struct UpdateVehicleInputBody: Swift.Equatable {
    let modelManifestArn: Swift.String?
    let decoderManifestArn: Swift.String?
    let attributes: [Swift.String:Swift.String]?
    let attributeUpdateMode: IoTFleetWiseClientTypes.UpdateMode?
}

extension UpdateVehicleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeUpdateMode
        case attributes
        case decoderManifestArn
        case modelManifestArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelManifestArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelManifestArn)
        modelManifestArn = modelManifestArnDecoded
        let decoderManifestArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .decoderManifestArn)
        decoderManifestArn = decoderManifestArnDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let attributeUpdateModeDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.UpdateMode.self, forKey: .attributeUpdateMode)
        attributeUpdateMode = attributeUpdateModeDecoded
    }
}

extension UpdateVehicleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateVehicleOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.vehicleName = output.vehicleName
        } else {
            self.arn = nil
            self.vehicleName = nil
        }
    }
}

public struct UpdateVehicleOutput: Swift.Equatable {
    /// The ARN of the updated vehicle.
    public var arn: Swift.String?
    /// The ID of the updated vehicle.
    public var vehicleName: Swift.String?

    public init(
        arn: Swift.String? = nil,
        vehicleName: Swift.String? = nil
    )
    {
        self.arn = arn
        self.vehicleName = vehicleName
    }
}

struct UpdateVehicleOutputBody: Swift.Equatable {
    let vehicleName: Swift.String?
    let arn: Swift.String?
}

extension UpdateVehicleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case vehicleName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vehicleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vehicleName)
        vehicleName = vehicleNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum UpdateVehicleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await IoTFleetWiseClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTFleetWiseClientTypes.UpdateVehicleRequestItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeUpdateMode
        case attributes
        case decoderManifestArn
        case modelManifestArn
        case vehicleName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeUpdateMode = self.attributeUpdateMode {
            try encodeContainer.encode(attributeUpdateMode.rawValue, forKey: .attributeUpdateMode)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributesMap0) in attributes {
                try attributesContainer.encode(attributesMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let decoderManifestArn = self.decoderManifestArn {
            try encodeContainer.encode(decoderManifestArn, forKey: .decoderManifestArn)
        }
        if let modelManifestArn = self.modelManifestArn {
            try encodeContainer.encode(modelManifestArn, forKey: .modelManifestArn)
        }
        if let vehicleName = self.vehicleName {
            try encodeContainer.encode(vehicleName, forKey: .vehicleName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vehicleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vehicleName)
        vehicleName = vehicleNameDecoded
        let modelManifestArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelManifestArn)
        modelManifestArn = modelManifestArnDecoded
        let decoderManifestArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .decoderManifestArn)
        decoderManifestArn = decoderManifestArnDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let attributeUpdateModeDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.UpdateMode.self, forKey: .attributeUpdateMode)
        attributeUpdateMode = attributeUpdateModeDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about the vehicle to update.
    public struct UpdateVehicleRequestItem: Swift.Equatable {
        /// The method the specified attributes will update the existing attributes on the vehicle. UseOverwite to replace the vehicle attributes with the specified attributes. Or use Merge to combine all attributes. This is required if attributes are present in the input.
        public var attributeUpdateMode: IoTFleetWiseClientTypes.UpdateMode?
        /// Static information about a vehicle in a key-value pair. For example: "engineType" : "1.3 L R2"
        public var attributes: [Swift.String:Swift.String]?
        /// The ARN of the signal decoder manifest associated with the vehicle to update.
        public var decoderManifestArn: Swift.String?
        /// The ARN of the vehicle model (model manifest) associated with the vehicle to update.
        public var modelManifestArn: Swift.String?
        /// The unique ID of the vehicle to update.
        /// This member is required.
        public var vehicleName: Swift.String?

        public init(
            attributeUpdateMode: IoTFleetWiseClientTypes.UpdateMode? = nil,
            attributes: [Swift.String:Swift.String]? = nil,
            decoderManifestArn: Swift.String? = nil,
            modelManifestArn: Swift.String? = nil,
            vehicleName: Swift.String? = nil
        )
        {
            self.attributeUpdateMode = attributeUpdateMode
            self.attributes = attributes
            self.decoderManifestArn = decoderManifestArn
            self.modelManifestArn = modelManifestArn
            self.vehicleName = vehicleName
        }
    }

}

extension IoTFleetWiseClientTypes.UpdateVehicleResponseItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case vehicleName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let vehicleName = self.vehicleName {
            try encodeContainer.encode(vehicleName, forKey: .vehicleName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vehicleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vehicleName)
        vehicleName = vehicleNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about the updated vehicle.
    public struct UpdateVehicleResponseItem: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the updated vehicle.
        public var arn: Swift.String?
        /// The unique ID of the updated vehicle.
        public var vehicleName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            vehicleName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.vehicleName = vehicleName
        }
    }

}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fieldList = output.fieldList
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.fieldList = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The list of fields that fail to satisfy the constraints specified by an Amazon Web Services service.
        public internal(set) var fieldList: [IoTFleetWiseClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason the input failed to satisfy the constraints specified by an Amazon Web Services service.
        public internal(set) var reason: IoTFleetWiseClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [IoTFleetWiseClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: IoTFleetWiseClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: IoTFleetWiseClientTypes.ValidationExceptionReason?
    let fieldList: [IoTFleetWiseClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([IoTFleetWiseClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[IoTFleetWiseClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [IoTFleetWiseClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension IoTFleetWiseClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// A validation error due to mismatch between the expected data type, length, or pattern of the parameter and the input.
    public struct ValidationExceptionField: Swift.Equatable {
        /// A message about the validation error.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the parameter field with the validation error.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension IoTFleetWiseClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension IoTFleetWiseClientTypes {
    public enum VehicleAssociationBehavior: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createIotThing
        case validateIotThingExists
        case sdkUnknown(Swift.String)

        public static var allCases: [VehicleAssociationBehavior] {
            return [
                .createIotThing,
                .validateIotThingExists,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createIotThing: return "CreateIotThing"
            case .validateIotThingExists: return "ValidateIotThingExists"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VehicleAssociationBehavior(rawValue: rawValue) ?? VehicleAssociationBehavior.sdkUnknown(rawValue)
        }
    }
}

extension IoTFleetWiseClientTypes {
    public enum VehicleState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case deleting
        case healthy
        case ready
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [VehicleState] {
            return [
                .created,
                .deleting,
                .healthy,
                .ready,
                .suspended,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .deleting: return "DELETING"
            case .healthy: return "HEALTHY"
            case .ready: return "READY"
            case .suspended: return "SUSPENDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VehicleState(rawValue: rawValue) ?? VehicleState.sdkUnknown(rawValue)
        }
    }
}

extension IoTFleetWiseClientTypes.VehicleStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignName
        case status
        case vehicleName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignName = self.campaignName {
            try encodeContainer.encode(campaignName, forKey: .campaignName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let vehicleName = self.vehicleName {
            try encodeContainer.encode(vehicleName, forKey: .vehicleName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .campaignName)
        campaignName = campaignNameDecoded
        let vehicleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vehicleName)
        vehicleName = vehicleNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTFleetWiseClientTypes.VehicleState.self, forKey: .status)
        status = statusDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about the state of a vehicle and how it relates to the status of a campaign.
    public struct VehicleStatus: Swift.Equatable {
        /// The name of a campaign.
        public var campaignName: Swift.String?
        /// The state of a vehicle, which can be one of the following:
        ///
        /// * CREATED - Amazon Web Services IoT FleetWise sucessfully created the vehicle.
        ///
        /// * READY - The vehicle is ready to receive a campaign deployment.
        ///
        /// * HEALTHY - A campaign deployment was delivered to the vehicle.
        ///
        /// * SUSPENDED - A campaign associated with the vehicle was suspended and data collection was paused.
        ///
        /// * DELETING - Amazon Web Services IoT FleetWise is removing a campaign from the vehicle.
        public var status: IoTFleetWiseClientTypes.VehicleState?
        /// The unique ID of the vehicle.
        public var vehicleName: Swift.String?

        public init(
            campaignName: Swift.String? = nil,
            status: IoTFleetWiseClientTypes.VehicleState? = nil,
            vehicleName: Swift.String? = nil
        )
        {
            self.campaignName = campaignName
            self.status = status
            self.vehicleName = vehicleName
        }
    }

}

extension IoTFleetWiseClientTypes.VehicleSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case decoderManifestArn
        case lastModificationTime
        case modelManifestArn
        case vehicleName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let decoderManifestArn = self.decoderManifestArn {
            try encodeContainer.encode(decoderManifestArn, forKey: .decoderManifestArn)
        }
        if let lastModificationTime = self.lastModificationTime {
            try encodeContainer.encodeTimestamp(lastModificationTime, format: .epochSeconds, forKey: .lastModificationTime)
        }
        if let modelManifestArn = self.modelManifestArn {
            try encodeContainer.encode(modelManifestArn, forKey: .modelManifestArn)
        }
        if let vehicleName = self.vehicleName {
            try encodeContainer.encode(vehicleName, forKey: .vehicleName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vehicleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vehicleName)
        vehicleName = vehicleNameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let modelManifestArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelManifestArn)
        modelManifestArn = modelManifestArnDecoded
        let decoderManifestArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .decoderManifestArn)
        decoderManifestArn = decoderManifestArnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension IoTFleetWiseClientTypes {
    /// Information about a vehicle. To return this information about vehicles in your account, you can use the API operation.
    public struct VehicleSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the vehicle.
        /// This member is required.
        public var arn: Swift.String?
        /// The time the vehicle was created in seconds since epoch (January 1, 1970 at midnight UTC time).
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The ARN of a decoder manifest associated with the vehicle.
        /// This member is required.
        public var decoderManifestArn: Swift.String?
        /// The time the vehicle was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).
        /// This member is required.
        public var lastModificationTime: ClientRuntime.Date?
        /// The ARN of a vehicle model (model manifest) associated with the vehicle.
        /// This member is required.
        public var modelManifestArn: Swift.String?
        /// The unique ID of the vehicle.
        /// This member is required.
        public var vehicleName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            decoderManifestArn: Swift.String? = nil,
            lastModificationTime: ClientRuntime.Date? = nil,
            modelManifestArn: Swift.String? = nil,
            vehicleName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.decoderManifestArn = decoderManifestArn
            self.lastModificationTime = lastModificationTime
            self.modelManifestArn = modelManifestArn
            self.vehicleName = vehicleName
        }
    }

}
