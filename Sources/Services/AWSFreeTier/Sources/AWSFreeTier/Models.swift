//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class ClientRuntime.Indirect
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

/// You don't have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension FreeTierClientTypes {

    public enum AccountPlanStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case expired
        case notStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [AccountPlanStatus] {
            return [
                .active,
                .expired,
                .notStarted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .expired: return "EXPIRED"
            case .notStarted: return "NOT_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FreeTierClientTypes {

    public enum AccountPlanType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case free
        case paid
        case sdkUnknown(Swift.String)

        public static var allCases: [AccountPlanType] {
            return [
                .free,
                .paid
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .free: return "FREE"
            case .paid: return "PAID"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FreeTierClientTypes {

    public enum CurrencyCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case usd
        case sdkUnknown(Swift.String)

        public static var allCases: [CurrencyCode] {
            return [
                .usd
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .usd: return "USD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FreeTierClientTypes {

    /// The monetary amount of the credit.
    public struct MonetaryAmount: Swift.Sendable {
        /// The aggregated monetary amount of credits earned.
        /// This member is required.
        public var amount: Swift.Double
        /// The unit that the monetary amount is given in.
        /// This member is required.
        public var unit: FreeTierClientTypes.CurrencyCode?

        public init(
            amount: Swift.Double = 0.0,
            unit: FreeTierClientTypes.CurrencyCode? = nil
        ) {
            self.amount = amount
            self.unit = unit
        }
    }
}

extension FreeTierClientTypes {

    /// The summary of the rewards granted as a result of activities completed.
    public enum ActivityReward: Swift.Sendable {
        /// The credits gained by activity rewards.
        case credit(FreeTierClientTypes.MonetaryAmount)
        case sdkUnknown(Swift.String)
    }
}

extension FreeTierClientTypes {

    public enum ActivityStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case expiring
        case inProgress
        case notStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [ActivityStatus] {
            return [
                .completed,
                .expiring,
                .inProgress,
                .notStarted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .expiring: return "EXPIRING"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FreeTierClientTypes {

    /// The summary of activities.
    public struct ActivitySummary: Swift.Sendable {
        /// A unique identifier that identifies the activity.
        /// This member is required.
        public var activityId: Swift.String?
        /// The reward for the activity.
        /// This member is required.
        public var reward: FreeTierClientTypes.ActivityReward?
        /// The current status of the activity.
        /// This member is required.
        public var status: FreeTierClientTypes.ActivityStatus?
        /// The title of the activity.
        /// This member is required.
        public var title: Swift.String?

        public init(
            activityId: Swift.String? = nil,
            reward: FreeTierClientTypes.ActivityReward? = nil,
            status: FreeTierClientTypes.ActivityStatus? = nil,
            title: Swift.String? = nil
        ) {
            self.activityId = activityId
            self.reward = reward
            self.status = status
            self.title = title
        }
    }
}

/// An unexpected error occurred during the processing of your request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// This exception is thrown when the requested resource cannot be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The input fails to satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension FreeTierClientTypes {

    public enum LanguageCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deDe
        case enGb
        case enUs
        case esEs
        case frFr
        case idId
        case itIt
        case jaJp
        case koKr
        case ptPt
        case trTr
        case zhCn
        case zhTw
        case sdkUnknown(Swift.String)

        public static var allCases: [LanguageCode] {
            return [
                .deDe,
                .enGb,
                .enUs,
                .esEs,
                .frFr,
                .idId,
                .itIt,
                .jaJp,
                .koKr,
                .ptPt,
                .trTr,
                .zhCn,
                .zhTw
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deDe: return "de-DE"
            case .enGb: return "en-GB"
            case .enUs: return "en-US"
            case .esEs: return "es-ES"
            case .frFr: return "fr-FR"
            case .idId: return "id-ID"
            case .itIt: return "it-IT"
            case .jaJp: return "ja-JP"
            case .koKr: return "ko-KR"
            case .ptPt: return "pt-PT"
            case .trTr: return "tr-TR"
            case .zhCn: return "zh-CN"
            case .zhTw: return "zh-TW"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetAccountActivityInput: Swift.Sendable {
    /// A unique identifier that identifies the activity.
    /// This member is required.
    public var activityId: Swift.String?
    /// The language code used to return translated title and description fields.
    public var languageCode: FreeTierClientTypes.LanguageCode?

    public init(
        activityId: Swift.String? = nil,
        languageCode: FreeTierClientTypes.LanguageCode? = nil
    ) {
        self.activityId = activityId
        self.languageCode = languageCode
    }
}

public struct GetAccountActivityOutput: Swift.Sendable {
    /// A unique identifier that identifies the activity.
    /// This member is required.
    public var activityId: Swift.String?
    /// The timestamp when the activity is completed. This field appears only for activities in the COMPLETED state.
    public var completedAt: Foundation.Date?
    /// Provides detailed information about the activity and its expected outcomes.
    /// This member is required.
    public var description: Swift.String?
    /// The estimated time to complete the activity. This is the duration in minutes.
    public var estimatedTimeToCompleteInMinutes: Swift.Int?
    /// The time by which the activity must be completed to receive a reward.
    public var expiresAt: Foundation.Date?
    /// The URL resource that provides guidance on activity requirements and completion.
    /// This member is required.
    public var instructionsUrl: Swift.String?
    /// A reward granted upon activity completion.
    /// This member is required.
    public var reward: FreeTierClientTypes.ActivityReward?
    /// The timestamp when the activity started. This field appears only for activities in the IN_PROGRESS or COMPLETED states.
    public var startedAt: Foundation.Date?
    /// The current activity status.
    /// This member is required.
    public var status: FreeTierClientTypes.ActivityStatus?
    /// A short activity title.
    /// This member is required.
    public var title: Swift.String?

    public init(
        activityId: Swift.String? = nil,
        completedAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        estimatedTimeToCompleteInMinutes: Swift.Int? = nil,
        expiresAt: Foundation.Date? = nil,
        instructionsUrl: Swift.String? = nil,
        reward: FreeTierClientTypes.ActivityReward? = nil,
        startedAt: Foundation.Date? = nil,
        status: FreeTierClientTypes.ActivityStatus? = nil,
        title: Swift.String? = nil
    ) {
        self.activityId = activityId
        self.completedAt = completedAt
        self.description = description
        self.estimatedTimeToCompleteInMinutes = estimatedTimeToCompleteInMinutes
        self.expiresAt = expiresAt
        self.instructionsUrl = instructionsUrl
        self.reward = reward
        self.startedAt = startedAt
        self.status = status
        self.title = title
    }
}

public struct GetAccountPlanStateInput: Swift.Sendable {

    public init() { }
}

public struct GetAccountPlanStateOutput: Swift.Sendable {
    /// A unique identifier that identifies the account.
    /// This member is required.
    public var accountId: Swift.String?
    /// The timestamp for when the current account plan expires.
    public var accountPlanExpirationDate: Foundation.Date?
    /// The amount of credits remaining for the account.
    public var accountPlanRemainingCredits: FreeTierClientTypes.MonetaryAmount?
    /// The current status for the account plan.
    /// This member is required.
    public var accountPlanStatus: FreeTierClientTypes.AccountPlanStatus?
    /// The plan type for the account.
    /// This member is required.
    public var accountPlanType: FreeTierClientTypes.AccountPlanType?

    public init(
        accountId: Swift.String? = nil,
        accountPlanExpirationDate: Foundation.Date? = nil,
        accountPlanRemainingCredits: FreeTierClientTypes.MonetaryAmount? = nil,
        accountPlanStatus: FreeTierClientTypes.AccountPlanStatus? = nil,
        accountPlanType: FreeTierClientTypes.AccountPlanType? = nil
    ) {
        self.accountId = accountId
        self.accountPlanExpirationDate = accountPlanExpirationDate
        self.accountPlanRemainingCredits = accountPlanRemainingCredits
        self.accountPlanStatus = accountPlanStatus
        self.accountPlanType = accountPlanType
    }
}

extension FreeTierClientTypes {

    public enum Dimension: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case description
        case freeTierType
        case operation
        case region
        case service
        case usagePercentage
        case usageType
        case sdkUnknown(Swift.String)

        public static var allCases: [Dimension] {
            return [
                .description,
                .freeTierType,
                .operation,
                .region,
                .service,
                .usagePercentage,
                .usageType
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .description: return "DESCRIPTION"
            case .freeTierType: return "FREE_TIER_TYPE"
            case .operation: return "OPERATION"
            case .region: return "REGION"
            case .service: return "SERVICE"
            case .usagePercentage: return "USAGE_PERCENTAGE"
            case .usageType: return "USAGE_TYPE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FreeTierClientTypes {

    public enum MatchOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contains
        case endsWith
        case equals
        case greaterThanOrEqual
        case startsWith
        case sdkUnknown(Swift.String)

        public static var allCases: [MatchOption] {
            return [
                .contains,
                .endsWith,
                .equals,
                .greaterThanOrEqual,
                .startsWith
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contains: return "CONTAINS"
            case .endsWith: return "ENDS_WITH"
            case .equals: return "EQUALS"
            case .greaterThanOrEqual: return "GREATER_THAN_OR_EQUAL"
            case .startsWith: return "STARTS_WITH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FreeTierClientTypes {

    /// Contains the specifications for the filters to use for your request.
    public struct DimensionValues: Swift.Sendable {
        /// The name of the dimension that you want to filter on.
        /// This member is required.
        public var key: FreeTierClientTypes.Dimension?
        /// The match options that you can use to filter your results. You can specify only one of these values in the array.
        /// This member is required.
        public var matchOptions: [FreeTierClientTypes.MatchOption]?
        /// The metadata values you can specify to filter upon, so that the results all match at least one of the specified values.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            key: FreeTierClientTypes.Dimension? = nil,
            matchOptions: [FreeTierClientTypes.MatchOption]? = nil,
            values: [Swift.String]? = nil
        ) {
            self.key = key
            self.matchOptions = matchOptions
            self.values = values
        }
    }
}

extension FreeTierClientTypes {

    /// Consists of a Amazon Web Services Free Tier offer’s metadata and your data usage for the offer.
    public struct FreeTierUsage: Swift.Sendable {
        /// Describes the actual usage accrued month-to-day (MTD) that you've used so far.
        public var actualUsageAmount: Swift.Double
        /// The description of the Free Tier offer.
        public var description: Swift.String?
        /// Describes the forecasted usage by the month that you're expected to use.
        public var forecastedUsageAmount: Swift.Double
        /// Describes the type of the Free Tier offer. For example, the offer can be "12 Months Free", "Always Free", and "Free Trial".
        public var freeTierType: Swift.String?
        /// Describes the maximum usage allowed in Free Tier.
        public var limit: Swift.Double
        /// Describes usageType more granularly with the specific Amazon Web Services service API operation. For example, this can be the RunInstances API operation for Amazon Elastic Compute Cloud.
        public var operation: Swift.String?
        /// Describes the Amazon Web Services Region for which this offer is applicable
        public var region: Swift.String?
        /// The name of the Amazon Web Services service providing the Free Tier offer. For example, this can be Amazon Elastic Compute Cloud.
        public var service: Swift.String?
        /// Describes the unit of the usageType, such as Hrs.
        public var unit: Swift.String?
        /// Describes the usage details of the offer. For example, this might be Global-BoxUsage:freetrial.
        public var usageType: Swift.String?

        public init(
            actualUsageAmount: Swift.Double = 0.0,
            description: Swift.String? = nil,
            forecastedUsageAmount: Swift.Double = 0.0,
            freeTierType: Swift.String? = nil,
            limit: Swift.Double = 0.0,
            operation: Swift.String? = nil,
            region: Swift.String? = nil,
            service: Swift.String? = nil,
            unit: Swift.String? = nil,
            usageType: Swift.String? = nil
        ) {
            self.actualUsageAmount = actualUsageAmount
            self.description = description
            self.forecastedUsageAmount = forecastedUsageAmount
            self.freeTierType = freeTierType
            self.limit = limit
            self.operation = operation
            self.region = region
            self.service = service
            self.unit = unit
            self.usageType = usageType
        }
    }
}

public struct GetFreeTierUsageOutput: Swift.Sendable {
    /// The list of Free Tier usage objects that meet your filter expression.
    /// This member is required.
    public var freeTierUsages: [FreeTierClientTypes.FreeTierUsage]?
    /// The pagination token that indicates the next set of results to retrieve.
    public var nextToken: Swift.String?

    public init(
        freeTierUsages: [FreeTierClientTypes.FreeTierUsage]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.freeTierUsages = freeTierUsages
        self.nextToken = nextToken
    }
}

public struct ListAccountActivitiesInput: Swift.Sendable {
    /// The activity status filter. This field can be used to filter the response by activities status.
    public var filterActivityStatuses: [FreeTierClientTypes.ActivityStatus]?
    /// The language code used to return translated titles.
    public var languageCode: FreeTierClientTypes.LanguageCode?
    /// The maximum number of items to return for this request. To get the next page of items, make another request with the token returned in the output.
    public var maxResults: Swift.Int?
    /// A token from a previous paginated response. If this is specified, the response includes records beginning from this token (inclusive), up to the number specified by maxResults.
    public var nextToken: Swift.String?

    public init(
        filterActivityStatuses: [FreeTierClientTypes.ActivityStatus]? = nil,
        languageCode: FreeTierClientTypes.LanguageCode? = nil,
        maxResults: Swift.Int? = 10,
        nextToken: Swift.String? = nil
    ) {
        self.filterActivityStatuses = filterActivityStatuses
        self.languageCode = languageCode
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAccountActivitiesOutput: Swift.Sendable {
    /// A brief information about the activities.
    /// This member is required.
    public var activities: [FreeTierClientTypes.ActivitySummary]?
    /// The token to include in another request to get the next page of items. This value is null when there are no more items to return.
    public var nextToken: Swift.String?

    public init(
        activities: [FreeTierClientTypes.ActivitySummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.activities = activities
        self.nextToken = nextToken
    }
}

public struct UpgradeAccountPlanInput: Swift.Sendable {
    /// The target account plan type. This makes it explicit about the change and latest value of the accountPlanType.
    /// This member is required.
    public var accountPlanType: FreeTierClientTypes.AccountPlanType?

    public init(
        accountPlanType: FreeTierClientTypes.AccountPlanType? = nil
    ) {
        self.accountPlanType = accountPlanType
    }
}

public struct UpgradeAccountPlanOutput: Swift.Sendable {
    /// A unique identifier that identifies the account.
    /// This member is required.
    public var accountId: Swift.String?
    /// This indicates the latest state of the account plan within its lifecycle.
    /// This member is required.
    public var accountPlanStatus: FreeTierClientTypes.AccountPlanStatus?
    /// The type of plan for the account.
    /// This member is required.
    public var accountPlanType: FreeTierClientTypes.AccountPlanType?

    public init(
        accountId: Swift.String? = nil,
        accountPlanStatus: FreeTierClientTypes.AccountPlanStatus? = nil,
        accountPlanType: FreeTierClientTypes.AccountPlanType? = nil
    ) {
        self.accountId = accountId
        self.accountPlanStatus = accountPlanStatus
        self.accountPlanType = accountPlanType
    }
}

extension FreeTierClientTypes {

    /// Use Expression to filter in the GetFreeTierUsage API operation. You can use the following patterns:
    ///
    /// * Simple dimension values (Dimensions root operator)
    ///
    /// * Complex expressions with logical operators (AND, NOT, and OR root operators).
    ///
    ///
    /// For simple dimension values, you can set the dimension name, values, and match type for the filters that you plan to use. Example for simple dimension values You can filter to match exactly for REGION==us-east-1 OR REGION==us-west-1. The corresponding Expression appears like the following: { "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ], "MatchOptions": ["EQUALS"] } } As shown in the previous example, lists of dimension values are combined with OR when you apply the filter. For complex expressions with logical operators, you can have nested expressions to use the logical operators and specify advanced filtering. Example for complex expressions with logical operators You can filter by ((REGION == us-east-1 OR REGION == us-west-1) OR (SERVICE CONTAINS AWSLambda)) AND (USAGE_TYPE !CONTAINS DataTransfer). The corresponding Expression appears like the following: { "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ], "MatchOptions": ["EQUALS"] }}, {"Dimensions": { "Key": "SERVICE", "Values": ["AWSLambda"], "MatchOptions": ["CONTAINS"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"], "MatchOptions": ["CONTAINS"] }}} ] } In the following Contents, you must specify exactly one of the following root operators.
    public struct Expression: Swift.Sendable {
        /// Return results that match all Expressions that you specified in the array.
        public var and: [FreeTierClientTypes.Expression]?
        /// The specific dimension, values, and match type to filter objects with.
        public var dimensions: FreeTierClientTypes.DimensionValues?
        /// Return results that don’t match the Expression that you specified.
        @Indirect public var not: FreeTierClientTypes.Expression?
        /// Return results that match any of the Expressions that you specified. in the array.
        public var or: [FreeTierClientTypes.Expression]?

        public init(
            and: [FreeTierClientTypes.Expression]? = nil,
            dimensions: FreeTierClientTypes.DimensionValues? = nil,
            not: FreeTierClientTypes.Expression? = nil,
            or: [FreeTierClientTypes.Expression]? = nil
        ) {
            self.and = and
            self.dimensions = dimensions
            self.not = not
            self.or = or
        }
    }
}

public struct GetFreeTierUsageInput: Swift.Sendable {
    /// An expression that specifies the conditions that you want each FreeTierUsage object to meet.
    public var filter: FreeTierClientTypes.Expression?
    /// The maximum number of results to return in the response. MaxResults means that there can be up to the specified number of values, but there might be fewer results based on your filters.
    public var maxResults: Swift.Int?
    /// The pagination token that indicates the next set of results to retrieve.
    public var nextToken: Swift.String?

    public init(
        filter: FreeTierClientTypes.Expression? = nil,
        maxResults: Swift.Int? = 10,
        nextToken: Swift.String? = nil
    ) {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension GetAccountActivityInput {

    static func urlPathProvider(_ value: GetAccountActivityInput) -> Swift.String? {
        return "/"
    }
}

extension GetAccountPlanStateInput {

    static func urlPathProvider(_ value: GetAccountPlanStateInput) -> Swift.String? {
        return "/"
    }
}

extension GetFreeTierUsageInput {

    static func urlPathProvider(_ value: GetFreeTierUsageInput) -> Swift.String? {
        return "/"
    }
}

extension ListAccountActivitiesInput {

    static func urlPathProvider(_ value: ListAccountActivitiesInput) -> Swift.String? {
        return "/"
    }
}

extension UpgradeAccountPlanInput {

    static func urlPathProvider(_ value: UpgradeAccountPlanInput) -> Swift.String? {
        return "/"
    }
}

extension GetAccountActivityInput {

    static func write(value: GetAccountActivityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["activityId"].write(value.activityId)
        try writer["languageCode"].write(value.languageCode)
    }
}

extension GetAccountPlanStateInput {

    static func write(value: GetAccountPlanStateInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetFreeTierUsageInput {

    static func write(value: GetFreeTierUsageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: FreeTierClientTypes.Expression.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListAccountActivitiesInput {

    static func write(value: ListAccountActivitiesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filterActivityStatuses"].writeList(value.filterActivityStatuses, memberWritingClosure: SmithyReadWrite.WritingClosureBox<FreeTierClientTypes.ActivityStatus>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["languageCode"].write(value.languageCode)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension UpgradeAccountPlanInput {

    static func write(value: UpgradeAccountPlanInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountPlanType"].write(value.accountPlanType)
    }
}

extension GetAccountActivityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAccountActivityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAccountActivityOutput()
        value.activityId = try reader["activityId"].readIfPresent() ?? ""
        value.completedAt = try reader["completedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["description"].readIfPresent() ?? ""
        value.estimatedTimeToCompleteInMinutes = try reader["estimatedTimeToCompleteInMinutes"].readIfPresent()
        value.expiresAt = try reader["expiresAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.instructionsUrl = try reader["instructionsUrl"].readIfPresent() ?? ""
        value.reward = try reader["reward"].readIfPresent(with: FreeTierClientTypes.ActivityReward.read(from:))
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.title = try reader["title"].readIfPresent() ?? ""
        return value
    }
}

extension GetAccountPlanStateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAccountPlanStateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAccountPlanStateOutput()
        value.accountId = try reader["accountId"].readIfPresent() ?? ""
        value.accountPlanExpirationDate = try reader["accountPlanExpirationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.accountPlanRemainingCredits = try reader["accountPlanRemainingCredits"].readIfPresent(with: FreeTierClientTypes.MonetaryAmount.read(from:))
        value.accountPlanStatus = try reader["accountPlanStatus"].readIfPresent() ?? .sdkUnknown("")
        value.accountPlanType = try reader["accountPlanType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GetFreeTierUsageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFreeTierUsageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFreeTierUsageOutput()
        value.freeTierUsages = try reader["freeTierUsages"].readListIfPresent(memberReadingClosure: FreeTierClientTypes.FreeTierUsage.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAccountActivitiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAccountActivitiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAccountActivitiesOutput()
        value.activities = try reader["activities"].readListIfPresent(memberReadingClosure: FreeTierClientTypes.ActivitySummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension UpgradeAccountPlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpgradeAccountPlanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpgradeAccountPlanOutput()
        value.accountId = try reader["accountId"].readIfPresent() ?? ""
        value.accountPlanStatus = try reader["accountPlanStatus"].readIfPresent() ?? .sdkUnknown("")
        value.accountPlanType = try reader["accountPlanType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

enum GetAccountActivityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAccountPlanStateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFreeTierUsageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAccountActivitiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpgradeAccountPlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FreeTierClientTypes.ActivityReward {

    static func read(from reader: SmithyJSON.Reader) throws -> FreeTierClientTypes.ActivityReward {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "credit":
                return .credit(try reader["credit"].read(with: FreeTierClientTypes.MonetaryAmount.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension FreeTierClientTypes.ActivitySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> FreeTierClientTypes.ActivitySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FreeTierClientTypes.ActivitySummary()
        value.activityId = try reader["activityId"].readIfPresent() ?? ""
        value.title = try reader["title"].readIfPresent() ?? ""
        value.reward = try reader["reward"].readIfPresent(with: FreeTierClientTypes.ActivityReward.read(from:))
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension FreeTierClientTypes.DimensionValues {

    static func write(value: FreeTierClientTypes.DimensionValues?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["MatchOptions"].writeList(value.matchOptions, memberWritingClosure: SmithyReadWrite.WritingClosureBox<FreeTierClientTypes.MatchOption>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension FreeTierClientTypes.Expression {

    static func write(value: FreeTierClientTypes.Expression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["And"].writeList(value.and, memberWritingClosure: FreeTierClientTypes.Expression.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Dimensions"].write(value.dimensions, with: FreeTierClientTypes.DimensionValues.write(value:to:))
        try writer["Not"].write(value.not, with: FreeTierClientTypes.Expression.write(value:to:))
        try writer["Or"].writeList(value.or, memberWritingClosure: FreeTierClientTypes.Expression.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension FreeTierClientTypes.FreeTierUsage {

    static func read(from reader: SmithyJSON.Reader) throws -> FreeTierClientTypes.FreeTierUsage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FreeTierClientTypes.FreeTierUsage()
        value.service = try reader["service"].readIfPresent()
        value.operation = try reader["operation"].readIfPresent()
        value.usageType = try reader["usageType"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.actualUsageAmount = try reader["actualUsageAmount"].readIfPresent() ?? 0
        value.forecastedUsageAmount = try reader["forecastedUsageAmount"].readIfPresent() ?? 0
        value.limit = try reader["limit"].readIfPresent() ?? 0
        value.unit = try reader["unit"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.freeTierType = try reader["freeTierType"].readIfPresent()
        return value
    }
}

extension FreeTierClientTypes.MonetaryAmount {

    static func read(from reader: SmithyJSON.Reader) throws -> FreeTierClientTypes.MonetaryAmount {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FreeTierClientTypes.MonetaryAmount()
        value.amount = try reader["amount"].readIfPresent() ?? 0
        value.unit = try reader["unit"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

public enum FreeTierClientTypes {}
