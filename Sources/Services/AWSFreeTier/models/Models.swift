// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension FreeTierClientTypes {
    public enum Dimension: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case description
        case freeTierType
        case operation
        case region
        case service
        case usagePercentage
        case usageType
        case sdkUnknown(Swift.String)

        public static var allCases: [Dimension] {
            return [
                .description,
                .freeTierType,
                .operation,
                .region,
                .service,
                .usagePercentage,
                .usageType,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .description: return "DESCRIPTION"
            case .freeTierType: return "FREE_TIER_TYPE"
            case .operation: return "OPERATION"
            case .region: return "REGION"
            case .service: return "SERVICE"
            case .usagePercentage: return "USAGE_PERCENTAGE"
            case .usageType: return "USAGE_TYPE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Dimension(rawValue: rawValue) ?? Dimension.sdkUnknown(rawValue)
        }
    }
}

extension FreeTierClientTypes.DimensionValues: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case matchOptions = "MatchOptions"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let matchOptions = matchOptions {
            var matchOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchOptions)
            for matchoption0 in matchOptions {
                try matchOptionsContainer.encode(matchoption0.rawValue)
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for value0 in values {
                try valuesContainer.encode(value0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(FreeTierClientTypes.Dimension.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let matchOptionsContainer = try containerValues.decodeIfPresent([FreeTierClientTypes.MatchOption?].self, forKey: .matchOptions)
        var matchOptionsDecoded0:[FreeTierClientTypes.MatchOption]? = nil
        if let matchOptionsContainer = matchOptionsContainer {
            matchOptionsDecoded0 = [FreeTierClientTypes.MatchOption]()
            for enum0 in matchOptionsContainer {
                if let enum0 = enum0 {
                    matchOptionsDecoded0?.append(enum0)
                }
            }
        }
        matchOptions = matchOptionsDecoded0
    }
}

extension FreeTierClientTypes {
    /// Contains the specifications for the filters to use for your request.
    public struct DimensionValues: Swift.Equatable {
        /// The name of the dimension that you want to filter on.
        /// This member is required.
        public var key: FreeTierClientTypes.Dimension?
        /// The match options that you can use to filter your results. You can specify only one of these values in the array.
        /// This member is required.
        public var matchOptions: [FreeTierClientTypes.MatchOption]?
        /// The metadata values you can specify to filter upon, so that the results all match at least one of the specified values.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            key: FreeTierClientTypes.Dimension? = nil,
            matchOptions: [FreeTierClientTypes.MatchOption]? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.matchOptions = matchOptions
            self.values = values
        }
    }

}

extension FreeTierClientTypes.Expression: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case and = "And"
        case dimensions = "Dimensions"
        case not = "Not"
        case or = "Or"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let and = and {
            var andContainer = encodeContainer.nestedUnkeyedContainer(forKey: .and)
            for expression0 in and {
                try andContainer.encode(expression0)
            }
        }
        if let dimensions = self.dimensions {
            try encodeContainer.encode(dimensions, forKey: .dimensions)
        }
        if let not = self.not {
            try encodeContainer.encode(not, forKey: .not)
        }
        if let or = or {
            var orContainer = encodeContainer.nestedUnkeyedContainer(forKey: .or)
            for expression0 in or {
                try orContainer.encode(expression0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orContainer = try containerValues.decodeIfPresent([FreeTierClientTypes.Expression?].self, forKey: .or)
        var orDecoded0:[FreeTierClientTypes.Expression]? = nil
        if let orContainer = orContainer {
            orDecoded0 = [FreeTierClientTypes.Expression]()
            for structure0 in orContainer {
                if let structure0 = structure0 {
                    orDecoded0?.append(structure0)
                }
            }
        }
        or = orDecoded0
        let andContainer = try containerValues.decodeIfPresent([FreeTierClientTypes.Expression?].self, forKey: .and)
        var andDecoded0:[FreeTierClientTypes.Expression]? = nil
        if let andContainer = andContainer {
            andDecoded0 = [FreeTierClientTypes.Expression]()
            for structure0 in andContainer {
                if let structure0 = structure0 {
                    andDecoded0?.append(structure0)
                }
            }
        }
        and = andDecoded0
        let notDecoded = try containerValues.decodeIfPresent(FreeTierClientTypes.Expression.self, forKey: .not)
        not = notDecoded
        let dimensionsDecoded = try containerValues.decodeIfPresent(FreeTierClientTypes.DimensionValues.self, forKey: .dimensions)
        dimensions = dimensionsDecoded
    }
}

extension FreeTierClientTypes {
    /// Use Expression to filter in the GetFreeTierUsage API operation. You can use the following patterns:
    ///
    /// * Simple dimension values (Dimensions root operator)
    ///
    /// * Complex expressions with logical operators (AND, NOT, and OR root operators).
    ///
    ///
    /// For simple dimension values, you can set the dimension name, values, and match type for the filters that you plan to use. Example for simple dimension values You can filter to match exactly for REGION==us-east-1 OR REGION==us-west-1. The corresponding Expression appears like the following: { "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ], "MatchOptions": ["EQUALS"] } } As shown in the previous example, lists of dimension values are combined with OR when you apply the filter. For complex expressions with logical operators, you can have nested expressions to use the logical operators and specify advanced filtering. Example for complex expressions with logical operators You can filter by ((REGION == us-east-1 OR REGION == us-west-1) OR (SERVICE CONTAINS AWSLambda)) AND (USAGE_TYPE !CONTAINS DataTransfer). The corresponding Expression appears like the following: { "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ], "MatchOptions": ["EQUALS"] }}, {"Dimensions": { "Key": "SERVICE", "Values": ["AWSLambda"], "MatchOptions": ["CONTAINS"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"], "MatchOptions": ["CONTAINS"] }}} ] } In the following Contents, you must specify exactly one of the following root operators.
    public struct Expression: Swift.Equatable {
        /// Return results that match all Expressions that you specified in the array.
        public var and: [FreeTierClientTypes.Expression]?
        /// The specific dimension, values, and match type to filter objects with.
        public var dimensions: FreeTierClientTypes.DimensionValues?
        /// Return results that donâ€™t match the Expression that you specified.
        @Indirect public var not: FreeTierClientTypes.Expression?
        /// Return results that match any of the Expressions that you specified. in the array.
        public var or: [FreeTierClientTypes.Expression]?

        public init(
            and: [FreeTierClientTypes.Expression]? = nil,
            dimensions: FreeTierClientTypes.DimensionValues? = nil,
            not: FreeTierClientTypes.Expression? = nil,
            or: [FreeTierClientTypes.Expression]? = nil
        )
        {
            self.and = and
            self.dimensions = dimensions
            self.not = not
            self.or = or
        }
    }

}

extension FreeTierClientTypes.FreeTierUsage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actualUsageAmount
        case description
        case forecastedUsageAmount
        case freeTierType
        case limit
        case operation
        case region
        case service
        case unit
        case usageType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if actualUsageAmount != 0.0 {
            try encodeContainer.encode(actualUsageAmount, forKey: .actualUsageAmount)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if forecastedUsageAmount != 0.0 {
            try encodeContainer.encode(forecastedUsageAmount, forKey: .forecastedUsageAmount)
        }
        if let freeTierType = self.freeTierType {
            try encodeContainer.encode(freeTierType, forKey: .freeTierType)
        }
        if limit != 0.0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let operation = self.operation {
            try encodeContainer.encode(operation, forKey: .operation)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let service = self.service {
            try encodeContainer.encode(service, forKey: .service)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
        if let usageType = self.usageType {
            try encodeContainer.encode(usageType, forKey: .usageType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .service)
        service = serviceDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let usageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usageType)
        usageType = usageTypeDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let actualUsageAmountDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .actualUsageAmount) ?? 0.0
        actualUsageAmount = actualUsageAmountDecoded
        let forecastedUsageAmountDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .forecastedUsageAmount) ?? 0.0
        forecastedUsageAmount = forecastedUsageAmountDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .limit) ?? 0.0
        limit = limitDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let freeTierTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .freeTierType)
        freeTierType = freeTierTypeDecoded
    }
}

extension FreeTierClientTypes {
    /// Consists of a Amazon Web Services Free Tier offerâ€™s metadata and your data usage for the offer.
    public struct FreeTierUsage: Swift.Equatable {
        /// Describes the actual usage accrued month-to-day (MTD) that you've used so far.
        public var actualUsageAmount: Swift.Double
        /// The description of the Free Tier offer.
        public var description: Swift.String?
        /// Describes the forecasted usage by the month that you're expected to use.
        public var forecastedUsageAmount: Swift.Double
        /// Describes the type of the Free Tier offer. For example, the offer can be "12 Months Free", "Always Free", and "Free Trial".
        public var freeTierType: Swift.String?
        /// Describes the maximum usage allowed in Free Tier.
        public var limit: Swift.Double
        /// Describes usageType more granularly with the specific Amazon Web Service API operation. For example, this can be the RunInstances API operation for Amazon Elastic Compute Cloud.
        public var operation: Swift.String?
        /// Describes the Amazon Web Services Region for which this offer is applicable
        public var region: Swift.String?
        /// The name of the Amazon Web Service providing the Free Tier offer. For example, this can be Amazon Elastic Compute Cloud.
        public var service: Swift.String?
        /// Describes the unit of the usageType, such as Hrs.
        public var unit: Swift.String?
        /// Describes the usage details of the offer. For example, this might be Global-BoxUsage:freetrial.
        public var usageType: Swift.String?

        public init(
            actualUsageAmount: Swift.Double = 0.0,
            description: Swift.String? = nil,
            forecastedUsageAmount: Swift.Double = 0.0,
            freeTierType: Swift.String? = nil,
            limit: Swift.Double = 0.0,
            operation: Swift.String? = nil,
            region: Swift.String? = nil,
            service: Swift.String? = nil,
            unit: Swift.String? = nil,
            usageType: Swift.String? = nil
        )
        {
            self.actualUsageAmount = actualUsageAmount
            self.description = description
            self.forecastedUsageAmount = forecastedUsageAmount
            self.freeTierType = freeTierType
            self.limit = limit
            self.operation = operation
            self.region = region
            self.service = service
            self.unit = unit
            self.usageType = usageType
        }
    }

}

extension GetFreeTierUsageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetFreeTierUsageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetFreeTierUsageInput: Swift.Equatable {
    /// An expression that specifies the conditions that you want each FreeTierUsage object to meet.
    public var filter: FreeTierClientTypes.Expression?
    /// The maximum number of results to return in the response. MaxResults means that there can be up to the specified number of values, but there might be fewer results based on your filters.
    public var maxResults: Swift.Int?
    /// The pagination token that indicates the next set of results to retrieve.
    public var nextToken: Swift.String?

    public init(
        filter: FreeTierClientTypes.Expression? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetFreeTierUsageInputBody: Swift.Equatable {
    let filter: FreeTierClientTypes.Expression?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension GetFreeTierUsageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(FreeTierClientTypes.Expression.self, forKey: .filter)
        filter = filterDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetFreeTierUsageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFreeTierUsageOutputBody = try responseDecoder.decode(responseBody: data)
            self.freeTierUsages = output.freeTierUsages
            self.nextToken = output.nextToken
        } else {
            self.freeTierUsages = nil
            self.nextToken = nil
        }
    }
}

public struct GetFreeTierUsageOutput: Swift.Equatable {
    /// The list of Free Tier usage objects that meet your filter expression.
    /// This member is required.
    public var freeTierUsages: [FreeTierClientTypes.FreeTierUsage]?
    /// The pagination token that indicates the next set of results to retrieve.
    public var nextToken: Swift.String?

    public init(
        freeTierUsages: [FreeTierClientTypes.FreeTierUsage]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.freeTierUsages = freeTierUsages
        self.nextToken = nextToken
    }
}

struct GetFreeTierUsageOutputBody: Swift.Equatable {
    let freeTierUsages: [FreeTierClientTypes.FreeTierUsage]?
    let nextToken: Swift.String?
}

extension GetFreeTierUsageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case freeTierUsages
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let freeTierUsagesContainer = try containerValues.decodeIfPresent([FreeTierClientTypes.FreeTierUsage?].self, forKey: .freeTierUsages)
        var freeTierUsagesDecoded0:[FreeTierClientTypes.FreeTierUsage]? = nil
        if let freeTierUsagesContainer = freeTierUsagesContainer {
            freeTierUsagesDecoded0 = [FreeTierClientTypes.FreeTierUsage]()
            for structure0 in freeTierUsagesContainer {
                if let structure0 = structure0 {
                    freeTierUsagesDecoded0?.append(structure0)
                }
            }
        }
        freeTierUsages = freeTierUsagesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetFreeTierUsageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An unexpected error occurred during the processing of your request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FreeTierClientTypes {
    public enum MatchOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contains
        case endsWith
        case equals
        case greaterThanOrEqual
        case startsWith
        case sdkUnknown(Swift.String)

        public static var allCases: [MatchOption] {
            return [
                .contains,
                .endsWith,
                .equals,
                .greaterThanOrEqual,
                .startsWith,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contains: return "CONTAINS"
            case .endsWith: return "ENDS_WITH"
            case .equals: return "EQUALS"
            case .greaterThanOrEqual: return "GREATER_THAN_OR_EQUAL"
            case .startsWith: return "STARTS_WITH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MatchOption(rawValue: rawValue) ?? MatchOption.sdkUnknown(rawValue)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the constraints specified by an Amazon Web Service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
