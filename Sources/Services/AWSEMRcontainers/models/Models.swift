// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension CancelJobRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let virtualClusterId = virtualClusterId else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/virtualclusters/\(virtualClusterId.urlPercentEncoding())/jobruns/\(id.urlPercentEncoding())"
    }
}

public struct CancelJobRunInput: Swift.Equatable {
    /// The ID of the job run to cancel.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the virtual cluster for which the job run will be canceled.
    /// This member is required.
    public var virtualClusterId: Swift.String?

    public init(
        id: Swift.String? = nil,
        virtualClusterId: Swift.String? = nil
    )
    {
        self.id = id
        self.virtualClusterId = virtualClusterId
    }
}

struct CancelJobRunInputBody: Swift.Equatable {
}

extension CancelJobRunInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CancelJobRunOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CancelJobRunOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.virtualClusterId = output.virtualClusterId
        } else {
            self.id = nil
            self.virtualClusterId = nil
        }
    }
}

public struct CancelJobRunOutput: Swift.Equatable {
    /// The output contains the ID of the cancelled job run.
    public var id: Swift.String?
    /// The output contains the virtual cluster ID for which the job run is cancelled.
    public var virtualClusterId: Swift.String?

    public init(
        id: Swift.String? = nil,
        virtualClusterId: Swift.String? = nil
    )
    {
        self.id = id
        self.virtualClusterId = virtualClusterId
    }
}

struct CancelJobRunOutputBody: Swift.Equatable {
    let id: Swift.String?
    let virtualClusterId: Swift.String?
}

extension CancelJobRunOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case virtualClusterId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let virtualClusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualClusterId)
        virtualClusterId = virtualClusterIdDecoded
    }
}

enum CancelJobRunOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EMRcontainersClientTypes.Certificate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
        case certificateData
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificateData = self.certificateData {
            try encodeContainer.encode(certificateData, forKey: .certificateData)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateData)
        certificateData = certificateDataDecoded
    }
}

extension EMRcontainersClientTypes {
    /// The entity representing certificate data generated for managed endpoint.
    public struct Certificate: Swift.Equatable {
        /// The ARN of the certificate generated for managed endpoint.
        public var certificateArn: Swift.String?
        /// The base64 encoded PEM certificate data generated for managed endpoint.
        public var certificateData: Swift.String?

        public init(
            certificateArn: Swift.String? = nil,
            certificateData: Swift.String? = nil
        )
        {
            self.certificateArn = certificateArn
            self.certificateData = certificateData
        }
    }

}

extension EMRcontainersClientTypes.CloudWatchMonitoringConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logGroupName
        case logStreamNamePrefix
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logGroupName = self.logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
        if let logStreamNamePrefix = self.logStreamNamePrefix {
            try encodeContainer.encode(logStreamNamePrefix, forKey: .logStreamNamePrefix)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
        let logStreamNamePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logStreamNamePrefix)
        logStreamNamePrefix = logStreamNamePrefixDecoded
    }
}

extension EMRcontainersClientTypes {
    /// A configuration for CloudWatch monitoring. You can configure your jobs to send log information to CloudWatch Logs.
    public struct CloudWatchMonitoringConfiguration: Swift.Equatable {
        /// The name of the log group for log publishing.
        /// This member is required.
        public var logGroupName: Swift.String?
        /// The specified name prefix for log streams.
        public var logStreamNamePrefix: Swift.String?

        public init(
            logGroupName: Swift.String? = nil,
            logStreamNamePrefix: Swift.String? = nil
        )
        {
            self.logGroupName = logGroupName
            self.logStreamNamePrefix = logStreamNamePrefix
        }
    }

}

extension EMRcontainersClientTypes.Configuration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case classification
        case configurations
        case properties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let classification = self.classification {
            try encodeContainer.encode(classification, forKey: .classification)
        }
        if let configurations = configurations {
            var configurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurations)
            for configuration0 in configurations {
                try configurationsContainer.encode(configuration0)
            }
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .properties)
            for (dictKey0, sensitivePropertiesMap0) in properties {
                try propertiesContainer.encode(sensitivePropertiesMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let classificationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .classification)
        classification = classificationDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .properties)
        var propertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string10240) in propertiesContainer {
                if let string10240 = string10240 {
                    propertiesDecoded0?[key0] = string10240
                }
            }
        }
        properties = propertiesDecoded0
        let configurationsContainer = try containerValues.decodeIfPresent([EMRcontainersClientTypes.Configuration?].self, forKey: .configurations)
        var configurationsDecoded0:[EMRcontainersClientTypes.Configuration]? = nil
        if let configurationsContainer = configurationsContainer {
            configurationsDecoded0 = [EMRcontainersClientTypes.Configuration]()
            for structure0 in configurationsContainer {
                if let structure0 = structure0 {
                    configurationsDecoded0?.append(structure0)
                }
            }
        }
        configurations = configurationsDecoded0
    }
}

extension EMRcontainersClientTypes.Configuration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Configuration(classification: \(Swift.String(describing: classification)), configurations: \(Swift.String(describing: configurations)), properties: \"CONTENT_REDACTED\")"}
}

extension EMRcontainersClientTypes {
    /// A configuration specification to be used when provisioning virtual clusters, which can include configurations for applications and software bundled with Amazon EMR on EKS. A configuration consists of a classification, properties, and optional nested configurations. A classification refers to an application-specific configuration file. Properties are the settings you want to change in that file.
    public struct Configuration: Swift.Equatable {
        /// The classification within a configuration.
        /// This member is required.
        public var classification: Swift.String?
        /// A list of additional configurations to apply within a configuration object.
        public var configurations: [EMRcontainersClientTypes.Configuration]?
        /// A set of properties specified within a configuration classification.
        public var properties: [Swift.String:Swift.String]?

        public init(
            classification: Swift.String? = nil,
            configurations: [EMRcontainersClientTypes.Configuration]? = nil,
            properties: [Swift.String:Swift.String]? = nil
        )
        {
            self.classification = classification
            self.configurations = configurations
            self.properties = properties
        }
    }

}

extension EMRcontainersClientTypes.ConfigurationOverrides: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationConfiguration
        case monitoringConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationConfiguration = applicationConfiguration {
            var applicationConfigurationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applicationConfiguration)
            for configuration0 in applicationConfiguration {
                try applicationConfigurationContainer.encode(configuration0)
            }
        }
        if let monitoringConfiguration = self.monitoringConfiguration {
            try encodeContainer.encode(monitoringConfiguration, forKey: .monitoringConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationConfigurationContainer = try containerValues.decodeIfPresent([EMRcontainersClientTypes.Configuration?].self, forKey: .applicationConfiguration)
        var applicationConfigurationDecoded0:[EMRcontainersClientTypes.Configuration]? = nil
        if let applicationConfigurationContainer = applicationConfigurationContainer {
            applicationConfigurationDecoded0 = [EMRcontainersClientTypes.Configuration]()
            for structure0 in applicationConfigurationContainer {
                if let structure0 = structure0 {
                    applicationConfigurationDecoded0?.append(structure0)
                }
            }
        }
        applicationConfiguration = applicationConfigurationDecoded0
        let monitoringConfigurationDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.MonitoringConfiguration.self, forKey: .monitoringConfiguration)
        monitoringConfiguration = monitoringConfigurationDecoded
    }
}

extension EMRcontainersClientTypes {
    /// A configuration specification to be used to override existing configurations.
    public struct ConfigurationOverrides: Swift.Equatable {
        /// The configurations for the application running by the job run.
        public var applicationConfiguration: [EMRcontainersClientTypes.Configuration]?
        /// The configurations for monitoring.
        public var monitoringConfiguration: EMRcontainersClientTypes.MonitoringConfiguration?

        public init(
            applicationConfiguration: [EMRcontainersClientTypes.Configuration]? = nil,
            monitoringConfiguration: EMRcontainersClientTypes.MonitoringConfiguration? = nil
        )
        {
            self.applicationConfiguration = applicationConfiguration
            self.monitoringConfiguration = monitoringConfiguration
        }
    }

}

extension EMRcontainersClientTypes.ContainerInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eksinfo = "eksInfo"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .eksinfo(eksinfo):
                try container.encode(eksinfo, forKey: .eksinfo)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let eksinfoDecoded = try values.decodeIfPresent(EMRcontainersClientTypes.EksInfo.self, forKey: .eksinfo)
        if let eksinfo = eksinfoDecoded {
            self = .eksinfo(eksinfo)
            return
        }
        self = .sdkUnknown("")
    }
}

extension EMRcontainersClientTypes {
    /// The information about the container used for a job run or a managed endpoint.
    public enum ContainerInfo: Swift.Equatable {
        /// The information about the Amazon EKS cluster.
        case eksinfo(EMRcontainersClientTypes.EksInfo)
        case sdkUnknown(Swift.String)
    }

}

extension EMRcontainersClientTypes.ContainerLogRotationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxFilesToKeep
        case rotationSize
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxFilesToKeep = self.maxFilesToKeep {
            try encodeContainer.encode(maxFilesToKeep, forKey: .maxFilesToKeep)
        }
        if let rotationSize = self.rotationSize {
            try encodeContainer.encode(rotationSize, forKey: .rotationSize)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rotationSizeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rotationSize)
        rotationSize = rotationSizeDecoded
        let maxFilesToKeepDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxFilesToKeep)
        maxFilesToKeep = maxFilesToKeepDecoded
    }
}

extension EMRcontainersClientTypes {
    /// The settings for container log rotation.
    public struct ContainerLogRotationConfiguration: Swift.Equatable {
        /// The number of files to keep in container after rotation.
        /// This member is required.
        public var maxFilesToKeep: Swift.Int?
        /// The file size at which to rotate logs. Minimum of 2KB, Maximum of 2GB.
        /// This member is required.
        public var rotationSize: Swift.String?

        public init(
            maxFilesToKeep: Swift.Int? = nil,
            rotationSize: Swift.String? = nil
        )
        {
            self.maxFilesToKeep = maxFilesToKeep
            self.rotationSize = rotationSize
        }
    }

}

extension EMRcontainersClientTypes.ContainerProvider: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case info
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let info = self.info {
            try encodeContainer.encode(info, forKey: .info)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.ContainerProviderType.self, forKey: .type)
        type = typeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let infoDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.ContainerInfo.self, forKey: .info)
        info = infoDecoded
    }
}

extension EMRcontainersClientTypes {
    /// The information about the container provider.
    public struct ContainerProvider: Swift.Equatable {
        /// The ID of the container cluster.
        /// This member is required.
        public var id: Swift.String?
        /// The information about the container cluster.
        public var info: EMRcontainersClientTypes.ContainerInfo?
        /// The type of the container provider. Amazon EKS is the only supported type as of now.
        /// This member is required.
        public var type: EMRcontainersClientTypes.ContainerProviderType?

        public init(
            id: Swift.String? = nil,
            info: EMRcontainersClientTypes.ContainerInfo? = nil,
            type: EMRcontainersClientTypes.ContainerProviderType? = nil
        )
        {
            self.id = id
            self.info = info
            self.type = type
        }
    }

}

extension EMRcontainersClientTypes {
    public enum ContainerProviderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case eks
        case sdkUnknown(Swift.String)

        public static var allCases: [ContainerProviderType] {
            return [
                .eks,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .eks: return "EKS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContainerProviderType(rawValue: rawValue) ?? ContainerProviderType.sdkUnknown(rawValue)
        }
    }
}

extension CreateJobTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case jobTemplateData
        case kmsKeyArn
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let jobTemplateData = self.jobTemplateData {
            try encodeContainer.encode(jobTemplateData, forKey: .jobTemplateData)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateJobTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/jobtemplates"
    }
}

public struct CreateJobTemplateInput: Swift.Equatable {
    /// The client token of the job template.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The job template data which holds values of StartJobRun API request.
    /// This member is required.
    public var jobTemplateData: EMRcontainersClientTypes.JobTemplateData?
    /// The KMS key ARN used to encrypt the job template.
    public var kmsKeyArn: Swift.String?
    /// The specified name of the job template.
    /// This member is required.
    public var name: Swift.String?
    /// The tags that are associated with the job template.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        jobTemplateData: EMRcontainersClientTypes.JobTemplateData? = nil,
        kmsKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.jobTemplateData = jobTemplateData
        self.kmsKeyArn = kmsKeyArn
        self.name = name
        self.tags = tags
    }
}

struct CreateJobTemplateInputBody: Swift.Equatable {
    let name: Swift.String?
    let clientToken: Swift.String?
    let jobTemplateData: EMRcontainersClientTypes.JobTemplateData?
    let tags: [Swift.String:Swift.String]?
    let kmsKeyArn: Swift.String?
}

extension CreateJobTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case jobTemplateData
        case kmsKeyArn
        case name
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let jobTemplateDataDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.JobTemplateData.self, forKey: .jobTemplateData)
        jobTemplateData = jobTemplateDataDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringempty2560) in tagsContainer {
                if let stringempty2560 = stringempty2560 {
                    tagsDecoded0?[key0] = stringempty2560
                }
            }
        }
        tags = tagsDecoded0
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension CreateJobTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateJobTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.id = output.id
            self.name = output.name
        } else {
            self.arn = nil
            self.createdAt = nil
            self.id = nil
            self.name = nil
        }
    }
}

public struct CreateJobTemplateOutput: Swift.Equatable {
    /// This output display the ARN of the created job template.
    public var arn: Swift.String?
    /// This output displays the date and time when the job template was created.
    public var createdAt: ClientRuntime.Date?
    /// This output display the created job template ID.
    public var id: Swift.String?
    /// This output displays the name of the created job template.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.id = id
        self.name = name
    }
}

struct CreateJobTemplateOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let createdAt: ClientRuntime.Date?
}

extension CreateJobTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case id
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

enum CreateJobTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateManagedEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
        case clientToken
        case configurationOverrides
        case executionRoleArn
        case name
        case releaseLabel
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let configurationOverrides = self.configurationOverrides {
            try encodeContainer.encode(configurationOverrides, forKey: .configurationOverrides)
        }
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let releaseLabel = self.releaseLabel {
            try encodeContainer.encode(releaseLabel, forKey: .releaseLabel)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }
}

extension CreateManagedEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let virtualClusterId = virtualClusterId else {
            return nil
        }
        return "/virtualclusters/\(virtualClusterId.urlPercentEncoding())/endpoints"
    }
}

public struct CreateManagedEndpointInput: Swift.Equatable {
    /// The certificate ARN provided by users for the managed endpoint. This field is under deprecation and will be removed in future releases.
    @available(*, deprecated, message: "Customer provided certificate-arn is deprecated and would be removed in future.")
    public var certificateArn: Swift.String?
    /// The client idempotency token for this create call.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The configuration settings that will be used to override existing configurations.
    public var configurationOverrides: EMRcontainersClientTypes.ConfigurationOverrides?
    /// The ARN of the execution role.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// The name of the managed endpoint.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon EMR release version.
    /// This member is required.
    public var releaseLabel: Swift.String?
    /// The tags of the managed endpoint.
    public var tags: [Swift.String:Swift.String]?
    /// The type of the managed endpoint.
    /// This member is required.
    public var type: Swift.String?
    /// The ID of the virtual cluster for which a managed endpoint is created.
    /// This member is required.
    public var virtualClusterId: Swift.String?

    public init(
        certificateArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        configurationOverrides: EMRcontainersClientTypes.ConfigurationOverrides? = nil,
        executionRoleArn: Swift.String? = nil,
        name: Swift.String? = nil,
        releaseLabel: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: Swift.String? = nil,
        virtualClusterId: Swift.String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.clientToken = clientToken
        self.configurationOverrides = configurationOverrides
        self.executionRoleArn = executionRoleArn
        self.name = name
        self.releaseLabel = releaseLabel
        self.tags = tags
        self.type = type
        self.virtualClusterId = virtualClusterId
    }
}

struct CreateManagedEndpointInputBody: Swift.Equatable {
    let name: Swift.String?
    let type: Swift.String?
    let releaseLabel: Swift.String?
    let executionRoleArn: Swift.String?
    let certificateArn: Swift.String?
    let configurationOverrides: EMRcontainersClientTypes.ConfigurationOverrides?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateManagedEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
        case clientToken
        case configurationOverrides
        case executionRoleArn
        case name
        case releaseLabel
        case tags
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let releaseLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .releaseLabel)
        releaseLabel = releaseLabelDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let configurationOverridesDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.ConfigurationOverrides.self, forKey: .configurationOverrides)
        configurationOverrides = configurationOverridesDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringempty2560) in tagsContainer {
                if let stringempty2560 = stringempty2560 {
                    tagsDecoded0?[key0] = stringempty2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateManagedEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateManagedEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.name = output.name
            self.virtualClusterId = output.virtualClusterId
        } else {
            self.arn = nil
            self.id = nil
            self.name = nil
            self.virtualClusterId = nil
        }
    }
}

public struct CreateManagedEndpointOutput: Swift.Equatable {
    /// The output contains the ARN of the managed endpoint.
    public var arn: Swift.String?
    /// The output contains the ID of the managed endpoint.
    public var id: Swift.String?
    /// The output contains the name of the managed endpoint.
    public var name: Swift.String?
    /// The output contains the ID of the virtual cluster.
    public var virtualClusterId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        virtualClusterId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.name = name
        self.virtualClusterId = virtualClusterId
    }
}

struct CreateManagedEndpointOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let virtualClusterId: Swift.String?
}

extension CreateManagedEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case name
        case virtualClusterId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let virtualClusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualClusterId)
        virtualClusterId = virtualClusterIdDecoded
    }
}

enum CreateManagedEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateVirtualClusterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case containerProvider
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let containerProvider = self.containerProvider {
            try encodeContainer.encode(containerProvider, forKey: .containerProvider)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateVirtualClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/virtualclusters"
    }
}

public struct CreateVirtualClusterInput: Swift.Equatable {
    /// The client token of the virtual cluster.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The container provider of the virtual cluster.
    /// This member is required.
    public var containerProvider: EMRcontainersClientTypes.ContainerProvider?
    /// The specified name of the virtual cluster.
    /// This member is required.
    public var name: Swift.String?
    /// The tags assigned to the virtual cluster.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        containerProvider: EMRcontainersClientTypes.ContainerProvider? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.containerProvider = containerProvider
        self.name = name
        self.tags = tags
    }
}

struct CreateVirtualClusterInputBody: Swift.Equatable {
    let name: Swift.String?
    let containerProvider: EMRcontainersClientTypes.ContainerProvider?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateVirtualClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case containerProvider
        case name
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let containerProviderDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.ContainerProvider.self, forKey: .containerProvider)
        containerProvider = containerProviderDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringempty2560) in tagsContainer {
                if let stringempty2560 = stringempty2560 {
                    tagsDecoded0?[key0] = stringempty2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateVirtualClusterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateVirtualClusterOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.name = output.name
        } else {
            self.arn = nil
            self.id = nil
            self.name = nil
        }
    }
}

public struct CreateVirtualClusterOutput: Swift.Equatable {
    /// This output contains the ARN of virtual cluster.
    public var arn: Swift.String?
    /// This output contains the virtual cluster ID.
    public var id: Swift.String?
    /// This output contains the name of the virtual cluster.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.name = name
    }
}

struct CreateVirtualClusterOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
}

extension CreateVirtualClusterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum CreateVirtualClusterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EMRcontainersClientTypes.Credentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sdkUnknown
        case token
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .token(token):
                try container.encode(token, forKey: .token)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let tokenDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .token)
        if let token = tokenDecoded {
            self = .token(token)
            return
        }
        self = .sdkUnknown("")
    }
}

extension EMRcontainersClientTypes {
    /// The structure containing the session token being returned.
    public enum Credentials: Swift.Equatable {
        /// The actual session token being returned.
        case token(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension DeleteJobTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/jobtemplates/\(id.urlPercentEncoding())"
    }
}

public struct DeleteJobTemplateInput: Swift.Equatable {
    /// The ID of the job template that will be deleted.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteJobTemplateInputBody: Swift.Equatable {
}

extension DeleteJobTemplateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteJobTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteJobTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
        } else {
            self.id = nil
        }
    }
}

public struct DeleteJobTemplateOutput: Swift.Equatable {
    /// This output contains the ID of the job template that was deleted.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteJobTemplateOutputBody: Swift.Equatable {
    let id: Swift.String?
}

extension DeleteJobTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

enum DeleteJobTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteManagedEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let virtualClusterId = virtualClusterId else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/virtualclusters/\(virtualClusterId.urlPercentEncoding())/endpoints/\(id.urlPercentEncoding())"
    }
}

public struct DeleteManagedEndpointInput: Swift.Equatable {
    /// The ID of the managed endpoint.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the endpoint's virtual cluster.
    /// This member is required.
    public var virtualClusterId: Swift.String?

    public init(
        id: Swift.String? = nil,
        virtualClusterId: Swift.String? = nil
    )
    {
        self.id = id
        self.virtualClusterId = virtualClusterId
    }
}

struct DeleteManagedEndpointInputBody: Swift.Equatable {
}

extension DeleteManagedEndpointInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteManagedEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteManagedEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.virtualClusterId = output.virtualClusterId
        } else {
            self.id = nil
            self.virtualClusterId = nil
        }
    }
}

public struct DeleteManagedEndpointOutput: Swift.Equatable {
    /// The output displays the ID of the managed endpoint.
    public var id: Swift.String?
    /// The output displays the ID of the endpoint's virtual cluster.
    public var virtualClusterId: Swift.String?

    public init(
        id: Swift.String? = nil,
        virtualClusterId: Swift.String? = nil
    )
    {
        self.id = id
        self.virtualClusterId = virtualClusterId
    }
}

struct DeleteManagedEndpointOutputBody: Swift.Equatable {
    let id: Swift.String?
    let virtualClusterId: Swift.String?
}

extension DeleteManagedEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case virtualClusterId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let virtualClusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualClusterId)
        virtualClusterId = virtualClusterIdDecoded
    }
}

enum DeleteManagedEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVirtualClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/virtualclusters/\(id.urlPercentEncoding())"
    }
}

public struct DeleteVirtualClusterInput: Swift.Equatable {
    /// The ID of the virtual cluster that will be deleted.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteVirtualClusterInputBody: Swift.Equatable {
}

extension DeleteVirtualClusterInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVirtualClusterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteVirtualClusterOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
        } else {
            self.id = nil
        }
    }
}

public struct DeleteVirtualClusterOutput: Swift.Equatable {
    /// This output contains the ID of the virtual cluster that will be deleted.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteVirtualClusterOutputBody: Swift.Equatable {
    let id: Swift.String?
}

extension DeleteVirtualClusterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

enum DeleteVirtualClusterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeJobRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let virtualClusterId = virtualClusterId else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/virtualclusters/\(virtualClusterId.urlPercentEncoding())/jobruns/\(id.urlPercentEncoding())"
    }
}

public struct DescribeJobRunInput: Swift.Equatable {
    /// The ID of the job run request.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the virtual cluster for which the job run is submitted.
    /// This member is required.
    public var virtualClusterId: Swift.String?

    public init(
        id: Swift.String? = nil,
        virtualClusterId: Swift.String? = nil
    )
    {
        self.id = id
        self.virtualClusterId = virtualClusterId
    }
}

struct DescribeJobRunInputBody: Swift.Equatable {
}

extension DescribeJobRunInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeJobRunOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeJobRunOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobRun = output.jobRun
        } else {
            self.jobRun = nil
        }
    }
}

public struct DescribeJobRunOutput: Swift.Equatable {
    /// The output displays information about a job run.
    public var jobRun: EMRcontainersClientTypes.JobRun?

    public init(
        jobRun: EMRcontainersClientTypes.JobRun? = nil
    )
    {
        self.jobRun = jobRun
    }
}

struct DescribeJobRunOutputBody: Swift.Equatable {
    let jobRun: EMRcontainersClientTypes.JobRun?
}

extension DescribeJobRunOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobRun
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobRunDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.JobRun.self, forKey: .jobRun)
        jobRun = jobRunDecoded
    }
}

enum DescribeJobRunOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeJobTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/jobtemplates/\(id.urlPercentEncoding())"
    }
}

public struct DescribeJobTemplateInput: Swift.Equatable {
    /// The ID of the job template that will be described.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DescribeJobTemplateInputBody: Swift.Equatable {
}

extension DescribeJobTemplateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeJobTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeJobTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobTemplate = output.jobTemplate
        } else {
            self.jobTemplate = nil
        }
    }
}

public struct DescribeJobTemplateOutput: Swift.Equatable {
    /// This output displays information about the specified job template.
    public var jobTemplate: EMRcontainersClientTypes.JobTemplate?

    public init(
        jobTemplate: EMRcontainersClientTypes.JobTemplate? = nil
    )
    {
        self.jobTemplate = jobTemplate
    }
}

struct DescribeJobTemplateOutputBody: Swift.Equatable {
    let jobTemplate: EMRcontainersClientTypes.JobTemplate?
}

extension DescribeJobTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobTemplate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobTemplateDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.JobTemplate.self, forKey: .jobTemplate)
        jobTemplate = jobTemplateDecoded
    }
}

enum DescribeJobTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeManagedEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let virtualClusterId = virtualClusterId else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/virtualclusters/\(virtualClusterId.urlPercentEncoding())/endpoints/\(id.urlPercentEncoding())"
    }
}

public struct DescribeManagedEndpointInput: Swift.Equatable {
    /// This output displays ID of the managed endpoint.
    /// This member is required.
    public var id: Swift.String?
    /// The ID of the endpoint's virtual cluster.
    /// This member is required.
    public var virtualClusterId: Swift.String?

    public init(
        id: Swift.String? = nil,
        virtualClusterId: Swift.String? = nil
    )
    {
        self.id = id
        self.virtualClusterId = virtualClusterId
    }
}

struct DescribeManagedEndpointInputBody: Swift.Equatable {
}

extension DescribeManagedEndpointInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeManagedEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeManagedEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.endpoint = output.endpoint
        } else {
            self.endpoint = nil
        }
    }
}

public struct DescribeManagedEndpointOutput: Swift.Equatable {
    /// This output displays information about a managed endpoint.
    public var endpoint: EMRcontainersClientTypes.Endpoint?

    public init(
        endpoint: EMRcontainersClientTypes.Endpoint? = nil
    )
    {
        self.endpoint = endpoint
    }
}

struct DescribeManagedEndpointOutputBody: Swift.Equatable {
    let endpoint: EMRcontainersClientTypes.Endpoint?
}

extension DescribeManagedEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.Endpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

enum DescribeManagedEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeVirtualClusterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/virtualclusters/\(id.urlPercentEncoding())"
    }
}

public struct DescribeVirtualClusterInput: Swift.Equatable {
    /// The ID of the virtual cluster that will be described.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DescribeVirtualClusterInputBody: Swift.Equatable {
}

extension DescribeVirtualClusterInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeVirtualClusterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeVirtualClusterOutputBody = try responseDecoder.decode(responseBody: data)
            self.virtualCluster = output.virtualCluster
        } else {
            self.virtualCluster = nil
        }
    }
}

public struct DescribeVirtualClusterOutput: Swift.Equatable {
    /// This output displays information about the specified virtual cluster.
    public var virtualCluster: EMRcontainersClientTypes.VirtualCluster?

    public init(
        virtualCluster: EMRcontainersClientTypes.VirtualCluster? = nil
    )
    {
        self.virtualCluster = virtualCluster
    }
}

struct DescribeVirtualClusterOutputBody: Swift.Equatable {
    let virtualCluster: EMRcontainersClientTypes.VirtualCluster?
}

extension DescribeVirtualClusterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case virtualCluster
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualClusterDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.VirtualCluster.self, forKey: .virtualCluster)
        virtualCluster = virtualClusterDecoded
    }
}

enum DescribeVirtualClusterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EMRcontainersClientTypes.EksInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case namespace
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let namespace = self.namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

extension EMRcontainersClientTypes {
    /// The information about the Amazon EKS cluster.
    public struct EksInfo: Swift.Equatable {
        /// The namespaces of the Amazon EKS cluster.
        public var namespace: Swift.String?

        public init(
            namespace: Swift.String? = nil
        )
        {
            self.namespace = namespace
        }
    }

}

extension EMRcontainersClientTypes.Endpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case certificateArn
        case certificateAuthority
        case configurationOverrides
        case createdAt
        case executionRoleArn
        case failureReason
        case id
        case name
        case releaseLabel
        case securityGroup
        case serverUrl
        case state
        case stateDetails
        case subnetIds
        case tags
        case type
        case virtualClusterId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificateAuthority = self.certificateAuthority {
            try encodeContainer.encode(certificateAuthority, forKey: .certificateAuthority)
        }
        if let configurationOverrides = self.configurationOverrides {
            try encodeContainer.encode(configurationOverrides, forKey: .configurationOverrides)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason.rawValue, forKey: .failureReason)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let releaseLabel = self.releaseLabel {
            try encodeContainer.encode(releaseLabel, forKey: .releaseLabel)
        }
        if let securityGroup = self.securityGroup {
            try encodeContainer.encode(securityGroup, forKey: .securityGroup)
        }
        if let serverUrl = self.serverUrl {
            try encodeContainer.encode(serverUrl, forKey: .serverUrl)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateDetails = self.stateDetails {
            try encodeContainer.encode(stateDetails, forKey: .stateDetails)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for string2560 in subnetIds {
                try subnetIdsContainer.encode(string2560)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let virtualClusterId = self.virtualClusterId {
            try encodeContainer.encode(virtualClusterId, forKey: .virtualClusterId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let virtualClusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualClusterId)
        virtualClusterId = virtualClusterIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.EndpointState.self, forKey: .state)
        state = stateDecoded
        let releaseLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .releaseLabel)
        releaseLabel = releaseLabelDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateAuthorityDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.Certificate.self, forKey: .certificateAuthority)
        certificateAuthority = certificateAuthorityDecoded
        let configurationOverridesDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.ConfigurationOverrides.self, forKey: .configurationOverrides)
        configurationOverrides = configurationOverridesDecoded
        let serverUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverUrl)
        serverUrl = serverUrlDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let securityGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityGroup)
        securityGroup = securityGroupDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let stateDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateDetails)
        stateDetails = stateDetailsDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.FailureReason.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringempty2560) in tagsContainer {
                if let stringempty2560 = stringempty2560 {
                    tagsDecoded0?[key0] = stringempty2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension EMRcontainersClientTypes {
    /// This entity represents the endpoint that is managed by Amazon EMR on EKS.
    public struct Endpoint: Swift.Equatable {
        /// The ARN of the endpoint.
        public var arn: Swift.String?
        /// The certificate ARN of the endpoint. This field is under deprecation and will be removed in future.
        @available(*, deprecated, message: "Customer provided certificate-arn is deprecated and would be removed in future.")
        public var certificateArn: Swift.String?
        /// The certificate generated by emr control plane on customer behalf to secure the managed endpoint.
        public var certificateAuthority: EMRcontainersClientTypes.Certificate?
        /// The configuration settings that are used to override existing configurations for endpoints.
        public var configurationOverrides: EMRcontainersClientTypes.ConfigurationOverrides?
        /// The date and time when the endpoint was created.
        public var createdAt: ClientRuntime.Date?
        /// The execution role ARN of the endpoint.
        public var executionRoleArn: Swift.String?
        /// The reasons why the endpoint has failed.
        public var failureReason: EMRcontainersClientTypes.FailureReason?
        /// The ID of the endpoint.
        public var id: Swift.String?
        /// The name of the endpoint.
        public var name: Swift.String?
        /// The EMR release version to be used for the endpoint.
        public var releaseLabel: Swift.String?
        /// The security group configuration of the endpoint.
        public var securityGroup: Swift.String?
        /// The server URL of the endpoint.
        public var serverUrl: Swift.String?
        /// The state of the endpoint.
        public var state: EMRcontainersClientTypes.EndpointState?
        /// Additional details of the endpoint state.
        public var stateDetails: Swift.String?
        /// The subnet IDs of the endpoint.
        public var subnetIds: [Swift.String]?
        /// The tags of the endpoint.
        public var tags: [Swift.String:Swift.String]?
        /// The type of the endpoint.
        public var type: Swift.String?
        /// The ID of the endpoint's virtual cluster.
        public var virtualClusterId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            certificateArn: Swift.String? = nil,
            certificateAuthority: EMRcontainersClientTypes.Certificate? = nil,
            configurationOverrides: EMRcontainersClientTypes.ConfigurationOverrides? = nil,
            createdAt: ClientRuntime.Date? = nil,
            executionRoleArn: Swift.String? = nil,
            failureReason: EMRcontainersClientTypes.FailureReason? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            releaseLabel: Swift.String? = nil,
            securityGroup: Swift.String? = nil,
            serverUrl: Swift.String? = nil,
            state: EMRcontainersClientTypes.EndpointState? = nil,
            stateDetails: Swift.String? = nil,
            subnetIds: [Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: Swift.String? = nil,
            virtualClusterId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.certificateArn = certificateArn
            self.certificateAuthority = certificateAuthority
            self.configurationOverrides = configurationOverrides
            self.createdAt = createdAt
            self.executionRoleArn = executionRoleArn
            self.failureReason = failureReason
            self.id = id
            self.name = name
            self.releaseLabel = releaseLabel
            self.securityGroup = securityGroup
            self.serverUrl = serverUrl
            self.state = state
            self.stateDetails = stateDetails
            self.subnetIds = subnetIds
            self.tags = tags
            self.type = type
            self.virtualClusterId = virtualClusterId
        }
    }

}

extension EMRcontainersClientTypes {
    public enum EndpointState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case terminated
        case terminatedWithErrors
        case terminating
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointState] {
            return [
                .active,
                .creating,
                .terminated,
                .terminatedWithErrors,
                .terminating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .terminated: return "TERMINATED"
            case .terminatedWithErrors: return "TERMINATED_WITH_ERRORS"
            case .terminating: return "TERMINATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EndpointState(rawValue: rawValue) ?? EndpointState.sdkUnknown(rawValue)
        }
    }
}

extension EMRcontainersClientTypes {
    public enum FailureReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case clusterUnavailable
        case internalError
        case userError
        case validationError
        case sdkUnknown(Swift.String)

        public static var allCases: [FailureReason] {
            return [
                .clusterUnavailable,
                .internalError,
                .userError,
                .validationError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .clusterUnavailable: return "CLUSTER_UNAVAILABLE"
            case .internalError: return "INTERNAL_ERROR"
            case .userError: return "USER_ERROR"
            case .validationError: return "VALIDATION_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FailureReason(rawValue: rawValue) ?? FailureReason.sdkUnknown(rawValue)
        }
    }
}

extension GetManagedEndpointSessionCredentialsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case credentialType
        case durationInSeconds
        case executionRoleArn
        case logContext
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let credentialType = self.credentialType {
            try encodeContainer.encode(credentialType, forKey: .credentialType)
        }
        if let durationInSeconds = self.durationInSeconds {
            try encodeContainer.encode(durationInSeconds, forKey: .durationInSeconds)
        }
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let logContext = self.logContext {
            try encodeContainer.encode(logContext, forKey: .logContext)
        }
    }
}

extension GetManagedEndpointSessionCredentialsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let virtualClusterIdentifier = virtualClusterIdentifier else {
            return nil
        }
        guard let endpointIdentifier = endpointIdentifier else {
            return nil
        }
        return "/virtualclusters/\(virtualClusterIdentifier.urlPercentEncoding())/endpoints/\(endpointIdentifier.urlPercentEncoding())/credentials"
    }
}

public struct GetManagedEndpointSessionCredentialsInput: Swift.Equatable {
    /// The client idempotency token of the job run request.
    public var clientToken: Swift.String?
    /// Type of the token requested. Currently supported and default value of this field is TOKEN.
    /// This member is required.
    public var credentialType: Swift.String?
    /// Duration in seconds for which the session token is valid. The default duration is 15 minutes and the maximum is 12 hours.
    public var durationInSeconds: Swift.Int?
    /// The ARN of the managed endpoint for which the request is submitted.
    /// This member is required.
    public var endpointIdentifier: Swift.String?
    /// The IAM Execution Role ARN that will be used by the job run.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// String identifier used to separate sections of the execution logs uploaded to S3.
    public var logContext: Swift.String?
    /// The ARN of the Virtual Cluster which the Managed Endpoint belongs to.
    /// This member is required.
    public var virtualClusterIdentifier: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        credentialType: Swift.String? = nil,
        durationInSeconds: Swift.Int? = nil,
        endpointIdentifier: Swift.String? = nil,
        executionRoleArn: Swift.String? = nil,
        logContext: Swift.String? = nil,
        virtualClusterIdentifier: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.credentialType = credentialType
        self.durationInSeconds = durationInSeconds
        self.endpointIdentifier = endpointIdentifier
        self.executionRoleArn = executionRoleArn
        self.logContext = logContext
        self.virtualClusterIdentifier = virtualClusterIdentifier
    }
}

struct GetManagedEndpointSessionCredentialsInputBody: Swift.Equatable {
    let executionRoleArn: Swift.String?
    let credentialType: Swift.String?
    let durationInSeconds: Swift.Int?
    let logContext: Swift.String?
    let clientToken: Swift.String?
}

extension GetManagedEndpointSessionCredentialsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case credentialType
        case durationInSeconds
        case executionRoleArn
        case logContext
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let credentialTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentialType)
        credentialType = credentialTypeDecoded
        let durationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInSeconds)
        durationInSeconds = durationInSecondsDecoded
        let logContextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logContext)
        logContext = logContextDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension GetManagedEndpointSessionCredentialsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetManagedEndpointSessionCredentialsOutputBody = try responseDecoder.decode(responseBody: data)
            self.credentials = output.credentials
            self.expiresAt = output.expiresAt
            self.id = output.id
        } else {
            self.credentials = nil
            self.expiresAt = nil
            self.id = nil
        }
    }
}

public struct GetManagedEndpointSessionCredentialsOutput: Swift.Equatable {
    /// The structure containing the session credentials.
    public var credentials: EMRcontainersClientTypes.Credentials?
    /// The date and time when the session token will expire.
    public var expiresAt: ClientRuntime.Date?
    /// The identifier of the session token returned.
    public var id: Swift.String?

    public init(
        credentials: EMRcontainersClientTypes.Credentials? = nil,
        expiresAt: ClientRuntime.Date? = nil,
        id: Swift.String? = nil
    )
    {
        self.credentials = credentials
        self.expiresAt = expiresAt
        self.id = id
    }
}

struct GetManagedEndpointSessionCredentialsOutputBody: Swift.Equatable {
    let id: Swift.String?
    let credentials: EMRcontainersClientTypes.Credentials?
    let expiresAt: ClientRuntime.Date?
}

extension GetManagedEndpointSessionCredentialsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials
        case expiresAt
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let credentialsDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.Credentials.self, forKey: .credentials)
        credentials = credentialsDecoded
        let expiresAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .expiresAt)
        expiresAt = expiresAtDecoded
    }
}

enum GetManagedEndpointSessionCredentialsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestThrottledException": return try await RequestThrottledException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This is an internal server exception.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EMRcontainersClientTypes.JobDriver: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sparkSqlJobDriver
        case sparkSubmitJobDriver
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sparkSqlJobDriver = self.sparkSqlJobDriver {
            try encodeContainer.encode(sparkSqlJobDriver, forKey: .sparkSqlJobDriver)
        }
        if let sparkSubmitJobDriver = self.sparkSubmitJobDriver {
            try encodeContainer.encode(sparkSubmitJobDriver, forKey: .sparkSubmitJobDriver)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sparkSubmitJobDriverDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.SparkSubmitJobDriver.self, forKey: .sparkSubmitJobDriver)
        sparkSubmitJobDriver = sparkSubmitJobDriverDecoded
        let sparkSqlJobDriverDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.SparkSqlJobDriver.self, forKey: .sparkSqlJobDriver)
        sparkSqlJobDriver = sparkSqlJobDriverDecoded
    }
}

extension EMRcontainersClientTypes {
    /// Specify the driver that the job runs on. Exactly one of the two available job drivers is required, either sparkSqlJobDriver or sparkSubmitJobDriver.
    public struct JobDriver: Swift.Equatable {
        /// The job driver for job type.
        public var sparkSqlJobDriver: EMRcontainersClientTypes.SparkSqlJobDriver?
        /// The job driver parameters specified for spark submit.
        public var sparkSubmitJobDriver: EMRcontainersClientTypes.SparkSubmitJobDriver?

        public init(
            sparkSqlJobDriver: EMRcontainersClientTypes.SparkSqlJobDriver? = nil,
            sparkSubmitJobDriver: EMRcontainersClientTypes.SparkSubmitJobDriver? = nil
        )
        {
            self.sparkSqlJobDriver = sparkSqlJobDriver
            self.sparkSubmitJobDriver = sparkSubmitJobDriver
        }
    }

}

extension EMRcontainersClientTypes.JobRun: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientToken
        case configurationOverrides
        case createdAt
        case createdBy
        case executionRoleArn
        case failureReason
        case finishedAt
        case id
        case jobDriver
        case name
        case releaseLabel
        case retryPolicyConfiguration
        case retryPolicyExecution
        case state
        case stateDetails
        case tags
        case virtualClusterId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let configurationOverrides = self.configurationOverrides {
            try encodeContainer.encode(configurationOverrides, forKey: .configurationOverrides)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason.rawValue, forKey: .failureReason)
        }
        if let finishedAt = self.finishedAt {
            try encodeContainer.encodeTimestamp(finishedAt, format: .dateTime, forKey: .finishedAt)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let jobDriver = self.jobDriver {
            try encodeContainer.encode(jobDriver, forKey: .jobDriver)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let releaseLabel = self.releaseLabel {
            try encodeContainer.encode(releaseLabel, forKey: .releaseLabel)
        }
        if let retryPolicyConfiguration = self.retryPolicyConfiguration {
            try encodeContainer.encode(retryPolicyConfiguration, forKey: .retryPolicyConfiguration)
        }
        if let retryPolicyExecution = self.retryPolicyExecution {
            try encodeContainer.encode(retryPolicyExecution, forKey: .retryPolicyExecution)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateDetails = self.stateDetails {
            try encodeContainer.encode(stateDetails, forKey: .stateDetails)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let virtualClusterId = self.virtualClusterId {
            try encodeContainer.encode(virtualClusterId, forKey: .virtualClusterId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let virtualClusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualClusterId)
        virtualClusterId = virtualClusterIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.JobRunState.self, forKey: .state)
        state = stateDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let releaseLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .releaseLabel)
        releaseLabel = releaseLabelDecoded
        let configurationOverridesDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.ConfigurationOverrides.self, forKey: .configurationOverrides)
        configurationOverrides = configurationOverridesDecoded
        let jobDriverDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.JobDriver.self, forKey: .jobDriver)
        jobDriver = jobDriverDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let finishedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .finishedAt)
        finishedAt = finishedAtDecoded
        let stateDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateDetails)
        stateDetails = stateDetailsDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.FailureReason.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringempty2560) in tagsContainer {
                if let stringempty2560 = stringempty2560 {
                    tagsDecoded0?[key0] = stringempty2560
                }
            }
        }
        tags = tagsDecoded0
        let retryPolicyConfigurationDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.RetryPolicyConfiguration.self, forKey: .retryPolicyConfiguration)
        retryPolicyConfiguration = retryPolicyConfigurationDecoded
        let retryPolicyExecutionDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.RetryPolicyExecution.self, forKey: .retryPolicyExecution)
        retryPolicyExecution = retryPolicyExecutionDecoded
    }
}

extension EMRcontainersClientTypes {
    /// This entity describes a job run. A job run is a unit of work, such as a Spark jar, PySpark script, or SparkSQL query, that you submit to Amazon EMR on EKS.
    public struct JobRun: Swift.Equatable {
        /// The ARN of job run.
        public var arn: Swift.String?
        /// The client token used to start a job run.
        public var clientToken: Swift.String?
        /// The configuration settings that are used to override default configuration.
        public var configurationOverrides: EMRcontainersClientTypes.ConfigurationOverrides?
        /// The date and time when the job run was created.
        public var createdAt: ClientRuntime.Date?
        /// The user who created the job run.
        public var createdBy: Swift.String?
        /// The execution role ARN of the job run.
        public var executionRoleArn: Swift.String?
        /// The reasons why the job run has failed.
        public var failureReason: EMRcontainersClientTypes.FailureReason?
        /// The date and time when the job run has finished.
        public var finishedAt: ClientRuntime.Date?
        /// The ID of the job run.
        public var id: Swift.String?
        /// Parameters of job driver for the job run.
        public var jobDriver: EMRcontainersClientTypes.JobDriver?
        /// The name of the job run.
        public var name: Swift.String?
        /// The release version of Amazon EMR.
        public var releaseLabel: Swift.String?
        /// The configuration of the retry policy that the job runs on.
        public var retryPolicyConfiguration: EMRcontainersClientTypes.RetryPolicyConfiguration?
        /// The current status of the retry policy executed on the job.
        public var retryPolicyExecution: EMRcontainersClientTypes.RetryPolicyExecution?
        /// The state of the job run.
        public var state: EMRcontainersClientTypes.JobRunState?
        /// Additional details of the job run state.
        public var stateDetails: Swift.String?
        /// The assigned tags of the job run.
        public var tags: [Swift.String:Swift.String]?
        /// The ID of the job run's virtual cluster.
        public var virtualClusterId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            clientToken: Swift.String? = nil,
            configurationOverrides: EMRcontainersClientTypes.ConfigurationOverrides? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            executionRoleArn: Swift.String? = nil,
            failureReason: EMRcontainersClientTypes.FailureReason? = nil,
            finishedAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            jobDriver: EMRcontainersClientTypes.JobDriver? = nil,
            name: Swift.String? = nil,
            releaseLabel: Swift.String? = nil,
            retryPolicyConfiguration: EMRcontainersClientTypes.RetryPolicyConfiguration? = nil,
            retryPolicyExecution: EMRcontainersClientTypes.RetryPolicyExecution? = nil,
            state: EMRcontainersClientTypes.JobRunState? = nil,
            stateDetails: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            virtualClusterId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.clientToken = clientToken
            self.configurationOverrides = configurationOverrides
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.executionRoleArn = executionRoleArn
            self.failureReason = failureReason
            self.finishedAt = finishedAt
            self.id = id
            self.jobDriver = jobDriver
            self.name = name
            self.releaseLabel = releaseLabel
            self.retryPolicyConfiguration = retryPolicyConfiguration
            self.retryPolicyExecution = retryPolicyExecution
            self.state = state
            self.stateDetails = stateDetails
            self.tags = tags
            self.virtualClusterId = virtualClusterId
        }
    }

}

extension EMRcontainersClientTypes {
    public enum JobRunState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelPending
        case completed
        case failed
        case pending
        case running
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [JobRunState] {
            return [
                .cancelled,
                .cancelPending,
                .completed,
                .failed,
                .pending,
                .running,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelPending: return "CANCEL_PENDING"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobRunState(rawValue: rawValue) ?? JobRunState.sdkUnknown(rawValue)
        }
    }
}

extension EMRcontainersClientTypes.JobTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case createdBy
        case decryptionError
        case id
        case jobTemplateData
        case kmsKeyArn
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let decryptionError = self.decryptionError {
            try encodeContainer.encode(decryptionError, forKey: .decryptionError)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let jobTemplateData = self.jobTemplateData {
            try encodeContainer.encode(jobTemplateData, forKey: .jobTemplateData)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringempty2560) in tagsContainer {
                if let stringempty2560 = stringempty2560 {
                    tagsDecoded0?[key0] = stringempty2560
                }
            }
        }
        tags = tagsDecoded0
        let jobTemplateDataDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.JobTemplateData.self, forKey: .jobTemplateData)
        jobTemplateData = jobTemplateDataDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let decryptionErrorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .decryptionError)
        decryptionError = decryptionErrorDecoded
    }
}

extension EMRcontainersClientTypes {
    /// This entity describes a job template. Job template stores values of StartJobRun API request in a template and can be used to start a job run. Job template allows two use cases: avoid repeating recurring StartJobRun API request values, enforcing certain values in StartJobRun API request.
    public struct JobTemplate: Swift.Equatable {
        /// The ARN of the job template.
        public var arn: Swift.String?
        /// The date and time when the job template was created.
        public var createdAt: ClientRuntime.Date?
        /// The user who created the job template.
        public var createdBy: Swift.String?
        /// The error message in case the decryption of job template fails.
        public var decryptionError: Swift.String?
        /// The ID of the job template.
        public var id: Swift.String?
        /// The job template data which holds values of StartJobRun API request.
        /// This member is required.
        public var jobTemplateData: EMRcontainersClientTypes.JobTemplateData?
        /// The KMS key ARN used to encrypt the job template.
        public var kmsKeyArn: Swift.String?
        /// The name of the job template.
        public var name: Swift.String?
        /// The tags assigned to the job template.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            decryptionError: Swift.String? = nil,
            id: Swift.String? = nil,
            jobTemplateData: EMRcontainersClientTypes.JobTemplateData? = nil,
            kmsKeyArn: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.decryptionError = decryptionError
            self.id = id
            self.jobTemplateData = jobTemplateData
            self.kmsKeyArn = kmsKeyArn
            self.name = name
            self.tags = tags
        }
    }

}

extension EMRcontainersClientTypes.JobTemplateData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationOverrides
        case executionRoleArn
        case jobDriver
        case jobTags
        case parameterConfiguration
        case releaseLabel
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationOverrides = self.configurationOverrides {
            try encodeContainer.encode(configurationOverrides, forKey: .configurationOverrides)
        }
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let jobDriver = self.jobDriver {
            try encodeContainer.encode(jobDriver, forKey: .jobDriver)
        }
        if let jobTags = jobTags {
            var jobTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .jobTags)
            for (dictKey0, tagMap0) in jobTags {
                try jobTagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let parameterConfiguration = parameterConfiguration {
            var parameterConfigurationContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameterConfiguration)
            for (dictKey0, templateParameterConfigurationMap0) in parameterConfiguration {
                try parameterConfigurationContainer.encode(templateParameterConfigurationMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let releaseLabel = self.releaseLabel {
            try encodeContainer.encode(releaseLabel, forKey: .releaseLabel)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let releaseLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .releaseLabel)
        releaseLabel = releaseLabelDecoded
        let configurationOverridesDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.ParametricConfigurationOverrides.self, forKey: .configurationOverrides)
        configurationOverrides = configurationOverridesDecoded
        let jobDriverDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.JobDriver.self, forKey: .jobDriver)
        jobDriver = jobDriverDecoded
        let parameterConfigurationContainer = try containerValues.decodeIfPresent([Swift.String: EMRcontainersClientTypes.TemplateParameterConfiguration?].self, forKey: .parameterConfiguration)
        var parameterConfigurationDecoded0: [Swift.String:EMRcontainersClientTypes.TemplateParameterConfiguration]? = nil
        if let parameterConfigurationContainer = parameterConfigurationContainer {
            parameterConfigurationDecoded0 = [Swift.String:EMRcontainersClientTypes.TemplateParameterConfiguration]()
            for (key0, templateparameterconfiguration0) in parameterConfigurationContainer {
                if let templateparameterconfiguration0 = templateparameterconfiguration0 {
                    parameterConfigurationDecoded0?[key0] = templateparameterconfiguration0
                }
            }
        }
        parameterConfiguration = parameterConfigurationDecoded0
        let jobTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .jobTags)
        var jobTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let jobTagsContainer = jobTagsContainer {
            jobTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringempty2560) in jobTagsContainer {
                if let stringempty2560 = stringempty2560 {
                    jobTagsDecoded0?[key0] = stringempty2560
                }
            }
        }
        jobTags = jobTagsDecoded0
    }
}

extension EMRcontainersClientTypes {
    /// The values of StartJobRun API requests used in job runs started using the job template.
    public struct JobTemplateData: Swift.Equatable {
        /// The configuration settings that are used to override defaults configuration.
        public var configurationOverrides: EMRcontainersClientTypes.ParametricConfigurationOverrides?
        /// The execution role ARN of the job run.
        /// This member is required.
        public var executionRoleArn: Swift.String?
        /// Specify the driver that the job runs on. Exactly one of the two available job drivers is required, either sparkSqlJobDriver or sparkSubmitJobDriver.
        /// This member is required.
        public var jobDriver: EMRcontainersClientTypes.JobDriver?
        /// The tags assigned to jobs started using the job template.
        public var jobTags: [Swift.String:Swift.String]?
        /// The configuration of parameters existing in the job template.
        public var parameterConfiguration: [Swift.String:EMRcontainersClientTypes.TemplateParameterConfiguration]?
        /// The release version of Amazon EMR.
        /// This member is required.
        public var releaseLabel: Swift.String?

        public init(
            configurationOverrides: EMRcontainersClientTypes.ParametricConfigurationOverrides? = nil,
            executionRoleArn: Swift.String? = nil,
            jobDriver: EMRcontainersClientTypes.JobDriver? = nil,
            jobTags: [Swift.String:Swift.String]? = nil,
            parameterConfiguration: [Swift.String:EMRcontainersClientTypes.TemplateParameterConfiguration]? = nil,
            releaseLabel: Swift.String? = nil
        )
        {
            self.configurationOverrides = configurationOverrides
            self.executionRoleArn = executionRoleArn
            self.jobDriver = jobDriver
            self.jobTags = jobTags
            self.parameterConfiguration = parameterConfiguration
            self.releaseLabel = releaseLabel
        }
    }

}

extension ListJobRunsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let name = name {
                let nameQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
                items.append(nameQueryItem)
            }
            if let createdBefore = createdBefore {
                let createdBeforeQueryItem = ClientRuntime.URLQueryItem(name: "createdBefore".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: createdBefore)).urlPercentEncoding())
                items.append(createdBeforeQueryItem)
            }
            if let createdAfter = createdAfter {
                let createdAfterQueryItem = ClientRuntime.URLQueryItem(name: "createdAfter".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: createdAfter)).urlPercentEncoding())
                items.append(createdAfterQueryItem)
            }
            if let states = states {
                states.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "states".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension ListJobRunsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let virtualClusterId = virtualClusterId else {
            return nil
        }
        return "/virtualclusters/\(virtualClusterId.urlPercentEncoding())/jobruns"
    }
}

public struct ListJobRunsInput: Swift.Equatable {
    /// The date and time after which the job runs were submitted.
    public var createdAfter: ClientRuntime.Date?
    /// The date and time before which the job runs were submitted.
    public var createdBefore: ClientRuntime.Date?
    /// The maximum number of job runs that can be listed.
    public var maxResults: Swift.Int?
    /// The name of the job run.
    public var name: Swift.String?
    /// The token for the next set of job runs to return.
    public var nextToken: Swift.String?
    /// The states of the job run.
    public var states: [EMRcontainersClientTypes.JobRunState]?
    /// The ID of the virtual cluster for which to list the job run.
    /// This member is required.
    public var virtualClusterId: Swift.String?

    public init(
        createdAfter: ClientRuntime.Date? = nil,
        createdBefore: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        states: [EMRcontainersClientTypes.JobRunState]? = nil,
        virtualClusterId: Swift.String? = nil
    )
    {
        self.createdAfter = createdAfter
        self.createdBefore = createdBefore
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.states = states
        self.virtualClusterId = virtualClusterId
    }
}

struct ListJobRunsInputBody: Swift.Equatable {
}

extension ListJobRunsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListJobRunsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListJobRunsOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobRuns = output.jobRuns
            self.nextToken = output.nextToken
        } else {
            self.jobRuns = nil
            self.nextToken = nil
        }
    }
}

public struct ListJobRunsOutput: Swift.Equatable {
    /// This output lists information about the specified job runs.
    public var jobRuns: [EMRcontainersClientTypes.JobRun]?
    /// This output displays the token for the next set of job runs.
    public var nextToken: Swift.String?

    public init(
        jobRuns: [EMRcontainersClientTypes.JobRun]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobRuns = jobRuns
        self.nextToken = nextToken
    }
}

struct ListJobRunsOutputBody: Swift.Equatable {
    let jobRuns: [EMRcontainersClientTypes.JobRun]?
    let nextToken: Swift.String?
}

extension ListJobRunsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobRuns
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobRunsContainer = try containerValues.decodeIfPresent([EMRcontainersClientTypes.JobRun?].self, forKey: .jobRuns)
        var jobRunsDecoded0:[EMRcontainersClientTypes.JobRun]? = nil
        if let jobRunsContainer = jobRunsContainer {
            jobRunsDecoded0 = [EMRcontainersClientTypes.JobRun]()
            for structure0 in jobRunsContainer {
                if let structure0 = structure0 {
                    jobRunsDecoded0?.append(structure0)
                }
            }
        }
        jobRuns = jobRunsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListJobRunsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListJobTemplatesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let createdBefore = createdBefore {
                let createdBeforeQueryItem = ClientRuntime.URLQueryItem(name: "createdBefore".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: createdBefore)).urlPercentEncoding())
                items.append(createdBeforeQueryItem)
            }
            if let createdAfter = createdAfter {
                let createdAfterQueryItem = ClientRuntime.URLQueryItem(name: "createdAfter".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: createdAfter)).urlPercentEncoding())
                items.append(createdAfterQueryItem)
            }
            return items
        }
    }
}

extension ListJobTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/jobtemplates"
    }
}

public struct ListJobTemplatesInput: Swift.Equatable {
    /// The date and time after which the job templates were created.
    public var createdAfter: ClientRuntime.Date?
    /// The date and time before which the job templates were created.
    public var createdBefore: ClientRuntime.Date?
    /// The maximum number of job templates that can be listed.
    public var maxResults: Swift.Int?
    /// The token for the next set of job templates to return.
    public var nextToken: Swift.String?

    public init(
        createdAfter: ClientRuntime.Date? = nil,
        createdBefore: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.createdAfter = createdAfter
        self.createdBefore = createdBefore
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListJobTemplatesInputBody: Swift.Equatable {
}

extension ListJobTemplatesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListJobTemplatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListJobTemplatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.templates = output.templates
        } else {
            self.nextToken = nil
            self.templates = nil
        }
    }
}

public struct ListJobTemplatesOutput: Swift.Equatable {
    /// This output displays the token for the next set of job templates.
    public var nextToken: Swift.String?
    /// This output lists information about the specified job templates.
    public var templates: [EMRcontainersClientTypes.JobTemplate]?

    public init(
        nextToken: Swift.String? = nil,
        templates: [EMRcontainersClientTypes.JobTemplate]? = nil
    )
    {
        self.nextToken = nextToken
        self.templates = templates
    }
}

struct ListJobTemplatesOutputBody: Swift.Equatable {
    let templates: [EMRcontainersClientTypes.JobTemplate]?
    let nextToken: Swift.String?
}

extension ListJobTemplatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case templates
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templatesContainer = try containerValues.decodeIfPresent([EMRcontainersClientTypes.JobTemplate?].self, forKey: .templates)
        var templatesDecoded0:[EMRcontainersClientTypes.JobTemplate]? = nil
        if let templatesContainer = templatesContainer {
            templatesDecoded0 = [EMRcontainersClientTypes.JobTemplate]()
            for structure0 in templatesContainer {
                if let structure0 = structure0 {
                    templatesDecoded0?.append(structure0)
                }
            }
        }
        templates = templatesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListJobTemplatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListManagedEndpointsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let types = types {
                types.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "types".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let createdBefore = createdBefore {
                let createdBeforeQueryItem = ClientRuntime.URLQueryItem(name: "createdBefore".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: createdBefore)).urlPercentEncoding())
                items.append(createdBeforeQueryItem)
            }
            if let createdAfter = createdAfter {
                let createdAfterQueryItem = ClientRuntime.URLQueryItem(name: "createdAfter".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: createdAfter)).urlPercentEncoding())
                items.append(createdAfterQueryItem)
            }
            if let states = states {
                states.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "states".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension ListManagedEndpointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let virtualClusterId = virtualClusterId else {
            return nil
        }
        return "/virtualclusters/\(virtualClusterId.urlPercentEncoding())/endpoints"
    }
}

public struct ListManagedEndpointsInput: Swift.Equatable {
    /// The date and time after which the endpoints are created.
    public var createdAfter: ClientRuntime.Date?
    /// The date and time before which the endpoints are created.
    public var createdBefore: ClientRuntime.Date?
    /// The maximum number of managed endpoints that can be listed.
    public var maxResults: Swift.Int?
    /// The token for the next set of managed endpoints to return.
    public var nextToken: Swift.String?
    /// The states of the managed endpoints.
    public var states: [EMRcontainersClientTypes.EndpointState]?
    /// The types of the managed endpoints.
    public var types: [Swift.String]?
    /// The ID of the virtual cluster.
    /// This member is required.
    public var virtualClusterId: Swift.String?

    public init(
        createdAfter: ClientRuntime.Date? = nil,
        createdBefore: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        states: [EMRcontainersClientTypes.EndpointState]? = nil,
        types: [Swift.String]? = nil,
        virtualClusterId: Swift.String? = nil
    )
    {
        self.createdAfter = createdAfter
        self.createdBefore = createdBefore
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.states = states
        self.types = types
        self.virtualClusterId = virtualClusterId
    }
}

struct ListManagedEndpointsInputBody: Swift.Equatable {
}

extension ListManagedEndpointsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListManagedEndpointsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListManagedEndpointsOutputBody = try responseDecoder.decode(responseBody: data)
            self.endpoints = output.endpoints
            self.nextToken = output.nextToken
        } else {
            self.endpoints = nil
            self.nextToken = nil
        }
    }
}

public struct ListManagedEndpointsOutput: Swift.Equatable {
    /// The managed endpoints to be listed.
    public var endpoints: [EMRcontainersClientTypes.Endpoint]?
    /// The token for the next set of endpoints to return.
    public var nextToken: Swift.String?

    public init(
        endpoints: [EMRcontainersClientTypes.Endpoint]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.endpoints = endpoints
        self.nextToken = nextToken
    }
}

struct ListManagedEndpointsOutputBody: Swift.Equatable {
    let endpoints: [EMRcontainersClientTypes.Endpoint]?
    let nextToken: Swift.String?
}

extension ListManagedEndpointsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoints
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointsContainer = try containerValues.decodeIfPresent([EMRcontainersClientTypes.Endpoint?].self, forKey: .endpoints)
        var endpointsDecoded0:[EMRcontainersClientTypes.Endpoint]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [EMRcontainersClientTypes.Endpoint]()
            for structure0 in endpointsContainer {
                if let structure0 = structure0 {
                    endpointsDecoded0?.append(structure0)
                }
            }
        }
        endpoints = endpointsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListManagedEndpointsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of tagged resources.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tags assigned to resources.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringempty2560) in tagsContainer {
                if let stringempty2560 = stringempty2560 {
                    tagsDecoded0?[key0] = stringempty2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListVirtualClustersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let containerProviderId = containerProviderId {
                let containerProviderIdQueryItem = ClientRuntime.URLQueryItem(name: "containerProviderId".urlPercentEncoding(), value: Swift.String(containerProviderId).urlPercentEncoding())
                items.append(containerProviderIdQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let containerProviderType = containerProviderType {
                let containerProviderTypeQueryItem = ClientRuntime.URLQueryItem(name: "containerProviderType".urlPercentEncoding(), value: Swift.String(containerProviderType.rawValue).urlPercentEncoding())
                items.append(containerProviderTypeQueryItem)
            }
            if let createdBefore = createdBefore {
                let createdBeforeQueryItem = ClientRuntime.URLQueryItem(name: "createdBefore".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: createdBefore)).urlPercentEncoding())
                items.append(createdBeforeQueryItem)
            }
            if let createdAfter = createdAfter {
                let createdAfterQueryItem = ClientRuntime.URLQueryItem(name: "createdAfter".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: createdAfter)).urlPercentEncoding())
                items.append(createdAfterQueryItem)
            }
            if let states = states {
                states.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "states".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension ListVirtualClustersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/virtualclusters"
    }
}

public struct ListVirtualClustersInput: Swift.Equatable {
    /// The container provider ID of the virtual cluster.
    public var containerProviderId: Swift.String?
    /// The container provider type of the virtual cluster. Amazon EKS is the only supported type as of now.
    public var containerProviderType: EMRcontainersClientTypes.ContainerProviderType?
    /// The date and time after which the virtual clusters are created.
    public var createdAfter: ClientRuntime.Date?
    /// The date and time before which the virtual clusters are created.
    public var createdBefore: ClientRuntime.Date?
    /// The maximum number of virtual clusters that can be listed.
    public var maxResults: Swift.Int?
    /// The token for the next set of virtual clusters to return.
    public var nextToken: Swift.String?
    /// The states of the requested virtual clusters.
    public var states: [EMRcontainersClientTypes.VirtualClusterState]?

    public init(
        containerProviderId: Swift.String? = nil,
        containerProviderType: EMRcontainersClientTypes.ContainerProviderType? = nil,
        createdAfter: ClientRuntime.Date? = nil,
        createdBefore: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        states: [EMRcontainersClientTypes.VirtualClusterState]? = nil
    )
    {
        self.containerProviderId = containerProviderId
        self.containerProviderType = containerProviderType
        self.createdAfter = createdAfter
        self.createdBefore = createdBefore
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.states = states
    }
}

struct ListVirtualClustersInputBody: Swift.Equatable {
}

extension ListVirtualClustersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListVirtualClustersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListVirtualClustersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.virtualClusters = output.virtualClusters
        } else {
            self.nextToken = nil
            self.virtualClusters = nil
        }
    }
}

public struct ListVirtualClustersOutput: Swift.Equatable {
    /// This output displays the token for the next set of virtual clusters.
    public var nextToken: Swift.String?
    /// This output lists the specified virtual clusters.
    public var virtualClusters: [EMRcontainersClientTypes.VirtualCluster]?

    public init(
        nextToken: Swift.String? = nil,
        virtualClusters: [EMRcontainersClientTypes.VirtualCluster]? = nil
    )
    {
        self.nextToken = nextToken
        self.virtualClusters = virtualClusters
    }
}

struct ListVirtualClustersOutputBody: Swift.Equatable {
    let virtualClusters: [EMRcontainersClientTypes.VirtualCluster]?
    let nextToken: Swift.String?
}

extension ListVirtualClustersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case virtualClusters
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualClustersContainer = try containerValues.decodeIfPresent([EMRcontainersClientTypes.VirtualCluster?].self, forKey: .virtualClusters)
        var virtualClustersDecoded0:[EMRcontainersClientTypes.VirtualCluster]? = nil
        if let virtualClustersContainer = virtualClustersContainer {
            virtualClustersDecoded0 = [EMRcontainersClientTypes.VirtualCluster]()
            for structure0 in virtualClustersContainer {
                if let structure0 = structure0 {
                    virtualClustersDecoded0?.append(structure0)
                }
            }
        }
        virtualClusters = virtualClustersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListVirtualClustersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EMRcontainersClientTypes.MonitoringConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchMonitoringConfiguration
        case containerLogRotationConfiguration
        case persistentAppUI
        case s3MonitoringConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchMonitoringConfiguration = self.cloudWatchMonitoringConfiguration {
            try encodeContainer.encode(cloudWatchMonitoringConfiguration, forKey: .cloudWatchMonitoringConfiguration)
        }
        if let containerLogRotationConfiguration = self.containerLogRotationConfiguration {
            try encodeContainer.encode(containerLogRotationConfiguration, forKey: .containerLogRotationConfiguration)
        }
        if let persistentAppUI = self.persistentAppUI {
            try encodeContainer.encode(persistentAppUI.rawValue, forKey: .persistentAppUI)
        }
        if let s3MonitoringConfiguration = self.s3MonitoringConfiguration {
            try encodeContainer.encode(s3MonitoringConfiguration, forKey: .s3MonitoringConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let persistentAppUIDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.PersistentAppUI.self, forKey: .persistentAppUI)
        persistentAppUI = persistentAppUIDecoded
        let cloudWatchMonitoringConfigurationDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.CloudWatchMonitoringConfiguration.self, forKey: .cloudWatchMonitoringConfiguration)
        cloudWatchMonitoringConfiguration = cloudWatchMonitoringConfigurationDecoded
        let s3MonitoringConfigurationDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.S3MonitoringConfiguration.self, forKey: .s3MonitoringConfiguration)
        s3MonitoringConfiguration = s3MonitoringConfigurationDecoded
        let containerLogRotationConfigurationDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.ContainerLogRotationConfiguration.self, forKey: .containerLogRotationConfiguration)
        containerLogRotationConfiguration = containerLogRotationConfigurationDecoded
    }
}

extension EMRcontainersClientTypes {
    /// Configuration setting for monitoring.
    public struct MonitoringConfiguration: Swift.Equatable {
        /// Monitoring configurations for CloudWatch.
        public var cloudWatchMonitoringConfiguration: EMRcontainersClientTypes.CloudWatchMonitoringConfiguration?
        /// Enable or disable container log rotation.
        public var containerLogRotationConfiguration: EMRcontainersClientTypes.ContainerLogRotationConfiguration?
        /// Monitoring configurations for the persistent application UI.
        public var persistentAppUI: EMRcontainersClientTypes.PersistentAppUI?
        /// Amazon S3 configuration for monitoring log publishing.
        public var s3MonitoringConfiguration: EMRcontainersClientTypes.S3MonitoringConfiguration?

        public init(
            cloudWatchMonitoringConfiguration: EMRcontainersClientTypes.CloudWatchMonitoringConfiguration? = nil,
            containerLogRotationConfiguration: EMRcontainersClientTypes.ContainerLogRotationConfiguration? = nil,
            persistentAppUI: EMRcontainersClientTypes.PersistentAppUI? = nil,
            s3MonitoringConfiguration: EMRcontainersClientTypes.S3MonitoringConfiguration? = nil
        )
        {
            self.cloudWatchMonitoringConfiguration = cloudWatchMonitoringConfiguration
            self.containerLogRotationConfiguration = containerLogRotationConfiguration
            self.persistentAppUI = persistentAppUI
            self.s3MonitoringConfiguration = s3MonitoringConfiguration
        }
    }

}

extension EMRcontainersClientTypes.ParametricCloudWatchMonitoringConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logGroupName
        case logStreamNamePrefix
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logGroupName = self.logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
        if let logStreamNamePrefix = self.logStreamNamePrefix {
            try encodeContainer.encode(logStreamNamePrefix, forKey: .logStreamNamePrefix)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
        let logStreamNamePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logStreamNamePrefix)
        logStreamNamePrefix = logStreamNamePrefixDecoded
    }
}

extension EMRcontainersClientTypes {
    /// A configuration for CloudWatch monitoring. You can configure your jobs to send log information to CloudWatch Logs. This data type allows job template parameters to be specified within.
    public struct ParametricCloudWatchMonitoringConfiguration: Swift.Equatable {
        /// The name of the log group for log publishing.
        public var logGroupName: Swift.String?
        /// The specified name prefix for log streams.
        public var logStreamNamePrefix: Swift.String?

        public init(
            logGroupName: Swift.String? = nil,
            logStreamNamePrefix: Swift.String? = nil
        )
        {
            self.logGroupName = logGroupName
            self.logStreamNamePrefix = logStreamNamePrefix
        }
    }

}

extension EMRcontainersClientTypes.ParametricConfigurationOverrides: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationConfiguration
        case monitoringConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationConfiguration = applicationConfiguration {
            var applicationConfigurationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applicationConfiguration)
            for configuration0 in applicationConfiguration {
                try applicationConfigurationContainer.encode(configuration0)
            }
        }
        if let monitoringConfiguration = self.monitoringConfiguration {
            try encodeContainer.encode(monitoringConfiguration, forKey: .monitoringConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationConfigurationContainer = try containerValues.decodeIfPresent([EMRcontainersClientTypes.Configuration?].self, forKey: .applicationConfiguration)
        var applicationConfigurationDecoded0:[EMRcontainersClientTypes.Configuration]? = nil
        if let applicationConfigurationContainer = applicationConfigurationContainer {
            applicationConfigurationDecoded0 = [EMRcontainersClientTypes.Configuration]()
            for structure0 in applicationConfigurationContainer {
                if let structure0 = structure0 {
                    applicationConfigurationDecoded0?.append(structure0)
                }
            }
        }
        applicationConfiguration = applicationConfigurationDecoded0
        let monitoringConfigurationDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.ParametricMonitoringConfiguration.self, forKey: .monitoringConfiguration)
        monitoringConfiguration = monitoringConfigurationDecoded
    }
}

extension EMRcontainersClientTypes {
    /// A configuration specification to be used to override existing configurations. This data type allows job template parameters to be specified within.
    public struct ParametricConfigurationOverrides: Swift.Equatable {
        /// The configurations for the application running by the job run.
        public var applicationConfiguration: [EMRcontainersClientTypes.Configuration]?
        /// The configurations for monitoring.
        public var monitoringConfiguration: EMRcontainersClientTypes.ParametricMonitoringConfiguration?

        public init(
            applicationConfiguration: [EMRcontainersClientTypes.Configuration]? = nil,
            monitoringConfiguration: EMRcontainersClientTypes.ParametricMonitoringConfiguration? = nil
        )
        {
            self.applicationConfiguration = applicationConfiguration
            self.monitoringConfiguration = monitoringConfiguration
        }
    }

}

extension EMRcontainersClientTypes.ParametricMonitoringConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchMonitoringConfiguration
        case persistentAppUI
        case s3MonitoringConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchMonitoringConfiguration = self.cloudWatchMonitoringConfiguration {
            try encodeContainer.encode(cloudWatchMonitoringConfiguration, forKey: .cloudWatchMonitoringConfiguration)
        }
        if let persistentAppUI = self.persistentAppUI {
            try encodeContainer.encode(persistentAppUI, forKey: .persistentAppUI)
        }
        if let s3MonitoringConfiguration = self.s3MonitoringConfiguration {
            try encodeContainer.encode(s3MonitoringConfiguration, forKey: .s3MonitoringConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let persistentAppUIDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .persistentAppUI)
        persistentAppUI = persistentAppUIDecoded
        let cloudWatchMonitoringConfigurationDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.ParametricCloudWatchMonitoringConfiguration.self, forKey: .cloudWatchMonitoringConfiguration)
        cloudWatchMonitoringConfiguration = cloudWatchMonitoringConfigurationDecoded
        let s3MonitoringConfigurationDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.ParametricS3MonitoringConfiguration.self, forKey: .s3MonitoringConfiguration)
        s3MonitoringConfiguration = s3MonitoringConfigurationDecoded
    }
}

extension EMRcontainersClientTypes {
    /// Configuration setting for monitoring. This data type allows job template parameters to be specified within.
    public struct ParametricMonitoringConfiguration: Swift.Equatable {
        /// Monitoring configurations for CloudWatch.
        public var cloudWatchMonitoringConfiguration: EMRcontainersClientTypes.ParametricCloudWatchMonitoringConfiguration?
        /// Monitoring configurations for the persistent application UI.
        public var persistentAppUI: Swift.String?
        /// Amazon S3 configuration for monitoring log publishing.
        public var s3MonitoringConfiguration: EMRcontainersClientTypes.ParametricS3MonitoringConfiguration?

        public init(
            cloudWatchMonitoringConfiguration: EMRcontainersClientTypes.ParametricCloudWatchMonitoringConfiguration? = nil,
            persistentAppUI: Swift.String? = nil,
            s3MonitoringConfiguration: EMRcontainersClientTypes.ParametricS3MonitoringConfiguration? = nil
        )
        {
            self.cloudWatchMonitoringConfiguration = cloudWatchMonitoringConfiguration
            self.persistentAppUI = persistentAppUI
            self.s3MonitoringConfiguration = s3MonitoringConfiguration
        }
    }

}

extension EMRcontainersClientTypes.ParametricS3MonitoringConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logUri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logUri = self.logUri {
            try encodeContainer.encode(logUri, forKey: .logUri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logUri)
        logUri = logUriDecoded
    }
}

extension EMRcontainersClientTypes {
    /// Amazon S3 configuration for monitoring log publishing. You can configure your jobs to send log information to Amazon S3. This data type allows job template parameters to be specified within.
    public struct ParametricS3MonitoringConfiguration: Swift.Equatable {
        /// Amazon S3 destination URI for log publishing.
        public var logUri: Swift.String?

        public init(
            logUri: Swift.String? = nil
        )
        {
            self.logUri = logUri
        }
    }

}

extension EMRcontainersClientTypes {
    public enum PersistentAppUI: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PersistentAppUI] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PersistentAppUI(rawValue: rawValue) ?? PersistentAppUI.sdkUnknown(rawValue)
        }
    }
}

extension RequestThrottledException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RequestThrottledExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request throttled.
public struct RequestThrottledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RequestThrottledException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RequestThrottledExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RequestThrottledExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EMRcontainersClientTypes.RetryPolicyConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxAttempts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxAttempts = self.maxAttempts {
            try encodeContainer.encode(maxAttempts, forKey: .maxAttempts)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxAttempts)
        maxAttempts = maxAttemptsDecoded
    }
}

extension EMRcontainersClientTypes {
    /// The configuration of the retry policy that the job runs on.
    public struct RetryPolicyConfiguration: Swift.Equatable {
        /// The maximum number of attempts on the job's driver.
        /// This member is required.
        public var maxAttempts: Swift.Int?

        public init(
            maxAttempts: Swift.Int? = nil
        )
        {
            self.maxAttempts = maxAttempts
        }
    }

}

extension EMRcontainersClientTypes.RetryPolicyExecution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentAttemptCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentAttemptCount = self.currentAttemptCount {
            try encodeContainer.encode(currentAttemptCount, forKey: .currentAttemptCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentAttemptCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .currentAttemptCount)
        currentAttemptCount = currentAttemptCountDecoded
    }
}

extension EMRcontainersClientTypes {
    /// The current status of the retry policy executed on the job.
    public struct RetryPolicyExecution: Swift.Equatable {
        /// The current number of attempts made on the driver of the job.
        /// This member is required.
        public var currentAttemptCount: Swift.Int?

        public init(
            currentAttemptCount: Swift.Int? = nil
        )
        {
            self.currentAttemptCount = currentAttemptCount
        }
    }

}

extension EMRcontainersClientTypes.S3MonitoringConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logUri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logUri = self.logUri {
            try encodeContainer.encode(logUri, forKey: .logUri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logUri)
        logUri = logUriDecoded
    }
}

extension EMRcontainersClientTypes {
    /// Amazon S3 configuration for monitoring log publishing. You can configure your jobs to send log information to Amazon S3.
    public struct S3MonitoringConfiguration: Swift.Equatable {
        /// Amazon S3 destination URI for log publishing.
        /// This member is required.
        public var logUri: Swift.String?

        public init(
            logUri: Swift.String? = nil
        )
        {
            self.logUri = logUri
        }
    }

}

extension EMRcontainersClientTypes.SparkSqlJobDriver: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entryPoint
        case sparkSqlParameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entryPoint = self.entryPoint {
            try encodeContainer.encode(entryPoint, forKey: .entryPoint)
        }
        if let sparkSqlParameters = self.sparkSqlParameters {
            try encodeContainer.encode(sparkSqlParameters, forKey: .sparkSqlParameters)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryPointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryPoint)
        entryPoint = entryPointDecoded
        let sparkSqlParametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sparkSqlParameters)
        sparkSqlParameters = sparkSqlParametersDecoded
    }
}

extension EMRcontainersClientTypes.SparkSqlJobDriver: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SparkSqlJobDriver(entryPoint: \"CONTENT_REDACTED\", sparkSqlParameters: \"CONTENT_REDACTED\")"}
}

extension EMRcontainersClientTypes {
    /// The job driver for job type.
    public struct SparkSqlJobDriver: Swift.Equatable {
        /// The SQL file to be executed.
        public var entryPoint: Swift.String?
        /// The Spark parameters to be included in the Spark SQL command.
        public var sparkSqlParameters: Swift.String?

        public init(
            entryPoint: Swift.String? = nil,
            sparkSqlParameters: Swift.String? = nil
        )
        {
            self.entryPoint = entryPoint
            self.sparkSqlParameters = sparkSqlParameters
        }
    }

}

extension EMRcontainersClientTypes.SparkSubmitJobDriver: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entryPoint
        case entryPointArguments
        case sparkSubmitParameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entryPoint = self.entryPoint {
            try encodeContainer.encode(entryPoint, forKey: .entryPoint)
        }
        if let entryPointArguments = entryPointArguments {
            var entryPointArgumentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entryPointArguments)
            for entrypointargument0 in entryPointArguments {
                try entryPointArgumentsContainer.encode(entrypointargument0)
            }
        }
        if let sparkSubmitParameters = self.sparkSubmitParameters {
            try encodeContainer.encode(sparkSubmitParameters, forKey: .sparkSubmitParameters)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryPointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryPoint)
        entryPoint = entryPointDecoded
        let entryPointArgumentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .entryPointArguments)
        var entryPointArgumentsDecoded0:[Swift.String]? = nil
        if let entryPointArgumentsContainer = entryPointArgumentsContainer {
            entryPointArgumentsDecoded0 = [Swift.String]()
            for string0 in entryPointArgumentsContainer {
                if let string0 = string0 {
                    entryPointArgumentsDecoded0?.append(string0)
                }
            }
        }
        entryPointArguments = entryPointArgumentsDecoded0
        let sparkSubmitParametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sparkSubmitParameters)
        sparkSubmitParameters = sparkSubmitParametersDecoded
    }
}

extension EMRcontainersClientTypes.SparkSubmitJobDriver: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SparkSubmitJobDriver(entryPointArguments: \(Swift.String(describing: entryPointArguments)), entryPoint: \"CONTENT_REDACTED\", sparkSubmitParameters: \"CONTENT_REDACTED\")"}
}

extension EMRcontainersClientTypes {
    /// The information about job driver for Spark submit.
    public struct SparkSubmitJobDriver: Swift.Equatable {
        /// The entry point of job application.
        /// This member is required.
        public var entryPoint: Swift.String?
        /// The arguments for job application.
        public var entryPointArguments: [Swift.String]?
        /// The Spark submit parameters that are used for job runs.
        public var sparkSubmitParameters: Swift.String?

        public init(
            entryPoint: Swift.String? = nil,
            entryPointArguments: [Swift.String]? = nil,
            sparkSubmitParameters: Swift.String? = nil
        )
        {
            self.entryPoint = entryPoint
            self.entryPointArguments = entryPointArguments
            self.sparkSubmitParameters = sparkSubmitParameters
        }
    }

}

extension StartJobRunInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case configurationOverrides
        case executionRoleArn
        case jobDriver
        case jobTemplateId
        case jobTemplateParameters
        case name
        case releaseLabel
        case retryPolicyConfiguration
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let configurationOverrides = self.configurationOverrides {
            try encodeContainer.encode(configurationOverrides, forKey: .configurationOverrides)
        }
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let jobDriver = self.jobDriver {
            try encodeContainer.encode(jobDriver, forKey: .jobDriver)
        }
        if let jobTemplateId = self.jobTemplateId {
            try encodeContainer.encode(jobTemplateId, forKey: .jobTemplateId)
        }
        if let jobTemplateParameters = jobTemplateParameters {
            var jobTemplateParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .jobTemplateParameters)
            for (dictKey0, templateParameterInputMap0) in jobTemplateParameters {
                try jobTemplateParametersContainer.encode(templateParameterInputMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let releaseLabel = self.releaseLabel {
            try encodeContainer.encode(releaseLabel, forKey: .releaseLabel)
        }
        if let retryPolicyConfiguration = self.retryPolicyConfiguration {
            try encodeContainer.encode(retryPolicyConfiguration, forKey: .retryPolicyConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartJobRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let virtualClusterId = virtualClusterId else {
            return nil
        }
        return "/virtualclusters/\(virtualClusterId.urlPercentEncoding())/jobruns"
    }
}

public struct StartJobRunInput: Swift.Equatable {
    /// The client idempotency token of the job run request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The configuration overrides for the job run.
    public var configurationOverrides: EMRcontainersClientTypes.ConfigurationOverrides?
    /// The execution role ARN for the job run.
    public var executionRoleArn: Swift.String?
    /// The job driver for the job run.
    public var jobDriver: EMRcontainersClientTypes.JobDriver?
    /// The job template ID to be used to start the job run.
    public var jobTemplateId: Swift.String?
    /// The values of job template parameters to start a job run.
    public var jobTemplateParameters: [Swift.String:Swift.String]?
    /// The name of the job run.
    public var name: Swift.String?
    /// The Amazon EMR release version to use for the job run.
    public var releaseLabel: Swift.String?
    /// The retry policy configuration for the job run.
    public var retryPolicyConfiguration: EMRcontainersClientTypes.RetryPolicyConfiguration?
    /// The tags assigned to job runs.
    public var tags: [Swift.String:Swift.String]?
    /// The virtual cluster ID for which the job run request is submitted.
    /// This member is required.
    public var virtualClusterId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        configurationOverrides: EMRcontainersClientTypes.ConfigurationOverrides? = nil,
        executionRoleArn: Swift.String? = nil,
        jobDriver: EMRcontainersClientTypes.JobDriver? = nil,
        jobTemplateId: Swift.String? = nil,
        jobTemplateParameters: [Swift.String:Swift.String]? = nil,
        name: Swift.String? = nil,
        releaseLabel: Swift.String? = nil,
        retryPolicyConfiguration: EMRcontainersClientTypes.RetryPolicyConfiguration? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        virtualClusterId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.configurationOverrides = configurationOverrides
        self.executionRoleArn = executionRoleArn
        self.jobDriver = jobDriver
        self.jobTemplateId = jobTemplateId
        self.jobTemplateParameters = jobTemplateParameters
        self.name = name
        self.releaseLabel = releaseLabel
        self.retryPolicyConfiguration = retryPolicyConfiguration
        self.tags = tags
        self.virtualClusterId = virtualClusterId
    }
}

struct StartJobRunInputBody: Swift.Equatable {
    let name: Swift.String?
    let clientToken: Swift.String?
    let executionRoleArn: Swift.String?
    let releaseLabel: Swift.String?
    let jobDriver: EMRcontainersClientTypes.JobDriver?
    let configurationOverrides: EMRcontainersClientTypes.ConfigurationOverrides?
    let tags: [Swift.String:Swift.String]?
    let jobTemplateId: Swift.String?
    let jobTemplateParameters: [Swift.String:Swift.String]?
    let retryPolicyConfiguration: EMRcontainersClientTypes.RetryPolicyConfiguration?
}

extension StartJobRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case configurationOverrides
        case executionRoleArn
        case jobDriver
        case jobTemplateId
        case jobTemplateParameters
        case name
        case releaseLabel
        case retryPolicyConfiguration
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let releaseLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .releaseLabel)
        releaseLabel = releaseLabelDecoded
        let jobDriverDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.JobDriver.self, forKey: .jobDriver)
        jobDriver = jobDriverDecoded
        let configurationOverridesDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.ConfigurationOverrides.self, forKey: .configurationOverrides)
        configurationOverrides = configurationOverridesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringempty2560) in tagsContainer {
                if let stringempty2560 = stringempty2560 {
                    tagsDecoded0?[key0] = stringempty2560
                }
            }
        }
        tags = tagsDecoded0
        let jobTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobTemplateId)
        jobTemplateId = jobTemplateIdDecoded
        let jobTemplateParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .jobTemplateParameters)
        var jobTemplateParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let jobTemplateParametersContainer = jobTemplateParametersContainer {
            jobTemplateParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string10240) in jobTemplateParametersContainer {
                if let string10240 = string10240 {
                    jobTemplateParametersDecoded0?[key0] = string10240
                }
            }
        }
        jobTemplateParameters = jobTemplateParametersDecoded0
        let retryPolicyConfigurationDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.RetryPolicyConfiguration.self, forKey: .retryPolicyConfiguration)
        retryPolicyConfiguration = retryPolicyConfigurationDecoded
    }
}

extension StartJobRunOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartJobRunOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.name = output.name
            self.virtualClusterId = output.virtualClusterId
        } else {
            self.arn = nil
            self.id = nil
            self.name = nil
            self.virtualClusterId = nil
        }
    }
}

public struct StartJobRunOutput: Swift.Equatable {
    /// This output lists the ARN of job run.
    public var arn: Swift.String?
    /// This output displays the started job run ID.
    public var id: Swift.String?
    /// This output displays the name of the started job run.
    public var name: Swift.String?
    /// This output displays the virtual cluster ID for which the job run was submitted.
    public var virtualClusterId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        virtualClusterId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.name = name
        self.virtualClusterId = virtualClusterId
    }
}

struct StartJobRunOutputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let arn: Swift.String?
    let virtualClusterId: Swift.String?
}

extension StartJobRunOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case name
        case virtualClusterId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let virtualClusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualClusterId)
        virtualClusterId = virtualClusterIdDecoded
    }
}

enum StartJobRunOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of resources.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags assigned to resources.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringempty2560) in tagsContainer {
                if let stringempty2560 = stringempty2560 {
                    tagsDecoded0?[key0] = stringempty2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EMRcontainersClientTypes.TemplateParameterConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.TemplateParameterDataType.self, forKey: .type)
        type = typeDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension EMRcontainersClientTypes {
    /// The configuration of a job template parameter.
    public struct TemplateParameterConfiguration: Swift.Equatable {
        /// The default value for the job template parameter.
        public var defaultValue: Swift.String?
        /// The type of the job template parameter. Allowed values are: STRING, NUMBER.
        public var type: EMRcontainersClientTypes.TemplateParameterDataType?

        public init(
            defaultValue: Swift.String? = nil,
            type: EMRcontainersClientTypes.TemplateParameterDataType? = nil
        )
        {
            self.defaultValue = defaultValue
            self.type = type
        }
    }

}

extension EMRcontainersClientTypes {
    public enum TemplateParameterDataType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case number
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [TemplateParameterDataType] {
            return [
                .number,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .number: return "NUMBER"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TemplateParameterDataType(rawValue: rawValue) ?? TemplateParameterDataType.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of resources.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys of the resources.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There are invalid parameters in the client request.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EMRcontainersClientTypes.VirtualCluster: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case containerProvider
        case createdAt
        case id
        case name
        case state
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let containerProvider = self.containerProvider {
            try encodeContainer.encode(containerProvider, forKey: .containerProvider)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.VirtualClusterState.self, forKey: .state)
        state = stateDecoded
        let containerProviderDecoded = try containerValues.decodeIfPresent(EMRcontainersClientTypes.ContainerProvider.self, forKey: .containerProvider)
        containerProvider = containerProviderDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringempty2560) in tagsContainer {
                if let stringempty2560 = stringempty2560 {
                    tagsDecoded0?[key0] = stringempty2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension EMRcontainersClientTypes {
    /// This entity describes a virtual cluster. A virtual cluster is a Kubernetes namespace that Amazon EMR is registered with. Amazon EMR uses virtual clusters to run jobs and host endpoints. Multiple virtual clusters can be backed by the same physical cluster. However, each virtual cluster maps to one namespace on an Amazon EKS cluster. Virtual clusters do not create any active resources that contribute to your bill or that require lifecycle management outside the service.
    public struct VirtualCluster: Swift.Equatable {
        /// The ARN of the virtual cluster.
        public var arn: Swift.String?
        /// The container provider of the virtual cluster.
        public var containerProvider: EMRcontainersClientTypes.ContainerProvider?
        /// The date and time when the virtual cluster is created.
        public var createdAt: ClientRuntime.Date?
        /// The ID of the virtual cluster.
        public var id: Swift.String?
        /// The name of the virtual cluster.
        public var name: Swift.String?
        /// The state of the virtual cluster.
        public var state: EMRcontainersClientTypes.VirtualClusterState?
        /// The assigned tags of the virtual cluster.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            containerProvider: EMRcontainersClientTypes.ContainerProvider? = nil,
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            state: EMRcontainersClientTypes.VirtualClusterState? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.containerProvider = containerProvider
            self.createdAt = createdAt
            self.id = id
            self.name = name
            self.state = state
            self.tags = tags
        }
    }

}

extension EMRcontainersClientTypes {
    public enum VirtualClusterState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case arrested
        case running
        case terminated
        case terminating
        case sdkUnknown(Swift.String)

        public static var allCases: [VirtualClusterState] {
            return [
                .arrested,
                .running,
                .terminated,
                .terminating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .arrested: return "ARRESTED"
            case .running: return "RUNNING"
            case .terminated: return "TERMINATED"
            case .terminating: return "TERMINATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VirtualClusterState(rawValue: rawValue) ?? VirtualClusterState.sdkUnknown(rawValue)
        }
    }
}
