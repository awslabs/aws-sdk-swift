//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension ControlCatalogClientTypes {

    /// A summary of the domain that a common control or an objective belongs to.
    public struct AssociatedDomainSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the related domain.
        public var arn: Swift.String?
        /// The name of the related domain.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        ) {
            self.arn = arn
            self.name = name
        }
    }
}

extension ControlCatalogClientTypes {

    /// A summary of the objective that a common control supports.
    public struct AssociatedObjectiveSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the related objective.
        public var arn: Swift.String?
        /// The name of the related objective.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        ) {
            self.arn = arn
            self.name = name
        }
    }
}

extension ControlCatalogClientTypes {

    /// The objective resource that's being used as a filter.
    public struct ObjectiveResourceFilter: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the objective.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        ) {
            self.arn = arn
        }
    }
}

extension ControlCatalogClientTypes {

    /// An optional filter that narrows the results to a specific objective.
    public struct CommonControlFilter: Swift.Sendable {
        /// The objective that's used as filter criteria. You can use this parameter to specify one objective ARN at a time. Passing multiple ARNs in the CommonControlFilter isn’t supported.
        public var objectives: [ControlCatalogClientTypes.ObjectiveResourceFilter]?

        public init(
            objectives: [ControlCatalogClientTypes.ObjectiveResourceFilter]? = nil
        ) {
            self.objectives = objectives
        }
    }
}

extension ControlCatalogClientTypes {

    /// A structure that contains details about a common control mapping. In particular, it returns the Amazon Resource Name (ARN) of the common control.
    public struct CommonControlMappingDetails: Swift.Sendable {
        /// The Amazon Resource Name (ARN) that identifies the common control in the mapping.
        /// This member is required.
        public var commonControlArn: Swift.String?

        public init(
            commonControlArn: Swift.String? = nil
        ) {
            self.commonControlArn = commonControlArn
        }
    }
}

/// An internal service error occurred during the processing of your request. Try again later.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request has invalid or missing parameters.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct ListCommonControlsInput: Swift.Sendable {
    /// An optional filter that narrows the results to a specific objective. This filter allows you to specify one objective ARN at a time. Passing multiple ARNs in the CommonControlFilter isn’t supported.
    public var commonControlFilter: ControlCatalogClientTypes.CommonControlFilter?
    /// The maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        commonControlFilter: ControlCatalogClientTypes.CommonControlFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.commonControlFilter = commonControlFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ControlCatalogClientTypes {

    /// A summary of metadata for a common control.
    public struct CommonControlSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) that identifies the common control.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the common control was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The description of the common control.
        /// This member is required.
        public var description: Swift.String?
        /// The domain that the common control belongs to.
        /// This member is required.
        public var domain: ControlCatalogClientTypes.AssociatedDomainSummary?
        /// The time when the common control was most recently updated.
        /// This member is required.
        public var lastUpdateTime: Foundation.Date?
        /// The name of the common control.
        /// This member is required.
        public var name: Swift.String?
        /// The objective that the common control belongs to.
        /// This member is required.
        public var objective: ControlCatalogClientTypes.AssociatedObjectiveSummary?

        public init(
            arn: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            domain: ControlCatalogClientTypes.AssociatedDomainSummary? = nil,
            lastUpdateTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            objective: ControlCatalogClientTypes.AssociatedObjectiveSummary? = nil
        ) {
            self.arn = arn
            self.createTime = createTime
            self.description = description
            self.domain = domain
            self.lastUpdateTime = lastUpdateTime
            self.name = name
            self.objective = objective
        }
    }
}

public struct ListCommonControlsOutput: Swift.Sendable {
    /// The list of common controls that the ListCommonControls API returns.
    /// This member is required.
    public var commonControls: [ControlCatalogClientTypes.CommonControlSummary]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        commonControls: [ControlCatalogClientTypes.CommonControlSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.commonControls = commonControls
        self.nextToken = nextToken
    }
}

extension ControlCatalogClientTypes {

    public enum ControlBehavior: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case detective
        case preventive
        case proactive
        case sdkUnknown(Swift.String)

        public static var allCases: [ControlBehavior] {
            return [
                .detective,
                .preventive,
                .proactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .detective: return "DETECTIVE"
            case .preventive: return "PREVENTIVE"
            case .proactive: return "PROACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The requested resource does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct GetControlInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the control. It has one of the following formats: Global format arn:{PARTITION}:controlcatalog:::control/{CONTROL_CATALOG_OPAQUE_ID} Or Regional format arn:{PARTITION}:controltower:{REGION}::control/{CONTROL_TOWER_OPAQUE_ID} Here is a more general pattern that covers Amazon Web Services Control Tower and Control Catalog ARNs: ^arn:(aws(?:[-a-z]*)?):(controlcatalog|controltower):[a-zA-Z0-9-]*::control/[0-9a-zA-Z_\\-]+$
    /// This member is required.
    public var controlArn: Swift.String?

    public init(
        controlArn: Swift.String? = nil
    ) {
        self.controlArn = controlArn
    }
}

extension ControlCatalogClientTypes {

    /// An object that describes the implementation type for a control. Our ImplementationDetailsType format has three required segments:
    ///
    /// * SERVICE-PROVIDER::SERVICE-NAME::RESOURCE-NAME
    ///
    ///
    /// For example, AWS::Config::ConfigRule or AWS::SecurityHub::SecurityControl resources have the format with three required segments. Our ImplementationDetailsType format has an optional fourth segment, which is present for applicable implementation types. The format is as follows:
    ///
    /// * SERVICE-PROVIDER::SERVICE-NAME::RESOURCE-NAME::RESOURCE-TYPE-DESCRIPTION
    ///
    ///
    /// For example, AWS::Organizations::Policy::SERVICE_CONTROL_POLICY or AWS::CloudFormation::Type::HOOK have the format with four segments. Although the format is similar, the values for the Type field do not match any Amazon Web Services CloudFormation values.
    public struct ImplementationDetails: Swift.Sendable {
        /// A service-specific identifier for the control, assigned by the service that implemented the control. For example, this identifier could be an Amazon Web Services Config Rule ID or a Security Hub Control ID.
        public var identifier: Swift.String?
        /// A string that describes a control's implementation type.
        /// This member is required.
        public var type: Swift.String?

        public init(
            identifier: Swift.String? = nil,
            type: Swift.String? = nil
        ) {
            self.identifier = identifier
            self.type = type
        }
    }
}

extension ControlCatalogClientTypes {

    /// Five types of control parameters are supported.
    ///
    /// * AllowedRegions: List of Amazon Web Services Regions exempted from the control. Each string is expected to be an Amazon Web Services Region code. This parameter is mandatory for the OU Region deny control, CT.MULTISERVICE.PV.1. Example: ["us-east-1","us-west-2"]
    ///
    /// * ExemptedActions: List of Amazon Web Services IAM actions exempted from the control. Each string is expected to be an IAM action. Example: ["logs:DescribeLogGroups","logs:StartQuery","logs:GetQueryResults"]
    ///
    /// * ExemptedPrincipalArns: List of Amazon Web Services IAM principal ARNs exempted from the control. Each string is expected to be an IAM principal that follows the pattern ^arn:(aws|aws-us-gov):(iam|sts)::.+:.+$ Example: ["arn:aws:iam::*:role/ReadOnly","arn:aws:sts::*:assumed-role/ReadOnly/*"]
    ///
    /// * ExemptedResourceArns: List of resource ARNs exempted from the control. Each string is expected to be a resource ARN. Example: ["arn:aws:s3:::my-bucket-name"]
    ///
    /// * ExemptAssumeRoot: A parameter that lets you choose whether to exempt requests made with AssumeRoot from this control, for this OU. For member accounts, the AssumeRoot property is included in requests initiated by IAM centralized root access. This parameter applies only to the AWS-GR_RESTRICT_ROOT_USER control. If you add the parameter when enabling the control, the AssumeRoot exemption is allowed. If you omit the parameter, the AssumeRoot exception is not permitted. The parameter does not accept False as a value. Example: Enabling the control and allowing AssumeRoot{ "controlIdentifier": "arn:aws:controlcatalog:::control/5kvme4m5d2b4d7if2fs5yg2ui", "parameters": [ { "key": "ExemptAssumeRoot", "value": true } ], "targetIdentifier": "arn:aws:organizations::8633900XXXXX:ou/o-6jmn81636m/ou-qsah-jtiihcla" }
    public struct ControlParameter: Swift.Sendable {
        /// The parameter name. This name is the parameter key when you call [EnableControl](https://docs.aws.amazon.com/controltower/latest/APIReference/API_EnableControl.html) or [UpdateEnabledControl](https://docs.aws.amazon.com/controltower/latest/APIReference/API_UpdateEnabledControl.html).
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        ) {
            self.name = name
        }
    }
}

extension ControlCatalogClientTypes {

    public enum ControlScope: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case global
        case regional
        case sdkUnknown(Swift.String)

        public static var allCases: [ControlScope] {
            return [
                .global,
                .regional
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .global: return "GLOBAL"
            case .regional: return "REGIONAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ControlCatalogClientTypes {

    /// Returns information about the control, including the scope of the control, if enabled, and the Regions in which the control is available for deployment. For more information about scope, see [Global services](https://docs.aws.amazon.com/whitepapers/latest/aws-fault-isolation-boundaries/global-services.html). If you are applying controls through an Amazon Web Services Control Tower landing zone environment, remember that the values returned in the RegionConfiguration API operation are not related to the governed Regions in your landing zone. For example, if you are governing Regions A,B,and C while the control is available in Regions A, B, C, and D, you'd see a response with DeployableRegions of A, B, C, and D for a control with REGIONAL scope, even though you may not intend to deploy the control in Region D, because you do not govern it through your landing zone.
    public struct RegionConfiguration: Swift.Sendable {
        /// Regions in which the control is available to be deployed.
        public var deployableRegions: [Swift.String]?
        /// The coverage of the control, if deployed. Scope is an enumerated type, with value Regional, or Global. A control with Global scope is effective in all Amazon Web Services Regions, regardless of the Region from which it is enabled, or to which it is deployed. A control implemented by an SCP is usually Global in scope. A control with Regional scope has operations that are restricted specifically to the Region from which it is enabled and to which it is deployed. Controls implemented by Config rules and CloudFormation hooks usually are Regional in scope. Security Hub controls usually are Regional in scope.
        /// This member is required.
        public var scope: ControlCatalogClientTypes.ControlScope?

        public init(
            deployableRegions: [Swift.String]? = nil,
            scope: ControlCatalogClientTypes.ControlScope? = nil
        ) {
            self.deployableRegions = deployableRegions
            self.scope = scope
        }
    }
}

extension ControlCatalogClientTypes {

    public enum ControlSeverity: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case critical
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [ControlSeverity] {
            return [
                .critical,
                .high,
                .low,
                .medium
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetControlOutput: Swift.Sendable {
    /// A list of alternative identifiers for the control. These are human-readable designators, such as SH.S3.1. Several aliases can refer to the same control across different Amazon Web Services services or compliance frameworks.
    public var aliases: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the control.
    /// This member is required.
    public var arn: Swift.String?
    /// A term that identifies the control's functional behavior. One of Preventive, Detective, Proactive
    /// This member is required.
    public var behavior: ControlCatalogClientTypes.ControlBehavior?
    /// A timestamp that notes the time when the control was released (start of its life) as a governance capability in Amazon Web Services.
    public var createTime: Foundation.Date?
    /// A description of what the control does.
    /// This member is required.
    public var description: Swift.String?
    /// A list of Amazon Web Services resource types that are governed by this control. This information helps you understand which controls can govern certain types of resources, and conversely, which resources are affected when the control is implemented. The resources are represented as Amazon Web Services CloudFormation resource types. If GovernedResources cannot be represented by available CloudFormation resource types, it’s returned as an empty list.
    public var governedResources: [Swift.String]?
    /// Returns information about the control, as an ImplementationDetails object that shows the underlying implementation type for a control.
    public var implementation: ControlCatalogClientTypes.ImplementationDetails?
    /// The display name of the control.
    /// This member is required.
    public var name: Swift.String?
    /// Returns an array of ControlParameter objects that specify the parameters a control supports. An empty list is returned for controls that don’t support parameters.
    public var parameters: [ControlCatalogClientTypes.ControlParameter]?
    /// Returns information about the control, including the scope of the control, if enabled, and the Regions in which the control is available for deployment. For more information about scope, see [Global services](https://docs.aws.amazon.com/whitepapers/latest/aws-fault-isolation-boundaries/global-services.html). If you are applying controls through an Amazon Web Services Control Tower landing zone environment, remember that the values returned in the RegionConfiguration API operation are not related to the governed Regions in your landing zone. For example, if you are governing Regions A,B,and C while the control is available in Regions A, B, C, and D, you'd see a response with DeployableRegions of A, B, C, and D for a control with REGIONAL scope, even though you may not intend to deploy the control in Region D, because you do not govern it through your landing zone.
    /// This member is required.
    public var regionConfiguration: ControlCatalogClientTypes.RegionConfiguration?
    /// An enumerated type, with the following possible values:
    public var severity: ControlCatalogClientTypes.ControlSeverity?

    public init(
        aliases: [Swift.String]? = nil,
        arn: Swift.String? = nil,
        behavior: ControlCatalogClientTypes.ControlBehavior? = nil,
        createTime: Foundation.Date? = nil,
        description: Swift.String? = nil,
        governedResources: [Swift.String]? = nil,
        implementation: ControlCatalogClientTypes.ImplementationDetails? = nil,
        name: Swift.String? = nil,
        parameters: [ControlCatalogClientTypes.ControlParameter]? = nil,
        regionConfiguration: ControlCatalogClientTypes.RegionConfiguration? = nil,
        severity: ControlCatalogClientTypes.ControlSeverity? = nil
    ) {
        self.aliases = aliases
        self.arn = arn
        self.behavior = behavior
        self.createTime = createTime
        self.description = description
        self.governedResources = governedResources
        self.implementation = implementation
        self.name = name
        self.parameters = parameters
        self.regionConfiguration = regionConfiguration
        self.severity = severity
    }
}

extension ControlCatalogClientTypes {

    /// A structure that defines filtering criteria for control implementations. You can use this filter to find controls that are implemented by specific Amazon Web Services services or with specific service identifiers.
    public struct ImplementationFilter: Swift.Sendable {
        /// A list of service-specific identifiers that can serve as filters. For example, you can filter for controls with specific Amazon Web Services Config Rule IDs or Security Hub Control IDs.
        public var identifiers: [Swift.String]?
        /// A list of implementation types that can serve as filters. For example, you can filter for controls implemented as Amazon Web Services Config Rules by specifying AWS::Config::ConfigRule as a type.
        public var types: [Swift.String]?

        public init(
            identifiers: [Swift.String]? = nil,
            types: [Swift.String]? = nil
        ) {
            self.identifiers = identifiers
            self.types = types
        }
    }
}

extension ControlCatalogClientTypes {

    /// A structure that defines filtering criteria for the ListControls operation. You can use this filter to narrow down the list of controls based on their implementation details.
    public struct ControlFilter: Swift.Sendable {
        /// A filter that narrows the results to controls with specific implementation types or identifiers. This field allows you to find controls that are implemented by specific Amazon Web Services services or with specific service identifiers.
        public var implementations: ControlCatalogClientTypes.ImplementationFilter?

        public init(
            implementations: ControlCatalogClientTypes.ImplementationFilter? = nil
        ) {
            self.implementations = implementations
        }
    }
}

public struct ListControlsInput: Swift.Sendable {
    /// An optional filter that narrows the results to controls with specific implementation types or identifiers. If you don't provide a filter, the operation returns all available controls.
    public var filter: ControlCatalogClientTypes.ControlFilter?
    /// The maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        filter: ControlCatalogClientTypes.ControlFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ControlCatalogClientTypes {

    /// A summary of how the control is implemented, including the Amazon Web Services service that enforces the control and its service-specific identifier. For example, the value of this field could indicate that the control is implemented as an Amazon Web Services Config Rule or an Amazon Web Services Security Hub control.
    public struct ImplementationSummary: Swift.Sendable {
        /// The identifier originally assigned by the Amazon Web Services service that implements the control. For example, CODEPIPELINE_DEPLOYMENT_COUNT_CHECK.
        public var identifier: Swift.String?
        /// A string that represents the Amazon Web Services service that implements this control. For example, a value of AWS::Config::ConfigRule indicates that the control is implemented by Amazon Web Services Config, and AWS::SecurityHub::SecurityControl indicates implementation by Amazon Web Services Security Hub.
        /// This member is required.
        public var type: Swift.String?

        public init(
            identifier: Swift.String? = nil,
            type: Swift.String? = nil
        ) {
            self.identifier = identifier
            self.type = type
        }
    }
}

extension ControlCatalogClientTypes {

    /// Overview of information about a control.
    public struct ControlSummary: Swift.Sendable {
        /// A list of alternative identifiers for the control. These are human-readable designators, such as SH.S3.1. Several aliases can refer to the same control across different Amazon Web Services services or compliance frameworks.
        public var aliases: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the control.
        /// This member is required.
        public var arn: Swift.String?
        /// An enumerated type, with the following possible values:
        public var behavior: ControlCatalogClientTypes.ControlBehavior?
        /// A timestamp that notes the time when the control was released (start of its life) as a governance capability in Amazon Web Services.
        public var createTime: Foundation.Date?
        /// A description of the control, as it may appear in the console. Describes the functionality of the control.
        /// This member is required.
        public var description: Swift.String?
        /// A list of Amazon Web Services resource types that are governed by this control. This information helps you understand which controls can govern certain types of resources, and conversely, which resources are affected when the control is implemented. The resources are represented as Amazon Web Services CloudFormation resource types. If GovernedResources cannot be represented by available CloudFormation resource types, it’s returned as an empty list.
        public var governedResources: [Swift.String]?
        /// An object of type ImplementationSummary that describes how the control is implemented.
        public var implementation: ControlCatalogClientTypes.ImplementationSummary?
        /// The display name of the control.
        /// This member is required.
        public var name: Swift.String?
        /// An enumerated type, with the following possible values:
        public var severity: ControlCatalogClientTypes.ControlSeverity?

        public init(
            aliases: [Swift.String]? = nil,
            arn: Swift.String? = nil,
            behavior: ControlCatalogClientTypes.ControlBehavior? = nil,
            createTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            governedResources: [Swift.String]? = nil,
            implementation: ControlCatalogClientTypes.ImplementationSummary? = nil,
            name: Swift.String? = nil,
            severity: ControlCatalogClientTypes.ControlSeverity? = nil
        ) {
            self.aliases = aliases
            self.arn = arn
            self.behavior = behavior
            self.createTime = createTime
            self.description = description
            self.governedResources = governedResources
            self.implementation = implementation
            self.name = name
            self.severity = severity
        }
    }
}

public struct ListControlsOutput: Swift.Sendable {
    /// Returns a list of controls, given as structures of type controlSummary.
    /// This member is required.
    public var controls: [ControlCatalogClientTypes.ControlSummary]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        controls: [ControlCatalogClientTypes.ControlSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.controls = controls
        self.nextToken = nextToken
    }
}

public struct ListDomainsInput: Swift.Sendable {
    /// The maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ControlCatalogClientTypes {

    /// A summary of metadata for a domain.
    public struct DomainSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) that identifies the domain.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the domain was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The description of the domain.
        /// This member is required.
        public var description: Swift.String?
        /// The time when the domain was most recently updated.
        /// This member is required.
        public var lastUpdateTime: Foundation.Date?
        /// The name of the domain.
        /// This member is required.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            lastUpdateTime: Foundation.Date? = nil,
            name: Swift.String? = nil
        ) {
            self.arn = arn
            self.createTime = createTime
            self.description = description
            self.lastUpdateTime = lastUpdateTime
            self.name = name
        }
    }
}

public struct ListDomainsOutput: Swift.Sendable {
    /// The list of domains that the ListDomains API returns.
    /// This member is required.
    public var domains: [ControlCatalogClientTypes.DomainSummary]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        domains: [ControlCatalogClientTypes.DomainSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.domains = domains
        self.nextToken = nextToken
    }
}

extension ControlCatalogClientTypes {

    public enum MappingType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case commonControl
        case framework
        case sdkUnknown(Swift.String)

        public static var allCases: [MappingType] {
            return [
                .commonControl,
                .framework
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .commonControl: return "COMMON_CONTROL"
            case .framework: return "FRAMEWORK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ControlCatalogClientTypes {

    /// A structure that defines filtering criteria for the ListControlMappings operation. You can use this filter to narrow down the list of control mappings based on control ARNs, common control ARNs, or mapping types.
    public struct ControlMappingFilter: Swift.Sendable {
        /// A list of common control ARNs to filter the mappings. When specified, only mappings associated with these common controls are returned.
        public var commonControlArns: [Swift.String]?
        /// A list of control ARNs to filter the mappings. When specified, only mappings associated with these controls are returned.
        public var controlArns: [Swift.String]?
        /// A list of mapping types to filter the mappings. When specified, only mappings of these types are returned.
        public var mappingTypes: [ControlCatalogClientTypes.MappingType]?

        public init(
            commonControlArns: [Swift.String]? = nil,
            controlArns: [Swift.String]? = nil,
            mappingTypes: [ControlCatalogClientTypes.MappingType]? = nil
        ) {
            self.commonControlArns = commonControlArns
            self.controlArns = controlArns
            self.mappingTypes = mappingTypes
        }
    }
}

public struct ListControlMappingsInput: Swift.Sendable {
    /// An optional filter that narrows the results to specific control mappings based on control ARNs, common control ARNs, or mapping types.
    public var filter: ControlCatalogClientTypes.ControlMappingFilter?
    /// The maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        filter: ControlCatalogClientTypes.ControlMappingFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ControlCatalogClientTypes {

    /// A structure that contains details about a framework mapping, including the framework name and specific item within the framework that the control maps to.
    public struct FrameworkMappingDetails: Swift.Sendable {
        /// The specific item or requirement within the framework that the control maps to.
        /// This member is required.
        public var item: Swift.String?
        /// The name of the compliance framework that the control maps to.
        /// This member is required.
        public var name: Swift.String?

        public init(
            item: Swift.String? = nil,
            name: Swift.String? = nil
        ) {
            self.item = item
            self.name = name
        }
    }
}

extension ControlCatalogClientTypes {

    /// A structure that contains the details of a mapping relationship, which can be either to a framework or to a common control.
    public enum Mapping: Swift.Sendable {
        /// The framework mapping details when the mapping type relates to a compliance framework.
        case framework(ControlCatalogClientTypes.FrameworkMappingDetails)
        /// The common control mapping details when the mapping type relates to a common control.
        case commoncontrol(ControlCatalogClientTypes.CommonControlMappingDetails)
        case sdkUnknown(Swift.String)
    }
}

extension ControlCatalogClientTypes {

    /// A structure that contains information about a control mapping, including the control ARN, mapping type, and mapping details.
    public struct ControlMapping: Swift.Sendable {
        /// The Amazon Resource Name (ARN) that identifies the control in the mapping.
        /// This member is required.
        public var controlArn: Swift.String?
        /// The details of the mapping relationship, containing either framework or common control information.
        /// This member is required.
        public var mapping: ControlCatalogClientTypes.Mapping?
        /// The type of mapping relationship between the control and other entities. Indicates whether the mapping is to a framework or common control.
        /// This member is required.
        public var mappingType: ControlCatalogClientTypes.MappingType?

        public init(
            controlArn: Swift.String? = nil,
            mapping: ControlCatalogClientTypes.Mapping? = nil,
            mappingType: ControlCatalogClientTypes.MappingType? = nil
        ) {
            self.controlArn = controlArn
            self.mapping = mapping
            self.mappingType = mappingType
        }
    }
}

public struct ListControlMappingsOutput: Swift.Sendable {
    /// The list of control mappings that the ListControlMappings API returns.
    /// This member is required.
    public var controlMappings: [ControlCatalogClientTypes.ControlMapping]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        controlMappings: [ControlCatalogClientTypes.ControlMapping]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.controlMappings = controlMappings
        self.nextToken = nextToken
    }
}

extension ControlCatalogClientTypes {

    /// The domain resource that's being used as a filter.
    public struct DomainResourceFilter: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the domain.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        ) {
            self.arn = arn
        }
    }
}

extension ControlCatalogClientTypes {

    /// An optional filter that narrows the list of objectives to a specific domain.
    public struct ObjectiveFilter: Swift.Sendable {
        /// The domain that's used as filter criteria. You can use this parameter to specify one domain ARN at a time. Passing multiple ARNs in the ObjectiveFilter isn’t supported.
        public var domains: [ControlCatalogClientTypes.DomainResourceFilter]?

        public init(
            domains: [ControlCatalogClientTypes.DomainResourceFilter]? = nil
        ) {
            self.domains = domains
        }
    }
}

public struct ListObjectivesInput: Swift.Sendable {
    /// The maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?
    /// An optional filter that narrows the results to a specific domain. This filter allows you to specify one domain ARN at a time. Passing multiple ARNs in the ObjectiveFilter isn’t supported.
    public var objectiveFilter: ControlCatalogClientTypes.ObjectiveFilter?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        objectiveFilter: ControlCatalogClientTypes.ObjectiveFilter? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectiveFilter = objectiveFilter
    }
}

extension ControlCatalogClientTypes {

    /// A summary of metadata for an objective.
    public struct ObjectiveSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) that identifies the objective.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the objective was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The description of the objective.
        /// This member is required.
        public var description: Swift.String?
        /// The domain that the objective belongs to.
        /// This member is required.
        public var domain: ControlCatalogClientTypes.AssociatedDomainSummary?
        /// The time when the objective was most recently updated.
        /// This member is required.
        public var lastUpdateTime: Foundation.Date?
        /// The name of the objective.
        /// This member is required.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            domain: ControlCatalogClientTypes.AssociatedDomainSummary? = nil,
            lastUpdateTime: Foundation.Date? = nil,
            name: Swift.String? = nil
        ) {
            self.arn = arn
            self.createTime = createTime
            self.description = description
            self.domain = domain
            self.lastUpdateTime = lastUpdateTime
            self.name = name
        }
    }
}

public struct ListObjectivesOutput: Swift.Sendable {
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?
    /// The list of objectives that the ListObjectives API returns.
    /// This member is required.
    public var objectives: [ControlCatalogClientTypes.ObjectiveSummary]?

    public init(
        nextToken: Swift.String? = nil,
        objectives: [ControlCatalogClientTypes.ObjectiveSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.objectives = objectives
    }
}

extension GetControlInput {

    static func urlPathProvider(_ value: GetControlInput) -> Swift.String? {
        return "/get-control"
    }
}

extension ListCommonControlsInput {

    static func urlPathProvider(_ value: ListCommonControlsInput) -> Swift.String? {
        return "/common-controls"
    }
}

extension ListCommonControlsInput {

    static func queryItemProvider(_ value: ListCommonControlsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListControlMappingsInput {

    static func urlPathProvider(_ value: ListControlMappingsInput) -> Swift.String? {
        return "/list-control-mappings"
    }
}

extension ListControlMappingsInput {

    static func queryItemProvider(_ value: ListControlMappingsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListControlsInput {

    static func urlPathProvider(_ value: ListControlsInput) -> Swift.String? {
        return "/list-controls"
    }
}

extension ListControlsInput {

    static func queryItemProvider(_ value: ListControlsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDomainsInput {

    static func urlPathProvider(_ value: ListDomainsInput) -> Swift.String? {
        return "/domains"
    }
}

extension ListDomainsInput {

    static func queryItemProvider(_ value: ListDomainsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListObjectivesInput {

    static func urlPathProvider(_ value: ListObjectivesInput) -> Swift.String? {
        return "/objectives"
    }
}

extension ListObjectivesInput {

    static func queryItemProvider(_ value: ListObjectivesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetControlInput {

    static func write(value: GetControlInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ControlArn"].write(value.controlArn)
    }
}

extension ListCommonControlsInput {

    static func write(value: ListCommonControlsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CommonControlFilter"].write(value.commonControlFilter, with: ControlCatalogClientTypes.CommonControlFilter.write(value:to:))
    }
}

extension ListControlMappingsInput {

    static func write(value: ListControlMappingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filter"].write(value.filter, with: ControlCatalogClientTypes.ControlMappingFilter.write(value:to:))
    }
}

extension ListControlsInput {

    static func write(value: ListControlsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filter"].write(value.filter, with: ControlCatalogClientTypes.ControlFilter.write(value:to:))
    }
}

extension ListObjectivesInput {

    static func write(value: ListObjectivesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ObjectiveFilter"].write(value.objectiveFilter, with: ControlCatalogClientTypes.ObjectiveFilter.write(value:to:))
    }
}

extension GetControlOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetControlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetControlOutput()
        value.aliases = try reader["Aliases"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.behavior = try reader["Behavior"].readIfPresent() ?? .sdkUnknown("")
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent() ?? ""
        value.governedResources = try reader["GovernedResources"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.implementation = try reader["Implementation"].readIfPresent(with: ControlCatalogClientTypes.ImplementationDetails.read(from:))
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.parameters = try reader["Parameters"].readListIfPresent(memberReadingClosure: ControlCatalogClientTypes.ControlParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.regionConfiguration = try reader["RegionConfiguration"].readIfPresent(with: ControlCatalogClientTypes.RegionConfiguration.read(from:))
        value.severity = try reader["Severity"].readIfPresent()
        return value
    }
}

extension ListCommonControlsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCommonControlsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCommonControlsOutput()
        value.commonControls = try reader["CommonControls"].readListIfPresent(memberReadingClosure: ControlCatalogClientTypes.CommonControlSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListControlMappingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListControlMappingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListControlMappingsOutput()
        value.controlMappings = try reader["ControlMappings"].readListIfPresent(memberReadingClosure: ControlCatalogClientTypes.ControlMapping.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListControlsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListControlsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListControlsOutput()
        value.controls = try reader["Controls"].readListIfPresent(memberReadingClosure: ControlCatalogClientTypes.ControlSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListDomainsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDomainsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDomainsOutput()
        value.domains = try reader["Domains"].readListIfPresent(memberReadingClosure: ControlCatalogClientTypes.DomainSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListObjectivesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListObjectivesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListObjectivesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.objectives = try reader["Objectives"].readListIfPresent(memberReadingClosure: ControlCatalogClientTypes.ObjectiveSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

enum GetControlOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCommonControlsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListControlMappingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListControlsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDomainsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListObjectivesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ControlCatalogClientTypes.RegionConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> ControlCatalogClientTypes.RegionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ControlCatalogClientTypes.RegionConfiguration()
        value.scope = try reader["Scope"].readIfPresent() ?? .sdkUnknown("")
        value.deployableRegions = try reader["DeployableRegions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ControlCatalogClientTypes.ImplementationDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> ControlCatalogClientTypes.ImplementationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ControlCatalogClientTypes.ImplementationDetails()
        value.type = try reader["Type"].readIfPresent() ?? ""
        value.identifier = try reader["Identifier"].readIfPresent()
        return value
    }
}

extension ControlCatalogClientTypes.ControlParameter {

    static func read(from reader: SmithyJSON.Reader) throws -> ControlCatalogClientTypes.ControlParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ControlCatalogClientTypes.ControlParameter()
        value.name = try reader["Name"].readIfPresent() ?? ""
        return value
    }
}

extension ControlCatalogClientTypes.CommonControlSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ControlCatalogClientTypes.CommonControlSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ControlCatalogClientTypes.CommonControlSummary()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.description = try reader["Description"].readIfPresent() ?? ""
        value.domain = try reader["Domain"].readIfPresent(with: ControlCatalogClientTypes.AssociatedDomainSummary.read(from:))
        value.objective = try reader["Objective"].readIfPresent(with: ControlCatalogClientTypes.AssociatedObjectiveSummary.read(from:))
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdateTime = try reader["LastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension ControlCatalogClientTypes.AssociatedObjectiveSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ControlCatalogClientTypes.AssociatedObjectiveSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ControlCatalogClientTypes.AssociatedObjectiveSummary()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension ControlCatalogClientTypes.AssociatedDomainSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ControlCatalogClientTypes.AssociatedDomainSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ControlCatalogClientTypes.AssociatedDomainSummary()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension ControlCatalogClientTypes.ControlMapping {

    static func read(from reader: SmithyJSON.Reader) throws -> ControlCatalogClientTypes.ControlMapping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ControlCatalogClientTypes.ControlMapping()
        value.controlArn = try reader["ControlArn"].readIfPresent() ?? ""
        value.mappingType = try reader["MappingType"].readIfPresent() ?? .sdkUnknown("")
        value.mapping = try reader["Mapping"].readIfPresent(with: ControlCatalogClientTypes.Mapping.read(from:))
        return value
    }
}

extension ControlCatalogClientTypes.Mapping {

    static func read(from reader: SmithyJSON.Reader) throws -> ControlCatalogClientTypes.Mapping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "Framework":
                return .framework(try reader["Framework"].read(with: ControlCatalogClientTypes.FrameworkMappingDetails.read(from:)))
            case "CommonControl":
                return .commoncontrol(try reader["CommonControl"].read(with: ControlCatalogClientTypes.CommonControlMappingDetails.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension ControlCatalogClientTypes.CommonControlMappingDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> ControlCatalogClientTypes.CommonControlMappingDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ControlCatalogClientTypes.CommonControlMappingDetails()
        value.commonControlArn = try reader["CommonControlArn"].readIfPresent() ?? ""
        return value
    }
}

extension ControlCatalogClientTypes.FrameworkMappingDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> ControlCatalogClientTypes.FrameworkMappingDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ControlCatalogClientTypes.FrameworkMappingDetails()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.item = try reader["Item"].readIfPresent() ?? ""
        return value
    }
}

extension ControlCatalogClientTypes.ControlSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ControlCatalogClientTypes.ControlSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ControlCatalogClientTypes.ControlSummary()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.aliases = try reader["Aliases"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.description = try reader["Description"].readIfPresent() ?? ""
        value.behavior = try reader["Behavior"].readIfPresent()
        value.severity = try reader["Severity"].readIfPresent()
        value.implementation = try reader["Implementation"].readIfPresent(with: ControlCatalogClientTypes.ImplementationSummary.read(from:))
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.governedResources = try reader["GovernedResources"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ControlCatalogClientTypes.ImplementationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ControlCatalogClientTypes.ImplementationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ControlCatalogClientTypes.ImplementationSummary()
        value.type = try reader["Type"].readIfPresent() ?? ""
        value.identifier = try reader["Identifier"].readIfPresent()
        return value
    }
}

extension ControlCatalogClientTypes.DomainSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ControlCatalogClientTypes.DomainSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ControlCatalogClientTypes.DomainSummary()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.description = try reader["Description"].readIfPresent() ?? ""
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdateTime = try reader["LastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension ControlCatalogClientTypes.ObjectiveSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ControlCatalogClientTypes.ObjectiveSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ControlCatalogClientTypes.ObjectiveSummary()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.description = try reader["Description"].readIfPresent() ?? ""
        value.domain = try reader["Domain"].readIfPresent(with: ControlCatalogClientTypes.AssociatedDomainSummary.read(from:))
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdateTime = try reader["LastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension ControlCatalogClientTypes.CommonControlFilter {

    static func write(value: ControlCatalogClientTypes.CommonControlFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Objectives"].writeList(value.objectives, memberWritingClosure: ControlCatalogClientTypes.ObjectiveResourceFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ControlCatalogClientTypes.ObjectiveResourceFilter {

    static func write(value: ControlCatalogClientTypes.ObjectiveResourceFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
    }
}

extension ControlCatalogClientTypes.ControlMappingFilter {

    static func write(value: ControlCatalogClientTypes.ControlMappingFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CommonControlArns"].writeList(value.commonControlArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ControlArns"].writeList(value.controlArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MappingTypes"].writeList(value.mappingTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<ControlCatalogClientTypes.MappingType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ControlCatalogClientTypes.ControlFilter {

    static func write(value: ControlCatalogClientTypes.ControlFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Implementations"].write(value.implementations, with: ControlCatalogClientTypes.ImplementationFilter.write(value:to:))
    }
}

extension ControlCatalogClientTypes.ImplementationFilter {

    static func write(value: ControlCatalogClientTypes.ImplementationFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Identifiers"].writeList(value.identifiers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Types"].writeList(value.types, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ControlCatalogClientTypes.ObjectiveFilter {

    static func write(value: ControlCatalogClientTypes.ObjectiveFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Domains"].writeList(value.domains, memberWritingClosure: ControlCatalogClientTypes.DomainResourceFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ControlCatalogClientTypes.DomainResourceFilter {

    static func write(value: ControlCatalogClientTypes.DomainResourceFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
    }
}

public enum ControlCatalogClientTypes {}
