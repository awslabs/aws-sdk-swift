// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ControlCatalogClientTypes.AssociatedDomainSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ControlCatalogClientTypes {
    /// A summary of the domain that a common control or an objective belongs to.
    public struct AssociatedDomainSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the related domain.
        public var arn: Swift.String?
        /// The name of the related domain.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
        }
    }

}

extension ControlCatalogClientTypes.AssociatedObjectiveSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ControlCatalogClientTypes {
    /// A summary of the objective that a common control supports.
    public struct AssociatedObjectiveSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the related objective.
        public var arn: Swift.String?
        /// The name of the related objective.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
        }
    }

}

extension ControlCatalogClientTypes.CommonControlFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectives = "Objectives"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectives = objectives {
            var objectivesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .objectives)
            for objectiveresourcefilter0 in objectives {
                try objectivesContainer.encode(objectiveresourcefilter0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectivesContainer = try containerValues.decodeIfPresent([ControlCatalogClientTypes.ObjectiveResourceFilter?].self, forKey: .objectives)
        var objectivesDecoded0:[ControlCatalogClientTypes.ObjectiveResourceFilter]? = nil
        if let objectivesContainer = objectivesContainer {
            objectivesDecoded0 = [ControlCatalogClientTypes.ObjectiveResourceFilter]()
            for structure0 in objectivesContainer {
                if let structure0 = structure0 {
                    objectivesDecoded0?.append(structure0)
                }
            }
        }
        objectives = objectivesDecoded0
    }
}

extension ControlCatalogClientTypes {
    /// An optional filter that narrows the results to a specific objective.
    public struct CommonControlFilter: Swift.Equatable {
        /// The objective that's used as filter criteria. You can use this parameter to specify one objective ARN at a time. Passing multiple ARNs in the CommonControlFilter isn’t currently supported.
        public var objectives: [ControlCatalogClientTypes.ObjectiveResourceFilter]?

        public init(
            objectives: [ControlCatalogClientTypes.ObjectiveResourceFilter]? = nil
        )
        {
            self.objectives = objectives
        }
    }

}

extension ControlCatalogClientTypes.CommonControlSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createTime = "CreateTime"
        case description = "Description"
        case domain = "Domain"
        case lastUpdateTime = "LastUpdateTime"
        case name = "Name"
        case objective = "Objective"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domain = self.domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let lastUpdateTime = self.lastUpdateTime {
            try encodeContainer.encodeTimestamp(lastUpdateTime, format: .epochSeconds, forKey: .lastUpdateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let objective = self.objective {
            try encodeContainer.encode(objective, forKey: .objective)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let domainDecoded = try containerValues.decodeIfPresent(ControlCatalogClientTypes.AssociatedDomainSummary.self, forKey: .domain)
        domain = domainDecoded
        let objectiveDecoded = try containerValues.decodeIfPresent(ControlCatalogClientTypes.AssociatedObjectiveSummary.self, forKey: .objective)
        objective = objectiveDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension ControlCatalogClientTypes {
    /// A summary of metadata for a common control.
    public struct CommonControlSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that identifies the common control.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the common control was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The description of the common control.
        /// This member is required.
        public var description: Swift.String?
        /// The domain that the common control belongs to.
        /// This member is required.
        public var domain: ControlCatalogClientTypes.AssociatedDomainSummary?
        /// The time when the common control was most recently updated.
        /// This member is required.
        public var lastUpdateTime: ClientRuntime.Date?
        /// The name of the common control.
        /// This member is required.
        public var name: Swift.String?
        /// The objective that the common control belongs to.
        /// This member is required.
        public var objective: ControlCatalogClientTypes.AssociatedObjectiveSummary?

        public init(
            arn: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            domain: ControlCatalogClientTypes.AssociatedDomainSummary? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            objective: ControlCatalogClientTypes.AssociatedObjectiveSummary? = nil
        )
        {
            self.arn = arn
            self.createTime = createTime
            self.description = description
            self.domain = domain
            self.lastUpdateTime = lastUpdateTime
            self.name = name
            self.objective = objective
        }
    }

}

public enum ControlCatalogClientTypes {}

extension ControlCatalogClientTypes.DomainResourceFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension ControlCatalogClientTypes {
    /// The domain resource that's being used as a filter.
    public struct DomainResourceFilter: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the domain.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension ControlCatalogClientTypes.DomainSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createTime = "CreateTime"
        case description = "Description"
        case lastUpdateTime = "LastUpdateTime"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastUpdateTime = self.lastUpdateTime {
            try encodeContainer.encodeTimestamp(lastUpdateTime, format: .epochSeconds, forKey: .lastUpdateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension ControlCatalogClientTypes {
    /// A summary of metadata for a domain.
    public struct DomainSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that identifies the domain.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the domain was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The description of the domain.
        /// This member is required.
        public var description: Swift.String?
        /// The time when the domain was most recently updated.
        /// This member is required.
        public var lastUpdateTime: ClientRuntime.Date?
        /// The name of the domain.
        /// This member is required.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createTime = createTime
            self.description = description
            self.lastUpdateTime = lastUpdateTime
            self.name = name
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An internal service error occurred during the processing of your request. Try again later.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListCommonControlsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commonControlFilter = "CommonControlFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commonControlFilter = self.commonControlFilter {
            try encodeContainer.encode(commonControlFilter, forKey: .commonControlFilter)
        }
    }
}

extension ListCommonControlsInput {

    static func queryItemProvider(_ value: ListCommonControlsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListCommonControlsInput {

    static func urlPathProvider(_ value: ListCommonControlsInput) -> Swift.String? {
        return "/common-controls"
    }
}

public struct ListCommonControlsInput: Swift.Equatable {
    /// An optional filter that narrows the results to a specific objective. This filter allows you to specify one objective ARN at a time. Passing multiple ARNs in the CommonControlFilter isn’t currently supported.
    public var commonControlFilter: ControlCatalogClientTypes.CommonControlFilter?
    /// The maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        commonControlFilter: ControlCatalogClientTypes.CommonControlFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.commonControlFilter = commonControlFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCommonControlsInputBody: Swift.Equatable {
    let commonControlFilter: ControlCatalogClientTypes.CommonControlFilter?
}

extension ListCommonControlsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commonControlFilter = "CommonControlFilter"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commonControlFilterDecoded = try containerValues.decodeIfPresent(ControlCatalogClientTypes.CommonControlFilter.self, forKey: .commonControlFilter)
        commonControlFilter = commonControlFilterDecoded
    }
}

extension ListCommonControlsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCommonControlsOutputBody = try responseDecoder.decode(responseBody: data)
            self.commonControls = output.commonControls
            self.nextToken = output.nextToken
        } else {
            self.commonControls = nil
            self.nextToken = nil
        }
    }
}

public struct ListCommonControlsOutput: Swift.Equatable {
    /// The list of common controls that the ListCommonControls API returns.
    /// This member is required.
    public var commonControls: [ControlCatalogClientTypes.CommonControlSummary]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        commonControls: [ControlCatalogClientTypes.CommonControlSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.commonControls = commonControls
        self.nextToken = nextToken
    }
}

struct ListCommonControlsOutputBody: Swift.Equatable {
    let commonControls: [ControlCatalogClientTypes.CommonControlSummary]?
    let nextToken: Swift.String?
}

extension ListCommonControlsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commonControls = "CommonControls"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commonControlsContainer = try containerValues.decodeIfPresent([ControlCatalogClientTypes.CommonControlSummary?].self, forKey: .commonControls)
        var commonControlsDecoded0:[ControlCatalogClientTypes.CommonControlSummary]? = nil
        if let commonControlsContainer = commonControlsContainer {
            commonControlsDecoded0 = [ControlCatalogClientTypes.CommonControlSummary]()
            for structure0 in commonControlsContainer {
                if let structure0 = structure0 {
                    commonControlsDecoded0?.append(structure0)
                }
            }
        }
        commonControls = commonControlsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCommonControlsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDomainsInput {

    static func queryItemProvider(_ value: ListDomainsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDomainsInput {

    static func urlPathProvider(_ value: ListDomainsInput) -> Swift.String? {
        return "/domains"
    }
}

public struct ListDomainsInput: Swift.Equatable {
    /// The maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDomainsInputBody: Swift.Equatable {
}

extension ListDomainsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDomainsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDomainsOutputBody = try responseDecoder.decode(responseBody: data)
            self.domains = output.domains
            self.nextToken = output.nextToken
        } else {
            self.domains = nil
            self.nextToken = nil
        }
    }
}

public struct ListDomainsOutput: Swift.Equatable {
    /// The list of domains that the ListDomains API returns.
    /// This member is required.
    public var domains: [ControlCatalogClientTypes.DomainSummary]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        domains: [ControlCatalogClientTypes.DomainSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domains = domains
        self.nextToken = nextToken
    }
}

struct ListDomainsOutputBody: Swift.Equatable {
    let domains: [ControlCatalogClientTypes.DomainSummary]?
    let nextToken: Swift.String?
}

extension ListDomainsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domains = "Domains"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainsContainer = try containerValues.decodeIfPresent([ControlCatalogClientTypes.DomainSummary?].self, forKey: .domains)
        var domainsDecoded0:[ControlCatalogClientTypes.DomainSummary]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [ControlCatalogClientTypes.DomainSummary]()
            for structure0 in domainsContainer {
                if let structure0 = structure0 {
                    domainsDecoded0?.append(structure0)
                }
            }
        }
        domains = domainsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDomainsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListObjectivesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectiveFilter = "ObjectiveFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectiveFilter = self.objectiveFilter {
            try encodeContainer.encode(objectiveFilter, forKey: .objectiveFilter)
        }
    }
}

extension ListObjectivesInput {

    static func queryItemProvider(_ value: ListObjectivesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListObjectivesInput {

    static func urlPathProvider(_ value: ListObjectivesInput) -> Swift.String? {
        return "/objectives"
    }
}

public struct ListObjectivesInput: Swift.Equatable {
    /// The maximum number of results on a page or for an API request call.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?
    /// An optional filter that narrows the results to a specific domain. This filter allows you to specify one domain ARN at a time. Passing multiple ARNs in the ObjectiveFilter isn’t currently supported.
    public var objectiveFilter: ControlCatalogClientTypes.ObjectiveFilter?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        objectiveFilter: ControlCatalogClientTypes.ObjectiveFilter? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.objectiveFilter = objectiveFilter
    }
}

struct ListObjectivesInputBody: Swift.Equatable {
    let objectiveFilter: ControlCatalogClientTypes.ObjectiveFilter?
}

extension ListObjectivesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectiveFilter = "ObjectiveFilter"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectiveFilterDecoded = try containerValues.decodeIfPresent(ControlCatalogClientTypes.ObjectiveFilter.self, forKey: .objectiveFilter)
        objectiveFilter = objectiveFilterDecoded
    }
}

extension ListObjectivesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListObjectivesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.objectives = output.objectives
        } else {
            self.nextToken = nil
            self.objectives = nil
        }
    }
}

public struct ListObjectivesOutput: Swift.Equatable {
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?
    /// The list of objectives that the ListObjectives API returns.
    /// This member is required.
    public var objectives: [ControlCatalogClientTypes.ObjectiveSummary]?

    public init(
        nextToken: Swift.String? = nil,
        objectives: [ControlCatalogClientTypes.ObjectiveSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.objectives = objectives
    }
}

struct ListObjectivesOutputBody: Swift.Equatable {
    let objectives: [ControlCatalogClientTypes.ObjectiveSummary]?
    let nextToken: Swift.String?
}

extension ListObjectivesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case objectives = "Objectives"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectivesContainer = try containerValues.decodeIfPresent([ControlCatalogClientTypes.ObjectiveSummary?].self, forKey: .objectives)
        var objectivesDecoded0:[ControlCatalogClientTypes.ObjectiveSummary]? = nil
        if let objectivesContainer = objectivesContainer {
            objectivesDecoded0 = [ControlCatalogClientTypes.ObjectiveSummary]()
            for structure0 in objectivesContainer {
                if let structure0 = structure0 {
                    objectivesDecoded0?.append(structure0)
                }
            }
        }
        objectives = objectivesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListObjectivesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ControlCatalogClientTypes.ObjectiveFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domains = "Domains"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domains = domains {
            var domainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domains)
            for domainresourcefilter0 in domains {
                try domainsContainer.encode(domainresourcefilter0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainsContainer = try containerValues.decodeIfPresent([ControlCatalogClientTypes.DomainResourceFilter?].self, forKey: .domains)
        var domainsDecoded0:[ControlCatalogClientTypes.DomainResourceFilter]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [ControlCatalogClientTypes.DomainResourceFilter]()
            for structure0 in domainsContainer {
                if let structure0 = structure0 {
                    domainsDecoded0?.append(structure0)
                }
            }
        }
        domains = domainsDecoded0
    }
}

extension ControlCatalogClientTypes {
    /// An optional filter that narrows the list of objectives to a specific domain.
    public struct ObjectiveFilter: Swift.Equatable {
        /// The domain that's used as filter criteria. You can use this parameter to specify one domain ARN at a time. Passing multiple ARNs in the ObjectiveFilter isn’t currently supported.
        public var domains: [ControlCatalogClientTypes.DomainResourceFilter]?

        public init(
            domains: [ControlCatalogClientTypes.DomainResourceFilter]? = nil
        )
        {
            self.domains = domains
        }
    }

}

extension ControlCatalogClientTypes.ObjectiveResourceFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension ControlCatalogClientTypes {
    /// The objective resource that's being used as a filter.
    public struct ObjectiveResourceFilter: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the objective.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension ControlCatalogClientTypes.ObjectiveSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createTime = "CreateTime"
        case description = "Description"
        case domain = "Domain"
        case lastUpdateTime = "LastUpdateTime"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domain = self.domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let lastUpdateTime = self.lastUpdateTime {
            try encodeContainer.encodeTimestamp(lastUpdateTime, format: .epochSeconds, forKey: .lastUpdateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let domainDecoded = try containerValues.decodeIfPresent(ControlCatalogClientTypes.AssociatedDomainSummary.self, forKey: .domain)
        domain = domainDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension ControlCatalogClientTypes {
    /// A summary of metadata for an objective.
    public struct ObjectiveSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that identifies the objective.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the objective was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The description of the objective.
        /// This member is required.
        public var description: Swift.String?
        /// The domain that the objective belongs to.
        /// This member is required.
        public var domain: ControlCatalogClientTypes.AssociatedDomainSummary?
        /// The time when the objective was most recently updated.
        /// This member is required.
        public var lastUpdateTime: ClientRuntime.Date?
        /// The name of the objective.
        /// This member is required.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            domain: ControlCatalogClientTypes.AssociatedDomainSummary? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createTime = createTime
            self.description = description
            self.domain = domain
            self.lastUpdateTime = lastUpdateTime
            self.name = name
        }
    }

}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request has invalid or missing parameters.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
